# created by mk-doc-cache.pl
# name: cache
# type: cell
# rows: 3
# columns: 1558
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
daspk_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5804
 -- : daspk_options ()
 -- : val = daspk_options (OPT)
 -- : daspk_options (OPT, VAL)
     Query or set options for the function ‘daspk’.

     When called with no arguments, the names of all available options and their current values are displayed.

     Given one argument, return the value of the option OPT.

     When called with two arguments, ‘daspk_options’ sets the option OPT to value VAL.

     Options include

     "absolute tolerance"
          Absolute tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length.

     "relative tolerance"
          Relative tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     "compute consistent initial condition"
          Denoting the differential variables in the state vector by ‘Y_d’ and the algebraic variables by ‘Y_a’, ‘ddaspk’ can solve one of two initialization problems:

            1. Given Y_d, calculate Y_a and Y’_d

            2. Given Y’, calculate Y.

          In either case, initial values for the given components are input, and initial guesses for the unknown components must also be provided as input.  Set this option to 1 to solve the first problem, or 2 to solve the second (the default is 0, so you must provide a set of initial conditions that are consistent).

          If this option is set to a nonzero value, you must also set the "algebraic variables" option to declare which variables in the problem are algebraic.

     "use initial condition heuristics"
          Set to a nonzero value to use the initial condition heuristics options described below.

     "initial condition heuristics"
          A vector of the following parameters that can be used to control the initial condition calculation.

          ‘MXNIT’
               Maximum number of Newton iterations (default is 5).

          ‘MXNJ’
               Maximum number of Jacobian evaluations (default is 6).

          ‘MXNH’
               Maximum number of values of the artificial stepsize parameter to be tried if the "compute consistent initial condition" option has been set to 1 (default is 5).

               Note that the maximum total number of Newton iterations allowed is ‘MXNIT*MXNJ*MXNH’ if the "compute consistent initial condition" option has been set to 1 and ‘MXNIT*MXNJ’ if it is set to 2.

          ‘LSOFF’
               Set to a nonzero value to disable the linesearch algorithm (default is 0).

          ‘STPTOL’
               Minimum scaled step in linesearch algorithm (default is eps^(2/3)).

          ‘EPINIT’
               Swing factor in the Newton iteration convergence test.  The test is applied to the residual vector, premultiplied by the approximate Jacobian.  For convergence, the weighted RMS norm of this vector (scaled by the error weights) must be less than ‘EPINIT*EPCON’, where ‘EPCON’ = 0.33 is the analogous test constant used in the time steps.  The default is ‘EPINIT’ = 0.01.

     "print initial condition info"
          Set this option to a nonzero value to display detailed information about the initial condition calculation (default is 0).

     "exclude algebraic variables from error test"
          Set to a nonzero value to exclude algebraic variables from the error test.  You must also set the "algebraic variables" option to declare which variables in the problem are algebraic (default is 0).

     "algebraic variables"
          A vector of the same length as the state vector.  A nonzero element indicates that the corresponding element of the state vector is an algebraic variable (i.e., its derivative does not appear explicitly in the equation set).

          This option is required by the "compute consistent initial condition" and "exclude algebraic variables from error test" options.

     "enforce inequality constraints"
          Set to one of the following values to enforce the inequality constraints specified by the "inequality constraint types" option (default is 0).

            1. To have constraint checking only in the initial condition calculation.

            2. To enforce constraint checking during the integration.

            3. To enforce both options 1 and 2.

     "inequality constraint types"
          A vector of the same length as the state specifying the type of inequality constraint.  Each element of the vector corresponds to an element of the state and should be assigned one of the following codes

          -2
               Less than zero.

          -1
               Less than or equal to zero.

          0
               Not constrained.

          1
               Greater than or equal to zero.

          2
               Greater than zero.

          This option only has an effect if the "enforce inequality constraints" option is nonzero.

     "initial step size"
          Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step.  If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize (default is computed automatically).

     "maximum order"
          Restrict the maximum order of the solution method.  This option must be between 1 and 5, inclusive (default is 5).

     "maximum step size"
          Setting the maximum stepsize will avoid passing over very large regions (default is not specified).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Query or set options for the function ‘daspk’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dasrt_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1693
 -- : dasrt_options ()
 -- : val = dasrt_options (OPT)
 -- : dasrt_options (OPT, VAL)
     Query or set options for the function ‘dasrt’.

     When called with no arguments, the names of all available options and their current values are displayed.

     Given one argument, return the value of the option OPT.

     When called with two arguments, ‘dasrt_options’ sets the option OPT to value VAL.

     Options include

     "absolute tolerance"
          Absolute tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length.

     "relative tolerance"
          Relative tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol(i) * abs (Y(i)) + atol(i)

     "initial step size"
          Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step.  If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize.

     "maximum order"
          Restrict the maximum order of the solution method.  This option must be between 1 and 5, inclusive.

     "maximum step size"
          Setting the maximum stepsize will avoid passing over very large regions.

     "step limit"
          Maximum number of integration steps to attempt on a single call to the underlying Fortran code.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Query or set options for the function ‘dasrt’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dassl_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2303
 -- : dassl_options ()
 -- : val = dassl_options (OPT)
 -- : dassl_options (OPT, VAL)
     Query or set options for the function ‘dassl’.

     When called with no arguments, the names of all available options and their current values are displayed.

     Given one argument, return the value of the option OPT.

     When called with two arguments, ‘dassl_options’ sets the option OPT to value VAL.

     Options include

     "absolute tolerance"
          Absolute tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the relative tolerance must also be a vector of the same length.

     "relative tolerance"
          Relative tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector, and the absolute tolerance must also be a vector of the same length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     "compute consistent initial condition"
          If nonzero, ‘dassl’ will attempt to compute a consistent set of initial conditions.  This is generally not reliable, so it is best to provide a consistent set and leave this option set to zero.

     "enforce nonnegativity constraints"
          If you know that the solutions to your equations will always be non-negative, it may help to set this parameter to a nonzero value.  However, it is probably best to try leaving this option set to zero first, and only setting it to a nonzero value if that doesn’t work very well.

     "initial step size"
          Differential-algebraic problems may occasionally suffer from severe scaling difficulties on the first step.  If you know a great deal about the scaling of your problem, you can help to alleviate this problem by specifying an initial stepsize.

     "maximum order"
          Restrict the maximum order of the solution method.  This option must be between 1 and 5, inclusive.

     "maximum step size"
          Setting the maximum stepsize will avoid passing over very large regions (default is not specified).

     "step limit"
          Maximum number of integration steps to attempt on a single call to the underlying Fortran code.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Query or set options for the function ‘dassl’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
lsode_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2001
 -- : lsode_options ()
 -- : val = lsode_options (OPT)
 -- : lsode_options (OPT, VAL)
     Query or set options for the function ‘lsode’.

     When called with no arguments, the names of all available options and their current values are displayed.

     Given one argument, return the value of the option OPT.

     When called with two arguments, ‘lsode_options’ sets the option OPT to value VAL.

     Options include

     "absolute tolerance"
          Absolute tolerance.  May be either vector or scalar.  If a vector, it must match the dimension of the state vector.

     "relative tolerance"
          Relative tolerance parameter.  Unlike the absolute tolerance, this parameter may only be a scalar.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol * abs (y(i)) + atol(i)

     "integration method"
          A string specifying the method of integration to use to solve the ODE system.  Valid values are

          "adams"
          "non-stiff"
               No Jacobian used (even if it is available).

          "bdf"
          "stiff"
               Use stiff backward differentiation formula (BDF) method.  If a function to compute the Jacobian is not supplied, ‘lsode’ will compute a finite difference approximation of the Jacobian matrix.

     "initial step size"
          The step size to be attempted on the first step (default is determined automatically).

     "maximum order"
          Restrict the maximum order of the solution method.  If using the Adams method, this option must be between 1 and 12.  Otherwise, it must be between 1 and 5, inclusive.

     "maximum step size"
          Setting the maximum stepsize will avoid passing over very large regions (default is not specified).

     "minimum step size"
          The minimum absolute step size allowed (default is 0).

     "step limit"
          Maximum number of steps allowed (default is 100000).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Query or set options for the function ‘lsode’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
quad_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1084
 -- : quad_options ()
 -- : val = quad_options (OPT)
 -- : quad_options (OPT, VAL)
     Query or set options for the function ‘quad’.

     When called with no arguments, the names of all available options and their current values are displayed.

     Given one argument, return the value of the option OPT.

     When called with two arguments, ‘quad_options’ sets the option OPT to value VAL.

     Options include

     "absolute tolerance"
          Absolute tolerance; may be zero for pure relative error test.

     "relative tolerance"
          Non-negative relative tolerance.  If the absolute tolerance is zero, the relative tolerance must be greater than or equal to ‘max (50*eps, 0.5e-28)’.

     "single precision absolute tolerance"
          Absolute tolerance for single precision; may be zero for pure relative error test.

     "single precision relative tolerance"
          Non-negative relative tolerance for single precision.  If the absolute tolerance is zero, the relative tolerance must be greater than or equal to ‘max (50*eps, 0.5e-28)’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Query or set options for the function ‘quad’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
isguirunning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- : isguirunning ()
     Return true if Octave is running in GUI mode and false otherwise.

     See also: have_window_system.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if Octave is running in GUI mode and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
argv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- : argv ()
     Return the command line arguments passed to Octave.

     For example, if you invoked Octave using the command

          octave --no-line-editing --silent

     ‘argv’ would return a cell array of strings with the elements ‘--no-line-editing’ and ‘--silent’.

     If you write an executable Octave script, ‘argv’ will return the list of arguments passed to the script.  *Note Executable Octave Programs::, for an example of how to create an executable Octave script.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the command line arguments passed to Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
program_invocation_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 401
 -- : program_invocation_name ()
     Return the name that was typed at the shell prompt to run Octave.

     If executing a script from the command line (e.g., ‘octave foo.m’) or using an executable Octave script, the program name is set to the name of the script.  *Note Executable Octave Programs::, for an example of how to create an executable Octave script.

     See also: program_name.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the name that was typed at the shell prompt to run Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
program_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- : program_name ()
     Return the last component of the value returned by ‘program_invocation_name’.

     See also: program_invocation_name.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Return the last component of the value returned by ‘program_invocation_name’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
sparse_auto_mutate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 744
 -- : VAL = sparse_auto_mutate ()
 -- : OLD_VAL = sparse_auto_mutate (NEW_VAL)
 -- : sparse_auto_mutate (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will automatically mutate sparse matrices to full matrices to save memory.

     For example:

          s = speye (3);
          sparse_auto_mutate (false);
          s(:, 1) = 1;
          typeinfo (s)
          ⇒ sparse matrix
          sparse_auto_mutate (true);
          s(1, :) = 1;
          typeinfo (s)
          ⇒ matrix

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
Query or set the internal variable that controls whether Octave will automatically mutate sparse matrices to full matrices to save memory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
logical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 387
 -- : logical (X)
     Convert the numeric object X to logical type.

     Any nonzero values will be converted to true (1) while zero values will be converted to false (0).  The non-numeric value NaN cannot be converted and will produce an error.

     Compatibility Note: Octave accepts complex values as input, whereas MATLAB issues an error.

     See also: double, single, char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric object X to logical type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
iscell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
 -- : iscell (X)
     Return true if X is a cell array object.

     See also: ismatrix, isstruct, iscellstr, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if X is a cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- : cell (N)
 -- : cell (M, N)
 -- : cell (M, N, K, ...)
 -- : cell ([M N ...])
     Create a new cell array object.

     If invoked with a single scalar integer argument, return a square NxN cell array.  If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions.

     See also: cellstr, mat2cell, num2cell, struct2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Create a new cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- : iscellstr (CELL)
     Return true if every element of the cell array CELL is a character string.

     See also: ischar, isstring.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if every element of the cell array CELL is a character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 331
 -- : CSTR = cellstr (STRMAT)
     Create a new cell array object from the elements of the string array STRMAT.

     Each row of STRMAT becomes an element of CSTR.  Any trailing spaces in a row are deleted before conversion.

     To convert back from a cellstr to a character array use ‘char’.

     See also: cell, char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Create a new cell array object from the elements of the string array STRMAT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
struct2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 810
 -- : C = struct2cell (S)
     Create a new cell array from the objects stored in the struct object.

     If F is the number of fields in the structure, the resulting cell array will have a dimension vector corresponding to ‘[F size(S)]’.  For example:

          s = struct ("name", {"Peter", "Hannah", "Robert"},
                     "age", {23, 16, 3});
          c = struct2cell (s)
             ⇒ c = {2x1x3 Cell Array}
          c(1,1,:)(:)
             ⇒
                {
                  [1,1] = Peter
                  [2,1] = Hannah
                  [3,1] = Robert
                }
          c(2,1,:)(:)
             ⇒
                {
                  [1,1] = 23
                  [2,1] = 16
                  [3,1] = 3
                }

     See also: cell2struct, fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Create a new cell array from the objects stored in the struct object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
class


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- : CLASSNAME = class (OBJ)
 -- : class (S, ID)
 -- : class (S, ID, P, ...)
     Return the class of the object OBJ, or create a class with fields from structure S and name (string) ID.

     Additional arguments name a list of parent classes from which the new class is derived.

     See also: typeinfo, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Return the class of the object OBJ, or create a class with fields from structure S and name (string) ID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
isa


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 619
 -- : isa (OBJ, CLASSNAME)
     Return true if OBJ is an object from the class CLASSNAME.

     CLASSNAME may also be one of the following class categories:

     "float"
          Floating point value comprising classes "double" and "single".

     "integer"
          Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.

     "numeric"
          Numeric value comprising either a floating point or integer value.

     If CLASSNAME is a cell array of string, a logical array of the same size is returned, containing true for each class to which OBJ belongs to.

     See also: class, typeinfo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return true if OBJ is an object from the class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isobject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- : isobject (X)
     Return true if X is a class object.

     See also: class, typeinfo, isa, ismethod, isprop.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return true if X is a class object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- : ismethod (OBJ, METHOD)
 -- : ismethod (CLSNAME, METHOD)
     Return true if the string METHOD is a valid method of the object OBJ or of the class CLSNAME.

     See also: isprop, isobject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return true if the string METHOD is a valid method of the object OBJ or of the class CLSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
superiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- : superiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently constructed as having a higher precedence than CLASS_NAME.

     More that one such class can be specified in a single call.  This function may _only_ be called from a class constructor.

     See also: inferiorto.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
When called from a class constructor, mark the object currently constructed as having a higher precedence than CLASS_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
inferiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 321
 -- : inferiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently constructed as having a lower precedence than CLASS_NAME.

     More that one such class can be specified in a single call.  This function may _only_ be called from a class constructor.

     See also: superiorto.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
When called from a class constructor, mark the object currently constructed as having a lower precedence than CLASS_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
metaclass


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- : metaclass (obj)
     Returns the meta.class object corresponding to the class of OBJ.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Returns the meta.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1156
 -- : S = functions (FCN_HANDLE)
     Return a structure containing information about the function handle FCN_HANDLE.

     The structure S always contains these three fields:

     function
          The function name.  For an anonymous function (no name) this will be the actual function definition.

     type
          Type of the function.

          anonymous
               The function is anonymous.

          private
               The function is private.

          overloaded
               The function overloads an existing function.

          simple
               The function is a built-in or m-file function.

          subfunction
               The function is a subfunction within an m-file.

     file
          The m-file that will be called to perform the function.  This field is empty for anonymous and built-in functions.

     In addition, some function types may return more information in additional fields.

     *Warning:* ‘functions’ is provided for debugging purposes only.  Its behavior may change in the future and programs should not depend on any particular output format.

     See also: func2str, str2func.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return a structure containing information about the function handle FCN_HANDLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
func2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- : func2str (FCN_HANDLE)
     Return a string containing the name of the function referenced by the function handle FCN_HANDLE.

     See also: str2func, functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Return a string containing the name of the function referenced by the function handle FCN_HANDLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
str2func


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- : str2func (FCN_NAME)
 -- : str2func (FCN_NAME, "global")
     Return a function handle constructed from the string FCN_NAME.

     If the optional "global" argument is passed, locally visible functions are ignored in the lookup.

     See also: func2str, inline, functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a function handle constructed from the string FCN_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
is_function_handle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- : is_function_handle (X)
     Return true if X is a function handle.

     See also: isa, typeinfo, class, functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a function handle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
inline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1167
 -- : inline (STR)
 -- : inline (STR, ARG1, ...)
 -- : inline (STR, N)
     Create an inline function from the character string STR.

     If called with a single argument, the arguments of the generated function are extracted from the function itself.  The generated function arguments will then be in alphabetical order.  It should be noted that i and j are ignored as arguments due to the ambiguity between their use as a variable or their use as an built-in constant.  All arguments followed by a parenthesis are considered to be functions.  If no arguments are found, a function taking a single argument named ‘x’ will be created.

     If the second and subsequent arguments are character strings, they are the names of the arguments of the function.

     If the second argument is an integer N, the arguments are "x", "P1", ..., "PN".

     Programming Note: The use of ‘inline’ is discouraged and it may be removed from a future version of Octave.  The preferred way to create functions from strings is through the use of anonymous functions (*note Anonymous Functions::) or ‘str2func’.

     See also: argnames, formula, vectorize, str2func.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create an inline function from the character string STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
formula


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- : formula (FUN)
     Return a character string representing the inline function FUN.

     Note that ‘char (FUN)’ is equivalent to ‘formula (FUN)’.

     See also: char, argnames, inline, vectorize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a character string representing the inline function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
argnames


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 180
 -- : argnames (FUN)
     Return a cell array of character strings containing the names of the arguments of the inline function FUN.

     See also: inline, formula, vectorize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Return a cell array of character strings containing the names of the arguments of the inline function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vectorize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- : vectorize (FUN)
     Create a vectorized version of the inline function FUN by replacing all occurrences of ‘*’, ‘/’, etc., with ‘.*’, ‘./’, etc.

     This may be useful, for example, when using inline functions with numerical integration or optimization where a vector-valued function is expected.

          fcn = vectorize (inline ("x^2 - 1"))
             ⇒ fcn = f(x) = x.^2 - 1
          quadv (fcn, 0, 3)
             ⇒ 6

     See also: inline, formula, argnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Create a vectorized version of the inline function FUN by replacing all occurrences of ‘*’, ‘/’, etc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaObject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- : JOBJ = javaObject (CLASSNAME)
 -- : JOBJ = javaObject (CLASSNAME, ARG1, ...)
     Create a Java object of class CLASSSNAME, by calling the class constructor with the arguments ARG1, ...

     The first example below creates an uninitialized object, while the second example supplies an initial argument to the constructor.

          x = javaObject ("java.lang.StringBuffer")
          x = javaObject ("java.lang.StringBuffer", "Initial string")

     See also: javaMethod, javaArray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Create a Java object of class CLASSSNAME, by calling the class constructor with the arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaMethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 666
 -- : RET = javaMethod (METHODNAME, OBJ)
 -- : RET = javaMethod (METHODNAME, OBJ, ARG1, ...)
     Invoke the method METHODNAME on the Java object OBJ with the arguments ARG1, ....

     For static methods, OBJ can be a string representing the fully qualified name of the corresponding class.

     When OBJ is a regular Java object, structure-like indexing can be used as a shortcut syntax.  For instance, the two following statements are equivalent

            ret = javaMethod ("method1", x, 1.0, "a string")
            ret = x.method1 (1.0, "a string")

     ‘javaMethod’ returns the result of the method invocation.

     See also: methods, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Invoke the method METHODNAME on the Java object OBJ with the arguments ARG1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
java_matrix_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 577
 -- : VAL = java_matrix_autoconversion ()
 -- : OLD_VAL = java_matrix_autoconversion (NEW_VAL)
 -- : java_matrix_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls whether Java arrays are automatically converted to Octave matrices.

     The default value is false.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: java_unsigned_autoconversion, debug_java.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Query or set the internal variable that controls whether Java arrays are automatically converted to Octave matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
java_unsigned_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 713
 -- : VAL = java_unsigned_autoconversion ()
 -- : OLD_VAL = java_unsigned_autoconversion (NEW_VAL)
 -- : java_unsigned_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls how integer classes are converted when ‘java_matrix_autoconversion’ is enabled.

     When enabled, Java arrays of class Byte or Integer are converted to matrices of class uint8 or uint32 respectively.  The default value is true.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: java_matrix_autoconversion, debug_java.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Query or set the internal variable that controls how integer classes are converted when ‘java_matrix_autoconversion’ is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
debug_java


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 557
 -- : VAL = debug_java ()
 -- : OLD_VAL = debug_java (NEW_VAL)
 -- : debug_java (NEW_VAL, "local")
     Query or set the internal variable that determines whether extra debugging information regarding the initialization of the JVM and any Java exceptions is printed.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: java_matrix_autoconversion, java_unsigned_autoconversion.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
Query or set the internal variable that determines whether extra debugging information regarding the initialization of the JVM and any Java exceptions is printed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isjava


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- : isjava (X)
     Return true if X is a Java object.

     See also: class, typeinfo, isa, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if X is a Java object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isnull


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1237
 -- : isnull (X)
     Return true if X is a special null matrix, string, or single quoted string.

     Indexed assignment with such a null value on the right-hand side should delete array elements.  This function is used in place of ‘isempty’ when overloading the indexed assignment method (‘subsasgn’) for user-defined classes.  ‘isnull’ is used to distinguish between these two cases:

     ‘A(I) = []’

     and

     ‘X = []; A(I) = X’

     In the first assignment, the right-hand side is ‘[]’ which is a special null value.  As long as the index I is not empty, this code should delete elements from A rather than perform assignment.

     In the second assignment, the right-hand side is empty (because X is ‘[]’), but it is *not* null.  This code should assign the empty value to elements in A.

     An example from Octave’s built-in char class demonstrates the interpreter behavior when ‘isnull’ is used correctly.

          str = "Hello World";
          nm = "Wally";
          str(7:end) = nm                # indexed assignment
            ⇒ str = Hello Wally
          str(7:end) = ""                # indexed deletion
            ⇒ str = Hello

     See also: isempty, isindex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if X is a special null matrix, string, or single quoted string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
onCleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- : OBJ = onCleanup (FUNCTION)
     Create a special object that executes a given function upon destruction.

     If the object is copied to multiple variables (or cell or struct array elements) or returned from a function, FUNCTION will be executed after clearing the last copy of the object.  Note that if multiple local onCleanup variables are created, the order in which they are called is unspecified.  For similar functionality *Note The unwind_protect Statement::.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Create a special object that executes a given function upon destruction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1857
 -- : S = struct ()
 -- : S = struct (FIELD1, VALUE1, FIELD2, VALUE2, ...)
 -- : S = struct (OBJ)

     Create a scalar or array structure and initialize its values.

     The FIELD1, FIELD2, ... variables are strings specifying the names of the fields and the VALUE1, VALUE2, ... variables can be of any type.

     If the values are cell arrays, create a structure array and initialize its values.  The dimensions of each cell array of values must match.  Singleton cells and non-cell values are repeated so that they fill the entire array.  If the cells are empty, create an empty structure array with the specified field names.

     If the argument is an object, return the underlying struct.

     Observe that the syntax is optimized for struct *arrays*.  Consider the following examples:

          struct ("foo", 1)
            ⇒ scalar structure containing the fields:
              foo =  1

          struct ("foo", {})
            ⇒ 0x0 struct array containing the fields:
              foo

          struct ("foo", { {} })
            ⇒ scalar structure containing the fields:
              foo = {}(0x0)

          struct ("foo", {1, 2, 3})
            ⇒ 1x3 struct array containing the fields:
              foo


     The first case is an ordinary scalar struct—one field, one value.  The second produces an empty struct array with one field and no values, since being passed an empty cell array of struct array values.  When the value is a cell array containing a single entry, this becomes a scalar struct with that single entry as the value of the field.  That single entry happens to be an empty cell array.

     Finally, if the value is a non-scalar cell array, then ‘struct’ produces a struct *array*.

     See also: cell2struct, fieldnames, getfield, setfield, rmfield, isfield, orderfields, isstruct, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Create a scalar or array structure and initialize its values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isstruct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
 -- : isstruct (X)
     Return true if X is a structure or a structure array.

     See also: ismatrix, iscell, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a structure or a structure array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 255
 -- : isfield (X, "NAME")
 -- : isfield (X, NAME)
     Return true if the X is a structure and it includes an element named NAME.

     If NAME is a cell array of strings then a logical array of equal dimension is returned.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if the X is a structure and it includes an element named NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
numfields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : numfields (S)
     Return the number of fields of the structure S.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the number of fields of the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
cell2struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 636
 -- : cell2struct (CELL, FIELDS)
 -- : cell2struct (CELL, FIELDS, DIM)
     Convert CELL to a structure.

     The number of fields in FIELDS must match the number of elements in CELL along dimension DIM, that is ‘numel (FIELDS) == size (CELL, DIM)’.  If DIM is omitted, a value of 1 is assumed.

          A = cell2struct ({"Peter", "Hannah", "Robert";
                             185, 170, 168},
                           {"Name","Height"}, 1);
          A(1)
             ⇒
                {
                  Name   = Peter
                  Height = 185
                }


     See also: struct2cell, cell2mat, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Convert CELL to a structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rmfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- : SOUT = rmfield (S, "F")
 -- : SOUT = rmfield (S, F)
     Return a _copy_ of the structure (array) S with the field F removed.

     If F is a cell array of strings or a character array, remove each of the named fields.

     See also: orderfields, fieldnames, isfield.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return a _copy_ of the structure (array) S with the field F removed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
struct_levels_to_print


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- : VAL = struct_levels_to_print ()
 -- : OLD_VAL = struct_levels_to_print (NEW_VAL)
 -- : struct_levels_to_print (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of structure levels to display.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: print_struct_array_contents.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Query or set the internal variable that specifies the number of structure levels to display.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
print_struct_array_contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 756
 -- : VAL = print_struct_array_contents ()
 -- : OLD_VAL = print_struct_array_contents (NEW_VAL)
 -- : print_struct_array_contents (NEW_VAL, "local")
     Query or set the internal variable that specifies whether to print struct array contents.

     If true, values of struct array elements are printed.  This variable does not affect scalar structures whose elements are always printed.  In both cases, however, printing will be limited to the number of levels specified by STRUCT_LEVELS_TO_PRINT.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: struct_levels_to_print.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Query or set the internal variable that specifies whether to print struct array contents.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typeinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- : typeinfo ()
 -- : typeinfo (EXPR)

     Return the type of the expression EXPR, as a string.

     If EXPR is omitted, return a cell array of strings containing all the currently installed data types.

     See also: class, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the type of the expression EXPR, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 872
 -- : nargin ()
 -- : nargin (FCN)
     Report the number of input arguments to a function.

     Called from within a function, return the number of arguments passed to the function.  At the top level, return the number of command line arguments passed to Octave.

     If called with the optional argument FCN—a function name or handle—return the declared number of arguments that the function can accept.

     If the last argument to FCN is VARARGIN the returned value is negative.  For example, the function ‘union’ for sets is declared as

          function [y, ia, ib] = union (a, b, varargin)

          and

          nargin ("union")
          ⇒ -3

     Programming Note: ‘nargin’ does not work on compiled functions (‘.oct’ files) such as built-in or dynamically loaded functions.

     See also: nargout, narginchk, varargin, inputname.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Report the number of input arguments to a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1185
 -- : nargout ()
 -- : nargout (FCN)
     Report the number of output arguments from a function.

     Called from within a function, return the number of values the caller expects to receive.  At the top level, ‘nargout’ with no argument is undefined and will produce an error.

     If called with the optional argument FCN—a function name or handle—return the number of declared output values that the function can produce.

     If the final output argument is VARARGOUT the returned value is negative.

     For example,

          f ()

     will cause ‘nargout’ to return 0 inside the function ‘f’ and

          [s, t] = f ()

     will cause ‘nargout’ to return 2 inside the function ‘f’.

     In the second usage,

          nargout (@histc)   # or nargout ("histc") using a string input

     will return 2, because ‘histc’ has two outputs, whereas

          nargout (@imread)

     will return -2, because ‘imread’ has two outputs and the second is VARARGOUT.

     Programming Note.  ‘nargout’ does not work for built-in functions and returns -1 for all anonymous functions.

     See also: nargin, varargout, isargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Report the number of output arguments from a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
optimize_subsasgn_calls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 596
 -- : VAL = optimize_subsasgn_calls ()
 -- : OLD_VAL = optimize_subsasgn_calls (NEW_VAL)
 -- : optimize_subsasgn_calls (NEW_VAL, "local")
     Query or set the internal flag for ‘subsasgn’ method call optimizations.

     If true, Octave will attempt to eliminate the redundant copying when calling the ‘subsasgn’ method of a user-defined class.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Query or set the internal flag for ‘subsasgn’ method call optimizations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 691
 -- : isargout (K)
     Within a function, return a logical value indicating whether the argument K will be assigned to a variable on output.

     If the result is false, the argument has been ignored during the function call through the use of the tilde (~) special output argument.  Functions can use ‘isargout’ to avoid performing unnecessary calculations for outputs which are unwanted.

     If K is outside the range ‘1:max (nargout)’, the function returns false.  K can also be an array, in which case the function works element-by-element and a logical array is returned.  At the top level, ‘isargout’ returns an error.

     See also: nargout, varargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Within a function, return a logical value indicating whether the argument K will be assigned to a variable on output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
 -- : double (X)
     Convert X to double precision type.

     See also: single.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to double precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
 -- : single (X)
     Convert X to single precision type.

     See also: double.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to single precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
int8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- : int8 (X)
     Convert X to 8-bit integer type.

     See also: uint8, int16, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Convert X to 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- : int16 (X)
     Convert X to 16-bit integer type.

     See also: int8, uint8, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- : int32 (X)
     Convert X to 32-bit integer type.

     See also: int8, uint8, int16, uint16, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- : int64 (X)
     Convert X to 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- : uint8 (X)
     Convert X to unsigned 8-bit integer type.

     See also: int8, int16, uint16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert X to unsigned 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- : uint16 (X)
     Convert X to unsigned 16-bit integer type.

     See also: int8, uint8, int16, int32, uint32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- : uint32 (X)
     Convert X to unsigned 32-bit integer type.

     See also: int8, uint8, int16, uint16, int32, int64, uint64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- : uint64 (X)
     Convert X to unsigned 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, int64.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sizeof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
 -- : sizeof (VAL)
     Return the size of VAL in bytes.

     See also: whos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the size of VAL in bytes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
subsref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 933
 -- : subsref (VAL, IDX)
     Perform the subscripted element selection operation on VAL according to the subscript specified by IDX.

     The subscript IDX must be a structure array with fields ‘type’ and ‘subs’.  Valid values for ‘type’ are "()", "{}", and ".".  The ‘subs’ field may be either ":" or a cell array of index values.

     The following example shows how to extract the first two columns of a matrix

          val = magic (3)
              ⇒ val = [ 8   1   6
                         3   5   7
                         4   9   2 ]
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsref (val, idx)
               ⇒ [ 8   1
                    3   5
                    4   9 ]

     Note that this is the same as writing ‘val(:, 1:2)’.

     If IDX is an empty structure array with fields ‘type’ and ‘subs’, return VAL.

     See also: subsasgn, substruct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Perform the subscripted element selection operation on VAL according to the subscript specified by IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subsasgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- : subsasgn (VAL, IDX, RHS)
     Perform the subscripted assignment operation according to the subscript specified by IDX.

     The subscript IDX must be a structure array with fields ‘type’ and ‘subs’.  Valid values for ‘type’ are "()", "{}", and ".".  The ‘subs’ field may be either ":" or a cell array of index values.

     The following example shows how to set the two first columns of a 3-by-3 matrix to zero.

          val = magic (3);
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsasgn (val, idx, 0)
               ⇒  [ 0   0   6
                     0   0   7
                     0   0   2 ]

     Note that this is the same as writing ‘val(:, 1:2) = 0’.

     If IDX is an empty structure array with fields ‘type’ and ‘subs’, return RHS.

     See also: subsref, substruct, optimize_subsasgn_calls.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Perform the subscripted assignment operation according to the subscript specified by IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_sq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : is_sq_string (X)
     Return true if X is a single-quoted character string.

     See also: is_dq_string, ischar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a single-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_dq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : is_dq_string (X)
     Return true if X is a double-quoted character string.

     See also: is_sq_string, ischar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a double-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
disable_permutation_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 668
 -- : VAL = disable_permutation_matrix ()
 -- : OLD_VAL = disable_permutation_matrix (NEW_VAL)
 -- : disable_permutation_matrix (NEW_VAL, "local")
     Query or set the internal variable that controls whether permutation matrices are stored in a special space-efficient format.

     The default value is true.  If this option is disabled Octave will store permutation matrices as full matrices.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: disable_range, disable_diagonal_matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Query or set the internal variable that controls whether permutation matrices are stored in a special space-efficient format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
disable_diagonal_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 656
 -- : VAL = disable_diagonal_matrix ()
 -- : OLD_VAL = disable_diagonal_matrix (NEW_VAL)
 -- : disable_diagonal_matrix (NEW_VAL, "local")
     Query or set the internal variable that controls whether diagonal matrices are stored in a special space-efficient format.

     The default value is true.  If this option is disabled Octave will store diagonal matrices as full matrices.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: disable_range, disable_permutation_matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Query or set the internal variable that controls whether diagonal matrices are stored in a special space-efficient format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
disable_range


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 614
 -- : VAL = disable_range ()
 -- : OLD_VAL = disable_range (NEW_VAL)
 -- : disable_range (NEW_VAL, "local")
     Query or set the internal variable that controls whether ranges are stored in a special space-efficient format.

     The default value is true.  If this option is disabled Octave will store ranges as full matrices.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: disable_diagonal_matrix, disable_permutation_matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the internal variable that controls whether ranges are stored in a special space-efficient format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iskeyword


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- : iskeyword ()
 -- : iskeyword (NAME)
     Return true if NAME is an Octave keyword.

     If NAME is omitted, return a list of keywords.

     See also: isvarname, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return true if NAME is an Octave keyword.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
end


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 548
 -- : end
     Last element of an array or the end of any ‘for’, ‘parfor’, ‘if’, ‘do’, ‘while’, ‘function’, ‘switch’, ‘try’, or ‘unwind_protect’ block.

     As an index of an array, the magic index "end" refers to the last valid entry in an indexing operation.

     Example:

          X = [ 1 2 3; 4 5 6 ];
          X(1,end)
             ⇒ 3
          X(end,1)
             ⇒ 4
          X(end,end)
             ⇒ 6

     See also: for, parfor, if, do, while, function, switch, try, unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 172
Last element of an array or the end of any ‘for’, ‘parfor’, ‘if’, ‘do’, ‘while’, ‘function’, ‘switch’, ‘try’, or ‘unwind_protect’ block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
max_recursion_depth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 571
 -- : VAL = max_recursion_depth ()
 -- : OLD_VAL = max_recursion_depth (NEW_VAL)
 -- : max_recursion_depth (NEW_VAL, "local")
     Query or set the internal limit on the number of times a function may be called recursively.

     If the limit is exceeded, an error message is printed and control returns to the top level.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: max_stack_depth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Query or set the internal limit on the number of times a function may be called recursively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
silent_functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 608
 -- : VAL = silent_functions ()
 -- : OLD_VAL = silent_functions (NEW_VAL)
 -- : silent_functions (NEW_VAL, "local")
     Query or set the internal variable that controls whether internal output from a function is suppressed.

     If this option is disabled, Octave will display the results produced by evaluating expressions within a function body that are not terminated with a semicolon.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Query or set the internal variable that controls whether internal output from a function is suppressed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
string_fill_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 700
 -- : VAL = string_fill_char ()
 -- : OLD_VAL = string_fill_char (NEW_VAL)
 -- : string_fill_char (NEW_VAL, "local")
     Query or set the internal variable used to pad all rows of a character matrix to the same length.

     The value must be a single character and the default is " " (a single space).  For example:

          string_fill_char ("X");
          [ "these"; "are"; "strings" ]
                ⇒  "theseXX"
                    "areXXXX"
                    "strings"

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Query or set the internal variable used to pad all rows of a character matrix to the same length.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- : VAL = PS4 ()
 -- : OLD_VAL = PS4 (NEW_VAL)
 -- : PS4 (NEW_VAL, "local")
     Query or set the character string used to prefix output produced when echoing commands is enabled.

     The default value is "+ ".  *Note Diary and Echo Commands::, for a description of echoing commands.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: echo, PS1, PS2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Query or set the character string used to prefix output produced when echoing commands is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
echo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 919
 -- : echo
 -- : echo on
 -- : echo off
 -- : echo on all
 -- : echo off all
 -- : echo FUNCTION on
 -- : echo FUNCTION off
     Control whether commands are displayed as they are executed.

     Valid options are:

     ‘on’
          Enable echoing of commands as they are executed in script files.

     ‘off’
          Disable echoing of commands as they are executed in script files.

     ‘on all’
          Enable echoing of commands as they are executed in script files and functions.

     ‘off all’
          Disable echoing of commands as they are executed in script files and functions.

     ‘FUNCTION on’
          Enable echoing of commands as they are executed in the named function.

     ‘FUNCTION off’
          Disable echoing of commands as they are executed in the named function.

     With no arguments, ‘echo’ toggles the current echo state.

     See also: PS4.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Control whether commands are displayed as they are executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
jit_failcnt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- : VAL = jit_failcnt ()
 -- : OLD_VAL = jit_failcnt (NEW_VAL)
 -- : jit_failcnt (NEW_VAL, "local")
     Query or set the internal variable that counts the number of JIT fail exceptions for Octave’s JIT compiler.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: jit_enable, jit_startcnt, debug_jit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Query or set the internal variable that counts the number of JIT fail exceptions for Octave’s JIT compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
debug_jit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- : VAL = debug_jit ()
 -- : OLD_VAL = debug_jit (NEW_VAL)
 -- : debug_jit (NEW_VAL, "local")
     Query or set the internal variable that determines whether debugging/tracing is enabled for Octave’s JIT compiler.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: jit_enable, jit_startcnt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Query or set the internal variable that determines whether debugging/tracing is enabled for Octave’s JIT compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
jit_enable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 -- : VAL = jit_enable ()
 -- : OLD_VAL = jit_enable (NEW_VAL)
 -- : jit_enable (NEW_VAL, "local")
     Query or set the internal variable that enables Octave’s JIT compiler.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: jit_startcnt, debug_jit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Query or set the internal variable that enables Octave’s JIT compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
jit_startcnt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 681
 -- : VAL = jit_startcnt ()
 -- : OLD_VAL = jit_startcnt (NEW_VAL)
 -- : jit_startcnt (NEW_VAL, "local")
     Query or set the internal variable that determines whether JIT compilation will take place for a specific loop.

     Because compilation is a costly operation it does not make sense to employ JIT when the loop count is low.  By default only loops with greater than 1000 iterations will be accelerated.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: jit_enable, jit_failcnt, debug_jit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the internal variable that determines whether JIT compilation will take place for a specific loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
balance


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1451
 -- : AA = balance (A)
 -- : AA = balance (A, OPT)
 -- : [DD, AA] = balance (A, OPT)
 -- : [D, P, AA] = balance (A, OPT)
 -- : [CC, DD, AA, BB] = balance (A, B, OPT)

     Balance the matrix A to reduce numerical errors in future calculations.

     Compute ‘AA = DD \ A * DD’ in which AA is a matrix whose row and column norms are roughly equal in magnitude, and ‘DD = P * D’, in which P is a permutation matrix and D is a diagonal matrix of powers of two.  This allows the equilibration to be computed without round-off.  Results of eigenvalue calculation are typically improved by balancing first.

     If two output values are requested, ‘balance’ returns the diagonal D and the permutation P separately as vectors.  In this case, ‘DD = eye(n)(:,P) * diag (D)’, where n is the matrix size.

     If four output values are requested, compute ‘AA = CC*A*DD’ and ‘BB = CC*B*DD’, in which AA and BB have nonzero elements of approximately the same magnitude and CC and DD are permuted diagonal matrices as in DD for the algebraic eigenvalue problem.

     The eigenvalue balancing option OPT may be one of:

     "noperm", "S"
          Scale only; do not permute.

     "noscal", "P"
          Permute only; do not scale.

     Algebraic eigenvalue balancing uses standard LAPACK routines.

     Generalized eigenvalue problem balancing uses Ward’s algorithm (SIAM Journal on Scientific and Statistical Computing, 1981).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Balance the matrix A to reduce numerical errors in future calculations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1227
 -- : J = besselj (ALPHA, X)
 -- : J = besselj (ALPHA, X, OPT)
 -- : [J, IERR] = besselj (...)
     Compute Bessel functions of the first kind.

     The order of the Bessel function ALPHA must be real.  The points for evaluation X may be complex.

     If the optional argument OPT is 1 or true, the result J is multiplied by ‘exp (-abs (imag (X)))’.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Loss of significance by argument reduction, output may be inaccurate.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: bessely, besseli, besselk, besselh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute Bessel functions of the first kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bessely


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1229
 -- : Y = bessely (ALPHA, X)
 -- : Y = bessely (ALPHA, X, OPT)
 -- : [Y, IERR] = bessely (...)
     Compute Bessel functions of the second kind.

     The order of the Bessel function ALPHA must be real.  The points for evaluation X may be complex.

     If the optional argument OPT is 1 or true, the result Y is multiplied by ‘exp (-abs (imag (X)))’.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return ‘NaN’.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: besselj, besseli, besselk, besselh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Compute Bessel functions of the second kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besseli


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1237
 -- : I = besseli (ALPHA, X)
 -- : I = besseli (ALPHA, X, OPT)
 -- : [I, IERR] = besseli (...)
     Compute modified Bessel functions of the first kind.

     The order of the Bessel function ALPHA must be real.  The points for evaluation X may be complex.

     If the optional argument OPT is 1 or true, the result I is multiplied by ‘exp (-abs (real (X)))’.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return ‘NaN’.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: besselk, besselj, bessely, besselh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute modified Bessel functions of the first kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1225
 -- : K = besselk (ALPHA, X)
 -- : K = besselk (ALPHA, X, OPT)
 -- : [K, IERR] = besselk (...)

     Compute modified Bessel functions of the second kind.

     The order of the Bessel function ALPHA must be real.  The points for evaluation X may be complex.

     If the optional argument OPT is 1 or true, the result K is multiplied by ‘exp (X)’.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return ‘NaN’.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: besseli, besselj, bessely, besselh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute modified Bessel functions of the second kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1458
 -- : H = besselh (ALPHA, X)
 -- : H = besselh (ALPHA, K, X)
 -- : H = besselh (ALPHA, K, X, OPT)
 -- : [H, IERR] = besselh (...)
     Compute Bessel functions of the third kind (Hankel functions).

     The order of the Bessel function ALPHA must be real.  The kind of Hankel function is specified by K and may be either first (K = 1) or second (K = 2).  The default is Hankel functions of the first kind.  The points for evaluation X may be complex.

     If the optional argument OPT is 1 or true, the result is multiplied by ‘exp (-I*X)’ for K = 1 or ‘exp (I*X)’ for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return ‘NaN’.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: besselj, bessely, besseli, besselk.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute Bessel functions of the third kind (Hankel functions).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
airy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1089
 -- : [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their derivatives.

           K   Function   Scale factor (if "opt" is supplied)
          ---  --------   ---------------------------------------
           0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
           1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
           2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
           3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))

     The function call ‘airy (Z)’ is equivalent to ‘airy (0, Z)’.

     The result is the same size as Z.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Loss of significance by argument reduction, output may be inaccurate.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute Airy functions of the first and second kind, and their derivatives.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- : bitand (X, Y)
     Return the bitwise AND of non-negative integers.

     X, Y must be in the range [0,intmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the bitwise AND of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bitor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
 -- : bitor (X, Y)
     Return the bitwise OR of non-negative integers X and Y.

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the bitwise OR of non-negative integers X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitxor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- : bitxor (X, Y)
     Return the bitwise XOR of non-negative integers X and Y.

     See also: bitand, bitor, bitset, bitget, bitcmp, bitshift, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the bitwise XOR of non-negative integers X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bitshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 513
 -- : bitshift (A, K)
 -- : bitshift (A, K, N)
     Return a K bit shift of N-digit unsigned integers in A.

     A positive K leads to a left shift; A negative value to a right shift.

     If N is omitted it defaults to 64.  N must be in the range [1,64].

          bitshift (eye (3), 1)
          ⇒
          2 0 0
          0 2 0
          0 0 2

          bitshift (10, [-2, -1, 0, 1, 2])
          ⇒ 2   5  10  20  40

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return a K bit shift of N-digit unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
flintmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- : flintmax ()
 -- : flintmax ("double")
 -- : flintmax ("single")
     Return the largest integer that can be represented consecutively in a floating point value.

     The default class is "double", but "single" is a valid option.  On IEEE 754 compatible systems, ‘flintmax’ is 2^{53} for "double" and 2^{24} for "single".

     See also: intmax, realmax, realmin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return the largest integer that can be represented consecutively in a floating point value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 623
 -- : intmax (TYPE)
     Return the largest integer that can be represented in an integer type.

     The variable TYPE can be

     ‘int8’
          signed 8-bit integer.

     ‘int16’
          signed 16-bit integer.

     ‘int32’
          signed 32-bit integer.

     ‘int64’
          signed 64-bit integer.

     ‘uint8’
          unsigned 8-bit integer.

     ‘uint16’
          unsigned 16-bit integer.

     ‘uint32’
          unsigned 32-bit integer.

     ‘uint64’
          unsigned 64-bit integer.

     The default for TYPE is ‘int32’.

     See also: intmin, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the largest integer that can be represented in an integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 624
 -- : intmin (TYPE)
     Return the smallest integer that can be represented in an integer type.

     The variable TYPE can be

     ‘int8’
          signed 8-bit integer.

     ‘int16’
          signed 16-bit integer.

     ‘int32’
          signed 32-bit integer.

     ‘int64’
          signed 64-bit integer.

     ‘uint8’
          unsigned 8-bit integer.

     ‘uint16’
          unsigned 16-bit integer.

     ‘uint32’
          unsigned 32-bit integer.

     ‘uint64’
          unsigned 64-bit integer.

     The default for TYPE is ‘int32’.

     See also: intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the smallest integer that can be represented in an integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sizemax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 349
 -- : sizemax ()
     Return the largest value allowed for the size of an array.

     If Octave is compiled with 64-bit indexing, the result is of class int64, otherwise it is of class int32.  The maximum array size is slightly smaller than the maximum value allowable for the relevant class as reported by ‘intmax’.

     See also: intmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the largest value allowed for the size of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bsxfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 617
 -- : bsxfun (F, A, B)
     Apply a binary function F element-by-element to two array arguments A and B, expanding singleton dimensions in either input argument as necessary.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be capable of accepting two column-vector arguments of equal length, or one column vector argument and a scalar.

     The dimensions of A and B must be equal or singleton.  The singleton dimensions of the arrays will be expanded to the same dimensionality as the other array.

     See also: arrayfun, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
Apply a binary function F element-by-element to two array arguments A and B, expanding singleton dimensions in either input argument as necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
max_stack_depth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 563
 -- : VAL = max_stack_depth ()
 -- : OLD_VAL = max_stack_depth (NEW_VAL)
 -- : max_stack_depth (NEW_VAL, "local")
     Query or set the internal limit on the number of times a function may be called recursively.

     If the limit is exceeded, an error message is printed and control returns to the top level.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: max_recursion_depth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Query or set the internal limit on the number of times a function may be called recursively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3935
 -- : cellfun (NAME, C)
 -- : cellfun ("size", C, K)
 -- : cellfun ("isclass", C, CLASS)
 -- : cellfun (FUNC, C)
 -- : cellfun (FUNC, C, D)
 -- : [A, ...] = cellfun (...)
 -- : cellfun (..., "ErrorHandler", ERRFUNC)
 -- : cellfun (..., "UniformOutput", VAL)

     Evaluate the function named NAME on the elements of the cell array C.

     Elements in C are passed on to the named function individually.  The function NAME can be one of the functions

     ‘isempty’
          Return 1 for empty elements.

     ‘islogical’
          Return 1 for logical elements.

     ‘isnumeric’
          Return 1 for numeric elements.

     ‘isreal’
          Return 1 for real elements.

     ‘length’
          Return a vector of the lengths of cell elements.

     ‘ndims’
          Return the number of dimensions of each element.

     ‘numel’
     ‘prodofsize’
          Return the number of elements contained within each cell element.  The number is the product of the dimensions of the object at each cell element.

     ‘size’
          Return the size along the K-th dimension.

     ‘isclass’
          Return 1 for elements of CLASS.

     Additionally, ‘cellfun’ accepts an arbitrary function FUNC in the form of an inline function, function handle, or the name of a function (in a character string).  The function can take one or more arguments, with the inputs arguments given by C, D, etc.  Equally the function can return one or more output arguments.  For example:

          cellfun ("atan2", {1, 0}, {0, 1})
               ⇒ [ 1.57080   0.00000 ]

     The number of output arguments of ‘cellfun’ matches the number of output arguments of the function.  The outputs of the function will be collected into the output arguments of ‘cellfun’ like this:

          function [a, b] = twoouts (x)
            a = x;
            b = x*x;
          endfunction
          [aa, bb] = cellfun (@twoouts, {1, 2, 3})
               ⇒
                  aa =
                     1 2 3
                  bb =
                     1 4 9

     Note that per default the output argument(s) are arrays of the same size as the input arguments.  Input arguments that are singleton (1x1) cells will be automatically expanded to the size of the other arguments.

     If the parameter "UniformOutput" is set to true (the default), then the function must return scalars which will be concatenated into the return array(s).  If "UniformOutput" is false, the outputs are concatenated into a cell array (or cell arrays).  For example:

          cellfun ("tolower", {"Foo", "Bar", "FooBar"},
                   "UniformOutput", false)
          ⇒ {"foo", "bar", "foobar"}

     Given the parameter "ErrorHandler", then ERRFUNC defines a function to call in case FUNC generates an error.  The form of the function is

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to FUNC, given by S.  This is a structure with the elements "identifier", "message", and "index" giving respectively the error identifier, the error message, and the index into the input arguments of the element that caused the error.  For example:

          function y = foo (s, x), y = NaN; endfunction
          cellfun ("factorial", {-1,2}, "ErrorHandler", @foo)
          ⇒ [NaN 2]

     Use ‘cellfun’ intelligently.  The ‘cellfun’ function is a useful tool for avoiding loops.  It is often used with anonymous function handles; however, calling an anonymous function involves an overhead quite comparable to the overhead of an m-file function.  Passing a handle to a built-in function is faster, because the interpreter is not involved in the internal loop.  For example:

          a = {...}
          v = cellfun (@(x) det (x), a); # compute determinants
          v = cellfun (@det, a); # faster

     See also: arrayfun, structfun, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Evaluate the function named NAME on the elements of the cell array C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3289
 -- : arrayfun (FUNC, A)
 -- : X = arrayfun (FUNC, A)
 -- : X = arrayfun (FUNC, A, B, ...)
 -- : [X, Y, ...] = arrayfun (FUNC, A, ...)
 -- : arrayfun (..., "UniformOutput", VAL)
 -- : arrayfun (..., "ErrorHandler", ERRFUNC)

     Execute a function on each element of an array.

     This is useful for functions that do not accept array arguments.  If the function does accept array arguments it is better to call the function directly.

     The first input argument FUNC can be a string, a function handle, an inline function, or an anonymous function.  The input argument A can be a logic array, a numeric array, a string array, a structure array, or a cell array.  By a call of the function ‘arrayfun’ all elements of A are passed on to the named function FUNC individually.

     The named function can also take more than two input arguments, with the input arguments given as third input argument B, fourth input argument C, ... If given more than one array input argument then all input arguments must have the same sizes, for example:

          arrayfun (@atan2, [1, 0], [0, 1])
               ⇒ [ 1.57080   0.00000 ]

     If the parameter VAL after a further string input argument "UniformOutput" is set ‘true’ (the default), then the named function FUNC must return a single element which then will be concatenated into the return value and is of type matrix.  Otherwise, if that parameter is set to ‘false’, then the outputs are concatenated in a cell array.  For example:

          arrayfun (@(x,y) x:y, "abc", "def", "UniformOutput", false)
          ⇒
             {
               [1,1] = abcd
               [1,2] = bcde
               [1,3] = cdef
             }

     If more than one output arguments are given then the named function must return the number of return values that also are expected, for example:

          [A, B, C] = arrayfun (@find, [10; 0], "UniformOutput", false)
          ⇒
          A =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          B =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          C =
          {
             [1,1] =  10
             [2,1] = [](0x0)
          }

     If the parameter ERRFUNC after a further string input argument "ErrorHandler" is another string, a function handle, an inline function, or an anonymous function, then ERRFUNC defines a function to call in the case that FUNC generates an error.  The definition of the function must be of the form

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to FUNC, given by S.  This is a structure with the elements "identifier", "message", and "index" giving, respectively, the error identifier, the error message, and the index of the array elements that caused the error.  The size of the output argument of ERRFUNC must have the same size as the output argument of FUNC, otherwise a real error is thrown.  For example:

          function y = ferr (s, x), y = "MyString"; endfunction
          arrayfun (@str2num, [1234],
                    "UniformOutput", false, "ErrorHandler", @ferr)
          ⇒
             {
               [1,1] = MyString
             }

     See also: spfun, cellfun, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Execute a function on each element of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
num2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 700
 -- : C = num2cell (A)
 -- : C = num2cell (A, DIM)
     Convert the numeric matrix A to a cell array.

     If DIM is defined, the value C is of dimension 1 in this dimension and the elements of A are placed into C in slices.  For example:

          num2cell ([1,2;3,4])
             ⇒
                {
                  [1,1] =  1
                  [2,1] =  3
                  [1,2] =  2
                  [2,2] =  4
                }
          num2cell ([1,2;3,4],1)
             ⇒
                {
                  [1,1] =
                     1
                     3
                  [1,2] =
                     2
                     4
                }

     See also: mat2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mat2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 950
 -- : C = mat2cell (A, M, N)
 -- : C = mat2cell (A, D1, D2, ...)
 -- : C = mat2cell (A, R)
     Convert the matrix A to a cell array.

     If A is 2-D, then it is required that ‘sum (M) == size (A, 1)’ and ‘sum (N) == size (A, 2)’.  Similarly, if A is multi-dimensional and the number of dimensional arguments is equal to the dimensions of A, then it is required that ‘sum (DI) == size (A, i)’.

     Given a single dimensional argument R, the other dimensional arguments are assumed to equal ‘size (A,I)’.

     An example of the use of mat2cell is

          mat2cell (reshape (1:16,4,4), [3,1], [3,1])
          ⇒
          {
             [1,1] =

                1   5   9
                2   6  10
                3   7  11

             [2,1] =

                4   8  12

             [1,2] =

               13
               14
               15

             [2,2] = 16
          }

     See also: num2cell, cell2mat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert the matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cellslices


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 602
 -- : SL = cellslices (X, LB, UB, DIM)
     Given an array X, this function produces a cell array of slices from the array determined by the index vectors LB, UB, for lower and upper bounds, respectively.

     In other words, it is equivalent to the following code:

          n = length (lb);
          sl = cell (1, n);
          for i = 1:length (lb)
            sl{i} = x(:,...,lb(i):ub(i),...,:);
          endfor

     The position of the index is determined by DIM.  If not specified, slicing is done along the first non-singleton dimension.

     See also: cell2mat, cellindexmat, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
Given an array X, this function produces a cell array of slices from the array determined by the index vectors LB, UB, for lower and upper bounds, respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
cellindexmat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 524
 -- : Y = cellindexmat (X, VARARGIN)
     Perform indexing of matrices in a cell array.

     Given a cell array of matrices X, this function computes

          Y = cell (size (X));
          for i = 1:numel (X)
            Y{i} = X{i}(varargin{1}, varargin{2}, ..., varargin{N});
          endfor

     The indexing arguments may be scalar (‘2’), arrays (‘[1, 3]’), ranges (‘1:3’), or the colon operator (":").  However, the indexing keyword ‘end’ is not available.

     See also: cellslices, cellfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Perform indexing of matrices in a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
colloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 263
 -- : [R, AMAT, BMAT, Q] = colloc (N, "left", "right")
     Compute derivative and integral weight matrices for orthogonal collocation.

     Reference: J. Villadsen, M. L. Michelsen, ‘Solution of Differential Equation Models by Polynomial Approximation’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute derivative and integral weight matrices for orthogonal collocation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
conv2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 838
 -- : conv2 (A, B)
 -- : conv2 (V1, V2, M)
 -- : conv2 (..., SHAPE)
     Return the 2-D convolution of A and B.

     The size of the result is determined by the optional SHAPE argument which takes the following values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return the central part of the convolution with the same size as A.  The central part of the convolution begins at the indices ‘floor ([size(B)/2] + 1)’.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.  The size of the result is ‘max (size (A) - size (B) + 1, 0)’.

     When the third argument is a matrix, return the convolution of the matrix M by the vector V1 in the column direction and by the vector V2 in the row direction.

     See also: conv, convn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the 2-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
convn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 653
 -- : C = convn (A, B)
 -- : C = convn (A, B, SHAPE)
     Return the n-D convolution of A and B.

     The size of the result is determined by the optional SHAPE argument which takes the following values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return central part of the convolution with the same size as A.  The central part of the convolution begins at the indices ‘floor ([size(B)/2] + 1)’.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.  The size of the result is ‘max (size (A) - size (B) + 1, 0)’.

     See also: conv2, conv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the n-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
daspk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2497
 -- : [X, XDOT, ISTATE, MSG] = daspk (FCN, X_0, XDOT_0, T, T_CRIT)
     Solve a set of differential-algebraic equations.

     ‘daspk’ solves the set of equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row in the result matrices corresponding to one of the elements in the vector T.  The first element of T should be t_0 and correspond to the initial state of the system X_0 and its derivative XDOT_0, so that the first row of the output X is X_0 and the first row of the output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle that names the function f to call to compute the vector of residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function f described above, and the second element names a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to ‘daspk’ specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition.

     The set of initial states and derivatives are not strictly required to be consistent.  If they are not consistent, you must use the ‘daspk_options’ function to provide additional information so that ‘daspk’ can compute a consistent starting point.

     The fifth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past.  It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater than zero (consistent with the Fortran version of DASPK).

     If the computation is not successful, the value of ISTATE will be less than zero and MSG will contain additional information.

     You can use the function ‘daspk_options’ to set optional parameters for ‘daspk’.

     See also: dassl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Solve a set of differential-algebraic equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dasrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4141
 -- : [X, XDOT, T_OUT, ISTAT, MSG] = dasrt (FCN, G, X_0, XDOT_0, T)
 -- : ... = dasrt (FCN, G, X_0, XDOT_0, T, T_CRIT)
 -- : ... = dasrt (FCN, X_0, XDOT_0, T)
 -- : ... = dasrt (FCN, X_0, XDOT_0, T, T_CRIT)
     Solve a set of differential-algebraic equations.

     ‘dasrt’ solves the set of equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     with functional stopping criteria (root solving).

     The solution is returned in the matrices X and XDOT, with each row in the result matrices corresponding to one of the elements in the vector T_OUT.  The first element of T should be t_0 and correspond to the initial state of the system X_0 and its derivative XDOT_0, so that the first row of the output X is X_0 and the first row of the output XDOT is XDOT_0.

     The vector T provides an upper limit on the length of the integration.  If the stopping condition is met, the vector T_OUT will be shorter than T, and the final element of T_OUT will be the point at which the stopping condition was met, and may not correspond to any element of the vector T.

     The first argument, FCN, is a string, inline, or function handle that names the function f to call to compute the vector of residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function f described above, and the second element names a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The optional second argument names a function that defines the constraint functions whose roots are desired during the integration.  This function must have the form

          G_OUT = g (X, T)

     and return a vector of the constraint function values.  If the value of any of the constraint functions changes sign, DASRT will attempt to stop the integration at the point of the sign change.

     If the name of the constraint function is omitted, ‘dasrt’ solves the same problem as ‘daspk’ or ‘dassl’.

     Note that because of numerical errors in the constraint functions due to round-off and integration error, DASRT may return false roots, or return the same root at two or more nearly equal values of T.  If such false roots are suspected, the user should consider smaller error tolerances or higher precision in the evaluation of the constraint functions.

     If a root of some constraint function defines the end of the problem, the input to DASRT should nevertheless allow integration to a point slightly past that root, so that DASRT can locate the root by interpolation.

     The third and fourth arguments to ‘dasrt’ specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition.

     The set of initial states and derivatives are not strictly required to be consistent.  In practice, however, DASSL is not very good at determining a consistent set for you, so it is best if you ensure that the initial values result in the function evaluating to zero.

     The sixth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past.  It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be less than zero and MSG will contain additional information.

     You can use the function ‘dasrt_options’ to set optional parameters for ‘dasrt’.

     See also: dasrt_options, daspk, dasrt, lsode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Solve a set of differential-algebraic equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dassl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2523
 -- : [X, XDOT, ISTATE, MSG] = dassl (FCN, X_0, XDOT_0, T, T_CRIT)
     Solve a set of differential-algebraic equations.

     ‘dassl’ solves the set of equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row in the result matrices corresponding to one of the elements in the vector T.  The first element of T should be t_0 and correspond to the initial state of the system X_0 and its derivative XDOT_0, so that the first row of the output X is X_0 and the first row of the output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle that names the function f to call to compute the vector of residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function f described above, and the second element names a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to ‘dassl’ specify the initial condition of the states and their derivatives, and the fourth argument specifies a vector of output times at which the solution is desired, including the time corresponding to the initial condition.

     The set of initial states and derivatives are not strictly required to be consistent.  In practice, however, DASSL is not very good at determining a consistent set for you, so it is best if you ensure that the initial values result in the function evaluating to zero.

     The fifth argument is optional, and may be used to specify a set of times that the DAE solver should not integrate past.  It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be less than zero and MSG will contain additional information.

     You can use the function ‘dassl_options’ to set optional parameters for ‘dassl’.

     See also: daspk, dasrt, lsode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Solve a set of differential-algebraic equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
all


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 484
 -- : all (X)
 -- : all (X, DIM)
     For a vector argument, return true (logical 1) if all elements of the vector are nonzero.

     For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether all of the elements of the corresponding column of the matrix are nonzero.  For example:

          all ([2, 3; 1, 0])
              ⇒ [ 1, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.

     See also: any.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
For a vector argument, return true (logical 1) if all elements of the vector are nonzero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
any


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 552
 -- : any (X)
 -- : any (X, DIM)
     For a vector argument, return true (logical 1) if any element of the vector is nonzero.

     For a matrix argument, return a row vector of logical ones and zeros with each element indicating whether any of the elements of the corresponding column of the matrix are nonzero.  For example:

          any (eye (2, 4))
           ⇒ [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.  For example:

          any (eye (2, 4), 2)
           ⇒ [ 1; 1 ]

     See also: all.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
For a vector argument, return true (logical 1) if any element of the vector is nonzero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atan2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- : atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.

     Y and X must match in size and orientation.  The signs of elements of Y and X are used to determine the quadrants of each resulting value.

     This function is equivalent to ‘arg (complex (X, Y))’.

     See also: tan, tand, tanh, atanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute atan (Y / X) for corresponding elements of Y and X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hypot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 484
 -- : hypot (X, Y)
 -- : hypot (X, Y, Z, ...)
     Compute the element-by-element square root of the sum of the squares of X and Y.

     This is equivalent to ‘sqrt (X.^2 + Y.^2)’, but is calculated in a manner that avoids overflows for large values of X or Y.

     ‘hypot’ can also be called with more than 2 arguments; in this case, the arguments are accumulated from left to right:

          hypot (hypot (X, Y), Z)
          hypot (hypot (hypot (X, Y), Z), W), etc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the element-by-element square root of the sum of the squares of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
log2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- : log2 (X)
 -- : [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa and exponent so that ‘1/2 <= abs(f) < 1’ and E is an integer.  If ‘x = 0’, ‘f = e = 0’.

     See also: pow2, log, log10, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the base-2 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
rem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 917
 -- : rem (X, Y)
     Return the remainder of the division ‘X / Y’.

     The remainder is computed using the expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do not agree, or if either argument is complex.

     Programming Notes: Floating point numbers within a few eps of an integer will be rounded to an integer before computation for compatibility with MATLAB.

     By convention,

          rem (X, 0) = NaN  if X is a floating point variable
          rem (X, 0) = 0    if X is an integer variable
          rem (X, Y)        returns a value with the signbit from X

     For the opposite conventions see the ‘mod’ function.  In general, ‘rem’ is best when computing the remainder after division of two _positive_ numbers.  For negative numbers, or when the values are periodic, ‘mod’ is a better choice.

     See also: mod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the remainder of the division ‘X / Y’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 935
 -- : mod (X, Y)
     Compute the modulo of X and Y.

     Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for integer types.  This function handles negative values correctly.  That is, ‘mod (-1, 3)’ is 2, not -1, as ‘rem (-1, 3)’ returns.

     An error results if the dimensions of the arguments do not agree, or if either of the arguments is complex.

     Programming Notes: Floating point numbers within a few eps of an integer will be rounded to an integer before computation for compatibility with MATLAB.

     By convention,

          mod (X, 0) = X
          mod (X, Y)      returns a value with the signbit from Y

     For the opposite conventions see the ‘rem’ function.  In general, ‘mod’ is a better choice than ‘rem’ when any of the inputs are negative numbers or when the values are periodic.

     See also: rem.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Compute the modulo of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cumprod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 330
 -- : cumprod (X)
 -- : cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.

     If DIM is omitted, it defaults to the first non-singleton dimension.  For example:

          cumprod ([1, 2; 3, 4; 5, 6])
             ⇒  1   2
                 3   8
                15  48

     See also: prod, cumsum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Cumulative product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cumsum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 470
 -- : cumsum (X)
 -- : cumsum (X, DIM)
 -- : cumsum (..., "native")
 -- : cumsum (..., "double")
     Cumulative sum of elements along dimension DIM.

     If DIM is omitted, it defaults to the first non-singleton dimension.  For example:

          cumsum ([1, 2; 3, 4; 5, 6])
             ⇒  1   2
                 4   6
                 9  12

     See ‘sum’ for an explanation of the optional parameters "native" and "double".

     See also: sum, cumprod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Cumulative sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 818
 -- : M = diag (V)
 -- : M = diag (V, K)
 -- : M = diag (V, M, N)
 -- : V = diag (M)
 -- : V = diag (M, K)
     Return a diagonal matrix with vector V on diagonal K.

     The second argument is optional.  If it is positive, the vector is placed on the K-th superdiagonal.  If it is negative, it is placed on the -K-th subdiagonal.  The default value of K is 0, and the vector is placed on the main diagonal.  For example:

          diag ([1, 2, 3], 1)
             ⇒  0  1  0  0
                 0  0  2  0
                 0  0  0  3
                 0  0  0  0

     The 3-input form returns a diagonal matrix with vector V on the main diagonal and the resulting matrix being of size M rows x N columns.

     Given a matrix argument, instead of a vector, ‘diag’ extracts the K-th diagonal of the matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return a diagonal matrix with vector V on diagonal K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
prod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 740
 -- : prod (X)
 -- : prod (X, DIM)
 -- : prod (..., "native")
 -- : prod (..., "double")
     Product of elements along dimension DIM.

     If DIM is omitted, it defaults to the first non-singleton dimension.

     The optional "type" input determines the class of the variable used for calculations.  If the argument "native" is given, then the operation is performed in the same type as the original argument, rather than the default double type.

     For example:

          prod ([true, true])
             ⇒ 1
          prod ([true, true], "native")
             ⇒ true

     On the contrary, if "double" is given, the operation is performed in double precision even for single precision inputs.

     See also: cumprod, sum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
horzcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 338
 -- : horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-D array objects, ARRAY1, ARRAY2, ..., ARRAYN along dimension 2.

     Arrays may also be concatenated horizontally using the syntax for creating new matrices.  For example:

          HCAT = [ ARRAY1, ARRAY2, ... ]

     See also: cat, vertcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the horizontal concatenation of N-D array objects, ARRAY1, ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vertcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 334
 -- : vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-D array objects, ARRAY1, ARRAY2, ..., ARRAYN along dimension 1.

     Arrays may also be concatenated vertically using the syntax for creating new matrices.  For example:

          VCAT = [ ARRAY1; ARRAY2; ... ]

     See also: cat, horzcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return the vertical concatenation of N-D array objects, ARRAY1, ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
 -- : cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-D array objects, ARRAY1, ARRAY2, ..., ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
            ⇒ 1 1 0 0
               1 1 0 0

     Alternatively, we can concatenate A and B along the second dimension in the following way:

          [A, B]

     DIM can be larger than the dimensions of the N-D array objects and the result will thus have DIM dimensions as the following example shows:

          cat (4, ones (2, 2), zeros (2, 2))
            ⇒ ans(:,:,1,1) =

                 1 1
                 1 1

               ans(:,:,1,2) =

                 0 0
                 0 0

     See also: horzcat, vertcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return the concatenation of N-D array objects, ARRAY1, ARRAY2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
permute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- : permute (A, PERM)
     Return the generalized transpose for an N-D array object A.

     The permutation vector PERM must contain the elements ‘1:ndims (A)’ (in any order, but each element must appear only once).  The Nth dimension of A gets remapped to dimension ‘PERM(N)’.  For example:

          X = zeros ([2, 3, 5, 7]);
          size (X)
             ⇒  2   3   5   7

          size (permute (X, [2, 1, 3, 4]))
             ⇒  3   2   5   7

          size (permute (X, [1, 3, 4, 2]))
             ⇒  2   5   7   3

          ## The identity permutation
          size (permute (X, [1, 2, 3, 4]))
             ⇒  2   3   5   7

     See also: ipermute.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the generalized transpose for an N-D array object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ipermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 205
 -- : ipermute (A, IPERM)
     The inverse of the ‘permute’ function.

     The expression

          ipermute (permute (A, perm), perm)

     returns the original array A.

     See also: permute.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
The inverse of the ‘permute’ function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
length


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 326
 -- : length (A)
     Return the length of the object A.

     The length is 0 for empty objects, 1 for scalars, and the number of elements for vectors.  For matrix or N-dimensional objects, the length is the number of elements along the largest dimension (equivalent to ‘max (size (A))’).

     See also: numel, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the length of the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ndims


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- : ndims (A)
     Return the number of dimensions of A.

     For any array, the result will always be greater than or equal to 2.  Trailing singleton dimensions are not counted.

          ndims (ones (4, 1, 2, 1))
              ⇒ 3

     See also: size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the number of dimensions of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
numel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 858
 -- : numel (A)
 -- : numel (A, IDX1, IDX2, ...)
     Return the number of elements in the object A.

     Optionally, if indices IDX1, IDX2, ... are supplied, return the number of elements that would result from the indexing

          A(IDX1, IDX2, ...)

     Note that the indices do not have to be scalar numbers.  For example,

          A = 1;
          B = ones (2, 3);
          numel (A, B)

     will return 6, as this is the number of ways to index with B.  Or the index could be the string ":" which represents the colon operator.  For example,

          A = ones (5, 3);
          numel (A, 2, ":")

     will return 3 as the second row has three column entries.

     This method is also called when an object appears as lvalue with cs-list indexing, i.e., ‘object{...}’ or ‘object(...).field’.

     See also: size, length, ndims.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the number of elements in the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1434
 -- : SZ = size (A)
 -- : DIM_SZ = size (A, DIM)
 -- : [ROWS, COLS, ..., DIM_N_SZ] = size (...)
     Return a row vector with the size (number of elements) of each dimension for the object A.

     When given a second argument, DIM, return the size of the corresponding dimension.

     With a single output argument, ‘size’ returns a row vector.  When called with multiple output arguments, ‘size’ returns the size of dimension N in the Nth argument.  The number of rows, dimension 1, is returned in the first argument, the number of columns, dimension 2, is returned in the second argument, etc.  If there are more dimensions in A than there are output arguments, ‘size’ returns the total number of elements in the remaining dimensions in the final output argument.

     Example 1: single row vector output

          size ([1, 2; 3, 4; 5, 6])
             ⇒ [ 3, 2 ]

     Example 2: number of elements in 2nd dimension (columns)

          size ([1, 2; 3, 4; 5, 6], 2)
              ⇒ 2

     Example 3: number of output arguments == number of dimensions

          [nr, nc] = size ([1, 2; 3, 4; 5, 6])
              ⇒ nr = 3
              ⇒ nc = 2

     Example 4: number of output arguments < number of dimensions

          [nr, remainder] = size (ones (2, 3, 4, 5))
              ⇒ nr = 2
              ⇒ remainder = 60

     See also: numel, ndims, length, rows, columns, size_equal, common_size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return a row vector with the size (number of elements) of each dimension for the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
size_equal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- : size_equal (A, B, ...)
     Return true if the dimensions of all arguments agree.

     Trailing singleton dimensions are ignored.  When called with a single argument, or no argument, ‘size_equal’ returns true.

     See also: size, numel, ndims, common_size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the dimensions of all arguments agree.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
nnz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : N = nnz (A)
     Return the number of nonzero elements in A.

     See also: nzmax, nonzeros, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the number of nonzero elements in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nzmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 354
 -- : N = nzmax (SM)
     Return the amount of storage allocated to the sparse matrix SM.

     Note that Octave tends to crop unused memory at the first opportunity for sparse objects.  Thus, in general the value of ‘nzmax’ will be the same as ‘nnz’ except for some cases of user-created sparse objects.

     See also: nnz, spalloc, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the amount of storage allocated to the sparse matrix SM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- : rows (A)
     Return the number of rows of A.

     See also: columns, size, length, numel, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return the number of rows of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- : columns (A)
     Return the number of columns of A.

     See also: rows, size, length, numel, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the number of columns of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1134
 -- : sum (X)
 -- : sum (X, DIM)
 -- : sum (..., "native")
 -- : sum (..., "double")
 -- : sum (..., "extra")
     Sum of elements along dimension DIM.

     If DIM is omitted, it defaults to the first non-singleton dimension.

     The optional "type" input determines the class of the variable used for calculations.  By default, operations on floating point inputs (double or single) are performed in their native data type, while operations on integer, logical, and character data types are performed using doubles.  If the argument "native" is given, then the operation is performed in the same type as the original argument.

     For example:

          sum ([true, true])
             ⇒ 2
          sum ([true, true], "native")
             ⇒ true

     If "double" is given the sum is performed in double precision even for single precision inputs.

     For double precision inputs, the "extra" option will use a more accurate algorithm than straightforward summation.  For single precision inputs, "extra" is the same as "double".  For all other data type "extra" has no effect.

     See also: cumsum, sumsq, prod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sumsq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 365
 -- : sumsq (X)
 -- : sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.

     If DIM is omitted, it defaults to the first non-singleton dimension.

     This function is conceptually equivalent to computing

          sum (x .* conj (x), dim)

     but it uses less memory and avoids calling ‘conj’ if X is real.

     See also: sum, prod.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Sum of squares of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
islogical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- : islogical (X)
 -- : isbool (X)
     Return true if X is a logical object.

     See also: ischar, isfloat, isinteger, isstring, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return true if X is a logical object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isinteger


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 290
 -- : isinteger (X)
     Return true if X is an integer object (int8, uint8, int16, etc.).

     Note that ‘isinteger (14)’ is false because numeric constants in Octave are double precision floating point values.

     See also: isfloat, ischar, islogical, isstring, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return true if X is an integer object (int8, uint8, int16, etc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscomplex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- : iscomplex (X)
     Return true if X is a complex-valued numeric object.

     See also: isreal, isnumeric, ischar, isfloat, islogical, isstring, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a complex-valued numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfloat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 219
 -- : isfloat (X)
     Return true if X is a floating-point numeric object.

     Objects of class double or single are floating-point objects.

     See also: isinteger, ischar, islogical, isnumeric, isstring, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a floating-point numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
complex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 453
 -- : complex (X)
 -- : complex (RE, IM)
     Return a complex value from real arguments.

     With 1 real argument X, return the complex result ‘X + 0i’.

     With 2 real arguments, return the complex result ‘RE + IMi’.  ‘complex’ can often be more convenient than expressions such as ‘a + b*i’.  For example:

          complex ([1, 2], [3, 4])
            ⇒ [ 1 + 3i   2 + 4i ]

     See also: real, imag, iscomplex, abs, arg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return a complex value from real arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isreal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- : isreal (X)
     Return true if X is a non-complex matrix or scalar.

     For compatibility with MATLAB, this includes logical and character matrices.

     See also: iscomplex, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if X is a non-complex matrix or scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isempty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- : isempty (A)
     Return true if A is an empty matrix (any one of its dimensions is zero).

     See also: isnull, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return true if A is an empty matrix (any one of its dimensions is zero).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isnumeric


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- : isnumeric (X)
     Return true if X is a numeric object, i.e., an integer, real, or complex array.

     Logical and character arrays are not considered to be numeric.

     See also: isinteger, isfloat, isreal, iscomplex, ischar, islogical, isstring, iscell, isstruct, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if X is a numeric object, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isscalar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- : isscalar (X)
     Return true if X is a scalar.

     See also: isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Return true if X is a scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isvector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 255
 -- : isvector (X)
     Return true if X is a vector.

     A vector is a 2-D array where one of the dimensions is equal to 1.  As a consequence a 1x1 array, or scalar, is also a vector.

     See also: isscalar, ismatrix, size, rows, columns, length.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Return true if X is a vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- : isrow (X)
     Return true if X is a row vector 1xN with non-negative N.

     See also: iscolumn, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return true if X is a row vector 1xN with non-negative N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
iscolumn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- : iscolumn (X)
     Return true if X is a column vector Nx1 with non-negative N.

     See also: isrow, isscalar, isvector, ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return true if X is a column vector Nx1 with non-negative N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- : ismatrix (A)
     Return true if A is a 2-D array.

     See also: isscalar, isvector, iscell, isstruct, issparse, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return true if A is a 2-D array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issquare


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : issquare (X)
     Return true if X is a square matrix.

     See also: isscalar, isvector, ismatrix, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a square matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 703
 -- : ones (N)
 -- : ones (M, N)
 -- : ones (M, N, K, ...)
 -- : ones ([M N ...])
 -- : ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.

     If invoked with a single scalar integer argument N, return a square NxN matrix.

     If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions.

     To create a constant matrix whose values are all the same use an expression such as

          val_matrix = val * ones (m, n)

     The optional argument CLASS specifies the class of the return array and defaults to double.  For example:

          val = ones (m,n, "uint8")

     See also: zeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
zeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 574
 -- : zeros (N)
 -- : zeros (M, N)
 -- : zeros (M, N, K, ...)
 -- : zeros ([M N ...])
 -- : zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.

     If invoked with a single scalar integer argument, return a square NxN matrix.

     If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions.

     The optional argument CLASS specifies the class of the return array and defaults to double.  For example:

          val = zeros (m,n, "uint8")

     See also: ones.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
Inf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 960
 -- : Inf
 -- : Inf (N)
 -- : Inf (N, M)
 -- : Inf (N, M, K, ...)
 -- : Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented using the IEEE floating point format for numbers.  Two common examples which produce infinity are division by zero and overflow.

          [ 1/0 e^800 ]
          ⇒ Inf   Inf

     When called with no arguments, return a scalar with the value ‘Inf’.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: isinf, NaN.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Return a scalar, matrix or N-dimensional array whose elements are all equal to the IEEE representation for positive infinity.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
NaN


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1155
 -- : NaN
 -- : NaN (N)
 -- : NaN (N, M)
 -- : NaN (N, M, K, ...)
 -- : NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the IEEE symbol NaN (Not a Number).

     NaN is the result of operations which do not produce a well defined numerical result.  Common operations which produce a NaN are arithmetic with infinity (Inf - Inf), zero divided by zero (0/0), and any operation involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN). This behavior is specified by the IEEE standard for floating point arithmetic.  To find NaN values, use the ‘isnan’ function.

     When called with no arguments, return a scalar with the value ‘NaN’.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: isnan, Inf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the IEEE symbol NaN (Not a Number).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
e


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 752
 -- : e
 -- : e (N)
 -- : e (N, M)
 -- : e (N, M, K, ...)
 -- : e (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the base of natural logarithms.

     The constant ‘e’ satisfies the equation ‘log’ (e) = 1.

     When called with no arguments, return a scalar with the value e.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: log, exp, pi, I.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the base of natural logarithms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1025
 -- : eps
 -- : eps (X)
 -- : eps (N, M)
 -- : eps (N, M, K, ...)
 -- : eps (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are all eps, the machine precision.

     More precisely, ‘eps’ is the relative spacing between any two adjacent numbers in the machine’s floating point system.  This number is obviously system dependent.  On machines that support IEEE floating point arithmetic, ‘eps’ is approximately 2.2204e-16 for double precision and 1.1921e-07 for single precision.

     When called with no arguments, return a scalar with the value ‘eps (1.0)’.

     Given a single argument X, return the distance between X and the next largest value.

     When called with more than one argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.  The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: realmax, realmin, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Return a scalar, matrix or N-dimensional array whose elements are all eps, the machine precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
pi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 775
 -- : pi
 -- : pi (N)
 -- : pi (N, M)
 -- : pi (N, M, K, ...)
 -- : pi (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the ratio of the circumference of a circle to its diameter.

     Internally, ‘pi’ is computed as ‘4.0 * atan (1.0)’.

     When called with no arguments, return a scalar with the value of pi.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: e, I.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the ratio of the circumference of a circle to its diameter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 979
 -- : realmax
 -- : realmax (N)
 -- : realmax (N, M)
 -- : realmax (N, M, K, ...)
 -- : realmax (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the largest floating point number that is representable.

     The actual value is system dependent.  On machines that support IEEE floating point arithmetic, ‘realmax’ is approximately 1.7977e+308 for double precision and 3.4028e+38 for single precision.

     When called with no arguments, return a scalar with the value ‘realmax ("double")’.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: realmin, intmax, flintmax, eps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the largest floating point number that is representable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 981
 -- : realmin
 -- : realmin (N)
 -- : realmin (N, M)
 -- : realmin (N, M, K, ...)
 -- : realmin (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the smallest normalized floating point number that is representable.

     The actual value is system dependent.  On machines that support IEEE floating point arithmetic, ‘realmin’ is approximately 2.2251e-308 for double precision and 1.1755e-38 for single precision.

     When called with no arguments, return a scalar with the value ‘realmin ("double")’.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: realmax, intmin, eps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the smallest normalized floating point number that is representable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
I


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 849
 -- : I
 -- : I (N)
 -- : I (N, M)
 -- : I (N, M, K, ...)
 -- : I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the pure imaginary unit, defined as ‘sqrt (-1)’.

     I, and its equivalents i, j, and J, are functions so any of the names may be reused for other purposes (such as i for a counter variable).

     When called with no arguments, return a scalar with the value i.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: e, pi, log, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the pure imaginary unit, defined as ‘sqrt (-1)’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
NA


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 818
 -- : NA
 -- : NA (N)
 -- : NA (N, M)
 -- : NA (N, M, K, ...)
 -- : NA (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are all equal to the special constant used to designate missing values.

     Note that NA always compares not equal to NA (NA != NA). To find NA values, use the ‘isna’ function.

     When called with no arguments, return a scalar with the value ‘NA’.

     When called with a single argument, return a square matrix with the dimension specified.

     When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.

     The optional argument CLASS specifies the return type and may be either "double" or "single".

     See also: isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Return a scalar, matrix, or N-dimensional array whose elements are all equal to the special constant used to designate missing values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
false


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- : false (X)
 -- : false (N, M)
 -- : false (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all logical 0.

     If invoked with a single scalar integer argument, return a square matrix of the specified size.

     If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with given dimensions.

     See also: true.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a matrix or N-dimensional array whose elements are all logical 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
true


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- : true (X)
 -- : true (N, M)
 -- : true (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all logical 1.

     If invoked with a single scalar integer argument, return a square matrix of the specified size.

     If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with given dimensions.

     See also: false.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a matrix or N-dimensional array whose elements are all logical 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eye


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1067
 -- : eye (N)
 -- : eye (M, N)
 -- : eye ([M N])
 -- : eye (..., CLASS)
     Return an identity matrix.

     If invoked with a single scalar argument N, return a square NxN identity matrix.

     If supplied two scalar arguments (M, N), ‘eye’ takes them to be the number of rows and columns.  If given a vector with two elements, ‘eye’ uses the values of the elements as the number of rows and columns, respectively.  For example:

          eye (3)
           ⇒  1  0  0
               0  1  0
               0  0  1

     The following expressions all produce the same result:

          eye (2)
          ≡
          eye (2, 2)
          ≡
          eye (size ([1, 2; 3, 4]))

     The optional argument CLASS, allows ‘eye’ to return an array of the specified type, like

          val = zeros (n,m, "uint8")

     Calling ‘eye’ with no arguments is equivalent to calling it with an argument of 1.  Any negative dimensions are treated as zero.  These odd definitions are for compatibility with MATLAB.

     See also: speye, ones, zeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return an identity matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 842
 -- : linspace (START, END)
 -- : linspace (START, END, N)
     Return a row vector with N linearly spaced elements between START and END.

     If the number of elements is greater than one, then the endpoints START and END are always included in the range.  If START is greater than END, the elements are stored in decreasing order.  If the number of points is not specified, a value of 100 is used.

     The ‘linspace’ function returns a row vector when both START and END are scalars.  If one, or both, inputs are vectors, then ‘linspace’ transforms them to column vectors and returns a matrix where each row is an independent sequence between ‘START(ROW_N), END(ROW_N)’.

     For compatibility with MATLAB, return the second argument (END) when only a single value (N = 1) is requested.

     See also: colon, logspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return a row vector with N linearly spaced elements between START and END.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
resize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1139
 -- : resize (X, M)
 -- : resize (X, M, N, ...)
 -- : resize (X, [M N ...])
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the corresponding element of X if the indices are within the bounds of X; otherwise, the element is set to zero.

     In other words, the statement

          y = resize (x, dv)

     is equivalent to the following code:

          y = zeros (dv, class (x));
          sz = min (dv, size (x));
          for i = 1:length (sz)
            idx{i} = 1:sz(i);
          endfor
          y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied, and it is a scalar, the dimension of the result is M-by-M.  If M, N, ... are all scalars, then the dimensions of the result are M-by-N-by-....  If given a vector as input, then the dimensions of the result are given by the elements of that vector.

     An object can be resized to more dimensions than it has; in such case the missing dimensions are assumed to be 1.  Resizing an object to fewer dimensions is not possible.

     See also: reshape, postpad, prepad, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Resize X cutting off elements as necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
reshape


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 921
 -- : reshape (A, M, N, ...)
 -- : reshape (A, [M N ...])
 -- : reshape (A, ..., [], ...)
 -- : reshape (A, SIZE)
     Return a matrix with the specified dimensions (M, N, ...) whose elements are taken from the matrix A.

     The elements of the matrix are accessed in column-major order (like Fortran arrays are stored).

     The following code demonstrates reshaping a 1x4 row vector into a 2x2 square matrix.

          reshape ([1, 2, 3, 4], 2, 2)
                ⇒  1  3
                    2  4

     Note that the total number of elements in the original matrix (‘prod (size (A))’) must match the total number of elements in the new matrix (‘prod ([M N ...])’).

     A single dimension of the return matrix may be left unspecified and Octave will determine its size automatically.  An empty matrix ([]) is used to flag the unspecified dimension.

     See also: resize, vec, postpad, cat, squeeze.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return a matrix with the specified dimensions (M, N, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
vec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 382
 -- : V = vec (X)
 -- : V = vec (X, DIM)
     Return the vector obtained by stacking the columns of the matrix X one above the other.

     Without DIM this is equivalent to ‘X(:)’.

     If DIM is supplied, the dimensions of V are set to DIM with all elements along the last dimension.  This is equivalent to ‘shiftdim (X(:), 1-DIM)’.

     See also: vech, resize, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return the vector obtained by stacking the columns of the matrix X one above the other.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
squeeze


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 237
 -- : squeeze (X)
     Remove singleton dimensions from X and return the result.

     Note that for compatibility with MATLAB, all objects have a minimum of two dimensions and row vectors are left unchanged.

     See also: reshape.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Remove singleton dimensions from X and return the result.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
full


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- : FM = full (SM)
     Return a full storage matrix from a sparse, diagonal, or permutation matrix, or a range.

     See also: sparse, issparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return a full storage matrix from a sparse, diagonal, or permutation matrix, or a range.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
norm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1372
 -- : norm (A)
 -- : norm (A, P)
 -- : norm (A, P, OPT)
     Compute the p-norm of the matrix A.

     If the second argument is not given, ‘p = 2’ is used.

     If A is a matrix (or sparse matrix):

     P = ‘1’
          1-norm, the largest column sum of the absolute values of A.

     P = ‘2’
          Largest singular value of A.

     P = ‘Inf’ or "inf"
          Infinity norm, the largest row sum of the absolute values of A.

     P = "fro"
          Frobenius norm of A, ‘sqrt (sum (diag (A' * A)))’.

     other P, ‘P > 1’
          maximum ‘norm (A*x, p)’ such that ‘norm (x, p) == 1’

     If A is a vector or a scalar:

     P = ‘Inf’ or "inf"
          ‘max (abs (A))’.

     P = ‘-Inf’
          ‘min (abs (A))’.

     P = "fro"
          Frobenius norm of A, ‘sqrt (sumsq (abs (A)))’.

     P = 0
          Hamming norm—the number of nonzero elements.

     other P, ‘P > 1’
          p-norm of A, ‘(sum (abs (A) .^ P)) ^ (1/P)’.

     other P ‘P < 1’
          the p-pseudonorm defined as above.

     If OPT is the value "rows", treat each row as a vector and compute its norm.  The result is returned as a column vector.  Similarly, if OPT is "columns" or "cols" then compute the norms of each column and return a row vector.

     See also: normest, normest1, vecnorm, cond, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute the p-norm of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
not


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- : Z = not (X)
     Return the logical NOT of X.

     This function is equivalent to the operator syntax ‘! X’.

     See also: and, or, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return the logical NOT of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uplus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- : uplus (X)
     This function and + X are equivalent.

     See also: uminus, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and + X are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uminus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- : uminus (X)
     This function and - X are equivalent.

     See also: uplus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and - X are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
transpose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- : transpose (X)
     Return the transpose of X.

     This function and X.’ are equivalent.

     See also: ctranspose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ctranspose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
 -- : ctranspose (X)
     Return the complex conjugate transpose of X.

     This function and X’ are equivalent.

     See also: transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the complex conjugate transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
plus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 294
 -- : plus (X, Y)
 -- : plus (X1, X2, ...)
     This function and X + Y are equivalent.

     If more arguments are given, the summation is applied cumulatively from left to right:

          (...((X1 + X2) + X3) + ...)

     At least one argument is required.

     See also: minus, uplus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and X + Y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
minus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
 -- : minus (X, Y)
     This function and X - Y are equivalent.

     See also: plus, uminus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and X - Y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mtimes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- : mtimes (X, Y)
 -- : mtimes (X1, X2, ...)
     Return the matrix multiplication product of inputs.

     This function and X * Y are equivalent.  If more arguments are given, the multiplication is applied cumulatively from left to right:

          (...((X1 * X2) * X3) * ...)

     At least one argument is required.

     See also: times, plus, minus, rdivide, mrdivide, mldivide, mpower.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the matrix multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mrdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- : mrdivide (X, Y)
     Return the matrix right division of X and Y.

     This function and X / Y are equivalent.

     See also: mldivide, rdivide, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the matrix right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mpower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 180
 -- : mpower (X, Y)
     Return the matrix power operation of X raised to the Y power.

     This function and X ^ Y are equivalent.

     See also: power, mtimes, plus, minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the matrix power operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- : mldivide (X, Y)
     Return the matrix left division of X and Y.

     This function and X \ Y are equivalent.

     See also: mrdivide, ldivide, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the matrix left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : lt (X, Y)
     This function is equivalent to ‘X < Y’.

     See also: le, eq, ge, gt, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
This function is equivalent to ‘X < Y’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
le


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- : le (X, Y)
     This function is equivalent to ‘X <= Y’.

     See also: eq, ge, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
This function is equivalent to ‘X <= Y’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
eq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- : eq (X, Y)
     Return true if the two inputs are equal.

     This function is equivalent to ‘X == Y’.

     See also: ne, isequal, le, ge, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if the two inputs are equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- : ge (X, Y)
     This function is equivalent to ‘X >= Y’.

     See also: le, eq, gt, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
This function is equivalent to ‘X >= Y’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
gt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : gt (X, Y)
     This function is equivalent to ‘X > Y’.

     See also: le, eq, ge, ne, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
This function is equivalent to ‘X > Y’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ne


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- : ne (X, Y)
     Return true if the two inputs are not equal.

     This function is equivalent to ‘X != Y’.

     See also: eq, isequal, le, ge, lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if the two inputs are not equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
times


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 373
 -- : times (X, Y)
 -- : times (X1, X2, ...)
     Return the element-by-element multiplication product of inputs.

     This function and X .* Y are equivalent.  If more arguments are given, the multiplication is applied cumulatively from left to right:

          (...((X1 .* X2) .* X3) .* ...)

     At least one argument is required.

     See also: mtimes, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the element-by-element multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- : rdivide (X, Y)
     Return the element-by-element right division of X and Y.

     This function and X ./ Y are equivalent.

     See also: ldivide, mrdivide, times, plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the element-by-element right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
power


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 404
 -- : power (X, Y)
     Return the element-by-element operation of X raised to the Y power.

     This function and X .^ Y are equivalent.

     If several complex results are possible, returns the one with smallest non-negative argument (angle).  Use ‘realpow’, ‘realsqrt’, ‘cbrt’, or ‘nthroot’ if a real result is preferred.

     See also: mpower, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the element-by-element operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 180
 -- : ldivide (X, Y)
     Return the element-by-element left division of X and Y.

     This function and X .\ Y are equivalent.

     See also: rdivide, mldivide, times, plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the element-by-element left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
and


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 371
 -- : Z = and (X, Y)
 -- : Z = and (X1, X2, ...)
     Return the logical AND of X and Y.

     This function is equivalent to the operator syntax ‘X & Y’.  If more than two arguments are given, the logical AND is applied cumulatively from left to right:

          (...((X1 & X2) & X3) & ...)

     At least one argument is required.

     See also: or, not, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the logical AND of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
or


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 368
 -- : Z = or (X, Y)
 -- : Z = or (X1, X2, ...)
     Return the logical OR of X and Y.

     This function is equivalent to the operator syntax ‘X | Y’.  If more than two arguments are given, the logical OR is applied cumulatively from left to right:

          (...((X1 | X2) | X3) | ...)

     At least one argument is required.

     See also: and, not, xor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return the logical OR of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
colon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- : R = colon (BASE, LIMIT)
 -- : R = colon (BASE, INCREMENT, LIMIT)
     Return the result of the colon expression corresponding to BASE, LIMIT, and optionally, INCREMENT.

     This function is equivalent to the operator syntax ‘BASE : LIMIT’ or ‘BASE : INCREMENT : LIMIT’.

     See also: linspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return the result of the colon expression corresponding to BASE, LIMIT, and optionally, INCREMENT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1366
 -- : tic ()
 -- : ID = tic ()
     Initialize a wall-clock timer.

     Calling ‘tic’ without an output argument resets the internal timer.  Subsequent calls to ‘toc’ return the number of seconds since the timer was set.

     If called with one output argument, ‘tic’ creates a new timer instance and returns a timer identifier ID.  The ID is a scalar of type ‘uint64’ that may be passed to ‘toc’ to check elapsed time on this timer, rather than the default internal timer.

     Example 1 : benchmarking code with internal timer

          tic;
          # many computations later...
          elapsed_time = toc;

     Example 2 : mixed timer id and internal timer

          tic;
          pause (1);
          toc
          ⇒ Elapsed time is 1.0089 seconds.
          id = tic;
          pause (2);
          toc (id)
          ⇒ Elapsed time is 2.01142 seconds.
          toc
          Elapsed time is 3.02308 seconds.

     Calling ‘tic’ and ‘toc’ in this way allows nested timing calls.

     If you are more interested in the CPU time that your process used, you should use the ‘cputime’ function instead.  The ‘tic’ and ‘toc’ functions report the actual wall clock time that elapsed between the calls.  This may include time spent processing other jobs or doing nothing at all.

     See also: toc, cputime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Initialize a wall-clock timer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
toc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- : toc ()
 -- : toc (ID)
 -- : ELAPSED_TIME = toc (...)
     Measure elapsed time on a wall-clock timer.

     With no arguments, return the number of seconds elapsed on the internal timer since the last call to ‘tic’.

     When given the identifier ID of a specific timer, return the number of seconds elapsed since the timer ID was initialized.

     *Note tic: XREFtic, for examples of the use of ‘tic’/‘toc’.

     See also: tic, cputime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Measure elapsed time on a wall-clock timer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cputime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 685
 -- : [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.

     The first output is the total time spent executing your process and is equal to the sum of second and third outputs, which are the number of CPU seconds spent executing in user mode and the number of CPU seconds spent executing in system mode, respectively.

     If your system does not have a way to report CPU time usage, ‘cputime’ returns 0 for each of its output values.

     Note that because Octave used some CPU time to start, it is reasonable to check to see if ‘cputime’ works by checking to see if the total CPU time used is nonzero.

     See also: tic, toc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the CPU time used by your Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sort


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1786
 -- : [S, I] = sort (X)
 -- : [S, I] = sort (X, DIM)
 -- : [S, I] = sort (X, MODE)
 -- : [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.

     For matrices, ‘sort’ orders the elements within columns

     For example:

          sort ([1, 2; 2, 3; 3, 1])
             ⇒  1  1
                 2  2
                 3  3

     If the optional argument DIM is given, then the matrix is sorted along the dimension defined by DIM.  The optional argument MODE defines the order in which the values will be sorted.  Valid values of MODE are "ascend" or "descend".

     The ‘sort’ function may also be used to produce a matrix containing the original row indices of the elements in the sorted matrix.  For example:

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
            ⇒ s = 1  1
                   2  2
                   3  3
            ⇒ i = 1  3
                   2  1
                   3  2

     For equal elements, the indices are such that equal elements are listed in the order in which they appeared in the original list.

     Sorting of complex entries is done first by magnitude (‘abs (Z)’) and for any ties by phase angle (‘angle (z)’).  For example:

          sort ([1+i; 1; 1-i])
              ⇒ 1 + 0i
                 1 - 1i
                 1 + 1i

     NaN values are treated as being greater than any other value and are sorted to the end of the list.

     The ‘sort’ function may also be used to sort strings and cell arrays of strings, in which case ASCII dictionary order (uppercase ’A’ precedes lowercase ’a’) of the strings is used.

     The algorithm used in ‘sort’ is optimized for the sorting of partially ordered lists.

     See also: sortrows, issorted.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return a copy of X with the elements arranged in increasing order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issorted


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 529
 -- : issorted (A)
 -- : issorted (A, MODE)
 -- : issorted (A, "rows", MODE)
     Return true if the array is sorted according to MODE, which may be either "ascending", "descending", or "either".

     By default, MODE is "ascending".  NaNs are treated in the same manner as ‘sort’.

     If the optional argument "rows" is supplied, check whether the array is sorted by rows as output by the function ‘sortrows’ (with no options).

     This function does not support sparse matrices.

     See also: sort, sortrows.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return true if the array is sorted according to MODE, which may be either "ascending", "descending", or "either".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nth_element


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 868
 -- : nth_element (X, N)
 -- : nth_element (X, N, DIM)
     Select the n-th smallest element of a vector, using the ordering defined by ‘sort’.

     The result is equivalent to ‘sort(X)(N)’.

     N can also be a contiguous range, either ascending ‘l:u’ or descending ‘u:-1:l’, in which case a range of elements is returned.

     If X is an array, ‘nth_element’ operates along the dimension defined by DIM, or the first non-singleton dimension if DIM is not given.

     Programming Note: nth_element encapsulates the C++ standard library algorithms nth_element and partial_sort.  On average, the complexity of the operation is O(M*log(K)), where ‘M = size (X, DIM)’ and ‘K = length (N)’.  This function is intended for cases where the ratio K/M is small; otherwise, it may be better to use ‘sort’.

     See also: sort, min, max.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Select the n-th smallest element of a vector, using the ordering defined by ‘sort’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
merge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 783
 -- : merge (MASK, TVAL, FVAL)
 -- : ifelse (MASK, TVAL, FVAL)
     Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of MASK.

     If MASK is a logical scalar, the other two arguments can be arbitrary values.  Otherwise, MASK must be a logical array, and TVAL, FVAL should be arrays of matching class, or cell arrays.  In the scalar mask case, TVAL is returned if MASK is true, otherwise FVAL is returned.

     In the array mask case, both TVAL and FVAL must be either scalars or arrays with dimensions equal to MASK.  The result is constructed as follows:

          result(mask) = tval(mask);
          result(! mask) = fval(! mask);

     MASK can also be arbitrary numeric type, in which case it is first converted to logical.

     See also: logical, diff.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of MASK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 914
 -- : diff (X)
 -- : diff (X, K)
 -- : diff (X, K, DIM)
     If X is a vector of length n, ‘diff (X)’ is the vector of first differences X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, ‘diff (X)’ is the matrix of column differences along the first non-singleton dimension.

     The second argument is optional.  If supplied, ‘diff (X, K)’, where K is a non-negative integer, returns the K-th differences.  It is possible that K is larger than the first non-singleton dimension of the matrix.  In this case, ‘diff’ continues to take the differences along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly stated with the optional variable DIM.  In this case the K-th order differences are calculated along this dimension.  In the case where K exceeds ‘size (X, DIM)’ an empty matrix is returned.

     See also: sort, merge.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
If X is a vector of length n, ‘diff (X)’ is the vector of first differences X(2) - X(1), .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
repelems


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 688
 -- : repelems (X, R)
     Construct a vector of repeated elements from X.

     R is a 2xN integer matrix specifying which elements to repeat and how often to repeat each element.  Entries in the first row, R(1,j), select an element to repeat.  The corresponding entry in the second row, R(2,j), specifies the repeat count.  If X is a matrix then the columns of X are imagined to be stacked on top of each other for purposes of the selection index.  A row vector is always returned.

     Conceptually the result is calculated as follows:

          y = [];
          for i = 1:columns (R)
            y = [y, X(R(1,i)*ones(1, R(2,i)))];
          endfor

     See also: repmat, cat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Construct a vector of repeated elements from X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_encode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- : S = base64_encode (X)
     Encode a double matrix or array X into the base64 format string S.

     See also: base64_decode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Encode a double matrix or array X into the base64 format string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_decode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- : X = base64_decode (S)
 -- : X = base64_decode (S, DIMS)
     Decode the double matrix or array X from the base64 encoded string S.

     The optional input parameter DIMS should be a vector containing the dimensions of the decoded array.

     See also: base64_encode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Decode the double matrix or array X from the base64 encoded string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3582
 -- : dbstop FUNC
 -- : dbstop FUNC LINE
 -- : dbstop FUNC LINE1 LINE2 ...
 -- : dbstop LINE1 ...
 -- : dbstop in FUNC
 -- : dbstop in FUNC at LINE
 -- : dbstop in FUNC at LINE if "CONDITION"
 -- : dbstop if EVENT
 -- : dbstop if EVENT ID
 -- : dbstop (BP_STRUCT)
 -- : RLINE = dbstop ...

     Set breakpoints for the built-in debugger.

     FUNC is the name of a function on the current ‘path’.  When already in debug mode the FUNC argument can be omitted and the current function will be used.  Breakpoints at subfunctions are set with the scope operator ‘>’.  For example, If ‘file.m’ has a subfunction ‘func2’, then a breakpoint in ‘func2’ can be specified by ‘file>func2’.

     LINE is the line number at which to break.  If LINE is not specified, it defaults to the first executable line in the file ‘func.m’.  Multiple lines can be specified in a single command; when function syntax is used, the lines may also be passed as a single vector argument (‘[LINE1, LINE2, ...]’).

     CONDITION is any Octave expression that can be evaluated in the code context that exists at the breakpoint.  When the breakpoint is encountered, CONDITION will be evaluated, and execution will stop if CONDITION is true.  If CONDITION cannot be evaluated, for example because it refers to an undefined variable, an error will be thrown.  Expressions with side effects (such as ‘y++ > 1’) will alter variables, and should generally be avoided.  Conditions containing quotes (‘"’, ‘'’) or comment characters (‘#’, ‘%’) must be enclosed in quotes.  (This does not apply to conditions entered from the editor’s context menu.)  For example:

          dbstop in strread at 209 if 'any (format == "%f")'

     The form specifying EVENT does not cause a specific breakpoint at a given function and line number.  Instead it causes debug mode to be entered when certain unexpected events are encountered.  Possible values are

     ‘error’
          Stop when an error is reported.  This is equivalent to specifying both ‘debug_on_error (true)’ and ‘debug_on_interrupt (true)’.

     ‘caught error’
          Stop when an error is caught by a try-catch block (not yet implemented).

     ‘interrupt’
          Stop when an interrupt (‘Ctrl-C’) occurs.

     ‘naninf’
          Stop when code returns a non-finite value (not yet implemented).

     ‘warning’
          Stop when a warning is reported.  This is equivalent to specifying ‘debug_on_warning (true)’.

     The events ‘error’, ‘caught error’, and ‘warning’ can all be followed by a string specifying an error ID or warning ID.  If that is done, only errors with the specified ID will cause execution to stop.  To stop on one of a set of IDs, multiple ‘dbstop’ commands must be issued.

     Breakpoints and events can be removed using the ‘dbclear’ command with the same syntax.

     It is possible to save all breakpoints and restore them at once by issuing the commands ‘bp_state = dbstatus; ...; dbstop (bp_state)’.

     The optional output RLINE is the real line number where the breakpoint was set.  This can differ from the specified line if the line is not executable.  For example, if a breakpoint attempted on a blank line then Octave will set the real breakpoint at the next executable line.

     When a file is re-parsed, such as when it is modified outside the GUI, all breakpoints within the file are cleared.

     See also: dbclear, dbstatus, dbstep, debug_on_error, debug_on_warning, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Set breakpoints for the built-in debugger.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1171
 -- : dbclear FUNC
 -- : dbclear FUNC LINE
 -- : dbclear FUNC LINE1 LINE2 ...
 -- : dbclear LINE ...
 -- : dbclear all
 -- : dbclear in FUNC
 -- : dbclear in FUNC at LINE
 -- : dbclear if EVENT
 -- : dbclear ("FUNC")
 -- : dbclear ("FUNC", LINE)
 -- : dbclear ("FUNC", LINE1, LINE2, ...)
 -- : dbclear ("FUNC", LINE1, ...)
 -- : dbclear (LINE, ...)
 -- : dbclear ("all")
     Delete a breakpoint at line number LINE in the function FUNC.

     Arguments are

     FUNC
          Function name as a string variable.  When already in debug mode this argument can be omitted and the current function will be used.

     LINE
          Line number from which to remove a breakpoint.  Multiple lines may be given as separate arguments or as a vector.

     EVENT
          An event such as ‘error’, ‘interrupt’, or ‘warning’ (*note dbstop: XREFdbstop. for details).

     When called without a line number specification all breakpoints in the named function are cleared.

     If the requested line is not a breakpoint no action is performed.

     The special keyword "all" will clear all breakpoints from all files.

     See also: dbstop, dbstatus, dbwhere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Delete a breakpoint at line number LINE in the function FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dbstatus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1308
 -- : dbstatus
 -- : dbstatus FUNC
 -- : BP_LIST = dbstatus ...
     Report the location of active breakpoints.

     When called with no input or output arguments, print the list of all functions with breakpoints and the line numbers where those breakpoints are set.

     If a function name FUNC is specified then only report breakpoints for the named function and its subfunctions.

     The optional return argument BP_LIST is a struct array with the following fields.

     name
          The name of the function with a breakpoint.  A subfunction, say ‘func2’ within an m-file, say ‘file.m’, is specified as ‘file>func2’.

     file
          The name of the m-file where the function code is located.

     line
          The line number with the breakpoint.

     cond
          The condition that must be satisfied for the breakpoint to be active, or the empty string for unconditional breakpoints.

     If ‘dbstop if error’ is true but no explicit IDs are specified, the return value will have an empty field called "errs".  If IDs are specified, the ‘errs’ field will have one row per ID.  If ‘dbstop if error’ is false, there is no "errs" field.  The "warn" field is set similarly by ‘dbstop if warning’.

     See also: dbstop, dbclear, dbwhere, dblist, dbstack.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Report the location of active breakpoints.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbwhere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 -- : dbwhere
     In debugging mode, report the current file and line number where execution is stopped.

     See also: dbstack, dblist, dbstatus, dbcont, dbstep, dbup, dbdown.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
In debugging mode, report the current file and line number where execution is stopped.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbtype


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 658
 -- : dbtype
 -- : dbtype LINENO
 -- : dbtype STARTL:ENDL
 -- : dbtype STARTL:END
 -- : dbtype FUNC
 -- : dbtype FUNC LINENO
 -- : dbtype FUNC STARTL:ENDL
 -- : dbtype FUNC STARTL:END
     Display a script file with line numbers.

     When called with no arguments in debugging mode, display the script file currently being debugged.

     An optional range specification can be used to list only a portion of the file.  The special keyword "end" is a valid line number specification for the last line of the file.

     When called with the name of a function, list that script file with line numbers.

     See also: dblist, dbwhere, dbstatus, dbstop.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Display a script file with line numbers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dblist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 242
 -- : dblist
 -- : dblist N
     In debugging mode, list N lines of the function being debugged centered around the current line to be executed.

     If unspecified N defaults to 10 (+/- 5 lines)

     See also: dbwhere, dbtype, dbstack.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
In debugging mode, list N lines of the function being debugged centered around the current line to be executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbstack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1034
 -- : dbstack
 -- : dbstack N
 -- : dbstack -COMPLETENAMES
 -- : [STACK, IDX] = dbstack (...)
     Display or return current debugging function stack information.

     With optional argument N, omit the N innermost stack frames.

     Although accepted, the argument -COMPLETENAMES is silently ignored.  Octave always returns absolute filenames.

     The arguments N and -COMPLETENAMES can be both specified in any order.

     The optional return argument STACK is a struct array with the following fields:

     file
          The name of the m-file where the function code is located.

     name
          The name of the function with a breakpoint.

     line
          The line number of an active breakpoint.

     column
          The column number of the line where the breakpoint begins.

     scope
          Undocumented.

     context
          Undocumented.

     The return argument IDX specifies which element of the STACK struct array is currently active.

     See also: dbup, dbdown, dbwhere, dblist, dbstatus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Display or return current debugging function stack information.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dbup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- : dbup
 -- : dbup N
     In debugging mode, move up the execution stack N frames.

     If N is omitted, move up one frame.

     See also: dbstack, dbdown.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
In debugging mode, move up the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbdown


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 170
 -- : dbdown
 -- : dbdown N
     In debugging mode, move down the execution stack N frames.

     If N is omitted, move down one frame.

     See also: dbstack, dbup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
In debugging mode, move down the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 595
 -- : dbstep
 -- : dbstep N
 -- : dbstep in
 -- : dbstep out
 -- : dbnext ...
     In debugging mode, execute the next N lines of code.

     If N is omitted, execute the next single line of code.  If the next line of code is itself defined in terms of an m-file remain in the existing function.

     Using ‘dbstep in’ will cause execution of the next line to step into any m-files defined on the next line.

     Using ‘dbstep out’ will cause execution to continue until the current function returns.

     ‘dbnext’ is an alias for ‘dbstep’.

     See also: dbcont, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
In debugging mode, execute the next N lines of code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbcont


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- : dbcont
     Leave command-line debugging mode and continue code execution normally.

     See also: dbstep, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Leave command-line debugging mode and continue code execution normally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbquit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- : dbquit
     Quit debugging mode immediately without further code execution and return to the Octave prompt.

     See also: dbcont, dbstep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Quit debugging mode immediately without further code execution and return to the Octave prompt.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
isdebugmode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- : isdebugmode ()
     Return true if in debugging mode, otherwise false.

     See also: dbwhere, dbstack, dbstatus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if in debugging mode, otherwise false.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
OCTAVE_HOME


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- : OCTAVE_HOME ()
     Return the name of the top-level Octave installation directory.  OCTAVE_HOME corresponds to the configuration variable PREFIX.

     See also: EXEC_PATH, IMAGE_PATH, OCTAVE_EXEC_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the name of the top-level Octave installation directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
OCTAVE_EXEC_HOME


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- : OCTAVE_EXEC_HOME ()
     Return the name of the top-level Octave installation directory for architecture-dependent files.  If not specified separately, the value is the same as OCTAVE_HOME.  OCTAVE_EXEC_HOME corresponds to the configuration variable EXEC_PREFIX.

     See also: EXEC_PATH, IMAGE_PATH, OCTAVE_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Return the name of the top-level Octave installation directory for architecture-dependent files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
OCTAVE_VERSION


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- : OCTAVE_VERSION ()
     Return the version number of Octave as a string.

     See also: ver, version.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the version number of Octave as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
det


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 485
 -- : det (A)
 -- : [D, RCOND] = det (A)
     Compute the determinant of A.

     Return an estimate of the reciprocal condition number if requested.

     Programming Notes: Routines from LAPACK are used for full matrices and code from UMFPACK is used for sparse matrices.

     The determinant should not be used to check a matrix for singularity.  For that, use any of the condition number functions: ‘cond’, ‘condest’, ‘rcond’.

     See also: cond, condest, rcond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Compute the determinant of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
cd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 714
 -- : cd DIR
 -- : cd
 -- : OLD_DIR = cd (DIR)
 -- : chdir ...
     Change the current working directory to DIR.

     If DIR is omitted, the current directory is changed to the user’s home directory ("~").

     For example,

          cd ~/octave

     changes the current working directory to ‘~/octave’.  If the directory does not exist, an error message is printed and the working directory is not changed.

     ‘chdir’ is an alias for ‘cd’ and can be used in all of the same calling formats.

     Compatibility Note: When called with no arguments, MATLAB prints the present working directory rather than changing to the user’s home directory.

     See also: pwd, mkdir, rmdir, dir, ls.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Change the current working directory to DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pwd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- : pwd ()
 -- : DIR = pwd ()
     Return the current working directory.

     See also: cd, dir, ls, mkdir, rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the current working directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
readdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 382
 -- : FILES = readdir (DIR)
 -- : [FILES, ERR, MSG] = readdir (DIR)
     Return the names of files in the directory DIR as a cell array of strings.

     If an error occurs, return an empty cell array in FILES.  If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: ls, dir, glob, what.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return the names of files in the directory DIR as a cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 490
 -- : rmdir DIR
 -- : rmdir (DIR, "s")
 -- : [STATUS, MSG, MSGID] = rmdir (...)
     Remove the directory named DIR.

     If the optional second parameter is supplied with value "s", recursively remove all subdirectories as well.

     If successful, STATUS is 1, and MSG, MSGID are empty character strings ("").  Otherwise, STATUS is 0, MSG contains a system-dependent error message, and MSGID contains a unique message identifier.

     See also: mkdir, confirm_recursive_rmdir, pwd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Remove the directory named DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
link


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- : link OLD NEW
 -- : [ERR, MSG] = link (OLD, NEW)
     Create a new link (also known as a hard link) to an existing file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: symlink, unlink, readlink, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Create a new link (also known as a hard link) to an existing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
symlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- : symlink OLD NEW
 -- : [ERR, MSG] = symlink (OLD, NEW)
     Create a symbolic link NEW which contains the string OLD.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: link, unlink, readlink, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create a symbolic link NEW which contains the string OLD.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
readlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 372
 -- : readlink SYMLINK
 -- : [RESULT, ERR, MSG] = readlink (SYMLINK)
     Read the value of the symbolic link SYMLINK.

     If successful, RESULT contains the contents of the symbolic link SYMLINK, ERR is 0, and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: lstat, symlink, link, unlink, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Read the value of the symbolic link SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 283
 -- : rename OLD NEW
 -- : [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: movefile, copyfile, ls, dir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Change the name of file OLD to NEW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
glob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1179
 -- : glob (PATTERN)
     Given an array of pattern strings (as a char array or a cell array) in PATTERN, return a cell array of filenames that match any of them, or an empty cell array if no patterns match.

     The pattern strings are interpreted as filename globbing patterns (as they are used by Unix shells).

     Within a pattern

     ‘*’
          matches any string, including the null string,

     ‘?’
          matches any single character, and

     ‘[...]’
          matches any of the enclosed characters.

     Tilde expansion is performed on each of the patterns before looking for matching filenames.  For example:

          ls
             ⇒
                file1  file2  file3  myfile1 myfile1b
          glob ("*file1")
             ⇒
                {
                  [1,1] = file1
                  [2,1] = myfile1
                }
          glob ("myfile?")
             ⇒
                {
                  [1,1] = myfile1
                }
          glob ("file[12]")
             ⇒
                {
                  [1,1] = file1
                  [2,1] = file2
                }

     See also: ls, dir, readdir, what.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
Given an array of pattern strings (as a char array or a cell array) in PATTERN, return a cell array of filenames that match any of them, or an empty cell array if no patterns match.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
filesep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- : filesep ()
 -- : filesep ("all")
     Return the system-dependent character used to separate directory names.

     If "all" is given, the function returns all valid file separators in the form of a string.  The list of file separators is system-dependent.  It is ‘/’ (forward slash) under UNIX or Mac OS X, ‘/’ and ‘\’ (forward and backward slashes) under Windows.

     See also: pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the system-dependent character used to separate directory names.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pathsep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : VAL = pathsep ()
     Query the character used to separate directories in a path.

     See also: filesep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query the character used to separate directories in a path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
confirm_recursive_rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- : VAL = confirm_recursive_rmdir ()
 -- : OLD_VAL = confirm_recursive_rmdir (NEW_VAL)
 -- : confirm_recursive_rmdir (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will ask for confirmation before recursively removing a directory tree.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Query or set the internal variable that controls whether Octave will ask for confirmation before recursively removing a directory tree.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
have_window_system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- : have_window_system ()
     Return true if a window system is available (X11, Windows, or Apple OS X) and false otherwise.

     See also: isguirunning.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return true if a window system is available (X11, Windows, or Apple OS X) and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dlmread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1388
 -- : DATA = dlmread (FILE)
 -- : DATA = dlmread (FILE, SEP)
 -- : DATA = dlmread (FILE, SEP, R0, C0)
 -- : DATA = dlmread (FILE, SEP, RANGE)
 -- : DATA = dlmread (..., "emptyvalue", EMPTYVAL)
     Read numeric data from the text file FILE which uses the delimiter SEP between data values.

     If SEP is not defined the separator between fields is determined from the file itself.

     The optional scalar arguments R0 and C0 define the starting row and column of the data to be read.  These values are indexed from zero, i.e., the first data row corresponds to an index of zero.

     The RANGE parameter specifies exactly which data elements are read.  The first form of the parameter is a 4-element vector containing the upper left and lower right corners ‘[R0,C0,R1,C1]’ where the indices are zero-based.  Alternatively, a spreadsheet style form such as "A2..Q15" or "T1:AA5" can be used.  The lowest alphabetical index ’A’ refers to the first column.  The lowest row index is 1.

     FILE should be a filename or a file id given by ‘fopen’.  In the latter case, the file is read until end of file is reached.

     The "emptyvalue" option may be used to specify the value used to fill empty fields.  The default is zero.  Note that any non-numeric values, such as text, are also replaced by the "emptyvalue".

     See also: csvread, textscan, textread, dlmwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Read numeric data from the text file FILE which uses the delimiter SEP between data values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- : dot (X, Y, DIM)
     Compute the dot product of two vectors.

     If X and Y are matrices, calculate the dot products along the first non-singleton dimension.

     If the optional argument DIM is given, calculate the dot products along this dimension.

     This is equivalent to ‘sum (conj (X) .* Y, DIM)’, but avoids forming a temporary array and is faster.  When X and Y are column vectors, the result is equivalent to ‘X' * Y’.

     See also: cross, divergence.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Compute the dot product of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
blkmm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 401
 -- : blkmm (A, B)
     Compute products of matrix blocks.

     The blocks are given as 2-dimensional subarrays of the arrays A, B.  The size of A must have the form ‘[m,k,...]’ and size of B must be ‘[k,n,...]’.  The result is then of size ‘[m,n,...]’ and is computed as follows:

          for i = 1:prod (size (A)(3:end))
            C(:,:,i) = A(:,:,i) * B(:,:,i)
          endfor
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute products of matrix blocks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4690
 -- : LAMBDA = eig (A)
 -- : LAMBDA = eig (A, B)
 -- : [V, LAMBDA] = eig (A)
 -- : [V, LAMBDA] = eig (A, B)
 -- : [V, LAMBDA, W] = eig (A)
 -- : [V, LAMBDA, W] = eig (A, B)
 -- : [...] = eig (A, BALANCEOPTION)
 -- : [...] = eig (A, B, ALGORITHM)
 -- : [...] = eig (..., EIGVALOPTION)
     Compute the eigenvalues (LAMBDA) and optionally the right eigenvectors (V) and the left eigenvectors (W) of a matrix or pair of matrices.

     The flag BALANCEOPTION can be one of:

     "balance" (default)
          Preliminary balancing is on.

     "nobalance"
          Disables preliminary balancing.

     The flag EIGVALOPTION can be one of:

     "matrix"
          Return the eigenvalues in a diagonal matrix.  (default if 2 or 3 outputs are requested)

     "vector"
          Return the eigenvalues in a column vector.  (default if only 1 output is requested, e.g., LAMBDA = eig (A))

     The flag ALGORITHM can be one of:

     "chol"
          Use the Cholesky factorization of B. (default if A is symmetric (Hermitian) and B is symmetric (Hermitian) positive definite)

     "qz"
          Use the QZ algorithm.  (used whenever A or B are not symmetric)

                                                                                                                                                                                                                                                                                                                                   no flag                                                                                                                                                                                                                                      chol                                                                                                                                                                                                                                         qz
     ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     both are symmetric                                                                                                                                                                                                                                                                                                            "chol"                                                                                                                                                                                                                                       "chol"                                                                                                                                                                                                                                       "qz"
     at least one is not symmetric                                                                                                                                                                                                                                                                                                 "qz"                                                                                                                                                                                                                                         "qz"                                                                                                                                                                                                                                         "qz"

     The eigenvalues returned by ‘eig’ are not ordered.

     See also: eigs, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Compute the eigenvalues (LAMBDA) and optionally the right eigenvectors (V) and the left eigenvectors (W) of a matrix or pair of matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ellipj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1123
 -- : [SN, CN, DN, ERR] = ellipj (U, M)
 -- : [SN, CN, DN, ERR] = ellipj (U, M, TOL)
     Compute the Jacobi elliptic functions SN, CN, and DN of complex argument U and real parameter M.

     If M is a scalar, the results are the same size as U.  If U is a scalar, the results are the same size as M.  If U is a column vector and M is a row vector, the results are matrices with ‘length (U)’ rows and ‘length (M)’ columns.  Otherwise, U and M must conform in size and the results will be the same size as the inputs.

     The value of U may be complex.  The value of M must be 0 ≤ M ≤ 1.

     The optional input TOL is currently ignored (MATLAB uses this to allow faster, less accurate approximation).

     If requested, ERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     Reference: Milton Abramowitz and Irene A Stegun, ‘Handbook of Mathematical Functions’, Chapter 16 (Sections 16.4, 16.13, and 16.15), Dover, 1965.

     See also: ellipke.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Compute the Jacobi elliptic functions SN, CN, and DN of complex argument U and real parameter M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
EDITOR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 601
 -- : VAL = EDITOR ()
 -- : OLD_VAL = EDITOR (NEW_VAL)
 -- : EDITOR (NEW_VAL, "local")
     Query or set the internal variable that specifies the default text editor.

     The default value is taken from the environment variable ‘EDITOR’ when Octave starts.  If the environment variable is not initialized, ‘EDITOR’ will be set to "emacs".

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: edit, edit_history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Query or set the internal variable that specifies the default text editor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
EXEC_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 702
 -- : VAL = EXEC_PATH ()
 -- : OLD_VAL = EXEC_PATH (NEW_VAL)
 -- : EXEC_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated list of directories to append to the shell PATH when executing external programs.

     The initial value of is taken from the environment variable ‘OCTAVE_EXEC_PATH’, but that value can be overridden by the command line argument ‘--exec-path PATH’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: IMAGE_PATH, OCTAVE_HOME, OCTAVE_EXEC_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
Query or set the internal variable that specifies a colon separated list of directories to append to the shell PATH when executing external programs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
IMAGE_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- : VAL = IMAGE_PATH ()
 -- : OLD_VAL = IMAGE_PATH (NEW_VAL)
 -- : IMAGE_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated list of directories in which to search for image files.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: EXEC_PATH, OCTAVE_HOME, OCTAVE_EXEC_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Query or set the internal variable that specifies a colon separated list of directories in which to search for image files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rethrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 354
 -- : rethrow (ERR)
     Reissue a previous error as defined by ERR.

     ERR is a structure that must contain at least the "message" and "identifier" fields.  ERR can also contain a field "stack" that gives information on the assumed location of the error.  Typically ERR is returned from ‘lasterror’.

     See also: lasterror, lasterr, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Reissue a previous error as defined by ERR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2642
 -- : error (TEMPLATE, ...)
 -- : error (ID, TEMPLATE, ...)
     Display an error message and stop m-file execution.

     Format the optional arguments under the control of the template string TEMPLATE using the same rules as the ‘printf’ family of functions (*note Formatted Output::) and print the resulting message on the ‘stderr’ stream.  The message is prefixed by the character string ‘error: ’.

     Calling ‘error’ also sets Octave’s internal error state such that control will return to the top level without evaluating any further commands.  This is useful for aborting from functions or scripts.

     If the error message does not end with a newline character, Octave will print a traceback of all the function calls leading to the error.  For example, given the following function definitions:

          function f () g (); end
          function g () h (); end
          function h () nargin == 1 || error ("nargin != 1"); end

     calling the function ‘f’ will result in a list of messages that can help you to quickly find the exact location of the error:

          f ()
          error: nargin != 1
          error: called from:
          error:   h at line 1, column 27
          error:   g at line 1, column 15
          error:   f at line 1, column 15

     If the error message ends in a newline character, Octave will print the message but will not display any traceback messages as it returns control to the top level.  For example, modifying the error message in the previous example to end in a newline causes Octave to only print a single message:

          function h () nargin == 1 || error ("nargin != 1\n"); end
          f ()
          error: nargin != 1

     A null string ("") input to ‘error’ will be ignored and the code will continue running as if the statement were a NOP.  This is for compatibility with MATLAB.  It also makes it possible to write code such as

          err_msg = "";
          if (CONDITION 1)
            err_msg = "CONDITION 1 found";
          elseif (CONDITION2)
            err_msg = "CONDITION 2 found";
          ...
          endif
          error (err_msg);

     which will only stop execution if an error has been found.

     Implementation Note: For compatibility with MATLAB, escape sequences in TEMPLATE (e.g., "\n" => newline) are processed regardless of whether TEMPLATE has been defined with single quotes, as long as there are two or more input arguments.  To disable escape sequence expansion use a second backslash before the sequence (e.g., "\\n") or use the ‘regexptranslate’ function.

     See also: warning, lasterror.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Display an error message and stop m-file execution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3949
 -- : warning (TEMPLATE, ...)
 -- : warning (ID, TEMPLATE, ...)
 -- : warning ("on", ID)
 -- : warning ("off", ID)
 -- : warning ("error", ID)
 -- : warning ("query", ID)
 -- : warning (STATE, ID, "local")
 -- : warning (WARNING_STRUCT)
 -- : WARNING_STRUCT = warning (...)
 -- : warning (STATE, MODE)

     Display a warning message or control the behavior of Octave’s warning system.

     The first call form uses a template TEMPLATE and optional additional arguments to display a message on the ‘stderr’ stream.  The message is formatted using the same rules as the ‘printf’ family of functions (*note Formatted Output::) and prefixed by the character string ‘warning: ’.  You should use this function when you want to notify the user of an unusual condition, but only when it makes sense for your program to go on.  For example:

          warning ("foo: maybe something wrong here");

     The optional warning identifier ID allows users to enable or disable warnings tagged by this identifier.  A message identifier is a string of the form "NAMESPACE:WARNING-NAME". Octave’s own warnings use the "Octave" namespace (*note warning_ids: XREFwarning_ids.).  For example:

          warning ("MyNameSpace:check-something",
                   "foo: maybe something wrong here");

     The second call form is meant to change and/or query the state of warnings.  The first input argument must be a string STATE ("on", "off", "error", or "query") followed by an optional warning identifier ID or "all" (default).

     The optional output argument WARNING_STRUCT is a structure or structure array with fields "state" and "identifier".  The STATE argument may have the following values:

     "on"|"off":
          Enable or disable the display of warnings identified by ID and optionally return their previous state STOUT.

     "error":
          Turn warnings identified by ID into errors and optionally return their previous state STOUT.

     "query":
          Return the current state of warnings identified by ID.

     A structure or structure array WARNING_STRUCT, with fields "state" and "identifier", may be given as an input to achieve equivalent results.  The following example shows how to temporarily disable a warning and then restore its original state:

          loglog (-1:10);
          ## Disable the previous warning and save its original state
          [~, id] = lastwarn ();
          warnstate = warning ("off", id);
          loglog (-1:10);
          ## Restore its original state
          warning (warnstate);

     If a final argument "local" is provided then the warning state will be set temporarily until the end of the current function.  Changes to warning states that are set locally affect the current function and all functions called from the current scope.  The previous warning state is restored on return from the current function.  The "local" option is ignored if used in the top-level workspace.

     With no input argument ‘warning ()’ is equivalent to ‘warning ("query", "all")’ except that in the absence of an output argument, the state of warnings is displayed on ‘stderr’.

     The level of verbosity of the warning system may also be controlled by two modes MODE:

     "backtrace":
          enable/disable the display of the stack trace after the warning message

     "verbose":
          enable/disable the display of additional information after the warning message

     In this case the STATE argument may only be "on" or "off".

     Implementation Note: For compatibility with MATLAB, escape sequences in TEMPLATE (e.g., "\n" => newline) are processed regardless of whether TEMPLATE has been defined with single quotes, as long as there are two or more input arguments.  To disable escape sequence expansion use a second backslash before the sequence (e.g., "\\n") or use the ‘regexptranslate’ function.

     See also: warning_ids, lastwarn, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Display a warning message or control the behavior of Octave’s warning system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lasterror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1355
 -- : LASTERR = lasterror ()
 -- : lasterror (ERR)
 -- : lasterror ("reset")
     Query or set the last error message structure.

     When called without arguments, return a structure containing the last error message and other information related to this error.  The elements of the structure are:

     ‘message’
          The text of the last error message

     ‘identifier’
          The message identifier of this error message

     ‘stack’
          A structure containing information on where the message occurred.  This may be an empty structure if the information cannot be obtained.  The fields of the structure are:

          ‘file’
               The name of the file where the error occurred

          ‘name’
               The name of function in which the error occurred

          ‘line’
               The line number at which the error occurred

          ‘column’
               An optional field with the column number at which the error occurred

     The last error structure may be set by passing a scalar structure, ERR, as input.  Any fields of ERR that match those above are set while any unspecified fields are initialized with default values.

     If ‘lasterror’ is called with the argument "reset", all fields are set to their default values.

     See also: lasterr, error, lastwarn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set the last error message structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lasterr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 389
 -- : [MSG, MSGID] = lasterr ()
 -- : lasterr (MSG)
 -- : lasterr (MSG, MSGID)
     Query or set the last error message.

     When called without input arguments, return the last error message and message identifier.

     With one argument, set the last error message to MSG.

     With two arguments, also set the last message identifier.

     See also: lasterror, error, lastwarn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Query or set the last error message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lastwarn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- : [MSG, MSGID] = lastwarn ()
 -- : lastwarn (MSG)
 -- : lastwarn (MSG, MSGID)
     Query or set the last warning message.

     When called without input arguments, return the last warning message and message identifier.

     With one argument, set the last warning message to MSG.

     With two arguments, also set the last message identifier.

     See also: warning, lasterror, lasterr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Query or set the last warning message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
beep_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- : VAL = beep_on_error ()
 -- : OLD_VAL = beep_on_error (NEW_VAL)
 -- : beep_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will try to ring the terminal bell before printing an error message.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Query or set the internal variable that controls whether Octave will try to ring the terminal bell before printing an error message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
debug_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 630
 -- : VAL = debug_on_error ()
 -- : OLD_VAL = debug_on_error (NEW_VAL)
 -- : debug_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will try to enter the debugger when an error is encountered.

     This will also inhibit printing of the normal traceback message (you will only see the top-level error message).

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: debug_on_warning, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Query or set the internal variable that controls whether Octave will try to enter the debugger when an error is encountered.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
debug_on_warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- : VAL = debug_on_warning ()
 -- : OLD_VAL = debug_on_warning (NEW_VAL)
 -- : debug_on_warning (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will try to enter the debugger when a warning is encountered.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: debug_on_error, debug_on_interrupt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Query or set the internal variable that controls whether Octave will try to enter the debugger when a warning is encountered.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 873
 -- : fft (X)
 -- : fft (X, N)
 -- : fft (X, N, DIM)
     Compute the discrete Fourier transform of X using a Fast Fourier Transform (FFT) algorithm.

     The FFT is calculated along the first non-singleton dimension of the array.  Thus if X is a matrix, ‘fft (X)’ computes the FFT for each column of X.

     If called with two arguments, N is expected to be an integer specifying the number of elements of X to use, or an empty matrix to specify that its value should be ignored.  If N is larger than the dimension along which the FFT is calculated, then X is resized and padded with zeros.  Otherwise, if N is smaller than the dimension along which the FFT is calculated, then X is truncated.

     If called with three arguments, DIM is an integer specifying the dimension of the matrix along which the FFT is performed.

     See also: ifft, fft2, fftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Compute the discrete Fourier transform of X using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ifft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925
 -- : ifft (X)
 -- : ifft (X, N)
 -- : ifft (X, N, DIM)
     Compute the inverse discrete Fourier transform of X using a Fast Fourier Transform (FFT) algorithm.

     The inverse FFT is calculated along the first non-singleton dimension of the array.  Thus if X is a matrix, ‘fft (X)’ computes the inverse FFT for each column of X.

     If called with two arguments, N is expected to be an integer specifying the number of elements of X to use, or an empty matrix to specify that its value should be ignored.  If N is larger than the dimension along which the inverse FFT is calculated, then X is resized and padded with zeros.  Otherwise, if N is smaller than the dimension along which the inverse FFT is calculated, then X is truncated.

     If called with three arguments, DIM is an integer specifying the dimension of the matrix along which the inverse FFT is performed.

     See also: fft, ifft2, ifftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Compute the inverse discrete Fourier transform of X using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 481
 -- : fft2 (A)
 -- : fft2 (A, M, N)
     Compute the two-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of rows and columns of A to use.  If either of these is larger than the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix of A is treated separately.

     See also: ifft2, fft, fftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Compute the two-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 492
 -- : ifft2 (A)
 -- : ifft2 (A, M, N)
     Compute the inverse two-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of rows and columns of A to use.  If either of these is larger than the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix of A is treated separately.

     See also: fft2, ifft, ifftn, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Compute the inverse two-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 547
 -- : fftn (A)
 -- : fftn (A, SIZE)
     Compute the N-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the dimensions of the array to be used.  If an element of SIZE is smaller than the corresponding dimension of A, then the dimension of A is truncated prior to performing the FFT.  Otherwise, if an element of SIZE is larger than the corresponding dimension then A is resized and padded with zeros.

     See also: ifftn, fft, fft2, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Compute the N-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 566
 -- : ifftn (A)
 -- : ifftn (A, SIZE)
     Compute the inverse N-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the dimensions of the array to be used.  If an element of SIZE is smaller than the corresponding dimension of A, then the dimension of A is truncated prior to performing the inverse FFT.  Otherwise, if an element of SIZE is larger than the corresponding dimension then A is resized and padded with zeros.

     See also: fftn, ifft, ifft2, fftw.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Compute the inverse N-dimensional discrete Fourier transform of A using a Fast Fourier Transform (FFT) algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 392
 -- : fclose (FID)
 -- : fclose ("all")
 -- : STATUS = fclose ("all")
     Close the file specified by the file descriptor FID.

     If successful, ‘fclose’ returns 0, otherwise, it returns -1.  The second form of the ‘fclose’ call closes all open files except ‘stdin’, ‘stdout’, ‘stderr’, and any FIDs associated with gnuplot.

     See also: fopen, fflush, freport.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Close the file specified by the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- : fclear (FID)
     Clear the stream state for the file specified by the file descriptor FID.

     See also: ferror, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Clear the stream state for the file specified by the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fflush


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 430
 -- : fflush (FID)
     Flush output to file descriptor FID.

     ‘fflush’ returns 0 on success and an OS dependent error value (−1 on Unix) on error.

     Programming Note: Flushing is useful for ensuring that all pending output makes it to the screen before some other event occurs.  For example, it is always a good idea to flush the standard output stream before calling ‘input’.

     See also: fopen, fclose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Flush output to file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgetl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 520
 -- : STR = fgetl (FID)
 -- : STR = fgetl (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or LEN characters have been read.

     The characters read, excluding the possible trailing newline, are returned as a string.

     If LEN is omitted, ‘fgetl’ reads until the next newline character.

     If there are no more characters to read, ‘fgetl’ returns −1.

     To read a line and return the terminating newline see ‘fgets’.

     See also: fgets, fscanf, fread, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Read characters from a file, stopping after a newline, or EOF, or LEN characters have been read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgets


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 528
 -- : STR = fgets (FID)
 -- : STR = fgets (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or LEN characters have been read.

     The characters read, including the possible trailing newline, are returned as a string.

     If LEN is omitted, ‘fgets’ reads until the next newline character.

     If there are no more characters to read, ‘fgets’ returns −1.

     To read a line and discard the terminating newline see ‘fgetl’.

     See also: fputs, fgetl, fscanf, fread, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Read characters from a file, stopping after a newline, or EOF, or LEN characters have been read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fskipl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 645
 -- : NLINES = fskipl (FID)
 -- : NLINES = fskipl (FID, COUNT)
 -- : NLINES = fskipl (FID, Inf)
     Read and skip COUNT lines from the file specified by the file descriptor FID.

     ‘fskipl’ discards characters until an end-of-line is encountered exactly COUNT-times, or until the end-of-file marker is found.

     If COUNT is omitted, it defaults to 1.  COUNT may also be ‘Inf’, in which case lines are skipped until the end of the file.  This form is suitable for counting the number of lines in a file.

     Returns the number of lines skipped (end-of-line sequences encountered).

     See also: fgetl, fgets, fscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Read and skip COUNT lines from the file specified by the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3849
 -- : FID = fopen (NAME)
 -- : FID = fopen (NAME, MODE)
 -- : FID = fopen (NAME, MODE, ARCH)
 -- : [FID, MSG] = fopen (...)
 -- : FID_LIST = fopen ("all")
 -- : [FILE, MODE, ARCH] = fopen (FID)
     Open a file for low-level I/O or query open files and file descriptors.

     The first form of the ‘fopen’ function opens the named file with the specified mode (read-write, read-only, etc.) and architecture interpretation (IEEE big endian, IEEE little endian, etc.), and returns an integer value that may be used to refer to the file later.  If an error occurs, FID is set to −1 and MSG contains the corresponding system error message.  The MODE is a one or two character string that specifies whether the file is to be opened for reading, writing, or both.

     The second form of the ‘fopen’ function returns a vector of file ids corresponding to all the currently open files, excluding the ‘stdin’, ‘stdout’, and ‘stderr’ streams.

     The third form of the ‘fopen’ function returns information about the open file given its file id.

     For example,

          myfile = fopen ("splat.dat", "r", "ieee-le");

     opens the file ‘splat.dat’ for reading.  If necessary, binary numeric values will be read assuming they are stored in IEEE format with the least significant bit first, and then converted to the native representation.

     Opening a file that is already open simply opens it again and returns a separate file id.  It is not an error to open a file several times, though writing to the same file through several different file ids may produce unexpected results.

     The possible values of MODE are

     ‘r’ (default)
          Open a file for reading.

     ‘w’
          Open a file for writing.  The previous contents are discarded.

     ‘a’
          Open or create a file for writing at the end of the file.

     ‘r+’
          Open an existing file for reading and writing.

     ‘w+’
          Open a file for reading or writing.  The previous contents are discarded.

     ‘a+’
          Open or create a file for reading or writing at the end of the file.

     Append a "t" to the mode string to open the file in text mode or a "b" to open in binary mode.  On Windows systems, text mode reading and writing automatically converts linefeeds to the appropriate line end character for the system (carriage-return linefeed on Windows).  The default when no mode is specified is binary.

     Additionally, you may append a "z" to the mode string to open a gzipped file for reading or writing.  For this to be successful, you must also open the file in binary mode.

     The parameter ARCH is a string specifying the default data format for the file.  Valid values for ARCH are:

     "native" or "n" (default)
          The format of the current machine.

     "ieee-be" or "b"
          IEEE big endian format.

     "ieee-le" or "l"
          IEEE little endian format.

     However, conversions are currently only supported for ‘native’, ‘ieee-be’, and ‘ieee-le’ formats.

     When opening a new file that does not yet exist, permissions will be set to ‘0666 - UMASK’.

     Compatibility Note: Octave opens files using buffered I/O. Small writes are accumulated until an internal buffer is filled, and then everything is written in a single operation.  This is very efficient and improves performance.  MATLAB, however, opens files using flushed I/O where every write operation is immediately performed.  If the write operation must be performed immediately after data has been written then the write should be followed by a call to ‘fflush’ to flush the internal buffer.

     See also: fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport, umask.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Open a file for low-level I/O or query open files and file descriptors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
freport


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- : freport ()
     Print a list of which files have been opened, and whether they are open for reading, writing, or both.

     For example:

          freport ()

               ⊣  number  mode  arch       name
               ⊣  ------  ----  ----       ----
               ⊣     0     r    ieee-le    stdin
               ⊣     1     w    ieee-le    stdout
               ⊣     2     w    ieee-le    stderr
               ⊣     3     r    ieee-le    myfile

     See also: fopen, fclose, is_valid_file_id.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Print a list of which files have been opened, and whether they are open for reading, writing, or both.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
frewind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- : frewind (FID)
 -- : STATUS = frewind (FID)
     Move the file pointer to the beginning of the file specified by file descriptor FID.

     ‘frewind’ returns 0 for success, and -1 if an error is encountered.  It is equivalent to ‘fseek (FID, 0, SEEK_SET)’.

     See also: fseek, ftell, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Move the file pointer to the beginning of the file specified by file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fseek


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 667
 -- : fseek (FID, OFFSET)
 -- : fseek (FID, OFFSET, ORIGIN)
 -- : STATUS = fseek (...)
     Set the file pointer to the location OFFSET within the file FID.

     The pointer is positioned OFFSET characters from the ORIGIN, which may be one of the predefined variables SEEK_SET (beginning), SEEK_CUR (current position), or SEEK_END (end of file) or strings "bof", "cof", or "eof".  If ORIGIN is omitted, SEEK_SET is assumed.  OFFSET may be positive, negative, or zero but not all combinations of ORIGIN and OFFSET can be realized.

     ‘fseek’ returns 0 on success and -1 on error.

     See also: fskipl, frewind, ftell, fopen, SEEK_SET, SEEK_CUR, SEEK_END.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Set the file pointer to the location OFFSET within the file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ftell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 210
 -- : POS = ftell (FID)
     Return the position of the file pointer as the number of characters from the beginning of the file specified by file descriptor FID.

     See also: fseek, frewind, feof, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Return the position of the file pointer as the number of characters from the beginning of the file specified by file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 695
 -- : fprintf (FID, TEMPLATE, ...)
 -- : fprintf (TEMPLATE, ...)
 -- : NUMBYTES = fprintf (...)
     This function is equivalent to ‘printf’, except that the output is written to the file descriptor FID instead of ‘stdout’.

     If FID is omitted, the output is written to ‘stdout’ making the function exactly equivalent to ‘printf’.

     The optional output returns the number of bytes written to the file.

     Implementation Note: For compatibility with MATLAB, escape sequences in the template string (e.g., "\n" => newline) are expanded even when the template string is defined with single quotes.

     See also: fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
This function is equivalent to ‘printf’, except that the output is written to the file descriptor FID instead of ‘stdout’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
printf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- : printf (TEMPLATE, ...)
     Print optional arguments under the control of the template string TEMPLATE to the stream ‘stdout’ and return the number of characters printed.

     See the Formatted Output section of the GNU Octave manual for a complete description of the syntax of the template string.

     Implementation Note: For compatibility with MATLAB, escape sequences in the template string (e.g., "\n" => newline) are expanded even when the template string is defined with single quotes.

     See also: fprintf, sprintf, scanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
Print optional arguments under the control of the template string TEMPLATE to the stream ‘stdout’ and return the number of characters printed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fputs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- : fputs (FID, STRING)
 -- : STATUS = fputs (FID, STRING)
     Write the string STRING to the file with file descriptor FID.

     The string is written to the file with no additional formatting.  Use ‘fdisp’ instead to automatically append a newline character appropriate for the local machine.

     Return a non-negative number on success or EOF on error.

     See also: fdisp, fprintf, fwrite, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Write the string STRING to the file with file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
puts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- : puts (STRING)
 -- : STATUS = puts (STRING)
     Write a string to the standard output with no formatting.

     The string is written verbatim to the standard output.  Use ‘disp’ to automatically append a newline character appropriate for the local machine.

     Return a non-negative number on success and EOF on error.

     See also: fputs, disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Write a string to the standard output with no formatting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 567
 -- : sprintf (TEMPLATE, ...)
     This is like ‘printf’, except that the output is returned as a string.

     Unlike the C library function, which requires you to provide a suitably sized string as an argument, Octave’s ‘sprintf’ function returns the string, automatically sized to hold all of the items converted.

     Implementation Note: For compatibility with MATLAB, escape sequences in the template string (e.g., "\n" => newline) are expanded even when the template string is defined with single quotes.

     See also: printf, fprintf, sscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
This is like ‘printf’, except that the output is returned as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1628
 -- : [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE, SIZE)
 -- : [V1, V2, ..., COUNT, ERRMSG] = fscanf (FID, TEMPLATE, "C")
     In the first form, read from FID according to TEMPLATE, returning the result in the matrix VAL.

     The optional argument SIZE specifies the amount of data to read and may be one of

     ‘Inf’
          Read as much as possible, returning a column vector.

     ‘NR’
          Read up to NR elements, returning a column vector.

     ‘[NR, Inf]’
          Read as much as possible, returning a matrix with NR rows.  If the number of elements read is not an exact multiple of NR, the last column is padded with zeros.

     ‘[NR, NC]’
          Read up to ‘NR * NC’ elements, returning a matrix with NR rows.  If the number of elements read is not an exact multiple of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of ‘Inf’ is assumed.

     A string is returned if TEMPLATE specifies only character conversions.

     The number of items successfully read is returned in COUNT.

     If an error occurs, ERRMSG contains a system-dependent error message.

     In the second form, read from FID according to TEMPLATE, with each conversion specifier in TEMPLATE corresponding to a single scalar return value.  This form is more “C-like”, and also compatible with previous versions of Octave.  The number of successful conversions is returned in COUNT

     See the Formatted Input section of the GNU Octave manual for a complete description of the syntax of the template string.

     See also: fgets, fgetl, fread, scanf, sscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
In the first form, read from FID according to TEMPLATE, returning the result in the matrix VAL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 488
 -- : [VAL, COUNT, ERRMSG, POS] = sscanf (STRING, TEMPLATE, SIZE)
 -- : [V1, V2, ..., COUNT, ERRMSG] = sscanf (STRING, TEMPLATE, "C")
     This is like ‘fscanf’, except that the characters are taken from the string STRING instead of from a stream.

     Reaching the end of the string is treated as an end-of-file condition.  In addition to the values returned by ‘fscanf’, the index of the next character to be read is returned in POS.

     See also: fscanf, scanf, sprintf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
This is like ‘fscanf’, except that the characters are taken from the string STRING instead of from a stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
scanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 304
 -- : [VAL, COUNT, ERRMSG] = scanf (TEMPLATE, SIZE)
 -- : [V1, V2, ..., COUNT, ERRMSG] = scanf (TEMPLATE, "C")
     This is equivalent to calling ‘fscanf’ with FID = ‘stdin’.

     It is currently not useful to call ‘scanf’ in interactive programs.

     See also: fscanf, sscanf, printf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
This is equivalent to calling ‘fscanf’ with FID = ‘stdin’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
textscan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9960
 -- : C = textscan (FID, FORMAT)
 -- : C = textscan (FID, FORMAT, REPEAT)
 -- : C = textscan (FID, FORMAT, PARAM, VALUE, ...)
 -- : C = textscan (FID, FORMAT, REPEAT, PARAM, VALUE, ...)
 -- : C = textscan (STR, ...)
 -- : [C, POSITION, ERRMSG] = textscan (...)
     Read data from a text file or string.

     The string STR or file associated with FID is read from and parsed according to FORMAT.  The function is an extension of ‘strread’ and ‘textread’.  Differences include: the ability to read from either a file or a string, additional options, and additional format specifiers.

     The input is interpreted as a sequence of words, delimiters (such as whitespace), and literals.  The characters that form delimiters and whitespace are determined by the options.  The format consists of format specifiers interspersed between literals.  In the format, whitespace forms a delimiter between consecutive literals, but is otherwise ignored.

     The output C is a cell array where the number of columns is determined by the number of format specifiers.

     The first word of the input is matched to the first specifier of the format and placed in the first column of the output; the second is matched to the second specifier and placed in the second column and so forth.  If there are more words than specifiers then the process is repeated until all words have been processed or the limit imposed by REPEAT has been met (see below).

     The string FORMAT describes how the words in STR should be parsed.  As in FSCANF, any (non-whitespace) text in the format that is not one of these specifiers is considered a literal.  If there is a literal between two format specifiers then that same literal must appear in the input stream between the matching words.

     The following specifiers are valid:

     ‘%f’
     ‘%f64’
     ‘%n’
          The word is parsed as a number and converted to double.

     ‘%f32’
          The word is parsed as a number and converted to single (float).

     ‘%d’
     ‘%d8’
     ‘%d16’
     ‘%d32’
     ‘%d64’
          The word is parsed as a number and converted to int8, int16, int32, or int64.  If no size is specified then int32 is used.

     ‘%u’
     ‘%u8’
     ‘%u16’
     ‘%u32’
     ‘%u64’
          The word is parsed as a number and converted to uint8, uint16, uint32, or uint64.  If no size is specified then uint32 is used.

     ‘%s’
          The word is parsed as a string ending at the last character before whitespace, an end-of-line, or a delimiter specified in the options.

     ‘%q’
          The word is parsed as a "quoted string".  If the first character of the string is a double quote (") then the string includes everything until a matching double quote—including whitespace, delimiters, and end-of-line characters.  If a pair of consecutive double quotes appears in the input, it is replaced in the output by a single double quote.  For examples, the input "He said ""Hello""" would return the value ’He said "Hello"’.

     ‘%c’
          The next character of the input is read.  This includes delimiters, whitespace, and end-of-line characters.

     ‘%[...]’
     ‘%[^...]’
          In the first form, the word consists of the longest run consisting of only characters between the brackets.  Ranges of characters can be specified by a hyphen; for example, %[0-9a-zA-Z] matches all alphanumeric characters (if the underlying character set is ASCII). Since MATLAB treats hyphens literally, this expansion only applies to alphanumeric characters.  To include ’-’ in the set, it should appear first or last in the brackets; to include ’]’, it should be the first character.  If the first character is ’^’ then the word consists of characters *not* listed.

     ‘%N...’
          For %s, %c %d, %f, %n, %u, an optional width can be specified as %Ns, etc.  where N is an integer > 1.  For %c, this causes exactly N characters to be read instead of a single character.  For the other specifiers, it is an upper bound on the number of characters read; normal delimiters can cause fewer characters to be read.  For complex numbers, this limit applies to the real and imaginary components individually.  For %f and %n, format specifiers like %N.Mf are allowed, where M is an upper bound on number of characters after the decimal point to be considered; subsequent digits are skipped.  For example, the specifier %8.2f would read 12.345e6 as 1.234e7.

     ‘%*...’
          The word specified by the remainder of the conversion specifier is skipped.

     ‘literals’
          In addition the format may contain literal character strings; these will be skipped during reading.  If the input string does not match this literal, the processing terminates.

     Parsed words corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers.

     By default, if there is only one input argument, FORMAT is "%f".  This means that numbers are read from the input into a single column vector.  If FORMAT is explicitly empty ("") then textscan will return data in a number of columns matching the number of fields on the first data line of the input.  Either of these is suitable only when the input is exclusively numeric.

     For example, the string

          STR = "\
          Bunny Bugs   5.5\n\
          Duck Daffy  -7.5e-5\n\
          Penguin Tux   6"

     can be read using

          A = textscan (STR, "%s %s %f");

     The optional numeric argument REPEAT can be used for limiting the number of items read:

     -1
          Read all of the string or file until the end (default).

     N
          Read until the first of two conditions occurs: 1) the format has been processed N times, or 2) N lines of the input have been processed.  Zero (0) is an acceptable value for REPEAT.  Currently, end-of-line characters inside %q, %c, and %[...]$ conversions do not contribute to the line count.  This is incompatible with MATLAB and may change in future.

     The behavior of ‘textscan’ can be changed via property/value pairs.  The following properties are recognized:

     "BufSize"
          This specifies the number of bytes to use for the internal buffer.  A modest speed improvement may be obtained by setting this to a large value when reading a large file, especially if the input contains long strings.  The default is 4096, or a value dependent on N if that is specified.

     "CollectOutput"
          A value of 1 or true instructs ‘textscan’ to concatenate consecutive columns of the same class in the output cell array.  A value of 0 or false (default) leaves output in distinct columns.

     "CommentStyle"
          Specify parts of the input which are considered comments and will be skipped.  VALUE is the comment style and can be either (1) A string or 1x1 cell string, to skip everything to the right of it; (2) A cell array of two strings, to skip everything between the first and second strings.  Comments are only parsed where whitespace is accepted and do not act as delimiters.

     "Delimiter"
          If VALUE is a string, any character in VALUE will be used to split the input into words.  If VALUE is a cell array of strings, any string in the array will be used to split the input into words.  (default value = any whitespace.)

     "EmptyValue"
          Value to return for empty numeric values in non-whitespace delimited data.  The default is NaN.  When the data type does not support NaN (int32 for example), then the default is zero.

     "EndOfLine"
          VALUE can be either an emtpy or one character specifying the end-of-line character, or the pair "\r\n" (CRLF). In the latter case, any of "\r", "\n" or "\r\n" is counted as a (single) newline.  If no value is given, "\r\n" is used.

     "HeaderLines"
          The first VALUE number of lines of FID are skipped.  Note that this does not refer to the first non-comment lines, but the first lines of any type.

     "MultipleDelimsAsOne"
          If VALUE is nonzero, treat a series of consecutive delimiters, without whitespace in between, as a single delimiter.  Consecutive delimiter series need not be vertically aligned.  Without this option, a single delimiter before the end of the line does not cause the line to be considered to end with an empty value, but a single delimiter at the start of a line causes the line to be considered to start with an empty value.

     "TreatAsEmpty"
          Treat single occurrences (surrounded by delimiters or whitespace) of the string(s) in VALUE as missing values.

     "ReturnOnError"
          If set to numerical 1 or true, return normally as soon as an error is encountered, such as trying to read a string using ‘%f’.  If set to 0 or false, return an error and no data.

     "Whitespace"
          Any character in VALUE will be interpreted as whitespace and trimmed; The default value for whitespace is " \b\r\n\t" (note the space).  Unless whitespace is set to "" (empty) AND at least one "%s" format conversion specifier is supplied, a space is always part of whitespace.

     When the number of words in STR or FID doesn’t match an exact multiple of the number of format conversion specifiers, ‘textscan’’s behavior depends on whether the last character of the string or file is an end-of-line as specified by the ‘EndOfLine’ option:

     last character = end-of-line
          Data columns are padded with empty fields, NaN or 0 (for integer fields) so that all columns have equal length

     last character is not end-of-line
          Data columns are not padded; ‘textscan’ returns columns of unequal length

     The second output POSITION provides the location, in characters from the beginning of the file or string, where processing stopped.

     See also: dlmread, fscanf, load, strread, textread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Read data from a text file or string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4084
 -- : VAL = fread (FID)
 -- : VAL = fread (FID, SIZE)
 -- : VAL = fread (FID, SIZE, PRECISION)
 -- : VAL = fread (FID, SIZE, PRECISION, SKIP)
 -- : VAL = fread (FID, SIZE, PRECISION, SKIP, ARCH)
 -- : [VAL, COUNT] = fread (...)
     Read binary data from the file specified by the file descriptor FID.

     The optional argument SIZE specifies the amount of data to read and may be one of

     ‘Inf’
          Read as much as possible, returning a column vector.

     ‘NR’
          Read up to NR elements, returning a column vector.

     ‘[NR, Inf]’
          Read as much as possible, returning a matrix with NR rows.  If the number of elements read is not an exact multiple of NR, the last column is padded with zeros.

     ‘[NR, NC]’
          Read up to ‘NR * NC’ elements, returning a matrix with NR rows.  If the number of elements read is not an exact multiple of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of ‘Inf’ is assumed.

     The optional argument PRECISION is a string specifying the type of data to read and may be one of

     "uint8" (default)
          8-bit unsigned integer.

     "int8"
     "integer*1"
          8-bit signed integer.

     "uint16"
     "ushort"
     "unsigned short"
          16-bit unsigned integer.

     "int16"
     "integer*2"
     "short"
          16-bit signed integer.

     "uint"
     "uint32"
     "unsigned int"
     "ulong"
     "unsigned long"
          32-bit unsigned integer.

     "int"
     "int32"
     "integer*4"
     "long"
          32-bit signed integer.

     "uint64"
          64-bit unsigned integer.

     "int64"
     "integer*8"
          64-bit signed integer.

     "single"
     "float"
     "float32"
     "real*4"
          32-bit floating point number.

     "double"
     "float64"
     "real*8"
          64-bit floating point number.

     "char"
     "char*1"
          8-bit single character.

     "uchar"
     "unsigned char"
          8-bit unsigned character.

     "schar"
     "signed char"
          8-bit signed character.

     The default precision is "uint8".

     The PRECISION argument may also specify an optional repeat count.  For example, ‘32*single’ causes ‘fread’ to read a block of 32 single precision floating point numbers.  Reading in blocks is useful in combination with the SKIP argument.

     The PRECISION argument may also specify a type conversion.  For example, ‘int16=>int32’ causes ‘fread’ to read 16-bit integer values and return an array of 32-bit integer values.  By default, ‘fread’ returns a double precision array.  The special form ‘*TYPE’ is shorthand for ‘TYPE=>TYPE’.

     The conversion and repeat counts may be combined.  For example, the specification ‘32*single=>single’ causes ‘fread’ to read blocks of single precision floating point values and return an array of single precision values instead of the default array of double precision values.

     The optional argument SKIP specifies the number of bytes to skip after each element (or block of elements) is read.  If it is not specified, a value of 0 is assumed.  If the final block read is not complete, the final skip is omitted.  For example,

          fread (f, 10, "3*single=>single", 8)

     will omit the final 8-byte skip because the last read will not be a complete block of 3 values.

     The optional argument ARCH is a string specifying the data format for the file.  Valid values are

     "native" or "n"
          The format of the current machine.

     "ieee-be" or "b"
          IEEE big endian.

     "ieee-le" or "l"
          IEEE little endian.

     If no ARCH is given the value used in the call to ‘fopen’ which created the file descriptor is used.  Otherwise, the value specified with ‘fread’ overrides that of ‘fopen’ and determines the data format.

     The output argument VAL contains the data read from the file.

     The optional return value COUNT contains the number of elements read.

     See also: fwrite, fgets, fgetl, fscanf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Read binary data from the file specified by the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 749
 -- : fwrite (FID, DATA)
 -- : fwrite (FID, DATA, PRECISION)
 -- : fwrite (FID, DATA, PRECISION, SKIP)
 -- : fwrite (FID, DATA, PRECISION, SKIP, ARCH)
 -- : COUNT = fwrite (...)
     Write data in binary form to the file specified by the file descriptor FID, returning the number of values COUNT successfully written to the file.

     The argument DATA is a matrix of values that are to be written to the file.  The values are extracted in column-major order.

     The remaining arguments PRECISION, SKIP, and ARCH are optional, and are interpreted as described for ‘fread’.

     The behavior of ‘fwrite’ is undefined if the values in DATA are too large to fit in the specified precision.

     See also: fread, fputs, fprintf, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
Write data in binary form to the file specified by the file descriptor FID, returning the number of values COUNT successfully written to the file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
feof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 380
 -- : STATUS = feof (FID)
     Return 1 if an end-of-file condition has been encountered for the file specified by file descriptor FID and 0 otherwise.

     Note that ‘feof’ will only return 1 if the end of the file has already been encountered, not if the next read operation will result in an end-of-file condition.

     See also: fread, frewind, fseek, fclear, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
Return 1 if an end-of-file condition has been encountered for the file specified by file descriptor FID and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ferror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 716
 -- : MSG = ferror (FID)
 -- : [MSG, ERR] = ferror (FID)
 -- : [...] = ferror (FID, "clear")
     Query the error status of the stream specified by file descriptor FID.

     If an error condition exists then return a string MSG describing the error.  Otherwise, return an empty string "".

     The second input "clear" is optional.  If supplied, the error state on the stream will be cleared.

     The optional second output is a numeric indication of the error status.  ERR is 1 if an error condition has been encountered and 0 otherwise.

     Note that ‘ferror’ indicates if an error has already occurred, not whether the next operation will result in an error condition.

     See also: fclear, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Query the error status of the stream specified by file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
popen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 869
 -- : FID = popen (COMMAND, MODE)
     Start a process and create a pipe.

     The name of the command to run is given by COMMAND.  The argument MODE may be

     "r"
          The pipe will be connected to the standard output of the process, and open for reading.

     "w"
          The pipe will be connected to the standard input of the process, and open for writing.

     The file identifier corresponding to the input or output stream of the process is returned in FID.

     For example:

          fid = popen ("ls -ltr / | tail -3", "r");
          while (ischar (s = fgets (fid)))
            fputs (stdout, s);
          endwhile

             ⊣ drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
             ⊣ drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
             ⊣ drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp

     See also: popen2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Start a process and create a pipe.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- : pclose (FID)
     Close a file identifier that was opened by ‘popen’.

     The function ‘fclose’ may also be used for the same purpose.

     See also: fclose, popen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Close a file identifier that was opened by ‘popen’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tempname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 693
 -- : FNAME = tempname ()
 -- : FNAME = tempname (DIR)
 -- : FNAME = tempname (DIR, PREFIX)
     Return a unique temporary filename as a string.

     If PREFIX is omitted, a value of "oct-" is used.

     If DIR is also omitted, the default directory for temporary files (‘P_tmpdir’) is used.  If DIR is provided, it must exist, otherwise the default directory for temporary files is used.

     Programming Note: Because the named file is not opened by ‘tempname’, it is possible, though relatively unlikely, that it will not be available by the time your program attempts to open it.  If this is a concern, see ‘tmpfile’.

     See also: mkstemp, tempdir, P_tmpdir, tmpfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return a unique temporary filename as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tmpfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 447
 -- : [FID, MSG] = tmpfile ()
     Return the file ID corresponding to a new temporary file with a unique name.

     The file is opened in binary read/write ("w+b") mode and will be deleted automatically when it is closed or when Octave exits.

     If successful, FID is a valid file ID and MSG is an empty string.  Otherwise, FID is -1 and MSG contains a system-dependent error message.

     See also: tempname, mkstemp, tempdir, P_tmpdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the file ID corresponding to a new temporary file with a unique name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mkstemp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 969
 -- : [FID, NAME, MSG] = mkstemp ("TEMPLATE")
 -- : [FID, NAME, MSG] = mkstemp ("TEMPLATE", DELETE)
     Return the file descriptor FID corresponding to a new temporary file with a unique name created from TEMPLATE.

     The last six characters of TEMPLATE must be "XXXXXX" and these are replaced with a string that makes the filename unique.  The file is then created with mode read/write and permissions that are system dependent (on GNU/Linux systems, the permissions will be 0600 for versions of glibc 2.0.7 and later).  The file is opened in binary mode and with the ‘O_EXCL’ flag.

     If the optional argument DELETE is supplied and is true, the file will be deleted automatically when Octave exits.

     If successful, FID is a valid file ID, NAME is the name of the file, and MSG is an empty string.  Otherwise, FID is -1, NAME is empty, and MSG contains a system-dependent error message.

     See also: tempname, tempdir, P_tmpdir, tmpfile, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Return the file descriptor FID corresponding to a new temporary file with a unique name created from TEMPLATE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
umask


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- : umask (MASK)
     Set the permission mask for file creation.

     The parameter MASK is an integer, interpreted as an octal number.

     If successful, returns the previous value of the mask (as an integer to be interpreted as an octal number); otherwise an error message is printed.

     The permission mask is a UNIX concept used when creating new objects on a file system such as files, directories, or named FIFOs.  The object to be created has base permissions in an octal number MODE which are modified according to the octal value of MASK.  The final permissions for the new object are ‘MODE - MASK’.

     See also: fopen, mkdir, mkfifo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Set the permission mask for file creation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
P_tmpdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- : P_tmpdir ()
     Return the name of the host system’s *default* directory for temporary files.

     Programming Note: The value returned by ‘P_tmpdir’ is always the default location.  This value may not agree with that returned from ‘tempdir’ if the user has overridden the default with the ‘TMPDIR’ environment variable.

     See also: tempdir, tempname, mkstemp, tmpfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return the name of the host system’s *default* directory for temporary files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_SET


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 187
 -- : SEEK_SET ()
     Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the beginning of the file.

     See also: SEEK_CUR, SEEK_END, fseek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the beginning of the file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_CUR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 -- : SEEK_CUR ()
     Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the current position.

     See also: SEEK_SET, SEEK_END, fseek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the current position.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_END


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- : SEEK_END ()
     Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the end of the file.

     See also: SEEK_SET, SEEK_CUR, fseek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Return the numerical value to pass to ‘fseek’ to position the file pointer relative to the end of the file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
stdin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- : stdin ()
     Return the numeric value corresponding to the standard input stream.

     When Octave is used interactively, stdin is filtered through the command line editing functions.

     See also: stdout, stderr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the numeric value corresponding to the standard input stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stdout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 222
 -- : stdout ()
     Return the numeric value corresponding to the standard output stream.

     Data written to the standard output may be filtered through the pager.

     See also: stdin, stderr, page_screen_output.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the numeric value corresponding to the standard output stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stderr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 250
 -- : stderr ()
     Return the numeric value corresponding to the standard error stream.

     Even if paging is turned on, the standard error is not sent to the pager.  It is useful for error messages and prompts.

     See also: stdin, stdout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the numeric value corresponding to the standard error stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
filter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1559
 -- : Y = filter (B, A, X)
 -- : [Y, SF] = filter (B, A, X, SI)
 -- : [Y, SF] = filter (B, A, X, [], DIM)
 -- : [Y, SF] = filter (B, A, X, SI, DIM)
     Apply a 1-D digital filter to the data X.

     ‘filter’ returns the solution to the following linear, time-invariant difference equation:

           N                   M
          SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)
          k=0                 k=0

     where N=length(a)-1 and M=length(b)-1.  The result is calculated over the first non-singleton dimension of X or over DIM if supplied.

     An equivalent form of the equation is:

                    N                   M
          y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                   k=1                 k=0

     where c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial state of the system and the final state is returned as SF.  The state vector is a column vector whose length is equal to the length of the longest coefficient vector minus one.  If SI is not supplied, the initial state vector is set to all zeros.

     In terms of the Z Transform, Y is the result of passing the discrete-time signal X through a system characterized by the following rational system function:

                    M
                   SUM d(k+1) z^(-k)
                   k=0
          H(z) = ---------------------
                      N
                 1 + SUM c(k+1) z^(-k)
                     k=1

     See also: filter2, fftfilt, freqz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Apply a 1-D digital filter to the data X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
find


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1616
 -- : IDX = find (X)
 -- : IDX = find (X, N)
 -- : IDX = find (X, N, DIRECTION)
 -- : [i, j] = find (...)
 -- : [i, j, v] = find (...)
     Return a vector of indices of nonzero elements of a matrix, as a row if X is a row vector or as a column otherwise.

     To obtain a single index for each matrix element, Octave pretends that the columns of a matrix form one long vector (like Fortran arrays are stored).  For example:

          find (eye (2))
            ⇒ [ 1; 4 ]

     If two inputs are given, N indicates the maximum number of elements to find from the beginning of the matrix or vector.

     If three inputs are given, DIRECTION should be one of "first" or "last", requesting only the first or last N indices, respectively.  However, the indices are always returned in ascending order.

     If two outputs are requested, ‘find’ returns the row and column indices of nonzero elements of a matrix.  For example:

          [i, j] = find (2 * eye (2))
              ⇒ i = [ 1; 2 ]
              ⇒ j = [ 1; 2 ]

     If three outputs are requested, ‘find’ also returns a vector containing the nonzero values.  For example:

          [i, j, v] = find (3 * eye (2))
                 ⇒ i = [ 1; 2 ]
                 ⇒ j = [ 1; 2 ]
                 ⇒ v = [ 3; 3 ]

     Note that this function is particularly useful for sparse matrices, as it extracts the nonzero elements as vectors, which can then be used to create the original matrix.  For example:

          sz = size (a);
          [i, j, v] = find (a);
          b = sparse (i, j, v, sz(1), sz(2));

     See also: nonzeros.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Return a vector of indices of nonzero elements of a matrix, as a row if X is a row vector or as a column otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gcd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 795
 -- : G = gcd (A1, A2, ...)
 -- : [G, V1, ...] = gcd (A1, A2, ...)
     Compute the greatest common divisor of A1, A2, ....

     If more than one argument is given then all arguments must be the same size or scalar.  In this case the greatest common divisor is calculated for each element individually.  All elements must be ordinary or Gaussian (complex) integers.  Note that for Gaussian integers, the gcd is only unique up to a phase factor (multiplication by 1, -1, i, or -i), so an arbitrary greatest common divisor among the four possible is returned.

     Optional return arguments V1, ..., contain integer vectors such that,

          G = V1 .* A1 + V2 .* A2 + ...

     Example code:

          gcd ([15, 9], [20, 18])
             ⇒  5  9

     See also: lcm, factor, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the greatest common divisor of A1, A2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
 -- : GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.

     Once the end of data has been reached, ‘getgrent’ returns 0.

     See also: setgrent, endgrent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return an entry from the group database, opening it if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 219
 -- : GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID GID.

     If the group ID does not exist in the database, ‘getgrgid’ returns 0.

     See also: getgrnam.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the first entry from the group database with the group ID GID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 224
 -- : GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name NAME.

     If the group name does not exist in the database, ‘getgrnam’ returns 0.

     See also: getgrgid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the first entry from the group database with the group name NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- : setgrent ()
     Return the internal pointer to the beginning of the group database.

     See also: getgrent, endgrent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the internal pointer to the beginning of the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- : endgrent ()
     Close the group database.

     See also: getgrent, setgrent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Close the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 241
 -- : PW_STRUCT = getpwent ()
     Return a structure containing an entry from the password database, opening it if necessary.

     Once the end of the data has been reached, ‘getpwent’ returns 0.

     See also: setpwent, endpwent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Return a structure containing an entry from the password database, opening it if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 242
 -- : PW_STRUCT = getpwuid (UID).
     Return a structure containing the first entry from the password database with the user ID UID.

     If the user ID does not exist in the database, ‘getpwuid’ returns 0.

     See also: getpwnam.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return a structure containing the first entry from the password database with the user ID UID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 248
 -- : PW_STRUCT = getpwnam (NAME)
     Return a structure containing the first entry from the password database with the user name NAME.

     If the user name does not exist in the database, ‘getpwname’ returns 0.

     See also: getpwuid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Return a structure containing the first entry from the password database with the user name NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- : setpwent ()
     Return the internal pointer to the beginning of the password database.

     See also: getpwent, endpwent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the internal pointer to the beginning of the password database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- : endpwent ()
     Close the password database.

     See also: getpwent, setpwent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Close the password database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
getrusage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1425
 -- : getrusage ()
     Return a structure containing a number of statistics about the current Octave process.

     Not all fields are available on all systems.  If it is not possible to get CPU time statistics, the CPU time slots are set to zero.  Other missing data are replaced by NaN.  The list of possible fields is:

     ‘idrss’
          Unshared data size.

     ‘inblock’
          Number of block input operations.

     ‘isrss’
          Unshared stack size.

     ‘ixrss’
          Shared memory size.

     ‘majflt’
          Number of major page faults.

     ‘maxrss’
          Maximum data size.

     ‘minflt’
          Number of minor page faults.

     ‘msgrcv’
          Number of messages received.

     ‘msgsnd’
          Number of messages sent.

     ‘nivcsw’
          Number of involuntary context switches.

     ‘nsignals’
          Number of signals received.

     ‘nswap’
          Number of swaps.

     ‘nvcsw’
          Number of voluntary context switches.

     ‘oublock’
          Number of block output operations.

     ‘stime’
          A structure containing the system CPU time used.  The structure has the elements ‘sec’ (seconds) ‘usec’ (microseconds).

     ‘utime’
          A structure containing the user CPU time used.  The structure has the elements ‘sec’ (seconds) ‘usec’ (microseconds).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return a structure containing a number of statistics about the current Octave process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
givens


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 699
 -- : G = givens (X, Y)
 -- : [C, S] = givens (X, Y)
     Compute the Givens rotation matrix G.

     The Givens matrix is a 2-by-2 orthogonal matrix

          G = [ C , S
               -S', C]

     such that

          G * [X; Y] = [*; 0]

     with X and Y scalars.

     If two output arguments are requested, return the factors C and S rather than the Givens rotation matrix.

     For example:

          givens (1, 1)
             ⇒   0.70711   0.70711
                 -0.70711   0.70711

     Note: The Givens matrix represents a counterclockwise rotation of a 2-D plane and can be used to introduce zeros into a matrix prior to complete factorization.

     See also: planerot, qr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the Givens rotation matrix G.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ishghandle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- : ishghandle (H)
     Return true if H is a graphics handle and false otherwise.

     H may also be a matrix of handles in which case a logical array is returned that is true where the elements of H are graphics handles and false where they are not.

     See also: isgraphics, isaxes, isfigure, ishandle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return true if H is a graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
reset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 411
 -- : reset (H)
     Reset the properties of the graphic object H to their default values.

     For figures, the properties "position", "units", "windowstyle", and "paperunits" are not affected.  For axes, the properties "position" and "units" are not affected.

     The input H may also be a vector of graphic handles in which case each individual object will be reset.

     See also: cla, clf, newplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Reset the properties of the graphic object H to their default values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2231
 -- : set (H, PROPERTY, VALUE, ...)
 -- : set (H, PROPERTIES, VALUES)
 -- : set (H, PV)
 -- : VALUE_LIST = set (H, PROPERTY)
 -- : ALL_VALUE_LIST = set (H)
     Set named property values for the graphics handle (or vector of graphics handles) H.

     There are three ways to give the property names and values:

        • as a comma separated list of PROPERTY, VALUE pairs

          Here, each PROPERTY is a string containing the property name, each VALUE is a value of the appropriate type for the property.

        • as a cell array of strings PROPERTIES containing property names and a cell array VALUES containing property values.

          In this case, the number of columns of VALUES must match the number of elements in PROPERTIES.  The first column of VALUES contains values for the first entry in PROPERTIES, etc.  The number of rows of VALUES must be 1 or match the number of elements of H.  In the first case, each handle in H will be assigned the same values.  In the latter case, the first handle in H will be assigned the values from the first row of VALUES and so on.

        • as a structure array PV

          Here, the field names of PV represent the property names, and the field values give the property values.  In contrast to the previous case, all elements of PV will be set in all handles in H independent of the dimensions of PV.

     ‘set’ is also used to query the list of values a named property will take.  ‘CLIST = set (H, "property")’ will return the list of possible values for "property" in the cell list CLIST.  If no output variable is used then the list is formatted and printed to the screen.

     If no property is specified (‘SLIST = set (H)’) then a structure SLIST is returned where the fieldnames are the properties of the object H and the fields are the list of possible values for each property.  If no output variable is used then the list is formatted and printed to the screen.

     For example,

          hf = figure ();
          set (hf, "paperorientation")
          ⇒  paperorientation:  [ landscape | {portrait} | rotated ]

     shows the paperorientation property can take three values with the default being "portrait".

     See also: get.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Set named property values for the graphics handle (or vector of graphics handles) H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 302
 -- : VAL = get (H)
 -- : VAL = get (H, P)
     Return the value of the named property P from the graphics handle H.

     If P is omitted, return the complete property list for H.

     If H is a vector, return a cell array including the property values or lists respectively.

     See also: set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the value of the named property P from the graphics handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
available_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- : available_graphics_toolkits ()
     Return a cell array of registered graphics toolkits.

     See also: graphics_toolkit, register_graphics_toolkit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return a cell array of registered graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
register_graphics_toolkit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- : register_graphics_toolkit (TOOLKIT)
     List TOOLKIT as an available graphics toolkit.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
List TOOLKIT as an available graphics toolkit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
loaded_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- : loaded_graphics_toolkits ()
     Return a cell array of the currently loaded graphics toolkits.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a cell array of the currently loaded graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
drawnow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 439
 -- : drawnow ()
 -- : drawnow ("expose")
 -- : drawnow (TERM, FILE, DEBUG_FILE)
     Update figure windows and their children.

     The event queue is flushed and any callbacks generated are executed.

     With the optional argument "expose", only graphic objects are updated and no other events or callbacks are processed.

     The third calling form of ‘drawnow’ is for debugging and is undocumented.

     See also: refresh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Update figure windows and their children.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addlistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1130
 -- : addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics object H.

     Property listeners are executed (in order of registration) when the property is set.  The new value is already available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first element is a function handle.  If FCN is a function handle, the corresponding function should accept at least 2 arguments, that will be set to the object handle and the empty matrix respectively.  If FCN is a string, it must be any valid octave expression.  If FCN is a cell array, the first element must be a function handle with the same signature as described above.  The next elements of the cell array are passed as additional arguments to the function.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          addlistener (gcf, "position", {@my_listener, "my string"})

     See also: dellistener, addproperty, hggroup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Register FCN as listener for the property PROP of the graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
dellistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 650
 -- : dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP of the graphics object H.

     The function FCN must be the same variable (not just the same value), as was passed to the original call to ‘addlistener’.

     If FCN is not defined then all listener functions of PROP are removed.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          c = {@my_listener, "my string"};
          addlistener (gcf, "position", c);
          dellistener (gcf, "position", c);

     See also: addlistener.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Remove the registration of FCN as a listener for the property PROP of the graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addproperty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2458
 -- : addproperty (NAME, H, TYPE)
 -- : addproperty (NAME, H, TYPE, ARG, ...)
     Create a new property named NAME in graphics object H.

     TYPE determines the type of the property to create.  ARGS usually contains the default value of the property, but additional arguments might be given, depending on the type of the property.

     The supported property types are:

     ‘string’
          A string property.  ARG contains the default string value.

     ‘any’
          An un-typed property.  This kind of property can hold any octave value.  ARGS contains the default value.

     ‘radio’
          A string property with a limited set of accepted values.  The first argument must be a string with all accepted values separated by a vertical bar (’|’).  The default value can be marked by enclosing it with a ’{’ ’}’ pair.  The default value may also be given as an optional second string argument.

     ‘boolean’
          A boolean property.  This property type is equivalent to a radio property with "on|off" as accepted values.  ARG contains the default property value.

     ‘double’
          A scalar double property.  ARG contains the default value.

     ‘handle’
          A handle property.  This kind of property holds the handle of a graphics object.  ARG contains the default handle value.  When no default value is given, the property is initialized to the empty matrix.

     ‘data’
          A data (matrix) property.  ARG contains the default data value.  When no default value is given, the data is initialized to the empty matrix.

     ‘color’
          A color property.  ARG contains the default color value.  When no default color is given, the property is set to black.  An optional second string argument may be given to specify an additional set of accepted string values (like a radio property).

     TYPE may also be the concatenation of a core object type and a valid property name for that object type.  The property created then has the same characteristics as the referenced property (type, possible values, hidden state...).  This allows one to clone an existing property into the graphics object H.

     Examples:

          addproperty ("my_property", gcf, "string", "a string value");
          addproperty ("my_radio", gcf, "radio", "val_1|val_2|{val_3}");
          addproperty ("my_style", gcf, "linelinestyle", "--");

     See also: addlistener, hggroup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Create a new property named NAME in graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1777
 -- : waitfor (H)
 -- : waitfor (H, PROP)
 -- : waitfor (H, PROP, VALUE)
 -- : waitfor (..., "timeout", TIMEOUT)
     Suspend the execution of the current program until a condition is satisfied on the graphics handle H.

     While the program is suspended graphics events are still processed normally, allowing callbacks to modify the state of graphics objects.  This function is reentrant and can be called from a callback, while another ‘waitfor’ call is pending at the top-level.

     In the first form, program execution is suspended until the graphics object H is destroyed.  If the graphics handle is invalid, the function returns immediately.

     In the second form, execution is suspended until the graphics object is destroyed or the property named PROP is modified.  If the graphics handle is invalid or the property does not exist, the function returns immediately.

     In the third form, execution is suspended until the graphics object is destroyed or the property named PROP is set to VALUE.  The function ‘isequal’ is used to compare property values.  If the graphics handle is invalid, the property does not exist or the property is already set to VALUE, the function returns immediately.

     An optional timeout can be specified using the property "timeout".  This timeout value is the number of seconds to wait for the condition to be true.  TIMEOUT must be at least 1.  If a smaller value is specified, a warning is issued and a value of 1 is used instead.  If the timeout value is not an integer, it is truncated towards 0.

     To define a condition on a property named "timeout", use the string ’\timeout’ instead.

     In all cases, typing CTRL-C stops program execution immediately.

     See also: waitforbuttonpress, isequal.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Suspend the execution of the current program until a condition is satisfied on the graphics handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gsvd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 928
 -- : S = gsvd (A, B)
 -- : [U, V, X, C, S] = gsvd (A, B)
 -- : [U, V, X, C, S] = gsvd (A, B, 0)
     Compute the generalized singular value decomposition of (A, B).

     The generalized singular value decomposition is defined by the following relations:

          A = U*C*X'
          B = V*S*X'
          C'*C + S'*S = eye (columns (A))

     The function ‘gsvd’ normally returns just the vector of generalized singular values ‘sqrt (diag (C'*C) ./ diag (S'*S))’.  If asked for five return values, it also computes U, V, X, and C.

     If the optional third input is present, ‘gsvd’ constructs the "economy-sized" decomposition where the number of columns of U, V and the number of rows of C, S is less than or equal to the number of columns of A.  This option is not yet implemented.

     Programming Note: the code is a wrapper to the corresponding LAPACK dggsvd and zggsvd routines.

     See also: svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the generalized singular value decomposition of (A, B).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hash


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1270
 -- : hash (HFUN, STR)
     Calculate the hash value of the string STR using the hash function HFUN.

     The available hash functions are given in the table below.

     ‘MD2’
          Message-Digest Algorithm 2 (RFC 1319).

     ‘MD4’
          Message-Digest Algorithm 4 (RFC 1320).

     ‘MD5’
          Message-Digest Algorithm 5 (RFC 1321).

     ‘SHA1’
          Secure Hash Algorithm 1 (RFC 3174)

     ‘SHA224’
          Secure Hash Algorithm 2 (224 Bits, RFC 3874)

     ‘SHA256’
          Secure Hash Algorithm 2 (256 Bits, RFC 6234)

     ‘SHA384’
          Secure Hash Algorithm 2 (384 Bits, RFC 6234)

     ‘SHA512’
          Secure Hash Algorithm 2 (512 Bits, RFC 6234)

     To calculate for example the MD5 hash value of the string "abc" the ‘hash’ function is called as follows:

          hash ("md5", "abc")
               ⊣ ans = 900150983cd24fb0d6963f7d28e17f72

     For the same string, the SHA-1 hash value is calculated with:

          hash ("sha1", "abc")
               ⊣ ans = a9993e364706816aba3e25717850c26c9cd0d89d

     And to compute the hash value of a file, e.g., ‘file = "file.txt"’, call ‘hash’ in combination with the ‘fileread’:

          hash ("md5", fileread (file));

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Calculate the hash value of the string STR using the hash function HFUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
get_help_text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- : [TEXT, FORMAT] = get_help_text (NAME)
     Return the raw help text of function NAME.

     The raw help text is returned in TEXT and the format in FORMAT The format is a string which is one of "texinfo", "html", or "plain text".

     See also: get_help_text_from_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return the raw help text of function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
get_help_text_from_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- : [TEXT, FORMAT] = get_help_text_from_file (FNAME)
     Return the raw help text from the file FNAME.

     The raw help text is returned in TEXT and the format in FORMAT The format is a string which is one of "texinfo", "html", or "plain text".

     See also: get_help_text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the raw help text from the file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
localfunctions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- : localfunctions ()
     Return a list of all local functions, i.e., subfunctions, within the current file.

     The return value is a column cell array of function handles to all local functions accessible from the function from which ‘localfunctions’ is called.  Nested functions are _not_ included in the list.

     If the call is from the command line, an anonymous function, or a script, the return value is an empty cell array.

     See also: functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return a list of all local functions, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
built_in_docstrings_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 795
 -- : VAL = built_in_docstrings_file ()
 -- : OLD_VAL = built_in_docstrings_file (NEW_VAL)
 -- : built_in_docstrings_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the file containing docstrings for built-in Octave functions.

     The default value is ‘OCTAVE-HOME/share/octave/VERSION/etc/built-in-docstrings’, in which OCTAVE-HOME is the root directory of the Octave installation, and VERSION is the Octave version number.  The default value may be overridden by the environment variable ‘OCTAVE_BUILT_IN_DOCSTRINGS_FILE’, or the command line argument ‘--built-in-docstrings-file FNAME’.

     Note: This variable is only used when Octave is initializing itself.  Modifying it during a running session of Octave will have no effect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Query or set the internal variable that specifies the name of the file containing docstrings for built-in Octave functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
doc_cache_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 972
 -- : VAL = doc_cache_file ()
 -- : OLD_VAL = doc_cache_file (NEW_VAL)
 -- : doc_cache_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the Octave documentation cache file.

     A cache file significantly improves the performance of the ‘lookfor’ command.  The default value is ‘OCTAVE-HOME/share/octave/VERSION/etc/doc-cache’, in which OCTAVE-HOME is the root directory of the Octave installation, and VERSION is the Octave version number.  The default value may be overridden by the environment variable ‘OCTAVE_DOC_CACHE_FILE’, or the command line argument ‘--doc-cache-file FNAME’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: doc_cache_create, lookfor, info_program, doc, help, makeinfo_program.

     See also: lookfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Query or set the internal variable that specifies the name of the Octave documentation cache file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
info_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- : VAL = info_file ()
 -- : OLD_VAL = info_file (NEW_VAL)
 -- : info_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the Octave info file.

     The default value is ‘OCTAVE-HOME/info/octave.info’, in which OCTAVE-HOME is the root directory of the Octave installation.  The default value may be overridden by the environment variable ‘OCTAVE_INFO_FILE’, or the command line argument ‘--info-file FNAME’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: info_program, doc, help, makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Query or set the internal variable that specifies the name of the Octave info file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
info_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- : VAL = info_program ()
 -- : OLD_VAL = info_program (NEW_VAL)
 -- : info_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the info program to run.

     The default value is ‘OCTAVE-HOME/libexec/octave/VERSION/exec/ARCH/info’ in which OCTAVE-HOME is the root directory of the Octave installation, VERSION is the Octave version number, and ARCH is the system type (for example, ‘i686-pc-linux-gnu’).  The default value may be overridden by the environment variable ‘OCTAVE_INFO_PROGRAM’, or the command line argument ‘--info-program NAME’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: info_file, doc, help, makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Query or set the internal variable that specifies the name of the info program to run.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
makeinfo_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 598
 -- : VAL = makeinfo_program ()
 -- : OLD_VAL = makeinfo_program (NEW_VAL)
 -- : makeinfo_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the program that Octave runs to format help text containing Texinfo markup commands.

     The default value is ‘makeinfo’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: texi_macros_file, info_file, info_program, doc, help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
Query or set the internal variable that specifies the name of the program that Octave runs to format help text containing Texinfo markup commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
suppress_verbose_help_message


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 573
 -- : VAL = suppress_verbose_help_message ()
 -- : OLD_VAL = suppress_verbose_help_message (NEW_VAL)
 -- : suppress_verbose_help_message (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will add additional help information to the end of the output from the ‘help’ command and usage messages for built-in commands.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
Query or set the internal variable that controls whether Octave will add additional help information to the end of the output from the ‘help’ command and usage messages for built-in commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
texi_macros_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 902
 -- : VAL = texi_macros_file ()
 -- : OLD_VAL = texi_macros_file (NEW_VAL)
 -- : texi_macros_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the file containing Texinfo macros that are prepended to documentation strings before they are passed to makeinfo.

     The default value is ‘OCTAVE-HOME/share/octave/VERSION/etc/macros.texi’, in which OCTAVE-HOME is the root directory of the Octave installation, and VERSION is the Octave version number.  The default value may be overridden by the environment variable ‘OCTAVE_TEXI_MACROS_FILE’, or the command line argument ‘--texi-macros-file FNAME’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: makeinfo_program.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
Query or set the internal variable that specifies the name of the file containing Texinfo macros that are prepended to documentation strings before they are passed to makeinfo.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 583
 -- : H = hess (A)
 -- : [P, H] = hess (A)
     Compute the Hessenberg decomposition of the matrix A.

     The Hessenberg decomposition is ‘P * H * P' = A’ where P is a square unitary matrix (‘P' * P = I’, using complex-conjugate transposition) and H is upper Hessenberg (‘H(i, j) = 0 forall i > j+1)’.

     The Hessenberg decomposition is usually used as the first step in an eigenvalue computation, but has other applications as well (see Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).

     See also: eig, chol, lu, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the Hessenberg decomposition of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hex2num


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1058
 -- : N = hex2num (S)
 -- : N = hex2num (S, CLASS)
     Typecast a hexadecimal character array or cell array of strings to an array of numbers.

     By default, the input array is interpreted as a hexadecimal number representing a double precision value.  If fewer than 16 characters are given the strings are right padded with ’0’ characters.

     Given a string matrix, ‘hex2num’ treats each row as a separate number.

          hex2num (["4005bf0a8b145769"; "4024000000000000"])
             ⇒ [2.7183; 10.000]

     The optional second argument CLASS may be used to cause the input array to be interpreted as a different value type.  Possible values are

     Option   Characters
     ----------------------
     "int8"   2
     "uint8"  2
     "int16"  4
     "uint16" 4
     "int32"  8
     "uint32" 8
     "int64"  16
     "uint64" 16
     "char"   2
     "single" 8
     "double" 16

     For example:

          hex2num (["402df854"; "41200000"], "single")
             ⇒ [2.7183; 10.000]

     See also: num2hex, hex2dec, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Typecast a hexadecimal character array or cell array of strings to an array of numbers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
num2hex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 711
 -- : S = num2hex (N)
 -- : S = num2hex (N, "cell")
     Convert a numeric array to an array of hexadecimal strings.

     For example:

          num2hex ([-1, 1, e, Inf])
          ⇒ "bff0000000000000
              3ff0000000000000
              4005bf0a8b145769
              7ff0000000000000"

     If the argument N is a single precision number or vector, the returned string has a length of 8.  For example:

          num2hex (single ([-1, 1, e, Inf]))
          ⇒ "bf800000
              3f800000
              402df854
              7f800000"

     With the optional second argument "cell", return a cell array of strings instead of a character array.

     See also: hex2num, hex2dec, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Convert a numeric array to an array of hexadecimal strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
input


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1071
 -- : ANS = input (PROMPT)
 -- : ANS = input (PROMPT, "s")
     Print PROMPT and wait for user input.

     For example,

          input ("Pick a number, any number! ")

     prints the prompt

          Pick a number, any number!

     and waits for the user to enter a value.  The string entered by the user is evaluated as an expression, so it may be a literal constant, a variable name, or any other valid Octave code.

     The number of return arguments, their size, and their class depend on the expression entered.

     If you are only interested in getting a literal string value, you can call ‘input’ with the character string "s" as the second argument.  This tells Octave to return the string entered by the user directly, without evaluating it first.

     Because there may be output waiting to be displayed by the pager, it is a good idea to always call ‘fflush (stdout)’ before calling ‘input’.  This will ensure that all pending output is written to the screen before your prompt.

     See also: yes_or_no, kbhit, pause, menu, listdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Print PROMPT and wait for user input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
yes_or_no


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 446
 -- : ANS = yes_or_no ("PROMPT")
     Ask the user a yes-or-no question.

     Return logical true if the answer is yes or false if the answer is no.

     Takes one argument, PROMPT, which is the string to display when asking the question.  PROMPT should end in a space; ‘yes-or-no’ adds the string ‘(yes or no) ’ to it.  The user must confirm the answer with <RET> and can edit it until it has been confirmed.

     See also: input.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Ask the user a yes-or-no question.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
keyboard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 666
 -- : keyboard ()
 -- : keyboard ("PROMPT")
     Stop m-file execution and enter debug mode.

     When the ‘keyboard’ function is executed, Octave prints a prompt and waits for user input.  The input strings are then evaluated and the results are printed.  This makes it possible to examine the values of variables within a function, and to assign new values if necessary.  To leave the prompt and return to normal execution type ‘return’ or ‘dbcont’.  The ‘keyboard’ function does not return an exit status.

     If ‘keyboard’ is invoked without arguments, a default prompt of ‘debug> ’ is used.

     See also: dbstop, dbcont, dbquit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Stop m-file execution and enter debug mode.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
completion_matches


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- : completion_matches (HINT)
     Generate possible completions given HINT.

     This function is provided for the benefit of programs like Emacs which might be controlling Octave and handling user input.  The current command number is not incremented when this function is called.  This is a feature, not a bug.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Generate possible completions given HINT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
readline_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 290
 -- : readline_read_init_file (FILE)
     Read the readline library initialization file FILE.

     If FILE is omitted, read the default initialization file (normally ‘~/.inputrc’).

     *Note (readline)Readline Init File::, for details.

     See also: readline_re_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Read the readline library initialization file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
readline_re_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- : readline_re_read_init_file ()
     Re-read the last readline library initialization file that was read.

     *Note (readline)Readline Init File::, for details.

     See also: readline_read_init_file.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Re-read the last readline library initialization file that was read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
add_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 505
 -- : ID = add_input_event_hook (FCN)
 -- : ID = add_input_event_hook (FCN, DATA)
     Add the named function or function handle FCN to the list of functions to call periodically when Octave is waiting for input.

     The function should have the form

          FCN (DATA)

     If DATA is omitted, Octave calls the function without any arguments.

     The returned identifier may be used to remove the function handle from the list of input hook functions.

     See also: remove_input_event_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Add the named function or function handle FCN to the list of functions to call periodically when Octave is waiting for input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
remove_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- : remove_input_event_hook (NAME)
 -- : remove_input_event_hook (FCN_ID)
     Remove the named function or function handle with the given identifier from the list of functions to call periodically when Octave is waiting for input.

     See also: add_input_event_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Remove the named function or function handle with the given identifier from the list of functions to call periodically when Octave is waiting for input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1104
 -- : VAL = PS1 ()
 -- : OLD_VAL = PS1 (NEW_VAL)
 -- : PS1 (NEW_VAL, "local")
     Query or set the primary prompt string.

     When executing interactively, Octave displays the primary prompt when it is ready to read a command.

     The default value of the primary prompt string is ’octave:\#> ’.  To change it, use a command like

          PS1 ("\\u@\\H> ")

     which will result in the prompt ‘boris@kremvax> ’ for the user ‘boris’ logged in on the host ‘kremvax.kgb.su’.  Note that two backslashes are required to enter a backslash into a double-quoted character string.  *Note Strings::.

     You can also use ANSI escape sequences if your terminal supports them.  This can be useful for coloring the prompt.  For example,

          PS1 ('\[\033[01;31m\]\s:\#> \[\033[0m\]')

     will give the default Octave prompt a red coloring.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: PS2, PS4.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Query or set the primary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690
 -- : VAL = PS2 ()
 -- : OLD_VAL = PS2 (NEW_VAL)
 -- : PS2 (NEW_VAL, "local")
     Query or set the secondary prompt string.

     The secondary prompt is printed when Octave is expecting additional input to complete a command.  For example, if you are typing a ‘for’ loop that spans several lines, Octave will print the secondary prompt at the beginning of each line after the first.  The default value of the secondary prompt string is "> ".

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: PS1, PS4.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set the secondary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
completion_append_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 515
 -- : VAL = completion_append_char ()
 -- : OLD_VAL = completion_append_char (NEW_VAL)
 -- : completion_append_char (NEW_VAL, "local")
     Query or set the internal character variable that is appended to successful command-line completion attempts.

     The default value is " " (a single space).

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Query or set the internal character variable that is appended to successful command-line completion attempts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 705
 -- : X = inv (A)
 -- : [X, RCOND] = inv (A)
     Compute the inverse of the square matrix A.

     Return an estimate of the reciprocal condition number if requested, otherwise warn of an ill-conditioned matrix if the reciprocal condition number is small.

     In general it is best to avoid calculating the inverse of a matrix directly.  For example, it is both faster and more accurate to solve systems of equations (A*x = b) with ‘Y = A \ b’, rather than ‘Y = inv (A) * b’.

     If called with a sparse matrix, then in general X will be a full matrix requiring significantly more storage.  Avoid forming the inverse of a sparse matrix if possible.

     See also: ldivide, rdivide, pinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute the inverse of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- : exit
 -- : exit (STATUS)
 -- : quit
 -- : quit (STATUS)
     Exit the current Octave session.

     If the optional integer value STATUS is supplied, pass that value to the operating system as Octave’s exit status.  The default value is zero.

     When exiting, Octave will attempt to run the m-file ‘finish.m’ if it exists.  User commands to save the workspace or clean up temporary files may be placed in that file.  Alternatively, another m-file may be scheduled to run using ‘atexit’.

     See also: atexit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Exit the current Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
atexit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 968
 -- : atexit (FCN)
 -- : atexit (FCN, FLAG)
     Register a function to be called when Octave exits.

     For example,

          function last_words ()
            disp ("Bye bye");
          endfunction
          atexit ("last_words");

     will print the message "Bye bye" when Octave exits.

     The additional argument FLAG will register or unregister FCN from the list of functions to be called when Octave exits.  If FLAG is true, the function is registered, and if FLAG is false, it is unregistered.  For example, after registering the function ‘last_words’ above,

          atexit ("last_words", false);

     will remove the function from the list and Octave will not call ‘last_words’ when it exits.

     Note that ‘atexit’ only removes the first occurrence of a function from the list, so if a function was placed in the list multiple times with ‘atexit’, it must also be removed from the list multiple times.

     See also: quit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Register a function to be called when Octave exits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kron


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 531
 -- : kron (A, B)
 -- : kron (A1, A2, ...)
     Form the Kronecker product of two or more matrices.

     This is defined block by block as

          x = [ a(i,j)*b ]

     For example:

          kron (1:4, ones (3, 1))
               ⇒  1  2  3  4
                   1  2  3  4
                   1  2  3  4

     If there are more than two input arguments A1, A2, ..., AN the Kronecker product is computed as

          kron (kron (A1, A2), ..., AN)

     Since the Kronecker product is associative, this is well-defined.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Form the Kronecker product of two or more matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
genpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- : genpath (DIR)
 -- : genpath (DIR, SKIP, ...)
     Return a path constructed from DIR and all its subdirectories.

     The path does not include package directories (beginning with ‘+’), old-style class directories (beginning with ‘@’), ‘private’ directories, or any subdirectories of these types.

     If additional string parameters are given, the resulting path will exclude directories with those names.

     See also: path, addpath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a path constructed from DIR and all its subdirectories.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rehash


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 -- : rehash ()
     Reinitialize Octave’s load path directory cache.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Reinitialize Octave’s load path directory cache.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
command_line_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- : command_line_path ()
     Return the command line path variable.

     See also: path, addpath, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the command line path variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
restoredefaultpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- : restoredefaultpath ()
     Restore Octave’s path to its initial state at startup.

     See also: path, addpath, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Restore Octave’s path to its initial state at startup.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 589
 -- : path ()
 -- : STR = path ()
 -- : STR = path (PATH1, ...)
     Modify or display Octave’s load path.

     If NARGIN and NARGOUT are zero, display the elements of Octave’s load path in an easy to read format.

     If NARGIN is zero and nargout is greater than zero, return the current load path.

     If NARGIN is greater than zero, concatenate the arguments, separating them with ‘pathsep’.  Set the internal search path to the result and return it.

     No checks are made for duplicate elements.

     See also: addpath, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Modify or display Octave’s load path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 789
 -- : addpath (DIR1, ...)
 -- : addpath (DIR1, ..., OPTION)
     Add named directories to the function search path.

     If OPTION is "-begin" or 0 (the default), prepend the directory name to the current path.  If OPTION is "-end" or 1, append the directory name to the current path.  Directories added to the path must exist.

     In addition to accepting individual directory arguments, lists of directory names separated by ‘pathsep’ are also accepted.  For example:

          addpath ("dir1:/dir2:~/dir3")

     For each directory that is added, and that was not already in the path, ‘addpath’ checks for the existence of a file named ‘PKG_ADD’ (note lack of .m extension) and runs it if it exists.

     See also: path, rmpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Add named directories to the function search path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rmpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- : rmpath (DIR1, ...)
     Remove DIR1, ... from the current function search path.

     In addition to accepting individual directory arguments, lists of directory names separated by ‘pathsep’ are also accepted.  For example:

          rmpath ("dir1:/dir2:~/dir3")

     For each directory that is removed, ‘rmpath’ checks for the existence of a file named ‘PKG_DEL’ (note lack of .m extension) and runs it if it exists.

     See also: path, addpath, genpath, pathdef, savepath, pathsep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
Remove DIR1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
load


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3648
 -- : load file
 -- : load options file
 -- : load options file v1 v2 ...
 -- : S = load ("options", "file", "v1", "v2", ...)
 -- : load file options
 -- : load file options v1 v2 ...
 -- : S = load ("file", "options", "v1", "v2", ...)
     Load the named variables V1, V2, ..., from the file FILE.

     If no variables are specified then all variables found in the file will be loaded.  As with ‘save’, the list of variables to extract can be full names or use a pattern syntax.  The format of the file is automatically detected but may be overridden by supplying the appropriate option.

     If load is invoked using the functional form

          load ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must be specified as character strings.

     If a variable that is not marked as global is loaded from a file when a global symbol with the same name already exists, it is loaded in the global symbol table.  Also, if a variable is marked as global in a file and a local symbol exists, the local symbol is moved to the global symbol table and given the value from the file.

     If invoked with a single output argument, Octave returns data instead of inserting variables in the symbol table.  If the data file contains only numbers (TAB- or space-delimited columns), a matrix of values is returned.  Otherwise, ‘load’ returns a structure with members corresponding to the names of the variables in the file.

     The ‘load’ command can read data stored in Octave’s text and binary formats, and MATLAB’s binary format.  If compiled with zlib support, it can also load gzip-compressed files.  It will automatically detect the type of file and do conversion from different floating point formats (currently only IEEE big and little endian, though other formats may be added in the future).

     Valid options for ‘load’ are listed in the following table.

     ‘-force’
          This option is accepted for backward compatibility but is ignored.  Octave now overwrites variables currently in memory with those of the same name found in the file.

     ‘-ascii’
          Force Octave to assume the file contains columns of numbers in text format without any header or other information.  Data in the file will be loaded as a single numeric matrix with the name of the variable derived from the name of the file.

     ‘-binary’
          Force Octave to assume the file is in Octave’s binary format.

     ‘-hdf5’
          Force Octave to assume the file is in HDF5 format.  (HDF5 is a free, portable binary format developed by the National Center for Supercomputing Applications at the University of Illinois.)  Note that Octave can read HDF5 files not created by itself, but may skip some datasets in formats that it cannot support.  This format is only available if Octave was built with a link to the HDF5 libraries.

     ‘-import’
          This option is accepted for backward compatibility but is ignored.  Octave can now support multi-dimensional HDF data and automatically modifies variable names if they are invalid Octave identifiers.

     ‘-mat’
     ‘-mat-binary’
     ‘-6’
     ‘-v6’
     ‘-7’
     ‘-v7’
          Force Octave to assume the file is in MATLAB’s version 6 or 7 binary format.

     ‘-mat4-binary’
     ‘-4’
     ‘-v4’
     ‘-V4’
          Force Octave to assume the file is in the binary format written by MATLAB version 4.

     ‘-text’
          Force Octave to assume the file is in Octave’s text format.

     See also: save, dlmwrite, csvwrite, fwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Load the named variables V1, V2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4717
 -- : save file
 -- : save options file
 -- : save options file V1 V2 ...
 -- : save options file -struct STRUCT
 -- : save options file -struct STRUCT F1 F2 ...
 -- : save - V1 V2 ...
 -- : STR = save ("-", "V1", "V2", ...)
     Save the named variables V1, V2, ..., in the file FILE.

     The special filename ‘-’ may be used to return the content of the variables as a string.  If no variable names are listed, Octave saves all the variables in the current scope.  Otherwise, full variable names or pattern syntax can be used to specify the variables to save.  If the ‘-struct’ modifier is used then the fields of the *scalar* struct are saved as if they were variables with the corresponding field names.  The ‘-struct’ option can be combined with specific field names F1, F2, ... to write only certain fields to the file.

     Valid options for the ‘save’ command are listed in the following table.  Options that modify the output format override the format specified by ‘save_default_options’.

     If save is invoked using the functional form

          save ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must be specified as character strings.

     If called with a filename of "-", write the output to stdout if nargout is 0, otherwise return the output in a character string.

     ‘-append’
          Append to the destination instead of overwriting.

     ‘-ascii’
          Save a matrix in a text file without a header or any other information.  The matrix must be 2-D and only the real part of any complex value is written to the file.  Numbers are stored in single-precision format and separated by spaces.  Additional options for the ‘-ascii’ format are

          ‘-double’
               Store numbers in double-precision format.

          ‘-tabs’
               Separate numbers with tabs.

     ‘-binary’
          Save the data in Octave’s binary data format.

     ‘-float-binary’
          Save the data in Octave’s binary data format but using only single precision.  Use this format *only* if you know that all the values to be saved can be represented in single precision.

     ‘-hdf5’
          Save the data in HDF5 format.  (HDF5 is a free, portable, binary format developed by the National Center for Supercomputing Applications at the University of Illinois.)  This format is only available if Octave was built with a link to the HDF5 libraries.

     ‘-float-hdf5’
          Save the data in HDF5 format but using only single precision.  Use this format *only* if you know that all the values to be saved can be represented in single precision.

     ‘-V7’
     ‘-v7’
     ‘-7’
     ‘-mat7-binary’
          Save the data in MATLAB’s v7 binary data format.

     ‘-V6’
     ‘-v6’
     ‘-6’
     ‘-mat’
     ‘-mat-binary’
          Save the data in MATLAB’s v6 binary data format.

     ‘-V4’
     ‘-v4’
     ‘-4’
     ‘-mat4-binary’
          Save the data in the binary format written by MATLAB version 4.

     ‘-text’
          Save the data in Octave’s text data format.  (default).

     ‘-zip’
     ‘-z’
          Use the gzip algorithm to compress the file.  This works on files that are compressed with gzip outside of Octave, and gzip can also be used to convert the files for backward compatibility.  This option is only available if Octave was built with a link to the zlib libraries.

     The list of variables to save may use wildcard patterns containing the following special characters:

     ‘?’
          Match any single character.

     ‘*’
          Match zero or more characters.

     ‘[ LIST ]’
          Match the list of characters specified by LIST.  If the first character is ‘!’ or ‘^’, match all characters except those specified by LIST.  For example, the pattern ‘[a-zA-Z]’ will match all lower and uppercase alphabetic characters.

          Wildcards may also be used in the field name specifications when using the ‘-struct’ modifier (but not in the struct name itself).

     Except when using the MATLAB binary data file format or the ‘-ascii’ format, saving global variables also saves the global status of the variable.  If the variable is restored at a later time using ‘load’, it will be restored as a global variable.

     The command

          save -binary data a b*

     saves the variable ‘a’ and all variables beginning with ‘b’ to the file ‘data’ in Octave’s binary format.

     See also: load, save_default_options, save_header_format_string, save_precision, dlmread, csvread, fread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Save the named variables V1, V2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
crash_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 648
 -- : VAL = crash_dumps_octave_core ()
 -- : OLD_VAL = crash_dumps_octave_core (NEW_VAL)
 -- : crash_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it crashes or receives a hangup, terminate or similar signal.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: octave_core_file_limit, octave_core_file_name, octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it crashes or receives a hangup, terminate or similar signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
save_default_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 689
 -- : VAL = save_default_options ()
 -- : OLD_VAL = save_default_options (NEW_VAL)
 -- : save_default_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the default options for the ‘save’ command, and defines the default format.

     The default value is "-text" (Octave’s own text-based file format).  See the documentation of the ‘save’ command for other choices.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: save, save_header_format_string, save_precision.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Query or set the internal variable that specifies the default options for the ‘save’ command, and defines the default format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
octave_core_file_limit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1001
 -- : VAL = octave_core_file_limit ()
 -- : OLD_VAL = octave_core_file_limit (NEW_VAL)
 -- : octave_core_file_limit (NEW_VAL, "local")
     Query or set the internal variable that specifies the maximum amount of memory that Octave will save when writing a crash dump file.

     The limit is measured in kilobytes and is applied to the top-level workspace.  The name of the crash dump file is specified by OCTAVE_CORE_FILE_NAME.

     If OCTAVE_CORE_FILE_OPTIONS flags specify a binary format, then OCTAVE_CORE_FILE_LIMIT will be approximately the maximum size of the file.  If a text file format is used, then the file could be much larger than the limit.  The default value is -1 (unlimited).

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: crash_dumps_octave_core, octave_core_file_name, octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Query or set the internal variable that specifies the maximum amount of memory that Octave will save when writing a crash dump file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
octave_core_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 628
 -- : VAL = octave_core_file_name ()
 -- : OLD_VAL = octave_core_file_name (NEW_VAL)
 -- : octave_core_file_name (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the file used for saving data from the top-level workspace if Octave aborts.

     The default value is "octave-workspace"

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: crash_dumps_octave_core, octave_core_file_name, octave_core_file_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
Query or set the internal variable that specifies the name of the file used for saving data from the top-level workspace if Octave aborts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
octave_core_file_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- : VAL = octave_core_file_options ()
 -- : OLD_VAL = octave_core_file_options (NEW_VAL)
 -- : octave_core_file_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the options used for saving the workspace data if Octave aborts.

     The value of ‘octave_core_file_options’ should follow the same format as the options for the ‘save’ function.  The default value is Octave’s binary format.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Query or set the internal variable that specifies the options used for saving the workspace data if Octave aborts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
save_header_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 933
 -- : VAL = save_header_format_string ()
 -- : OLD_VAL = save_header_format_string (NEW_VAL)
 -- : save_header_format_string (NEW_VAL, "local")
     Query or set the internal variable that specifies the format string used for the comment line written at the beginning of text-format data files saved by Octave.

     The format string is passed to ‘strftime’ and must begin with the character ‘#’ and contain no newline characters.  If the value of ‘save_header_format_string’ is the empty string, the header comment is omitted from text-format data files.  The default value is

          "# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: strftime, save_default_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
Query or set the internal variable that specifies the format string used for the comment line written at the beginning of text-format data files saved by Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lookup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1721
 -- : IDX = lookup (TABLE, Y)
 -- : IDX = lookup (TABLE, Y, OPT)
     Lookup values in a *sorted* table.

     This function is usually used as a prelude to interpolation.

     If table is increasing, of length N and ‘idx = lookup (table, y)’, then ‘table(idx(i)) <= y(i) < table(idx(i+1))’ for all ‘y(i)’ within the table.  If ‘y(i) < table(1)’ then ‘idx(i)’ is 0.  If ‘y(i) >= table(end)’ or ‘isnan (y(i))’ then ‘idx(i)’ is N.

     If the table is decreasing, then the tests are reversed.  For non-strictly monotonic tables, empty intervals are always skipped.  The result is undefined if TABLE is not monotonic, or if TABLE contains a NaN.

     The complexity of the lookup is O(M*log(N)) where M is the size of Y.  In the special case when Y is also sorted, the complexity is O(min (M*log(N), M+N)).

     TABLE and Y can also be cell arrays of strings (or Y can be a single string).  In this case, string lookup is performed using lexicographical comparison.

     If OPTS is specified, it must be a string with letters indicating additional options.

     ‘m’
          Match.  ‘table(idx(i)) == y(i)’ if ‘y(i)’ occurs in table; otherwise, ‘idx(i)’ is zero.

     ‘b’
          Boolean.  ‘idx(i)’ is a logical 1 or 0, indicating whether ‘y(i)’ is contained in table or not.

     ‘l’
          Left.  For numeric lookups the leftmost subinterval shall be extended to minus infinity (i.e., all indices at least 1).

     ‘r’
          Right.  For numeric lookups the rightmost subinterval shall be extended to infinity (i.e., all indices at most N-1).

     *Note*: If TABLE is not sorted the results from ‘lookup’ will be unpredictable.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Lookup values in a *sorted* table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
save_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808
 -- : VAL = save_precision ()
 -- : OLD_VAL = save_precision (NEW_VAL)
 -- : save_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of digits to keep when saving data in text format.

     The default value is 17 which is the minimum necessary for the lossless saving and restoring of IEEE-754 double values; For IEEE-754 single values the minimum value is 9.  If file size is a concern, it is probably better to choose a binary format for saving data rather than to reduce the precision of the saved values.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: save_default_options.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the internal variable that specifies the number of digits to keep when saving data in text format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lsode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2729
 -- : [X, ISTATE, MSG] = lsode (FCN, X_0, T)
 -- : [X, ISTATE, MSG] = lsode (FCN, X_0, T, T_CRIT)
     Ordinary Differential Equation (ODE) solver.

     The set of differential equations to solve is

          dx
          -- = f (x, t)
          dt

     with

          x(t_0) = x_0

     The solution is returned in the matrix X, with each row corresponding to an element of the vector T.  The first element of T should be t_0 and should correspond to the initial state of the system X_0, so that the first row of the output is X_0.

     The first argument, FCN, is a string, inline, or function handle that names the function f to call to compute the vector of right hand sides for the set of equations.  The function must have the form

          XDOT = f (X, T)

     in which XDOT and X are vectors and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of strings, inline functions, or function handles, the first element names the function f described above, and the second element names a function to compute the Jacobian of f.  The Jacobian function must have the form

          JAC = j (X, T)

     in which JAC is the matrix of partial derivatives

                       | df_1  df_1       df_1 |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |
                       |                       |
                       | df_2  df_2       df_2 |
                       | ----  ----  ...  ---- |
                df_i   | dx_1  dx_2       dx_N |
          jac = ---- = |                       |
                dx_j   |  .    .     .    .    |
                       |  .    .      .   .    |
                       |  .    .       .  .    |
                       |                       |
                       | df_N  df_N       df_N |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |

     The second argument specifies the initial state of the system x_0.  The third argument is a vector, T, specifying the time values for which a solution is sought.

     The fourth argument is optional, and may be used to specify a set of times that the ODE solver should not integrate past.  It is useful for avoiding difficulties with singularities and points where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be 2 (consistent with the Fortran version of LSODE).

     If the computation is not successful, ISTATE will be something other than 2 and MSG will contain additional information.

     You can use the function ‘lsode_options’ to set optional parameters for ‘lsode’.

     See also: daspk, dassl, dasrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Ordinary Differential Equation (ODE) solver.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2498
 -- : [L, U] = lu (A)
 -- : [L, U, P] = lu (A)
 -- : [L, U, P, Q] = lu (S)
 -- : [L, U, P, Q, R] = lu (S)
 -- : [...] = lu (S, THRES)
 -- : Y = lu (...)
 -- : [...] = lu (..., "vector")
     Compute the LU decomposition of A.

     If A is full then subroutines from LAPACK are used, and if A is sparse then UMFPACK is used.

     The result is returned in a permuted form, according to the optional return value P.  For example, given the matrix ‘a = [1, 2; 3, 4]’,

          [l, u, p] = lu (A)

     returns

          l =

            1.00000  0.00000
            0.33333  1.00000

          u =

            3.00000  4.00000
            0.00000  0.66667

          p =

            0  1
            1  0

     The matrix is not required to be square.

     When called with two or three output arguments and a sparse input matrix, ‘lu’ does not attempt to perform sparsity preserving column permutations.  Called with a fourth output argument, the sparsity preserving column transformation Q is returned, such that ‘P * A * Q = L * U’.  This is the *preferred* way to call ‘lu’ with sparse input matrices.

     Called with a fifth output argument and a sparse input matrix, ‘lu’ attempts to use a scaling factor R on the input matrix such that ‘P * (R \ A) * Q = L * U’.  This typically leads to a sparser and more stable factorization.

     An additional input argument THRES, that defines the pivoting threshold can be given.  THRES can be a scalar, in which case it defines the UMFPACK pivoting tolerance for both symmetric and unsymmetric cases.  If THRES is a 2-element vector, then the first element defines the pivoting tolerance for the unsymmetric UMFPACK pivoting strategy and the second for the symmetric strategy.  By default, the values defined by ‘spparms’ are used ([0.1, 0.001]).

     Given the string argument "vector", ‘lu’ returns the values of P and Q as vector values, such that for full matrix, ‘A(P,:) = L * U’, and ‘R(P,:) * A(:,Q) = L * U’.

     With two output arguments, returns the permuted forms of the upper and lower triangular matrices, such that ‘A = L * U’.  With one output argument Y, then the matrix returned by the LAPACK routines is returned.  If the input matrix is sparse then the matrix L is embedded into U to give a return value similar to the full case.  For both full and sparse matrices, ‘lu’ loses the permutation information.

     See also: luupdate, ilu, chol, hess, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute the LU decomposition of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
luupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1154
 -- : [L, U] = luupdate (L, U, X, Y)
 -- : [L, U, P] = luupdate (L, U, P, X, Y)
     Given an LU factorization of a real or complex matrix A = L*U, L lower unit trapezoidal and U upper trapezoidal, return the LU factorization of A + X*Y.’, where X and Y are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update).

     Optionally, row-pivoted updating can be used by supplying a row permutation (pivoting) matrix P; in that case, an updated permutation matrix is returned.  Note that if L, U, P is a pivoted LU factorization as obtained by ‘lu’:

          [L, U, P] = lu (A);

     then a factorization of A+X*Y.’ can be obtained either as

          [L1, U1] = lu (L, U, P*X, Y)

     or

          [L1, U1, P1] = lu (L, U, P, X, Y)

     The first form uses the unpivoted algorithm, which is faster, but less stable.  The second form uses a slower pivoted algorithm, which is more stable.

     The matrix case is done as a sequence of rank-1 updates; thus, for large enough k, it will be both faster and more accurate to recompute the factorization from scratch.

     See also: lu, cholupdate, qrupdate.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
Given an LU factorization of a real or complex matrix A = L*U, L lower unit trapezoidal and U upper trapezoidal, return the LU factorization of A + X*Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
abs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- : abs (Z)
     Compute the magnitude of Z.

     The magnitude is defined as |Z| = ‘sqrt (x^2 + y^2)’.

     For example:

          abs (3 + 4i)
               ⇒ 5

     See also: arg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the magnitude of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- : acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: cos, acosd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse cosine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- : acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
angle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 -- : angle (Z)
     See ‘arg’.

     See also: arg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
See ‘arg’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
arg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 235
 -- : arg (Z)
 -- : angle (Z)
     Compute the argument, i.e., angle of Z.

     This is defined as, THETA = ‘atan2 (Y, X)’, in radians.

     For example:

          arg (3 + 4i)
               ⇒ 0.92730

     See also: abs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Compute the argument, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- : asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: sin, asind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse sine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- : asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: sinh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
atan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: tan, atand.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse tangent in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- : atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cbrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- : cbrt (X)
     Compute the real cube root of each element of X.

     Unlike ‘X^(1/3)’, the result will be negative if X is negative.

     See also: nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the real cube root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ceil


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- : ceil (X)
     Return the smallest integer not less than X.

     This is equivalent to rounding towards positive infinity.

     If X is complex, return ‘ceil (real (X)) + ceil (imag (X)) * I’.

          ceil ([-2.7, 2.7])
              ⇒ -2    3

     See also: floor, round, fix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the smallest integer not less than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
conj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- : conj (Z)
     Return the complex conjugate of Z.

     The complex conjugate is defined as ‘conj (Z)’ = X - IY.

     See also: real, imag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the complex conjugate of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : cos (X)
     Compute the cosine for each element of X in radians.

     See also: acos, cosd, cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the cosine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- : cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: acosh, sinh, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
erf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- : erf (Z)
     Compute the error function.

     The error function is defined as

                                  z
                        2        /
          erf (z) = --------- *  | e^(-t^2) dt
                    sqrt (pi)    /
                              t=0

     See also: erfc, erfcx, erfi, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
erfinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- : erfinv (X)
     Compute the inverse error function.

     The inverse error function is defined such that

          erf (Y) == X

     See also: erf, erfc, erfcx, erfi, dawson, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute the inverse error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
erfcinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- : erfcinv (X)
     Compute the inverse complementary error function.

     The inverse complementary error function is defined such that

          erfc (Y) == X

     See also: erfc, erf, erfcx, erfi, dawson, erfinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the inverse complementary error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- : erfc (Z)
     Compute the complementary error function.

     The complementary error function is defined as ‘1 - erf (Z)’.

     See also: erfcinv, erfcx, erfi, dawson, erf, erfinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Compute the complementary error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
erfcx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- : erfcx (Z)
     Compute the scaled complementary error function.

     The scaled complementary error function is defined as

          exp (z^2) * erfc (z)

     See also: erfc, erf, erfi, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the scaled complementary error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
 -- : erfi (Z)
     Compute the imaginary error function.

     The imaginary error function is defined as

          -i * erf (i*z)

     See also: erfc, erf, erfcx, dawson, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the imaginary error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dawson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- : dawson (Z)
     Compute the Dawson (scaled imaginary error) function.

     The Dawson function is defined as

          (sqrt (pi) / 2) * exp (-z^2) * erfi (z)

     See also: erfc, erf, erfcx, erfi, erfinv, erfcinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the Dawson (scaled imaginary error) function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
exp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- : exp (X)
     Compute ‘e^x’ for each element of X.

     To compute the matrix exponential, see *note Linear Algebra::.

     See also: log.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Compute ‘e^x’ for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
expm1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- : expm1 (X)
     Compute ‘exp (X) - 1’ accurately in the neighborhood of zero.

     See also: exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compute ‘exp (X) - 1’ accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isfinite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- : isfinite (X)
     Return a logical array which is true where the elements of X are finite values and false where they are not.

     For example:

          isfinite ([13, Inf, NA, NaN])
               ⇒ [ 1, 0, 0, 0 ]

     See also: isinf, isnan, isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a logical array which is true where the elements of X are finite values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 296
 -- : fix (X)
     Truncate fractional portion of X and return the integer portion.

     This is equivalent to rounding towards zero.  If X is complex, return ‘fix (real (X)) + fix (imag (X)) * I’.

          fix ([-2.7, 2.7])
             ⇒ -2    2

     See also: ceil, floor, round.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Truncate fractional portion of X and return the integer portion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
floor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- : floor (X)
     Return the largest integer not greater than X.

     This is equivalent to rounding towards negative infinity.  If X is complex, return ‘floor (real (X)) + floor (imag (X)) * I’.

          floor ([-2.7, 2.7])
               ⇒ -3    2

     See also: ceil, round, fix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the largest integer not greater than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 589
 -- : gamma (Z)
     Compute the Gamma function.

     The Gamma function is defined as

                       infinity
                      /
          gamma (z) = | t^(z-1) exp (-t) dt.
                      /
                   t=0

     Programming Note: The gamma function can grow quite large even for small input values.  In many cases it may be preferable to use the natural logarithm of the gamma function (‘gammaln’) in calculations to minimize loss of precision.  The final result is then ‘exp (RESULT_USING_GAMMALN).’

     See also: gammainc, gammaln, factorial.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the Gamma function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
imag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- : imag (Z)
     Return the imaginary part of Z as a real number.

     See also: real, conj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the imaginary part of Z as a real number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalnum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 263
 -- : isalnum (S)
     Return a logical array which is true where the elements of S are letters or digits and false where they are not.

     This is equivalent to (‘isalpha (S) | isdigit (S)’).

     See also: isalpha, isdigit, ispunct, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return a logical array which is true where the elements of S are letters or digits and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalpha


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- : isalpha (S)
     Return a logical array which is true where the elements of S are letters and false where they are not.

     This is equivalent to (‘islower (S) | isupper (S)’).

     See also: isdigit, ispunct, isspace, iscntrl, isalnum, islower, isupper.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Return a logical array which is true where the elements of S are letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 170
 -- : isascii (S)
     Return a logical array which is true where the elements of S are ASCII characters (in the range 0 to 127 decimal) and false where they are not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Return a logical array which is true where the elements of S are ASCII characters (in the range 0 to 127 decimal) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
iscntrl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- : iscntrl (S)
     Return a logical array which is true where the elements of S are control characters and false where they are not.

     See also: ispunct, isspace, isalpha, isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Return a logical array which is true where the elements of S are control characters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- : isdigit (S)
     Return a logical array which is true where the elements of S are decimal digits (0-9) and false where they are not.

     See also: isxdigit, isalpha, isletter, ispunct, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
Return a logical array which is true where the elements of S are decimal digits (0-9) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isinf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- : isinf (X)
     Return a logical array which is true where the elements of X are infinite and false where they are not.

     For example:

          isinf ([13, Inf, NA, NaN])
                ⇒ [ 0, 1, 0, 0 ]

     See also: isfinite, isnan, isna.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return a logical array which is true where the elements of X are infinite and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isgraph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- : isgraph (S)
     Return a logical array which is true where the elements of S are printable characters (but not the space character) and false where they are not.

     See also: isprint.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Return a logical array which is true where the elements of S are printable characters (but not the space character) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
islower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- : islower (S)
     Return a logical array which is true where the elements of S are lowercase letters and false where they are not.

     See also: isupper, isalpha, isletter, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return a logical array which is true where the elements of S are lowercase letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
isna


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- : isna (X)
     Return a logical array which is true where the elements of X are NA (missing) values and false where they are not.

     For example:

          isna ([13, Inf, NA, NaN])
               ⇒ [ 0, 0, 1, 0 ]

     See also: isnan, isinf, isfinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Return a logical array which is true where the elements of X are NA (missing) values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isnan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 304
 -- : isnan (X)
     Return a logical array which is true where the elements of X are NaN values and false where they are not.

     NA values are also considered NaN values.  For example:

          isnan ([13, Inf, NA, NaN])
                ⇒ [ 0, 0, 1, 1 ]

     See also: isna, isinf, isfinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Return a logical array which is true where the elements of X are NaN values and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- : isprint (S)
     Return a logical array which is true where the elements of S are printable characters (including the space character) and false where they are not.

     See also: isgraph.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
Return a logical array which is true where the elements of S are printable characters (including the space character) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ispunct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- : ispunct (S)
     Return a logical array which is true where the elements of S are punctuation characters and false where they are not.

     See also: isalpha, isdigit, isspace, iscntrl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Return a logical array which is true where the elements of S are punctuation characters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 262
 -- : isspace (S)
     Return a logical array which is true where the elements of S are whitespace characters (space, formfeed, newline, carriage return, tab, and vertical tab) and false where they are not.

     See also: iscntrl, ispunct, isalpha, isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
Return a logical array which is true where the elements of S are whitespace characters (space, formfeed, newline, carriage return, tab, and vertical tab) and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- : isupper (S)
     Return a logical array which is true where the elements of S are uppercase letters and false where they are not.

     See also: islower, isalpha, isletter, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Return a logical array which is true where the elements of S are uppercase letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isxdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 154
 -- : isxdigit (S)
     Return a logical array which is true where the elements of S are hexadecimal digits (0-9 and a-fA-F).

     See also: isdigit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Return a logical array which is true where the elements of S are hexadecimal digits (0-9 and a-fA-F).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lgamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- : gammaln (X)
 -- : lgamma (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the natural logarithm of the gamma function of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
log


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- : log (X)
     Compute the natural logarithm, ‘ln (X)’, for each element of X.

     To compute the matrix logarithm, see *note Linear Algebra::.

     See also: exp, log1p, log2, log10, logspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Compute the natural logarithm, ‘ln (X)’, for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log10


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
 -- : log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: log, log2, logspace, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the base-10 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log1p


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : log1p (X)
     Compute ‘log (1 + X)’ accurately in the neighborhood of zero.

     See also: log, exp, expm1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compute ‘log (1 + X)’ accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
real


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- : real (Z)
     Return the real part of Z.

     See also: imag, conj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the real part of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
round


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- : round (X)
     Return the integer nearest to X.

     If X is complex, return ‘round (real (X)) + round (imag (X)) * I’.  If there are two nearest integers, return the one further away from zero.

          round ([-2.7, 2.7])
               ⇒ -3    3

     See also: ceil, floor, fix, roundb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
roundb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 239
 -- : roundb (X)
     Return the integer nearest to X.  If there are two nearest integers, return the even one (banker’s rounding).

     If X is complex, return ‘roundb (real (X)) + roundb (imag (X)) * I’.

     See also: round.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sign


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- : sign (X)
     Compute the “signum” function.

     This is defined as

                     -1, x < 0;
          sign (x) =  0, x = 0;
                      1, x > 0.

     For complex arguments, ‘sign’ returns ‘x ./ abs (X)’.

     Note that ‘sign (-0.0)’ is 0.  Although IEEE 754 floating point allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test whether zero is signed, use the ‘signbit’ function.

     See also: signbit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute the “signum” function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
signbit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 522
 -- : signbit (X)
     Return logical true if the value of X has its sign bit set and false otherwise.

     This behavior is consistent with the other logical functions.  See *note Logical Values::.  The behavior differs from the C language function which returns nonzero if the sign bit is set.

     This is not the same as ‘x < 0.0’, because IEEE 754 floating point allows zero to be signed.  The comparison ‘-0.0 < 0.0’ is false, but ‘signbit (-0.0)’ will return a nonzero value.

     See also: sign.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return logical true if the value of X has its sign bit set and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- : sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: asinh, cosh, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sqrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- : sqrt (X)
     Compute the square root of each element of X.

     If X is negative, a complex result is returned.

     To compute the matrix square root, see *note Linear Algebra::.

     See also: realsqrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Compute the square root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- : tan (Z)
     Compute the tangent for each element of X in radians.

     See also: atan, tand, tanh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the tangent for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- : tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: atanh, sinh, cosh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tolower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- : tolower (S)
 -- : lower (S)
     Return a copy of the string or cell string S, with each uppercase character replaced by the corresponding lowercase one; non-alphabetic characters are left unchanged.

     For example:

          tolower ("MiXeD cAsE 123")
                ⇒ "mixed case 123"

     See also: toupper.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
Return a copy of the string or cell string S, with each uppercase character replaced by the corresponding lowercase one; non-alphabetic characters are left unchanged.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- : toupper (S)
 -- : upper (S)
     Return a copy of the string or cell string S, with each lowercase character replaced by the corresponding uppercase one; non-alphabetic characters are left unchanged.

     For example:

          toupper ("MiXeD cAsE 123")
                ⇒ "MIXED CASE 123"

     See also: tolower.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
Return a copy of the string or cell string S, with each lowercase character replaced by the corresponding uppercase one; non-alphabetic characters are left unchanged.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
matrix_type


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3072
 -- : TYPE = matrix_type (A)
 -- : TYPE = matrix_type (A, "nocompute")
 -- : A = matrix_type (A, TYPE)
 -- : A = matrix_type (A, "upper", PERM)
 -- : A = matrix_type (A, "lower", PERM)
 -- : A = matrix_type (A, "banded", NL, NU)
     Identify the matrix type or mark a matrix as a particular type.

     This allows more rapid solutions of linear equations involving A to be performed.

     Called with a single argument, ‘matrix_type’ returns the type of the matrix and caches it for future use.

     Called with more than one argument, ‘matrix_type’ allows the type of the matrix to be defined.

     If the option "nocompute" is given, the function will not attempt to guess the type if it is still unknown.  This is useful for debugging purposes.

     The possible matrix types depend on whether the matrix is full or sparse, and can be one of the following

     "unknown"
          Remove any previously cached matrix type, and mark type as unknown.

     "full"
          Mark the matrix as full.

     "positive definite"
          Probable full positive definite matrix.

     "diagonal"
          Diagonal matrix.  (Sparse matrices only)

     "permuted diagonal"
          Permuted Diagonal matrix.  The permutation does not need to be specifically indicated, as the structure of the matrix explicitly gives this.  (Sparse matrices only)

     "upper"
          Upper triangular.  If the optional third argument PERM is given, the matrix is assumed to be a permuted upper triangular with the permutations defined by the vector PERM.

     "lower"
          Lower triangular.  If the optional third argument PERM is given, the matrix is assumed to be a permuted lower triangular with the permutations defined by the vector PERM.

     "banded"
     "banded positive definite"
          Banded matrix with the band size of NL below the diagonal and NU above it.  If NL and NU are 1, then the matrix is tridiagonal and treated with specialized code.  In addition the matrix can be marked as probably a positive definite.  (Sparse matrices only)

     "singular"
          The matrix is assumed to be singular and will be treated with a minimum norm solution.

     Note that the matrix type will be discovered automatically on the first attempt to solve a linear equation involving A.  Therefore ‘matrix_type’ is only useful to give Octave hints of the matrix type.  Incorrectly defining the matrix type will result in incorrect results from solutions of linear equations; it is entirely *the responsibility of the user* to correctly identify the matrix type.

     Also, the test for positive definiteness is a low-cost test for a Hermitian matrix with a real positive diagonal.  This does not guarantee that the matrix is positive definite, but only that it is a probable candidate.  When such a matrix is factorized, a Cholesky factorization is first attempted, and if that fails the matrix is then treated with an LU factorization.  Once the matrix has been factorized, ‘matrix_type’ will return the correct classification of the matrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Identify the matrix type or mark a matrix as a particular type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
min


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1489
 -- : min (X)
 -- : min (X, [], DIM)
 -- : [W, IW] = min (X)
 -- : min (X, Y)
     Find minimum values in the array X.

     For a vector argument, return the minimum value.  For a matrix argument, return a row vector with the minimum value of each column.  For a multi-dimensional array, ‘min’ operates along the first non-singleton dimension.

     If the optional third argument DIM is present then operate along this dimension.  In this case the second argument is ignored and should be set to the empty matrix.

     For two matrices (or a matrix and a scalar), return the pairwise minimum.

     Thus,

          min (min (X))

     returns the smallest element of the 2-D matrix X, and

          min (2:5, pi)
              ⇒  2.0000  3.0000  3.1416  3.1416

     compares each element of the range ‘2:5’ with ‘pi’, and returns a row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for comparison.  If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi].  Hence,

          min ([-1 i 1 -i])
              ⇒ -i

     because all entries have magnitude 1, but -i has the smallest phase angle with value -pi/2.

     If called with one input and two output arguments, ‘min’ also returns the first index of the minimum value(s).  Thus,

          [x, ix] = min ([1, 3, 0, 2, 0])
              ⇒  x = 0
                  ix = 3

     See also: max, cummin, cummax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Find minimum values in the array X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
max


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1484
 -- : max (X)
 -- : max (X, [], DIM)
 -- : [W, IW] = max (X)
 -- : max (X, Y)
     Find maximum values in the array X.

     For a vector argument, return the maximum value.  For a matrix argument, return a row vector with the maximum value of each column.  For a multi-dimensional array, ‘max’ operates along the first non-singleton dimension.

     If the optional third argument DIM is present then operate along this dimension.  In this case the second argument is ignored and should be set to the empty matrix.

     For two matrices (or a matrix and a scalar), return the pairwise maximum.

     Thus,

          max (max (X))

     returns the largest element of the 2-D matrix X, and

          max (2:5, pi)
              ⇒  3.1416  3.1416  4.0000  5.0000

     compares each element of the range ‘2:5’ with ‘pi’, and returns a row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for comparison.  If the magnitudes are identical, then the results are ordered by phase angle in the range (-pi, pi].  Hence,

          max ([-1 i 1 -i])
              ⇒ -1

     because all entries have magnitude 1, but -1 has the largest phase angle with value pi.

     If called with one input and two output arguments, ‘max’ also returns the first index of the maximum value(s).  Thus,

          [x, ix] = max ([1, 3, 5, 2, 5])
              ⇒  x = 5
                  ix = 3

     See also: min, cummax, cummin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Find maximum values in the array X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 528
 -- : cummin (X)
 -- : cummin (X, DIM)
 -- : [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For example:

          cummin ([5 4 6 2 3 1])
             ⇒  5  4  4  2  2  1

     If called with two output arguments the index of the minimum value is also returned.

          [w, iw] = cummin ([5 4 6 2 3 1])
          ⇒
          w =  5  4  4  2  2  1
          iw = 1  2  2  4  4  6

     See also: cummax, min, max.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative minimum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- : cummax (X)
 -- : cummax (X, DIM)
 -- : [W, IW] = cummax (...)
     Return the cumulative maximum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For example:

          cummax ([1 3 2 6 4 5])
             ⇒  1  3  3  6  6  6

     If called with two output arguments the index of the maximum value is also returned.

          [w, iw] = cummax ([1 3 2 6 4 5])
          ⇒
          w =  1  3  3  6  6  6
          iw = 1  2  2  4  4  4

     See also: cummin, max, min.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative maximum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mgorth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- : [Y, H] = mgorth (X, V)
     Orthogonalize a given column vector X with respect to a set of orthonormal vectors comprising the columns of V using the modified Gram-Schmidt method.

     On exit, Y is a unit vector such that:

            norm (Y) = 1
            V' * Y = 0
            X = [V, Y]*H'

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
Orthogonalize a given column vector X with respect to a set of orthonormal vectors comprising the columns of V using the modified Gram-Schmidt method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 448
 -- : nproc ()
 -- : nproc (QUERY)
     Return the current number of available processors.

     If called with the optional argument QUERY, modify how processors are counted as follows:

     ‘all’
          total number of processors.

     ‘current’
          processors available to the current process.

     ‘overridable’
          same as ‘current’, but overridable through the ‘OMP_NUM_THREADS’ environment variable.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return the current number of available processors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
edit_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1274
 -- : edit_history
 -- : edit_history CMD_NUMBER
 -- : edit_history FIRST LAST
     Edit the history list using the editor named by the variable ‘EDITOR’.

     The commands to be edited are first copied to a temporary file.  When you exit the editor, Octave executes the commands that remain in the file.  It is often more convenient to use ‘edit_history’ to define functions rather than attempting to enter them directly on the command line.  The block of commands is executed as soon as you exit the editor.  To avoid executing any commands, simply delete all the lines from the buffer before leaving the editor.

     When invoked with no arguments, edit the previously executed command; With one argument, edit the specified command CMD_NUMBER; With two arguments, edit the list of commands between FIRST and LAST.  Command number specifiers may also be negative where -1 refers to the most recently executed command.  The following are equivalent and edit the most recently executed command.

          edit_history
          edit_history -1

     When using ranges, specifying a larger number for the first command than the last command reverses the list of commands before they are placed in the buffer to be edited.

     See also: run_history, history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Edit the history list using the editor named by the variable ‘EDITOR’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1185
 -- : history
 -- : history OPT1 ...
 -- : H = history ()
 -- : H = history (OPT1, ...)
     If invoked with no arguments, ‘history’ displays a list of commands that you have executed.

     Valid options are:

     ‘N’
     ‘-N’
          Display only the most recent N lines of history.

     ‘-c’
          Clear the history list.

     ‘-q’
          Don’t number the displayed lines of history.  This is useful for cutting and pasting commands using the X Window System.

     ‘-r FILE’
          Read the file FILE, appending its contents to the current history list.  If the name is omitted, use the default history file (normally ‘~/.octave_hist’).

     ‘-w FILE’
          Write the current history to the file FILE.  If the name is omitted, use the default history file (normally ‘~/.octave_hist’).

     For example, to display the five most recent commands that you have typed without displaying line numbers, use the command ‘history -q 5’.

     If invoked with a single output argument, the history will be saved to that argument as a cell string and will not be output to screen.

     See also: edit_history, run_history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
If invoked with no arguments, ‘history’ displays a list of commands that you have executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
run_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 947
 -- : run_history
 -- : run_history CMD_NUMBER
 -- : run_history FIRST LAST
     Run commands from the history list.

     When invoked with no arguments, run the previously executed command;

     With one argument, run the specified command CMD_NUMBER;

     With two arguments, run the list of commands between FIRST and LAST.  Command number specifiers may also be negative where -1 refers to the most recently executed command.  For example, the command

          run_history
               OR
          run_history -1

     executes the most recent command again.  The command

          run_history 13 169

     executes commands 13 through 169.

     Specifying a larger number for the first command than the last command reverses the list of commands before executing them.  For example:

          disp (1)
          disp (2)
          run_history -1 -2
          ⇒
           2
           1

     See also: edit_history, history.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Run commands from the history list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
history_control


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1160
 -- : VAL = history_control ()
 -- : OLD_VAL = history_control (NEW_VAL)
     Query or set the internal variable that specifies how commands are saved to the history list.

     The default value is an empty character string, but may be overridden by the environment variable ‘OCTAVE_HISTCONTROL’.

     The value of ‘history_control’ is a colon-separated list of values controlling how commands are saved on the history list.  If the list of values includes ‘ignorespace’, lines which begin with a space character are not saved in the history list.  A value of ‘ignoredups’ causes lines matching the previous history entry to not be saved.  A value of ‘ignoreboth’ is shorthand for ‘ignorespace’ and ‘ignoredups’.  A value of ‘erasedups’ causes all previous lines matching the current line to be removed from the history list before that line is saved.  Any value not in the above list is ignored.  If ‘history_control’ is the empty string, all commands are saved on the history list, subject to the value of ‘history_save’.

     See also: history_file, history_size, history_timestamp_format_string, history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Query or set the internal variable that specifies how commands are saved to the history list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 361
 -- : VAL = history_size ()
 -- : OLD_VAL = history_size (NEW_VAL)
     Query or set the internal variable that specifies how many entries to store in the history file.

     The default value is ‘1000’, but may be overridden by the environment variable ‘OCTAVE_HISTSIZE’.

     See also: history_file, history_timestamp_format_string, history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Query or set the internal variable that specifies how many entries to store in the history file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 376
 -- : VAL = history_file ()
 -- : OLD_VAL = history_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the file used to store command history.

     The default value is ‘~/.octave_hist’, but may be overridden by the environment variable ‘OCTAVE_HISTFILE’.

     See also: history_size, history_save, history_timestamp_format_string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Query or set the internal variable that specifies the name of the file used to store command history.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
history_timestamp_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- : VAL = history_timestamp_format_string ()
 -- : OLD_VAL = history_timestamp_format_string (NEW_VAL)
 -- : history_timestamp_format_string (NEW_VAL, "local")
     Query or set the internal variable that specifies the format string for the comment line that is written to the history file when Octave exits.

     The format string is passed to ‘strftime’.  The default value is

          "# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: strftime, history_file, history_size, history_save.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Query or set the internal variable that specifies the format string for the comment line that is written to the history file when Octave exits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 545
 -- : VAL = history_save ()
 -- : OLD_VAL = history_save (NEW_VAL)
 -- : history_save (NEW_VAL, "local")
     Query or set the internal variable that controls whether commands entered on the command line are saved in the history file.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: history_control, history_file, history_size, history_timestamp_format_string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
Query or set the internal variable that controls whether commands entered on the command line are saved in the history file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
openvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
 -- : openvar (NAME)
     Open the variable NAME in the graphical Variable Editor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Open the variable NAME in the graphical Variable Editor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ordschur


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 827
 -- : [UR, SR] = ordschur (U, S, SELECT)
     Reorders the real Schur factorization (U,S) obtained with the ‘schur’ function, so that selected eigenvalues appear in the upper left diagonal blocks of the quasi triangular Schur matrix.

     The logical vector SELECT specifies the selected eigenvalues as they appear along S’s diagonal.

     For example, given the matrix ‘A = [1, 2; 3, 4]’, and its Schur decomposition

          [U, S] = schur (A)

     which returns

          U =

            -0.82456  -0.56577
             0.56577  -0.82456

          S =

            -0.37228  -1.00000
             0.00000   5.37228


     It is possible to reorder the decomposition so that the positive eigenvalue is in the upper left corner, by doing:

          [U, S] = ordschur (U, S, [0,1])

     See also: schur.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
Reorders the real Schur factorization (U,S) obtained with the ‘schur’ function, so that selected eigenvalues appear in the upper left diagonal blocks of the quasi triangular Schur matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
diary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 837
 -- : diary
 -- : diary on
 -- : diary off
 -- : diary FILENAME
 -- : [STATUS, DIARYFILE] = diary
     Record a list of all commands _and_ the output they produce, mixed together just as they appear on the terminal.

     Valid options are:

     on
          Start recording a session in a file called ‘diary’ in the current working directory.

     off
          Stop recording the session in the diary file.

     FILENAME
          Record the session in the file named FILENAME.

     With no input or output arguments, ‘diary’ toggles the current diary state.

     If output arguments are requested, ‘diary’ ignores inputs and returns the current status.  The boolean STATUS indicates whether recording is on or off, and DIARYFILE is the name of the file where the session is stored.

     See also: history, evalc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Record a list of all commands _and_ the output they produce, mixed together just as they appear on the terminal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
more


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- : more
 -- : more on
 -- : more off
     Turn output pagination on or off.

     Without an argument, ‘more’ toggles the current state.

     The current state can be determined via ‘page_screen_output’.

     See also: page_screen_output, page_output_immediately, PAGER, PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Turn output pagination on or off.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
terminal_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- : terminal_size ()
     Return a two-element row vector containing the current size of the terminal window in characters (rows and columns).

     See also: list_in_columns.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Return a two-element row vector containing the current size of the terminal window in characters (rows and columns).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
page_output_immediately


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 658
 -- : VAL = page_output_immediately ()
 -- : OLD_VAL = page_output_immediately (NEW_VAL)
 -- : page_output_immediately (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave sends output to the pager as soon as it is available.

     Otherwise, Octave buffers its output and waits until just before the prompt is printed to flush it to the pager.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: page_screen_output, more, PAGER, PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Query or set the internal variable that controls whether Octave sends output to the pager as soon as it is available.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
page_screen_output


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 729
 -- : VAL = page_screen_output ()
 -- : OLD_VAL = page_screen_output (NEW_VAL)
 -- : page_screen_output (NEW_VAL, "local")
     Query or set the internal variable that controls whether output intended for the terminal window that is longer than one page is sent through a pager.

     This allows you to view one screenful at a time.  Some pagers (such as ‘less’—see *note Installation::) are also capable of moving backward on the output.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: more, page_output_immediately, PAGER, PAGER_FLAGS.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
Query or set the internal variable that controls whether output intended for the terminal window that is longer than one page is sent through a pager.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
PAGER


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 638
 -- : VAL = PAGER ()
 -- : OLD_VAL = PAGER (NEW_VAL)
 -- : PAGER (NEW_VAL, "local")
     Query or set the internal variable that specifies the program to use to display terminal output on your system.

     The default value is normally "less", "more", or "pg", depending on what programs are installed on your system.  *Note Installation::.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: PAGER_FLAGS, page_output_immediately, more, page_screen_output.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the internal variable that specifies the program to use to display terminal output on your system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
PAGER_FLAGS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 481
 -- : VAL = PAGER_FLAGS ()
 -- : OLD_VAL = PAGER_FLAGS (NEW_VAL)
 -- : PAGER_FLAGS (NEW_VAL, "local")
     Query or set the internal variable that specifies the options to pass to the pager.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: PAGER, more, page_screen_output, page_output_immediately.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Query or set the internal variable that specifies the options to pass to the pager.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 -- : pinv (X)
 -- : pinv (X, TOL)
     Return the Moore-Penrose pseudoinverse of X.

     Singular values less than TOL are ignored.

     If the second argument is omitted, it is taken to be

          tol = max ([rows(X), columns(X)]) * norm (X) * eps

     See also: inv, ldivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the Moore-Penrose pseudoinverse of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
output_max_field_width


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : output_max_field_width
     This function is obsolete and will be removed from a future version of Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
This function is obsolete and will be removed from a future version of Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
output_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 701
 -- : VAL = output_precision ()
 -- : OLD_VAL = output_precision (NEW_VAL)
 -- : output_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the minimum number of significant figures to display for numeric output.

     Note that regardless of the value set for ‘output_precision’, the number of digits of precision displayed is limited to 16 for double precision values and 7 for single precision values.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: format, fixed_point_format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Query or set the internal variable that specifies the minimum number of significant figures to display for numeric output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 517
 -- : rats (X, LEN)
     Convert X into a rational approximation represented as a string.

     The string can be converted back into a matrix as follows:

          r = rats (hilb (4));
          x = str2num (r)

     The optional second argument defines the maximum length of the string representing the elements of X.  By default LEN is 9.

     If the length of the smallest possible rational approximation exceeds LEN, an asterisk (*) padded with spaces will be returned instead.

     See also: format, rat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Convert X into a rational approximation represented as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
disp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- : disp (X)
 -- : STR = disp (X)
     Display the value of X.

     For example:

          disp ("The value of pi is:"), disp (pi)

               ⊣ the value of pi is:
               ⊣ 3.1416

     Note that the output from ‘disp’ always ends with a newline.

     If an output value is requested, ‘disp’ prints nothing and returns the formatted output in a string.

     See also: fdisp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Display the value of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fdisp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- : fdisp (FID, X)
     Display the value of X on the stream FID.

     For example:

          fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

               ⊣ the value of pi is:
               ⊣ 3.1416

     Note that the output from ‘fdisp’ always ends with a newline.

     See also: disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Display the value of X on the stream FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
display


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 793
 -- : display (OBJ)
     Display the contents of the object OBJ prepended by its name.

     The Octave interpreter calls the ‘display’ function whenever it needs to present a class on-screen.  Typically, this would be a statement which does not end in a semicolon to suppress output.  For example:

          myclass (...)

     Or:

          myobj = myclass (...)

     In general, user-defined classes should overload the ‘disp’ method to avoid the default output:

          myobj = myclass (...)
            ⇒ myobj =

            <class myclass>

     When overloading the ‘display’ method instead, one has to take care of properly displaying the object’s name.  This can be done by using the ‘inputname’ function.

     See also: disp, class, subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Display the contents of the object OBJ prepended by its name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5860
 -- : format
 -- : format options
 -- : [FORMAT, FORMATSPACING] = format
     Reset or specify the format of the output produced by ‘disp’ and Octave’s normal echoing mechanism.

     This command only affects the display of numbers, but not how they are stored or computed.  To change the internal representation from the default double use one of the conversion functions such as ‘single’, ‘uint8’, ‘int64’, etc.

     By default, Octave displays 5 significant digits in a human readable form (option ‘short’ paired with ‘loose’ format for matrices).  If ‘format’ is invoked without any options, this default format is restored.

     Valid formats for floating point numbers are listed in the following table.

     ‘short’
          Fixed point format with 5 significant figures (default).

     ‘long’
          Fixed point format with 16 significant figures.

          As with the ‘short’ format, Octave will switch to an exponential ‘e’ format if it is unable to format a matrix properly using the current format.

     ‘short e’
     ‘long e’
          Exponential format.  The number to be represented is split between a mantissa and an exponent (power of 10).  The mantissa has 5 significant digits in the short format.  In the long format, double values are displayed with 16 significant digits and single values are displayed with 8.  For example, with the ‘short e’ format, ‘pi’ is displayed as ‘3.1416e+00’.

     ‘short E’
     ‘long E’
          Identical to ‘short e’ or ‘long e’ but displays an uppercase ‘E’ to indicate the exponent.  For example, with the ‘long E’ format, ‘pi’ is displayed as ‘3.141592653589793E+00’.

     ‘short g’
     ‘long g’
          Optimally choose between fixed point and exponential format based on the magnitude of the number.  For example, with the ‘short g’ format, ‘pi .^ [2; 4; 8; 16; 32]’ is displayed as

               ans =

                     9.8696
                     97.409
                     9488.5
                 9.0032e+07
                 8.1058e+15

     ‘short eng’
     ‘long eng’
          Identical to ‘short e’ or ‘long e’ but displays the value using an engineering format, where the exponent is divisible by 3.  For example, with the ‘short eng’ format, ‘10 * pi’ is displayed as ‘31.416e+00’.

     ‘long G’
     ‘short G’
          Identical to ‘short g’ or ‘long g’ but displays an uppercase ‘E’ to indicate the exponent.

     ‘free’
     ‘none’
          Print output in free format, without trying to line up columns of matrices on the decimal point.  This is a raw format equivalent to the C++ code ‘std::cout << VARIABLE’.  In general, the result is a presentation with 6 significant digits where unnecessary precision (such as trailing zeros for integers) is suppressed.  Complex numbers are formatted as numeric pairs like this ‘(0.60419, 0.60709)’ instead of like this ‘0.60419 + 0.60709i’.

     The following formats affect all numeric output (floating point and integer types).

     "+"
     "+" "CHARS"
     ‘plus’
     ‘plus CHARS’
          Print a ‘+’ symbol for matrix elements greater than zero, a ‘-’ symbol for elements less than zero, and a space for zero matrix elements.  This format can be useful for examining the sparsity structure of a large matrix.  For very large matrices the function ‘spy’ which plots the sparsity pattern will be clearer.

          The optional argument CHARS specifies a list of 3 characters to use for printing values greater than zero, less than zero, and equal to zero.  For example, with the format "+" "+-.", the matrix ‘[1, 0, -1; -1, 0, 1]’ is displayed as

               ans =

               +.-
               -.+

     bank
          Print variable in a format appropriate for a currency (fixed format with two digits to the right of the decimal point).  Only the real part of a variable is displayed, as the imaginary part makes no sense for a currency.

     native-hex
          Print the hexadecimal representation of numbers as they are stored in memory.  For example, on a workstation which stores 8 byte real values in IEEE format with the least significant byte first, the value of ‘pi’ when printed in ‘native-hex’ format is ‘400921fb54442d18’.

     hex
          The same as ‘native-hex’, but always print the most significant byte first.

     native-bit
          Print the bit representation of numbers as stored in memory.  For example, the value of ‘pi’ is

               01000000000010010010000111111011
               01010100010001000010110100011000

          (shown here in two 32 bit sections for typesetting purposes) when printed in native-bit format on a workstation which stores 8 byte real values in IEEE format with the least significant byte first.

     bit
          The same as ‘native-bit’, but always print the most significant bits first.

     rat
          Print a rational approximation, i.e., values are approximated as the ratio of small integers.  For example, with the ‘rat’ format, ‘pi’ is displayed as ‘355/113’.

     The following two options affect the display of all matrices.

     ‘compact’
          Remove blank lines around column number labels and between matrices producing more compact output with more data per page.

     ‘loose’
          Insert blank lines above and below column number labels and between matrices to produce a more readable output with less data per page.  (default).

     If called with one or two output arguments, and no inputs, return the current format and format spacing.

     See also: fixed_point_format, output_precision, split_long_rows, print_empty_dimensions, rats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Reset or specify the format of the output produced by ‘disp’ and Octave’s normal echoing mechanism.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
fixed_point_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1027
 -- : VAL = fixed_point_format ()
 -- : OLD_VAL = fixed_point_format (NEW_VAL)
 -- : fixed_point_format (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will use a scaled format to print matrix values.

     The scaled format prints a scaling factor on the first line of output chosen such that the largest matrix element can be written with a single leading digit.  For example:

          logspace (1, 7, 5)'
          ans =

            1.0e+07  *

            0.00000
            0.00003
            0.00100
            0.03162
            1.00000

     Notice that the first value appears to be 0 when it is actually 1.  Because of the possibility for confusion you should be careful about enabling ‘fixed_point_format’.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: format, output_precision.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Query or set the internal variable that controls whether Octave will use a scaled format to print matrix values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
print_empty_dimensions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 628
 -- : VAL = print_empty_dimensions ()
 -- : OLD_VAL = print_empty_dimensions (NEW_VAL)
 -- : print_empty_dimensions (NEW_VAL, "local")
     Query or set the internal variable that controls whether the dimensions of empty matrices are printed along with the empty matrix symbol, ‘[]’.

     For example, the expression

          zeros (3, 0)

     will print

          ans = [](3x0)

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
Query or set the internal variable that controls whether the dimensions of empty matrices are printed along with the empty matrix symbol, ‘[]’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
split_long_rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1098
 -- : VAL = split_long_rows ()
 -- : OLD_VAL = split_long_rows (NEW_VAL)
 -- : split_long_rows (NEW_VAL, "local")
     Query or set the internal variable that controls whether rows of a matrix may be split when displayed to a terminal window.

     If the rows are split, Octave will display the matrix in a series of smaller pieces, each of which can fit within the limits of your terminal width and each set of rows is labeled so that you can easily see which columns are currently being displayed.  For example:

          octave:13> rand (2,10)
          ans =

           Columns 1 through 6:

            0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
            0.75697  0.51942  0.40031  0.61784  0.92309  0.40201

           Columns 7 through 10:

            0.90174  0.11854  0.72313  0.73326
            0.44672  0.94303  0.56564  0.82150

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Query or set the internal variable that controls whether rows of a matrix may be split when displayed to a terminal window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
psi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 624
 -- : psi (Z)
 -- : psi (K, Z)
     Compute the psi (polygamma) function.

     The polygamma functions are the Kth derivative of the logarithm of the gamma function.  If unspecified, K defaults to zero.  A value of zero computes the digamma function, a value of 1, the trigamma function, and so on.

     The digamma function is defined:

          psi (z) = d (log (gamma (z))) / dx

     When computing the digamma function (when K equals zero), Z can have any value real or complex value.  However, for polygamma functions (K higher than 0), Z must be real and non-negative.

     See also: gamma, gammainc, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the psi (polygamma) function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1682
 -- : Q = quad (F, A, B)
 -- : Q = quad (F, A, B, TOL)
 -- : Q = quad (F, A, B, TOL, SING)
 -- : [Q, IER, NFUN, ERR] = quad (...)
     Numerically evaluate the integral of F from A to B using Fortran routines from QUADPACK.

     F is a function handle, inline function, or a string containing the name of the function to evaluate.  The function must have the form ‘y = f (x)’ where Y and X are scalars.

     A and B are the lower and upper limits of integration.  Either or both may be infinite.

     The optional argument TOL is a vector that specifies the desired accuracy of the result.  The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance.  To choose a relative test only, set the absolute tolerance to zero.  To choose an absolute test only, set the relative tolerance to zero.  Both tolerances default to ‘sqrt (eps)’ or approximately 1.5e-8.

     The optional argument SING is a vector of values at which the integrand is known to be singular.

     The result of the integration is returned in Q.

     IER contains an integer error code (0 indicates a successful integration).

     NFUN indicates the number of function evaluations that were made.

     ERR contains an estimate of the error in the solution.

     The function ‘quad_options’ can set other optional parameters for ‘quad’.

     Note: because ‘quad’ is written in Fortran it cannot be called recursively.  This prevents its use in integrating over more than one variable by routines ‘dblquad’ and ‘triplequad’.

     See also: quad_options, quadv, quadl, quadgk, quadcc, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Numerically evaluate the integral of F from A to B using Fortran routines from QUADPACK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quadcc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3645
 -- : Q = quadcc (F, A, B)
 -- : Q = quadcc (F, A, B, TOL)
 -- : Q = quadcc (F, A, B, TOL, SING)
 -- : [Q, ERR, NR_POINTS] = quadcc (...)
     Numerically evaluate the integral of F from A to B using doubly-adaptive Clenshaw-Curtis quadrature.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be vectorized and must return a vector of output values if given a vector of input values.  For example,

          f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));

     which uses the element-by-element “dot” form for all operators.

     A and B are the lower and upper limits of integration.  Either or both limits may be infinite.  ‘quadcc’ handles an infinite limit by substituting the variable of integration with ‘x = tan (pi/2*u)’.

     The optional argument TOL is a 1- or 2-element vector that specifies the desired accuracy of the result.  The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance.  To choose a relative test only, set the absolute tolerance to zero.  To choose an absolute test only, set the relative tolerance to zero.  The default absolute tolerance is 1e-10 (1e-5 for single), and the default relative tolerance is 1e-6 (1e-4 for single).

     The optional argument SING contains a list of points where the integrand has known singularities, or discontinuities in any of its derivatives, inside the integration interval.  For the example above, which has a discontinuity at x=1, the call to ‘quadcc’ would be as follows

          int = quadcc (f, a, b, [], [ 1 ]);

     The result of the integration is returned in Q.

     ERR is an estimate of the absolute integration error.

     NR_POINTS is the number of points at which the integrand was evaluated.

     If the adaptive integration did not converge, the value of ERR will be larger than the requested tolerance.  Therefore, it is recommended to verify this value for difficult integrands.

     ‘quadcc’ is capable of dealing with non-numeric values of the integrand such as ‘NaN’ or ‘Inf’.  If the integral diverges, and ‘quadcc’ detects this, then a warning is issued and ‘Inf’ or ‘-Inf’ is returned.

     Note: ‘quadcc’ is a general purpose quadrature algorithm and, as such, may be less efficient for a smooth or otherwise well-behaved integrand than other methods such as ‘quadgk’.

     The algorithm uses Clenshaw-Curtis quadrature rules of increasing degree in each interval and bisects the interval if either the function does not appear to be smooth or a rule of maximum degree has been reached.  The error estimate is computed from the L2-norm of the difference between two successive interpolations of the integrand over the nodes of the respective quadrature rules.

     Implementation Note: For Octave versions ≤ 4.2, ‘quadcc’ accepted a single tolerance argument which specified the relative tolerance.  For versions 4.4 and 5, ‘quadcc’ will issue a warning when called with a single tolerance argument indicating that the meaning of this input has changed from relative tolerance to absolute tolerance.  The warning ID for this message is "Octave:quadcc:RelTol-conversion".  The warning may be disabled with ‘warning ("off", "Octave:quadcc:RelTol-conversion")’.

     Reference: P. Gonnet, ‘Increasing the Reliability of Adaptive Quadrature Using Explicit Interpolants’, ACM Transactions on Mathematical Software, Vol.  37, Issue 3, Article No.  3, 2010.

     See also: quad, quadv, quadl, quadgk, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Numerically evaluate the integral of F from A to B using doubly-adaptive Clenshaw-Curtis quadrature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2065
 -- : LAMBDA = qz (A, B)
 -- : [AA, BB, Q, Z, V, W, LAMBDA] = qz (A, B)
 -- : [AA, BB, Z] = qz (A, B, OPT)
 -- : [AA, BB, Z, LAMBDA] = qz (A, B, OPT)
     Compute the QZ decomposition of a generalized eigenvalue problem.

     The generalized eigenvalue problem is defined as

     A x = LAMBDA B x

     There are three calling forms of the function:

       1. ‘LAMBDA = qz (A, B)’

          Compute the generalized eigenvalues LAMBDA.

       2. ‘[AA, BB, Q, Z, V, W, LAMBDA] = qz (A, B)’

          Compute QZ decomposition, generalized eigenvectors, and generalized eigenvalues.


               A * V = B * V * diag (LAMBDA)
               W' * A = diag (LAMBDA) * W' * B
               AA = Q * A * Z, BB = Q * B * Z


          with Q and Z orthogonal (unitary for complex case).

       3. ‘[AA, BB, Z {, LAMBDA}] = qz (A, B, OPT)’

          As in form 2 above, but allows ordering of generalized eigenpairs for, e.g., solution of discrete time algebraic Riccati equations.  Form 3 is not available for complex matrices, and does not compute the generalized eigenvectors V, W, nor the orthogonal matrix Q.

          OPT
               for ordering eigenvalues of the GEP pencil.  The leading block of the revised pencil contains all eigenvalues that satisfy:

               "N"
                    unordered (default)

               "S"
                    small: leading block has all |LAMBDA| < 1

               "B"
                    big: leading block has all |LAMBDA| ≥ 1

               "-"
                    negative real part: leading block has all eigenvalues in the open left half-plane

               "+"
                    non-negative real part: leading block has all eigenvalues in the closed right half-plane

     Note: ‘qz’ performs permutation balancing, but not scaling (*note balance: XREFbalance.), which may be lead to less accurate results than ‘eig’.  The order of output arguments was selected for compatibility with MATLAB.

     See also: eig, balance, lu, chol, hess, qr, qzhess, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compute the QZ decomposition of a generalized eigenvalue problem.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3019
 -- : rand (N)
 -- : rand (M, N, ...)
 -- : rand ([M N ...])
 -- : V = rand ("state")
 -- : rand ("state", V)
 -- : rand ("state", "reset")
 -- : V = rand ("seed")
 -- : rand ("seed", V)
 -- : rand ("seed", "reset")
 -- : rand (..., "single")
 -- : rand (..., "double")
     Return a matrix with random elements uniformly distributed on the interval (0, 1).

     The arguments are handled the same as the arguments for ‘eye’.

     You can query the state of the random number generator using the form

          v = rand ("state")

     This returns a column vector V of length 625.  Later, you can restore the random number generator to the state V using the form

          rand ("state", v)

     You may also initialize the state vector from an arbitrary vector of length ≤ 625 for V.  This new state will be a hash based on the value of V, not V itself.

     By default, the generator is initialized from ‘/dev/urandom’ if it is available, otherwise from CPU time, wall clock time, and the current fraction of a second.  Note that this differs from MATLAB, which always initializes the state to the same state at startup.  To obtain behavior comparable to MATLAB, initialize with a deterministic state vector in Octave’s startup files (*note Startup Files::).

     To compute the pseudo-random sequence, ‘rand’ uses the Mersenne Twister with a period of 2^{19937}-1 (See M. Matsumoto and T. Nishimura, ‘Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator’, ACM Trans.  on Modeling and Computer Simulation Vol.  8, No.  1, pp.  3–30, January 1998, <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>).  Do *not* use for cryptography without securely hashing several returned values together, otherwise the generator state can be learned after reading 624 consecutive values.

     Older versions of Octave used a different random number generator.  The new generator is used by default as it is significantly faster than the old generator, and produces random numbers with a significantly longer cycle time.  However, in some circumstances it might be desirable to obtain the same random sequences as produced by the old generators.  To do this the keyword "seed" is used to specify that the old generators should be used, as in

          rand ("seed", val)

     which sets the seed of the generator to VAL.  The seed of the generator can be queried with

          s = rand ("seed")

     However, it should be noted that querying the seed will not cause ‘rand’ to use the old generators, only setting the seed will.  To cause ‘rand’ to once again use the new generators, the keyword "state" should be used to reset the state of the ‘rand’.

     The state or seed of the generator can be reset to a new random value using the "reset" keyword.

     The class of the value returned can be controlled by a trailing "double" or "single" argument.  These are the only valid classes.

     See also: randn, rande, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Return a matrix with random elements uniformly distributed on the interval (0, 1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 949
 -- : randn (N)
 -- : randn (M, N, ...)
 -- : randn ([M N ...])
 -- : V = randn ("state")
 -- : randn ("state", V)
 -- : randn ("state", "reset")
 -- : V = randn ("seed")
 -- : randn ("seed", V)
 -- : randn ("seed", "reset")
 -- : randn (..., "single")
 -- : randn (..., "double")
     Return a matrix with normally distributed random elements having zero mean and variance one.

     The arguments are handled the same as the arguments for ‘rand’.

     By default, ‘randn’ uses the Marsaglia and Tsang “Ziggurat technique” to transform from a uniform to a normal distribution.

     The class of the value returned can be controlled by a trailing "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, ‘Ziggurat Method for Generating Random Variables’, J. Statistical Software, vol 5, 2000, <https://www.jstatsoft.org/v05/i08/>

     See also: rand, rande, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Return a matrix with normally distributed random elements having zero mean and variance one.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rande


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 926
 -- : rande (N)
 -- : rande (M, N, ...)
 -- : rande ([M N ...])
 -- : V = rande ("state")
 -- : rande ("state", V)
 -- : rande ("state", "reset")
 -- : V = rande ("seed")
 -- : rande ("seed", V)
 -- : rande ("seed", "reset")
 -- : rande (..., "single")
 -- : rande (..., "double")
     Return a matrix with exponentially distributed random elements.

     The arguments are handled the same as the arguments for ‘rand’.

     By default, ‘rande’ uses the Marsaglia and Tsang “Ziggurat technique” to transform from a uniform to an exponential distribution.

     The class of the value returned can be controlled by a trailing "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, ‘Ziggurat Method for Generating Random Variables’, J. Statistical Software, vol 5, 2000, <https://www.jstatsoft.org/v05/i08/>

     See also: rand, randn, randg, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a matrix with exponentially distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1946
 -- : randg (A, N)
 -- : randg (A, M, N, ...)
 -- : randg (A, [M N ...])
 -- : V = randg ("state")
 -- : randg ("state", V)
 -- : randg ("state", "reset")
 -- : V = randg ("seed")
 -- : randg ("seed", V)
 -- : randg ("seed", "reset")
 -- : randg (..., "single")
 -- : randg (..., "double")

     Return a matrix with ‘gamma (A,1)’ distributed random elements.

     The arguments are handled the same as the arguments for ‘rand’, except for the argument A.

     This can be used to generate many distributions:

     ‘gamma (a, b)’ for ‘a > -1’, ‘b > 0’

               r = b * randg (a)

     ‘beta (a, b)’ for ‘a > -1’, ‘b > -1’

               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

     ‘Erlang (a, n)’

               r = a * randg (n)

     ‘chisq (df)’ for ‘df > 0’

               r = 2 * randg (df / 2)

     ‘t (df)’ for ‘0 < df < inf’ (use randn if df is infinite)

               r = randn () / sqrt (2 * randg (df / 2) / df)

     ‘F (n1, n2)’ for ‘0 < n1’, ‘0 < n2’

               ## r1 equals 1 if n1 is infinite
               r1 = 2 * randg (n1 / 2) / n1
               ## r2 equals 1 if n2 is infinite
               r2 = 2 * randg (n2 / 2) / n2
               r = r1 / r2

     negative ‘binomial (n, p)’ for ‘n > 0’, ‘0 < p <= 1’

               r = randp ((1 - p) / p * randg (n))

     non-central ‘chisq (df, L)’, for ‘df >= 0’ and ‘L > 0’
          (use chisq if ‘L = 0’)

               r = randp (L / 2)
               r(r > 0) = 2 * randg (r(r > 0))
               r(df > 0) += 2 * randg (df(df > 0)/2)

     ‘Dirichlet (a1, ... ak)’

               r = (randg (a1), ..., randg (ak))
               r = r / sum (r)

     The class of the value returned can be controlled by a trailing "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return a matrix with ‘gamma (A,1)’ distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1658
 -- : randp (L, N)
 -- : randp (L, M, N, ...)
 -- : randp (L, [M N ...])
 -- : V = randp ("state")
 -- : randp ("state", V)
 -- : randp ("state", "reset")
 -- : V = randp ("seed")
 -- : randp ("seed", V)
 -- : randp ("seed", "reset")
 -- : randp (..., "single")
 -- : randp (..., "double")
     Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, L.

     The arguments are handled the same as the arguments for ‘rand’, except for the argument L.

     Five different algorithms are used depending on the range of L and whether or not L is a scalar or a matrix.

     For scalar L ≤ 12, use direct method.
          W.H. Press, et al., ‘Numerical Recipes in C’, Cambridge University Press, 1992.

     For scalar L > 12, use rejection method.[1]
          W.H. Press, et al., ‘Numerical Recipes in C’, Cambridge University Press, 1992.

     For matrix L ≤ 10, use inversion method.[2]
          E. Stadlober, et al., WinRand source code, available via FTP.

     For matrix L > 10, use patchwork rejection method.
          E. Stadlober, et al., WinRand source code, available via FTP, or H. Zechner, ‘Efficient sampling from continuous and discrete unimodal distributions’, Doctoral Dissertation, 156pp., Technical University Graz, Austria, 1994.

     For L > 1e8, use normal approximation.
          L. Montanet, et al., ‘Review of Particle Properties’, Physical Review D 50 p1284, 1994.

     The class of the value returned can be controlled by a trailing "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
randperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- : randperm (N)
 -- : randperm (N, M)
     Return a row vector containing a random permutation of ‘1:N’.

     If M is supplied, return M unique entries, sampled without replacement from ‘1:N’.

     The complexity is O(N) in memory and O(M) in time, unless M < N/5, in which case O(M) memory is used as well.  The randomization is performed using rand().  All permutations are equally likely.

     See also: perms.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return a row vector containing a random permutation of ‘1:N’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rcond


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 407
 -- : C = rcond (A)
     Compute the 1-norm estimate of the reciprocal condition number as returned by LAPACK.

     If the matrix is well-conditioned then C will be near 1 and if the matrix is poorly conditioned it will be close to 0.

     The matrix A must not be sparse.  If the matrix is sparse then ‘condest (A)’ or ‘rcond (full (A))’ should be used instead.

     See also: cond, condest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Compute the 1-norm estimate of the reciprocal condition number as returned by LAPACK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
regexp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9320
 -- : [S, E, TE, M, T, NM, SP] = regexp (STR, PAT)
 -- : [...] = regexp (STR, PAT, "OPT1", ...)
     Regular expression string matching.

     Search for PAT in STR and return the positions and substrings of any matches, or empty values if there are none.

     The matched pattern PAT can include any of the standard regex operators, including:

     ‘.’
          Match any character

     ‘* + ? {}’
          Repetition operators, representing

          ‘*’
               Match zero or more times

          ‘+’
               Match one or more times

          ‘?’
               Match zero or one times

          ‘{N}’
               Match exactly N times

          ‘{N,}’
               Match N or more times

          ‘{M,N}’
               Match between M and N times

     ‘[...] [^...]’

          List operators.  The pattern will match any character listed between "[" and "]".  If the first character is "^" then the pattern is inverted and any character except those listed between brackets will match.

          Escape sequences defined below can also be used inside list operators.  For example, a template for a floating point number might be ‘[-+.\d]+’.

     ‘() (?:)’
          Grouping operator.  The first form, parentheses only, also creates a token.

     ‘|’
          Alternation operator.  Match one of a choice of regular expressions.  The alternatives must be delimited by the grouping operator ‘()’ above.

     ‘^ $’
          Anchoring operators.  Requires pattern to occur at the start (‘^’) or end (‘$’) of the string.

     In addition, the following escaped characters have special meaning.

     ‘\d’
          Match any digit

     ‘\D’
          Match any non-digit

     ‘\s’
          Match any whitespace character

     ‘\S’
          Match any non-whitespace character

     ‘\w’
          Match any word character

     ‘\W’
          Match any non-word character

     ‘\<’
          Match the beginning of a word

     ‘\>’
          Match the end of a word

     ‘\B’
          Match within a word

     Implementation Note: For compatibility with MATLAB, escape sequences in PAT (e.g., "\n" => newline) are expanded even when PAT has been defined with single quotes.  To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the ‘regexptranslate’ function.

     The outputs of ‘regexp’ default to the order given below

     S
          The start indices of each matching substring

     E
          The end indices of each matching substring

     TE
          The extents of each matched token surrounded by ‘(...)’ in PAT

     M
          A cell array of the text of each match

     T
          A cell array of the text of each token matched

     NM
          A structure containing the text of each matched named token, with the name being used as the fieldname.  A named token is denoted by ‘(?<name>...)’.

     SP
          A cell array of the text not returned by match, i.e., what remains if you split the string based on PAT.

     Particular output arguments, or the order of the output arguments, can be selected by additional OPT arguments.  These are strings and the correspondence between the output arguments and the optional argument are

                                                                                                                                                                                                                   ’start’                                                                                                                                                                                                                                                                                                             S
                                                                                                                                                                                                                   ’end’                                                                                                                                                                                                                                                                                                               E
                                                                                                                                                                                                                   ’tokenExtents’                                                                                                                                                                                                                                                                                                      TE
                                                                                                                                                                                                                   ’match’                                                                                                                                                                                                                                                                                                             M
                                                                                                                                                                                                                   ’tokens’                                                                                                                                                                                                                                                                                                            T
                                                                                                                                                                                                                   ’names’                                                                                                                                                                                                                                                                                                             NM
                                                                                                                                                                                                                   ’split’                                                                                                                                                                                                                                                                                                             SP

     Additional arguments are summarized below.

     ‘once’
          Return only the first occurrence of the pattern.

     ‘matchcase’
          Make the matching case sensitive.  (default)

          Alternatively, use (?-i) in the pattern.

     ‘ignorecase’
          Ignore case when matching the pattern to the string.

          Alternatively, use (?i) in the pattern.

     ‘stringanchors’
          Match the anchor characters at the beginning and end of the string.  (default)

          Alternatively, use (?-m) in the pattern.

     ‘lineanchors’
          Match the anchor characters at the beginning and end of the line.

          Alternatively, use (?m) in the pattern.

     ‘dotall’
          The pattern ‘.’ matches all characters including the newline character.  (default)

          Alternatively, use (?s) in the pattern.

     ‘dotexceptnewline’
          The pattern ‘.’ matches all characters except the newline character.

          Alternatively, use (?-s) in the pattern.

     ‘literalspacing’
          All characters in the pattern, including whitespace, are significant and are used in pattern matching.  (default)

          Alternatively, use (?-x) in the pattern.

     ‘freespacing’
          The pattern may include arbitrary whitespace and also comments beginning with the character ‘#’.

          Alternatively, use (?x) in the pattern.

     ‘noemptymatch’
          Zero-length matches are not returned.  (default)

     ‘emptymatch’
          Return zero-length matches.

          ‘regexp ('a', 'b*', 'emptymatch')’ returns ‘[1 2]’ because there are zero or more ’b’ characters at positions 1 and end-of-string.

     Stack Limitation Note: Pattern searches are done with a recursive function which can overflow the program stack when there are a high number of matches.  For example,

          regexp (repmat ('a', 1, 1e5), '(a)+')

     may lead to a segfault.  As an alternative, consider constructing pattern searches that reduce the number of matches (e.g., by creatively using set complement), and then further processing the return variables (now reduced in size) with successive ‘regexp’ searches.

     See also: regexpi, strfind, regexprep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
regexpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- : [S, E, TE, M, T, NM, SP] = regexpi (STR, PAT)
 -- : [...] = regexpi (STR, PAT, "OPT1", ...)

     Case insensitive regular expression string matching.

     Search for PAT in STR and return the positions and substrings of any matches, or empty values if there are none.  *Note regexp: XREFregexp, for details on the syntax of the search pattern.

     See also: regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Case insensitive regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
regexprep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1062
 -- : OUTSTR = regexprep (STRING, PAT, REPSTR)
 -- : OUTSTR = regexprep (STRING, PAT, REPSTR, "OPT1", ...)
     Replace occurrences of pattern PAT in STRING with REPSTR.

     The pattern is a regular expression as documented for ‘regexp’.  *Note regexp: XREFregexp.

     The replacement string may contain ‘$i’, which substitutes for the ith set of parentheses in the match string.  For example,

          regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')

     returns "Dunn, Bill"

     Options in addition to those of ‘regexp’ are

     ‘once’
          Replace only the first occurrence of PAT in the result.

     ‘warnings’
          This option is present for compatibility but is ignored.

     Implementation Note: For compatibility with MATLAB, escape sequences in PAT (e.g., "\n" => newline) are expanded even when PAT has been defined with single quotes.  To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the ‘regexptranslate’ function.

     See also: regexp, regexpi, strrep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Replace occurrences of pattern PAT in STRING with REPSTR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
schur


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1690
 -- : S = schur (A)
 -- : S = schur (A, "real")
 -- : S = schur (A, "complex")
 -- : S = schur (A, OPT)
 -- : [U, S] = schur (...)
     Compute the Schur decomposition of A.

     The Schur decomposition is defined as

          S = U' * A * U

     where U is a unitary matrix (‘U'* U’ is identity) and S is upper triangular.  The eigenvalues of A (and S) are the diagonal elements of S.  If the matrix A is real, then the real Schur decomposition is computed, in which the matrix U is orthogonal and S is block upper triangular with blocks of size at most ‘2 x 2’ along the diagonal.  The diagonal elements of S (or the eigenvalues of the ‘2 x 2’ blocks, when appropriate) are the eigenvalues of A and S.

     The default for real matrices is a real Schur decomposition.  A complex decomposition may be forced by passing the flag "complex".

     The eigenvalues are optionally ordered along the diagonal according to the value of OPT.  ‘OPT = "a"’ indicates that all eigenvalues with negative real parts should be moved to the leading block of S (used in ‘are’), ‘OPT = "d"’ indicates that all eigenvalues with magnitude less than one should be moved to the leading block of S (used in ‘dare’), and ‘OPT = "u"’, the default, indicates that no ordering of eigenvalues should occur.  The leading K columns of U always span the A-invariant subspace corresponding to the K leading eigenvalues of S.

     The Schur decomposition is used to compute eigenvalues of a square matrix, and has applications in the solution of algebraic Riccati equations in control (see ‘are’ and ‘dare’).

     See also: rsf2csf, ordschur, lu, chol, hess, qr, qz, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the Schur decomposition of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rsf2csf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- : [U, T] = rsf2csf (UR, TR)
     Convert a real, upper quasi-triangular Schur form TR to a complex, upper triangular Schur form T.

     Note that the following relations hold:

     UR * TR * UR’ = U * T * U’ and ‘U' * U’ is the identity matrix I.

     Note also that U and T are not unique.

     See also: schur.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Convert a real, upper quasi-triangular Schur form TR to a complex, upper triangular Schur form T.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
SIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- : SIG ()
     Return a structure containing Unix signal names and their defined values.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return a structure containing Unix signal names and their defined values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
debug_on_interrupt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 680
 -- : VAL = debug_on_interrupt ()
 -- : OLD_VAL = debug_on_interrupt (NEW_VAL)
 -- : debug_on_interrupt (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave will try to enter debugging mode when it receives an interrupt signal (typically generated with ‘C-c’).

     If a second interrupt signal is received before reaching the debugging mode, a normal interrupt will occur.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: debug_on_error, debug_on_warning.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
Query or set the internal variable that controls whether Octave will try to enter debugging mode when it receives an interrupt signal (typically generated with ‘C-c’).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
sighup_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 529
 -- : VAL = sighup_dumps_octave_core ()
 -- : OLD_VAL = sighup_dumps_octave_core (NEW_VAL)
 -- : sighup_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a hangup signal.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a hangup signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
sigquit_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- : VAL = sigquit_dumps_octave_core ()
 -- : OLD_VAL = sigquit_dumps_octave_core (NEW_VAL)
 -- : sigquit_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a quit signal.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a quit signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
sigterm_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 535
 -- : VAL = sigterm_dumps_octave_core ()
 -- : OLD_VAL = sigterm_dumps_octave_core (NEW_VAL)
 -- : sigterm_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a terminate signal.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
Query or set the internal variable that controls whether Octave tries to save all current variables to the file ‘octave-workspace’ if it receives a terminate signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- : issparse (X)
     Return true if X is a sparse matrix.

     See also: ismatrix.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2072
 -- : S = sparse (A)
 -- : S = sparse (I, J, SV, M, N)
 -- : S = sparse (I, J, SV)
 -- : S = sparse (M, N)
 -- : S = sparse (I, J, S, M, N, "unique")
 -- : S = sparse (I, J, SV, M, N, NZMAX)
     Create a sparse matrix from a full matrix, or row, column, value triplets.

     If A is a full matrix, convert it to a sparse matrix representation, removing all zero values in the process.

     Given the integer index vectors I and J, and a 1-by-‘nnz’ vector of real or complex values SV, construct the sparse matrix ‘S(I(K),J(K)) = SV(K)’ with overall dimensions M and N.  If any of SV, I or J are scalars, they are expanded to have a common size.

     If M or N are not specified their values are derived from the maximum index in the vectors I and J as given by ‘M = max (I)’, ‘N = max (J)’.

     *Note*: if multiple values are specified with the same I, J indices, the corresponding value in S will be the sum of the values at the repeated location.  See ‘accumarray’ for an example of how to produce different behavior, such as taking the minimum instead.

     If the option "unique" is given, and more than one value is specified at the same I, J indices, then the last specified value will be used.

     ‘sparse (M, N)’ will create an empty MxN sparse matrix and is equivalent to ‘sparse ([], [], [], M, N)’

     The argument NZMAX is ignored but accepted for compatibility with MATLAB.

     Example 1 (sum at repeated indices):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4)
          ⇒
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  7
            (2, 2) ->  5

     Example 2 ("unique" option):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4, "unique")
          ⇒
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  4
            (2, 2) ->  5

     See also: full, accumarray, spalloc, spdiags, speye, spones, sprand, sprandn, sprandsym, spconvert, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Create a sparse matrix from a full matrix, or row, column, value triplets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spalloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1058
 -- : S = spalloc (M, N, NZ)
     Create an M-by-N sparse matrix with pre-allocated space for at most NZ nonzero elements.

     This is useful for building a matrix incrementally by a sequence of indexed assignments.  Subsequent indexed assignments after ‘spalloc’ will reuse the pre-allocated memory, provided they are of one of the simple forms

        • ‘S(I:J) = X’

        • ‘S(:,I:J) = X’

        • ‘S(K:L,I:J) = X’

     and that the following conditions are met:

        • the assignment does not decrease nnz (S).

        • after the assignment, nnz (S) does not exceed NZ.

        • no index is out of bounds.

     Partial movement of data may still occur, but in general the assignment will be more memory and time efficient under these circumstances.  In particular, it is possible to efficiently build a pre-allocated sparse matrix from a contiguous block of columns.

     The amount of pre-allocated memory for a given matrix may be queried using the function ‘nzmax’.

     See also: nzmax, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Create an M-by-N sparse matrix with pre-allocated space for at most NZ nonzero elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spparms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2261
 -- : spparms ()
 -- : VALS = spparms ()
 -- : [KEYS, VALS] = spparms ()
 -- : VAL = spparms (KEY)
 -- : spparms (VALS)
 -- : spparms ("default")
 -- : spparms ("tight")
 -- : spparms (KEY, VAL)
     Query or set the parameters used by the sparse solvers and factorization functions.

     The first four calls above get information about the current settings, while the others change the current settings.  The parameters are stored as pairs of keys and values, where the values are all floats and the keys are one of the following strings:

     ‘spumoni’
          Printing level of debugging information of the solvers (default 0)

     ‘ths_rel’
          Included for compatibility.  Not used.  (default 1)

     ‘ths_abs’
          Included for compatibility.  Not used.  (default 1)

     ‘exact_d’
          Included for compatibility.  Not used.  (default 0)

     ‘supernd’
          Included for compatibility.  Not used.  (default 3)

     ‘rreduce’
          Included for compatibility.  Not used.  (default 3)

     ‘wh_frac’
          Included for compatibility.  Not used.  (default 0.5)

     ‘autommd’
          Flag whether the LU/QR and the ’\’ and ’/’ operators will automatically use the sparsity preserving mmd functions (default 1)

     ‘autoamd’
          Flag whether the LU and the ’\’ and ’/’ operators will automatically use the sparsity preserving amd functions (default 1)

     ‘piv_tol’
          The pivot tolerance of the UMFPACK solvers (default 0.1)

     ‘sym_tol’
          The pivot tolerance of the UMFPACK symmetric solvers (default 0.001)

     ‘bandden’
          The density of nonzero elements in a banded matrix before it is treated by the LAPACK banded solvers (default 0.5)

     ‘umfpack’
          Flag whether the UMFPACK or mmd solvers are used for the LU, ’\’ and ’/’ operations (default 1)

     The value of individual keys can be set with ‘spparms (KEY, VAL)’.  The default values can be restored with the special keyword "default".  The special keyword "tight" can be used to set the mmd solvers to attempt a sparser solution at the potential cost of longer running time.

     See also: chol, colamd, lu, qr, symamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Query or set the parameters used by the sparse solvers and factorization functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sqrtm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- : S = sqrtm (A)
 -- : [S, ERROR_ESTIMATE] = sqrtm (A)
     Compute the matrix square root of the square matrix A.

     Ref: N.J. Higham.  ‘A New sqrtm for MATLAB’.  Numerical Analysis Report No.  336, Manchester Centre for Computational Mathematics, Manchester, England, January 1999.

     See also: expm, logm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the matrix square root of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
str2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1534
 -- : str2double (S)
     Convert a string to a real or complex number.

     The string must be in one of the following formats where a and b are real numbers and the complex unit is ’i’ or ’j’:

        • a + bi

        • a + b*i

        • a + i*b

        • bi + a

        • b*i + a

        • i*b + a

     If present, a and/or b are of the form [+-]d[,.]d[[eE][+-]d] where the brackets indicate optional arguments and ’d’ indicates zero or more digits.  The special input values ‘Inf’, ‘NaN’, and ‘NA’ are also accepted.

     S may be a character string, character matrix, or cell array.  For character arrays the conversion is repeated for every row, and a double or complex array is returned.  Empty rows in S are deleted and not returned in the numeric array.  For cell arrays each character string element is processed and a double or complex array of the same dimensions as S is returned.

     For unconvertible scalar or character string input ‘str2double’ returns a NaN.  Similarly, for character array input ‘str2double’ returns a NaN for any row of S that could not be converted.  For a cell array, ‘str2double’ returns a NaN for any element of S for which conversion fails.  Note that numeric elements in a mixed string/numeric cell array are not strings and the conversion will fail for these elements and return NaN.

     ‘str2double’ can replace ‘str2num’, and it avoids the security risk of using ‘eval’ on unknown data.

     See also: str2num.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert a string to a real or complex number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strfind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1161
 -- : IDX = strfind (STR, PATTERN)
 -- : IDX = strfind (CELLSTR, PATTERN)
 -- : IDX = strfind (..., "overlaps", VAL)
     Search for PATTERN in the string STR and return the starting index of every such occurrence in the vector IDX.

     If there is no such occurrence, or if PATTERN is longer than STR, or if PATTERN itself is empty, then IDX is the empty array ‘[]’.

     The optional argument "overlaps" determines whether the pattern can match at every position in STR (true), or only for unique occurrences of the complete pattern (false).  The default is true.

     If a cell array of strings CELLSTR is specified then IDX is a cell array of vectors, as specified above.

     Examples:

          strfind ("abababa", "aba")
               ⇒ [1, 3, 5]

          strfind ("abababa", "aba", "overlaps", false)
               ⇒ [1, 5]

          strfind ({"abababa", "bebebe", "ab"}, "aba")
               ⇒
                  {
                    [1,1] =

                       1   3   5

                    [1,2] = [](1x0)
                    [1,3] = [](1x0)
                  }

     See also: findstr, strmatch, regexp, regexpi, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Search for PATTERN in the string STR and return the starting index of every such occurrence in the vector IDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strrep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 728
 -- : NEWSTR = strrep (STR, PTN, REP)
 -- : NEWSTR = strrep (CELLSTR, PTN, REP)
 -- : NEWSTR = strrep (..., "overlaps", VAL)
     Replace all occurrences of the pattern PTN in the string STR with the string REP and return the result.

     The optional argument "overlaps" determines whether the pattern can match at every position in STR (true), or only for unique occurrences of the complete pattern (false).  The default is true.

     S may also be a cell array of strings, in which case the replacement is done for each element and a cell array is returned.

     Example:

          strrep ("This is a test string", "is", "&%$")
              ⇒  "Th&%$ &%$ a test string"

     See also: regexprep, strfind, findstr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Replace all occurrences of the pattern PTN in the string STR with the string REP and return the result.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1028
 -- : char (X)
 -- : char (X, ...)
 -- : char (S1, S2, ...)
 -- : char (CELL_ARRAY)
     Create a string array from one or more numeric matrices, character matrices, or cell arrays.

     Arguments are concatenated vertically.  The returned values are padded with blanks as needed to make each row of the string array have the same length.  Empty input strings are significant and will concatenated in the output.

     For numerical input, each element is converted to the corresponding ASCII character.  A range error results if an input is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell arrays converted through ‘char’ can mostly be converted back with ‘cellstr’.  For example:

          char ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
             ⇒ ["abc "
                 "    "
                 "98  "
                 "99  "
                 "d   "
                 "str1"
                 "half"]

     See also: strvcat, cellstr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Create a string array from one or more numeric matrices, character matrices, or cell arrays.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strvcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1055
 -- : strvcat (X)
 -- : strvcat (X, ...)
 -- : strvcat (S1, S2, ...)
 -- : strvcat (CELL_ARRAY)
     Create a character array from one or more numeric matrices, character matrices, or cell arrays.

     Arguments are concatenated vertically.  The returned values are padded with blanks as needed to make each row of the string array have the same length.  Unlike ‘char’, empty strings are removed and will not appear in the output.

     For numerical input, each element is converted to the corresponding ASCII character.  A range error results if an input is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell arrays converted through ‘strvcat’ can mostly be converted back with ‘cellstr’.  For example:

          strvcat ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
                ⇒ ["abc "
                    "98  "
                    "99  "
                    "d   "
                    "str1"
                    "half"]

     See also: char, strcat, cstrcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Create a character array from one or more numeric matrices, character matrices, or cell arrays.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ischar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- : ischar (X)
     Return true if X is a character array.

     See also: isfloat, isinteger, islogical, isnumeric, isstring, iscellstr, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a character array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strcmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 660
 -- : strcmp (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array.  The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise.  This is just the opposite of the corresponding C library function.

     See also: strcmpi, strncmp, strncmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return 1 if the character strings S1 and S2 are the same, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strncmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 821
 -- : strncmp (S1, S2, N)
     Return 1 if the first N characters of strings S1 and S2 are the same, and 0 otherwise.

          strncmp ("abce", "abcd", 3)
                ⇒ 1

     If either S1 or S2 is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array.  The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string.

          strncmp ("abce", {"abcd", "bca", "abc"}, 3)
               ⇒ [1, 0, 1]

     *Caution:* For compatibility with MATLAB, Octave’s strncmp function returns 1 if the character strings are equal, and 0 otherwise.  This is just the opposite of the corresponding C library function.

     See also: strncmpi, strcmp, strcmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return 1 if the first N characters of strings S1 and S2 are the same, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strcmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 759
 -- : strcmpi (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array.  The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise.  This is just the opposite of the corresponding C library function.

     *Caution:* National alphabets are not supported.

     See also: strcmp, strncmp, strncmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Return 1 if the character strings S1 and S2 are the same, disregarding case of alphabetic characters, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strncmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 767
 -- : strncmpi (S1, S2, N)
     Return 1 if the first N character of S1 and S2 are the same, disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array.  The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave’s strncmpi function returns 1 if the character strings are equal, and 0 otherwise.  This is just the opposite of the corresponding C library function.

     *Caution:* National alphabets are not supported.

     See also: strncmp, strcmp, strcmpi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Return 1 if the first N character of S1 and S2 are the same, disregarding case of alphabetic characters, and 0 otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
list_in_columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1039
 -- : list_in_columns (ARG, WIDTH, PREFIX)
     Return a string containing the elements of ARG listed in columns with an overall maximum width of WIDTH and optional prefix PREFIX.

     The argument ARG must be a cell array of character strings or a character array.

     If WIDTH is not specified or is an empty matrix, or less than or equal to zero, the width of the terminal screen is used.  Newline characters are used to break the lines in the output string.  For example:

          list_in_columns ({"abc", "def", "ghijkl", "mnop", "qrs", "tuv"}, 20)
               ⇒ abc     mnop
                  def     qrs
                  ghijkl  tuv

          whos ans
               ⇒
               Variables in the current scope:

                 Attr Name        Size                     Bytes  Class
                 ==== ====        ====                     =====  =====
                      ans         1x37                        37  char

               Total is 37 elements using 37 bytes

     See also: terminal_size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
Return a string containing the elements of ARG listed in columns with an overall maximum width of WIDTH and optional prefix PREFIX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sub2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1514
 -- : IND = sub2ind (DIMS, I, J)
 -- : IND = sub2ind (DIMS, S1, S2, ..., SN)
     Convert subscripts to linear indices.

     The input DIMS is a dimension vector where each element is the size of the array in the respective dimension (*note size: XREFsize.).  The remaining inputs are scalars or vectors of subscripts to be converted.

     The output vector IND contains the converted linear indices.

     Background: Array elements can be specified either by a linear index which starts at 1 and runs through the number of elements in the array, or they may be specified with subscripts for the row, column, page, etc.  The functions ‘ind2sub’ and ‘sub2ind’ interconvert between the two forms.

     The linear index traverses dimension 1 (rows), then dimension 2 (columns), then dimension 3 (pages), etc. until it has numbered all of the elements.  Consider the following 3-by-3 matrices:

          [(1,1), (1,2), (1,3)]     [1, 4, 7]
          [(2,1), (2,2), (2,3)] ==> [2, 5, 8]
          [(3,1), (3,2), (3,3)]     [3, 6, 9]

     The left matrix contains the subscript tuples for each matrix element.  The right matrix shows the linear indices for the same matrix.

     The following example shows how to convert the two-dimensional indices ‘(2,1)’ and ‘(2,3)’ of a 3-by-3 matrix to linear indices with a single call to ‘sub2ind’.

          s1 = [2, 2];
          s2 = [1, 3];
          ind = sub2ind ([3, 3], s1, s2)
              ⇒ ind =  2   8

     See also: ind2sub, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert subscripts to linear indices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ind2sub


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2216
 -- : [S1, S2, ..., SN] = ind2sub (DIMS, IND)
     Convert linear indices to subscripts.

     The input DIMS is a dimension vector where each element is the size of the array in the respective dimension (*note size: XREFsize.).  The second input IND contains linear indies to be converted.

     The outputs S1, ..., SN contain the converted subscripts.

     Background: Array elements can be specified either by a linear index which starts at 1 and runs through the number of elements in the array, or they may be specified with subscripts for the row, column, page, etc.  The functions ‘ind2sub’ and ‘sub2ind’ interconvert between the two forms.

     The linear index traverses dimension 1 (rows), then dimension 2 (columns), then dimension 3 (pages), etc. until it has numbered all of the elements.  Consider the following 3-by-3 matrices:

          [1, 4, 7]     [(1,1), (1,2), (1,3)]
          [2, 5, 8] ==> [(2,1), (2,2), (2,3)]
          [3, 6, 9]     [(3,1), (3,2), (3,3)]

     The left matrix contains the linear indices for each matrix element.  The right matrix shows the subscript tuples for the same matrix.

     The following example shows how to convert the two-dimensional indices ‘(2,1)’ and ‘(2,3)’ of a 3-by-3 matrix to linear indices with a single call to ‘sub2ind’.

     The following example shows how to convert the linear indices ‘2’ and ‘8’ in a 3-by-3 matrix into subscripts.

          ind = [2, 8];
          [r, c] = ind2sub ([3, 3], ind)
              ⇒ r =  2   2
              ⇒ c =  1   3

     If the number of output subscripts exceeds the number of dimensions, the exceeded dimensions are set to ‘1’.  On the other hand, if fewer subscripts than dimensions are provided, the exceeding dimensions are merged into the final requested dimension.  For clarity, consider the following examples:

          ind  = [2, 8];
          dims = [3, 3];
          ## same as dims = [3, 3, 1]
          [r, c, s] = ind2sub (dims, ind)
              ⇒ r =  2   2
              ⇒ c =  1   3
              ⇒ s =  1   1
          ## same as dims = [9]
          r = ind2sub (dims, ind)
              ⇒ r =  2   8

     See also: ind2sub, size.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert linear indices to subscripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
svd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1867
 -- : S = svd (A)
 -- : [U, S, V] = svd (A)
 -- : [U, S, V] = svd (A, "econ")
 -- : [U, S, V] = svd (A, 0)
     Compute the singular value decomposition of A.

     The singular value decomposition is defined by the relation

          A = U*S*V'

     The function ‘svd’ normally returns only the vector of singular values.  When called with three return values, it computes U, S, and V.  For example,

          svd (hilb (3))

     returns

          ans =

            1.4083189
            0.1223271
            0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

          s =

            1.40832  0.00000  0.00000
            0.00000  0.12233  0.00000
            0.00000  0.00000  0.00269

          v =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

     When given a second argument that is not 0, ‘svd’ returns an economy-sized decomposition, eliminating the unnecessary rows or columns of U or V.

     If the second argument is exactly 0, then the choice of decomposition is based on the matrix A.  If A has more rows than columns then an economy-sized decomposition is returned, otherwise a regular decomposition is calculated.

     Algorithm Notes: When calculating the full decomposition (left and right singular matrices in addition to singular values) there is a choice of two routines in LAPACK.  The default routine used by Octave is ‘gesdd’ which is 5X faster than the alternative ‘gesvd’, but may use more memory and may be less accurate for some matrices.  See the documentation for ‘svd_driver’ for more information.

     See also: svd_driver, svds, eig, lu, chol, hess, qr, qz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compute the singular value decomposition of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
svd_driver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1604
 -- : VAL = svd_driver ()
 -- : OLD_VAL = svd_driver (NEW_VAL)
 -- : svd_driver (NEW_VAL, "local")
     Query or set the underlying LAPACK driver used by ‘svd’.

     Currently recognized values are "gesdd" and "gesvd".  The default is "gesdd".

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     Algorithm Notes: The LAPACK library provides two routines for calculating the full singular value decomposition (left and right singular matrices as well as singular values).  When calculating just the singular values the following discussion is not relevant.

     The default routine use by Octave is the newer ‘gesdd’ which is based on a Divide-and-Conquer algorithm that is 5X faster than the alternative ‘gesvd’, which is based on QR factorization.  However, the new algorithm can use significantly more memory.  For an MxN input matrix the memory usage is of order O(min(M,N) ^ 2), whereas the alternative is of order O(max(M,N)). In general, modern computers have abundant memory so Octave has chosen to prioritize speed.

     In addition, there have been instances in the past where some input matrices were not accurately decomposed by ‘gesdd’.  This appears to have been resolved with modern versions of LAPACK.  However, if certainty is required the accuracy of the decomposition can always be tested after the fact with

          [U, S, V] = svd (X);
          norm (X - U*S*V', "fro")

     See also: svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Query or set the underlying LAPACK driver used by ‘svd’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
sylvester


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- : X = sylvester (A, B, C)
     Solve the Sylvester equation.

     The Sylvester equation is defined as:

          A X + X B = C

     The solution is computed using standard LAPACK subroutines.

     For example:

          sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
             ⇒ [ 0.50000, 0.66667; 0.66667, 0.50000 ]
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Solve the Sylvester equation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
ignore_function_time_stamp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- : VAL = ignore_function_time_stamp ()
 -- : OLD_VAL = ignore_function_time_stamp (NEW_VAL)
     Query or set the internal variable that controls whether Octave checks the time stamp on files each time it looks up functions defined in function files.

     If the internal variable is set to "system", Octave will not automatically recompile function files in subdirectories of ‘OCTAVE-HOME/lib/VERSION’ if they have changed since they were last compiled, but will recompile other function files in the search path if they change.

     If set to "all", Octave will not recompile any function files unless their definitions are removed with ‘clear’.

     If set to "none", Octave will always check time stamps on files to determine whether functions defined in function files need to recompiled.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
Query or set the internal variable that controls whether Octave checks the time stamp on files each time it looks up functions defined in function files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dup2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 265
 -- : [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file ID.  Otherwise, FID is negative and MSG contains a system-dependent error message.

     See also: fopen, fclose, fcntl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Duplicate a file descriptor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
exec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- : [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.

     Calling ‘exec’ without first calling ‘fork’ will terminate your current Octave process and replace it with the program named by FILE.  For example,

          exec ("ls", "-l")

     will run ‘ls’ and return you to your shell prompt.

     If successful, ‘exec’ does not return.  If ‘exec’ does return, ERR will be nonzero, and MSG will contain a system-dependent error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Replace current process with a new process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
popen2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1309
 -- : [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.

     The name of the process is given by COMMAND, and ARGS is an array or cell array of strings containing options for the command.

     The file identifiers for the input and output streams of the subprocess are returned in IN and OUT.  If execution of the command is successful, PID contains the process ID of the subprocess.  Otherwise, PID is −1.

     For example:

          [in, out, pid] = popen2 ("sort", "-r");
          fputs (in, "these\nare\nsome\nstrings\n");
          fclose (in);
          EAGAIN = errno ("EAGAIN");
          done = false;
          do
            s = fgets (out);
            if (ischar (s))
              fputs (stdout, s);
            elseif (errno () == EAGAIN)
              pause (0.1);
              fclear (out);
            else
              done = true;
            endif
          until (done)
          fclose (out);
          waitpid (pid);

             ⊣ these
             ⊣ strings
             ⊣ some
             ⊣ are

     Note that ‘popen2’, unlike ‘popen’, will not "reap" the child process.  If you don’t use ‘waitpid’ to check the child’s exit status, it will linger until Octave exits.

     See also: popen, waitpid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Start a subprocess with two-way communication.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fcntl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1379
 -- : [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.

     The following values may be passed as REQUEST:

     ‘F_DUPFD’
          Return a duplicate file descriptor.

     ‘F_GETFD’
          Return the file descriptor flags for FID.

     ‘F_SETFD’
          Set the file descriptor flags for FID.

     ‘F_GETFL’
          Return the file status flags for FID.  The following codes may be returned (some of the flags may be undefined on some systems).

          ‘O_RDONLY’
               Open for reading only.

          ‘O_WRONLY’
               Open for writing only.

          ‘O_RDWR’
               Open for reading and writing.

          ‘O_APPEND’
               Append on each write.

          ‘O_CREAT’
               Create the file if it does not exist.

          ‘O_NONBLOCK’
               Non-blocking mode.

          ‘O_SYNC’
               Wait for writes to complete.

          ‘O_ASYNC’
               Asynchronous I/O.

     ‘F_SETFL’
          Set the file status flags for FID to the value specified by ARG.  The only flags that can be changed are ‘O_APPEND’ and ‘O_NONBLOCK’.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: fopen, dup2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Change the properties of the open file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fork


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 629
 -- : [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

     > 0
          You are in the parent process.  The value returned from ‘fork’ is the process id of the child process.  You should probably arrange to wait for any child processes to exit.

     0
          You are in the child process.  You can call ‘exec’ to start another process.  If that fails, you should probably call ‘exit’.

     < 0
          The call to ‘fork’ failed for some reason.  You must take evasive action.  A system dependent error message will be waiting in MSG.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Create a copy of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getpgrp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
 -- : pgid = getpgrp ()
     Return the process group id of the current process.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the process group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- : pid = getpid ()
     Return the process id of the current process.

     See also: getppid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the process id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getppid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- : pid = getppid ()
     Return the process id of the parent process.

     See also: getpid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the process id of the parent process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getegid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
 -- : egid = getegid ()
     Return the effective group id of the current process.

     See also: getgid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return the effective group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : gid = getgid ()
     Return the real group id of the current process.

     See also: getegid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the real group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
geteuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : euid = geteuid ()
     Return the effective user id of the current process.

     See also: getuid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the effective user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- : uid = getuid ()
     Return the real user id of the current process.

     See also: geteuid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the real user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 548
 -- : [ERR, MSG] = kill (PID, SIG)
     Send signal SIG to process PID.

     If PID is positive, then signal SIG is sent to PID.

     If PID is 0, then signal SIG is sent to every process in the process group of the current process.

     If PID is -1, then signal SIG is sent to every process except process 1.

     If PID is less than -1, then signal SIG is sent to every process in the process group -PID.

     If SIG is 0, then no signal is sent, but error checking is still performed.

     Return 0 if successful, otherwise return -1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Send signal SIG to process PID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 267
 -- : INFO = lstat (SYMLINK)
 -- : [INFO, ERR, MSG] = lstat (SYMLINK)
     Return a structure INFO containing information about the symbolic link SYMLINK.

     The function outputs are described in the documentation for ‘stat’.

     See also: stat, symlink.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return a structure INFO containing information about the symbolic link SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mkfifo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 -- : ERR = mkfifo (NAME, MODE)
 -- : [ERR, MSG] = mkfifo (NAME, MODE)
     Create a FIFO special file named NAME with file mode MODE.

     MODE is interpreted as an octal number and is subject to umask processing.  The final calculated mode is ‘MODE - UMASK’.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: pipe, umask.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Create a FIFO special file named NAME with file mode MODE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pipe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- : [READ_FD, WRITE_FD, ERR, MSG] = pipe ()
     Create a pipe and return the reading and writing ends of the pipe into READ_FD and WRITE_FD respectively.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: mkfifo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Create a pipe and return the reading and writing ends of the pipe into READ_FD and WRITE_FD respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2584
 -- : [INFO, ERR, MSG] = stat (FILE)
 -- : [INFO, ERR, MSG] = stat (FID)
 -- : [INFO, ERR, MSG] = lstat (FILE)
 -- : [INFO, ERR, MSG] = lstat (FID)
     Return a structure INFO containing the following information about FILE or file identifier FID.

     ‘dev’
          ID of device containing a directory entry for this file.

     ‘ino’
          File number of the file.

     ‘mode’
          File mode, as an integer.  Use the functions ‘S_ISREG’, ‘S_ISDIR’, ‘S_ISCHR’, ‘S_ISBLK’, ‘S_ISFIFO’, ‘S_ISLNK’, or ‘S_ISSOCK’ to extract information from this value.

     ‘modestr’
          File mode, as a string of ten letters or dashes as would be returned by ‘ls -l’.

     ‘nlink’
          Number of links.

     ‘uid’
          User ID of file’s owner.

     ‘gid’
          Group ID of file’s group.

     ‘rdev’
          ID of device for block or character special files.

     ‘size’
          Size in bytes.

     ‘atime’
          Time of last access in the same form as time values returned from ‘time’.  *Note Timing Utilities::.

     ‘mtime’
          Time of last modification in the same form as time values returned from ‘time’.  *Note Timing Utilities::.

     ‘ctime’
          Time of last file status change in the same form as time values returned from ‘time’.  *Note Timing Utilities::.

     ‘blksize’
          Size of blocks in the file.

     ‘blocks’
          Number of blocks allocated for file.

     If the call is successful ERR is 0 and MSG is an empty string.  If the file does not exist, or some other error occurs, INFO is an empty matrix, ERR is −1, and MSG contains the corresponding system error message.

     If FILE is a symbolic link, ‘stat’ will return information about the actual file that is referenced by the link.  Use ‘lstat’ if you want information about the symbolic link itself.

     For example:

          [info, err, msg] = stat ("/vmlinuz")
            ⇒ info =
               {
                 atime = 855399756
                 rdev = 0
                 ctime = 847219094
                 uid = 0
                 size = 389218
                 blksize = 4096
                 mtime = 847219094
                 gid = 6
                 nlink = 1
                 blocks = 768
                 mode = -rw-r--r--
                 modestr = -rw-r--r--
                 ino = 9316
                 dev = 2049
               }
            ⇒ err = 0
            ⇒ msg =

     See also: lstat, ls, dir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return a structure INFO containing the following information about FILE or file identifier FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISREG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- : S_ISREG (MODE)
     Return true if MODE corresponds to a regular file.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a regular file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISDIR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- : S_ISDIR (MODE)
     Return true if MODE corresponds to a directory.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return true if MODE corresponds to a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISCHR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- : S_ISCHR (MODE)
     Return true if MODE corresponds to a character device.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return true if MODE corresponds to a character device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISBLK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- : S_ISBLK (MODE)
     Return true if MODE corresponds to a block device.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a block device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISFIFO


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- : S_ISFIFO (MODE)
     Return true if MODE corresponds to a fifo.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return true if MODE corresponds to a fifo.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISLNK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 187
 -- : S_ISLNK (MODE)
     Return true if MODE corresponds to a symbolic link.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if MODE corresponds to a symbolic link.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISSOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- : S_ISSOCK (MODE)
     Return true if MODE corresponds to a socket.

     The value of MODE is assumed to be returned from a call to ‘stat’.

     See also: stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if MODE corresponds to a socket.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gethostname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- : gethostname ()
     Return the hostname of the system where Octave is running.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the hostname of the system where Octave is running.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- : [UTS, ERR, MSG] = uname ()
     Return system information in the structure.

     For example:

          uname ()
             ⇒ {
                   sysname = x86_64
                   nodename = segfault
                   release = 2.6.15-1-amd64-k8-smp
                   version = Linux
                   machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006
                }

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return system information in the structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 236
 -- : [ERR, MSG] = unlink (FILE)
     Delete the file named FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is nonzero and MSG contains a system-dependent error message.

     See also: delete, rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Delete the file named FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1433
 -- : [PID, STATUS, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.

     The PID argument can be:

     −1
          Wait for any child process.

     0
          Wait for any child process whose process group ID is equal to that of the Octave interpreter process.

     > 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be a bitwise OR of zero or more of the following constants:

     ‘0’
          Wait until signal is received or a child process exits (this is the default if the OPTIONS argument is missing).

     ‘WNOHANG’
          Do not hang if status is not immediately available.

     ‘WUNTRACED’
          Report the status of any child processes that are stopped, and whose status has not yet been reported since they stopped.

     ‘WCONTINUE’
          Return if a stopped child has been resumed by delivery of ‘SIGCONT’.  This value may not be meaningful on all systems.

     If the returned value of PID is greater than 0, it is the process ID of the child process that exited.  If an error occurs, PID will be less than zero and MSG will contain a system-dependent error message.  The value of STATUS contains additional system-dependent information about the subprocess that exited.

     See also: WCONTINUE, WCOREDUMP, WEXITSTATUS, WIFCONTINUED, WIFSIGNALED, WIFSTOPPED, WNOHANG, WSTOPSIG, WTERMSIG, WUNTRACED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Wait for process PID to terminate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WIFEXITED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- : WIFEXITED (STATUS)
     Given STATUS from a call to ‘waitpid’, return true if the child terminated normally.

     See also: waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Given STATUS from a call to ‘waitpid’, return true if the child terminated normally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WEXITSTATUS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- : WEXITSTATUS (STATUS)
     Given STATUS from a call to ‘waitpid’, return the exit status of the child.

     This function should only be employed if ‘WIFEXITED’ returned true.

     See also: waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Given STATUS from a call to ‘waitpid’, return the exit status of the child.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WIFSIGNALED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 245
 -- : WIFSIGNALED (STATUS)
     Given STATUS from a call to ‘waitpid’, return true if the child process was terminated by a signal.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Given STATUS from a call to ‘waitpid’, return true if the child process was terminated by a signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WTERMSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 340
 -- : WTERMSIG (STATUS)
     Given STATUS from a call to ‘waitpid’, return the number of the signal that caused the child process to terminate.

     This function should only be employed if ‘WIFSIGNALED’ returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Given STATUS from a call to ‘waitpid’, return the number of the signal that caused the child process to terminate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCOREDUMP


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 457
 -- : WCOREDUMP (STATUS)
     Given STATUS from a call to ‘waitpid’, return true if the child produced a core dump.

     This function should only be employed if ‘WIFSIGNALED’ returned true.  The macro used to implement this function is not specified in POSIX.1-2001 and is not available on some Unix implementations (e.g., AIX, SunOS).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Given STATUS from a call to ‘waitpid’, return true if the child produced a core dump.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
WIFSTOPPED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 376
 -- : WIFSTOPPED (STATUS)
     Given STATUS from a call to ‘waitpid’, return true if the child process was stopped by delivery of a signal.

     This is only possible if the call was done using ‘WUNTRACED’ or when the child is being traced (see ptrace(2)).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WSTOPSIG, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Given STATUS from a call to ‘waitpid’, return true if the child process was stopped by delivery of a signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WSTOPSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 327
 -- : WSTOPSIG (STATUS)
     Given STATUS from a call to ‘waitpid’, return the number of the signal which caused the child to stop.

     This function should only be employed if ‘WIFSTOPPED’ returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WIFCONTINUED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Given STATUS from a call to ‘waitpid’, return the number of the signal which caused the child to stop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
WIFCONTINUED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- : WIFCONTINUED (STATUS)
     Given STATUS from a call to ‘waitpid’, return true if the child process was resumed by delivery of ‘SIGCONT’.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
Given STATUS from a call to ‘waitpid’, return true if the child process was resumed by delivery of ‘SIGCONT’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
canonicalize_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- : [CNAME, STATUS, MSG] = canonicalize_file_name (FNAME)
     Return the canonical name of file FNAME.

     If the file does not exist the empty string ("") is returned.

     See also: make_absolute_filename, is_absolute_filename, is_rooted_relative_filename.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return the canonical name of file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_DUPFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- : F_DUPFD ()
     Return the numerical value to pass to ‘fcntl’ to return a duplicate file descriptor.

     See also: fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Return the numerical value to pass to ‘fcntl’ to return a duplicate file descriptor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- : F_GETFD ()
     Return the numerical value to pass to ‘fcntl’ to return the file descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return the numerical value to pass to ‘fcntl’ to return the file descriptor flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- : F_GETFL ()
     Return the numerical value to pass to ‘fcntl’ to return the file status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Return the numerical value to pass to ‘fcntl’ to return the file status flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- : F_SETFD ()
     Return the numerical value to pass to ‘fcntl’ to set the file descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return the numerical value to pass to ‘fcntl’ to set the file descriptor flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- : F_SETFL ()
     Return the numerical value to pass to ‘fcntl’ to set the file status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return the numerical value to pass to ‘fcntl’ to set the file status flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_APPEND


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- : O_APPEND ()
     Return the numerical value of the ‘O_APPEND’ macro.

     ‘O_APPEND’ is file status flag that may be returned by ‘fcntl’ to indicate each write operation appends, or that may be passed to ‘fcntl’ to set the write mode to append.

     See also: fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the numerical value of the ‘O_APPEND’ macro.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_ASYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- : O_ASYNC ()
     Return the numerical value of the ‘O_ASYNC’ macro.

     ‘O_ASYNC’ is the file status flag that may be returned by ‘fcntl’ to indicate asynchronous I/O.

     See also: fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the numerical value of the ‘O_ASYNC’ macro.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_CREAT


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- : O_CREAT ()
     Return the numerical value of the ‘O_CREAT’.

     ‘O_CREAT’ is the file status flag that may be returned by ‘fcntl’ to indicate that a file should be created if it does not exist.

     See also: fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the numerical value of the ‘O_CREAT’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_EXCL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- : O_EXCL ()
     Return the numerical value of the ‘O_EXCL’.

     ‘O_EXCL’ is the file status flag that may be returned by ‘fcntl’ to indicate that file locking is used.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the numerical value of the ‘O_EXCL’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
O_NONBLOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 375
 -- : O_NONBLOCK ()
     Return the numerical value of the ‘O_NONBLOCK’.

     ‘O_NONBLOCK’ is the file status flag that may be returned by ‘fcntl’ to indicate that non-blocking I/O is in use, or that may be passsed to ‘fcntl’ to set non-blocking I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the numerical value of the ‘O_NONBLOCK’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_RDONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- : O_RDONLY ()
     Return the numerical value of the ‘O_RDONLY’.

     ‘O_RDONLY’ is the file status flag that may be returned by ‘fcntl’ to indicate that a file is open for reading only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the numerical value of the ‘O_RDONLY’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_RDWR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 321
 -- : O_RDWR ()
     Return the numerical value of the ‘O_RDWR’.

     ‘O_RDWR’ is the file status flag that may be returned by ‘fcntl’ to indicate that a file is open for both reading and writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the numerical value of the ‘O_RDWR’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_SYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 311
 -- : O_SYNC ()
     Return the numerical value of the ‘O_SYNC’.

     ‘O_SYNC’ is the file status flag that may be returned by ‘fcntl’ to indicate that a file is open for synchronous I/O

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the numerical value of the ‘O_SYNC’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_TRUNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 331
 -- : O_TRUNC ()
     Return the numerical value of the ‘O_TRUNC’.

     ‘O_TRUNC’ is the file status flag that may be returned by ‘fcntl’ to indicate that if file exists, it should be truncated when writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the numerical value of the ‘O_TRUNC’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_WRONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- : O_WRONLY ()
     Return the numerical value of the ‘O_WRONLY’.

     ‘O_WRONLY’ is the file status flag that may be returned by ‘fcntl’ to indicate that a file is open for writing only

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the numerical value of the ‘O_WRONLY’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
WNOHANG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 305
 -- : WNOHANG ()
     Return the numerical value of the ‘WNOHANG’ macro.

     ‘WNOHANG’ is the option argument that may be passed to ‘waitpid’ to indicate that it should return its status immediately instead of waiting for a process to exit.

     See also: waitpid, WUNTRACED, WCONTINUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the numerical value of the ‘WNOHANG’ macro.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WUNTRACED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 333
 -- : WUNTRACED ()
     Return the numerical value of the ‘WUNTRACED’ macro.

     ‘WUNTRACED’ is the option argument that may be passed to ‘waitpid’ to indicate that it should also return if the child process has stopped but is not traced via the ‘ptrace’ system call

     See also: waitpid, WNOHANG, WCONTINUE.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the numerical value of the ‘WUNTRACED’ macro.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCONTINUE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- : WCONTINUE ()
     Return the numerical value of the ‘WCONTINUE’ macro.

     ‘WCONTINUE’ is the option argument that may be passed to ‘waitpid’ to indicate that it should also return if a stopped child has been resumed by delivery of a ‘SIGCONT’ signal.

     See also: waitpid, WNOHANG, WUNTRACED.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the numerical value of the ‘WCONTINUE’ macro.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
clc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- : clc ()
 -- : home ()
     Clear the terminal screen and move the cursor to the upper left corner.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Clear the terminal screen and move the cursor to the upper left corner.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 215
 -- : getenv (VAR)
     Return the value of the environment variable VAR.

     For example,

          getenv ("PATH")

     returns a string containing the value of your path.

     See also: setenv, unsetenv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the value of the environment variable VAR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 245
 -- : setenv (VAR, VALUE)
 -- : setenv (VAR)
 -- : putenv (...)
     Set the value of the environment variable VAR to VALUE.

     If no VALUE is specified then the variable will be assigned the null string.

     See also: unsetenv, getenv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Set the value of the environment variable VAR to VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
unsetenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- : STATUS = unsetenv (VAR)
     Delete the environment variable VAR.

     Return 0 if the variable was deleted, or did not exist, and -1 if an error occurred.

     See also: setenv, getenv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Delete the environment variable VAR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
winqueryreg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1630
 -- : VALUE = winqueryreg (ROOTKEY, SUBKEY, VALUENAME)
 -- : VALUE = winqueryreg (ROOTKEY, SUBKEY)
 -- : NAMES = winqueryreg (‘"name"’, ROOTKEY, SUBKEY)

     Query names or value from the Windows registry.

     On Windows, return the value of the registry key SUBKEY from the root key ROOTKEY.  You can specify the name of the queried registry value with the optional argument VALUENAME.  Otherwise, if called with only two arguments or VALUENAME is empty, then the default value of SUBKEY is returned.  If the registry value is of type "REG_DWORD" then VALUE is of class int32.  If the value is of the type "REG_SZ" or "REG_EXPAND_SZ" a string is returned.

     If the first argument is "name", a cell array of strings with the names of the values at that key is returned.

     The variable ROOTKEY must be a string with a valid root key identifier:

     HKCR
     HKEY_CLASSES_ROOT

     HKEY_CURRENT_CONFIG

     HKCU
     HKEY_CURRENT_USER

     HKLM
     HKEY_LOCAL_MACHINE

     HKU
     HKEY_USERS

     HKEY_PERFORMANCE_DATA

     Examples:

     Get a list of value names at the key ’HKCU\Environment’:

          VALUENAMES = winqueryreg ("name", "HKEY_CURRENT_USER", ...
                                    "Environment");

     For each VALUENAMES, display the value:

          for K = 1:numel (VALUENAMES)
            VAL = winqueryreg ("HKEY_CURRENT_USER", "Environment", ...
                               VALUENAMES{K});
            STR = sprintf ("%s = %s", VALUENAMES{K}, num2str (VAL));
            disp (STR);
          endfor

     On non-Windows platforms this function fails with an error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Query names or value from the Windows registry.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
kbhit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 457
 -- : kbhit ()
 -- : kbhit (1)
     Read a single keystroke from the keyboard.

     If called with an argument, don’t wait for a keypress.

     For example,

          x = kbhit ();

     will set X to the next character typed at the keyboard as soon as it is typed.

          x = kbhit (1);

     is identical to the above example, but doesn’t wait for a keypress, returning the empty string if no key is available.

     See also: input, pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Read a single keystroke from the keyboard.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pause


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 553
 -- : pause ()
 -- : pause (N)
     Suspend the execution of the program for N seconds.

     If invoked without an input arguments then the program is suspended until a character is typed.

     N is a positive real value and may be a fraction of a second, for example:

          tic; pause (0.05); toc
               ⊣ Elapsed time is 0.05039 seconds.

     The following example prints a message and then waits 5 seconds before clearing the screen.

          disp ("wait please...");
          pause (5);
          clc;

     See also: kbhit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Suspend the execution of the program for N seconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isieee


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- : isieee ()
     Return true if your computer _claims_ to conform to the IEEE standard for floating point calculations.

     No actual tests are performed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Return true if your computer _claims_ to conform to the IEEE standard for floating point calculations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
native_float_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- : native_float_format ()
     Return the native floating point format as a string.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the native floating point format as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
tilde_expand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 796
 -- : tilde_expand (STRING)
 -- : tilde_expand (CELLSTR)
     Perform tilde expansion on STRING.

     If STRING begins with a tilde character, (‘~’), all of the characters preceding the first slash (or all characters, if there is no slash) are treated as a possible user name, and the tilde and the following characters up to the slash are replaced by the home directory of the named user.  If the tilde is followed immediately by a slash, the tilde is replaced by the home directory of the user running Octave.

     If the input is a cell array of strings CELLSTR then tilde expansion is performed on each string element.

     Examples:

          tilde_expand ("~joeuser/bin")
               ⇒ "/home/joeuser/bin"
          tilde_expand ("~/bin")
               ⇒ "/home/jwe/bin"
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Perform tilde expansion on STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
get_home_directory


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- : HOMEDIR = get_home_directory ()
     Return the current home directory.

     On most systems, this is equivalent to ‘getenv ("HOME")’.  On Windows systems, if the environment variable ‘HOME’ is not set then it is equivalent to ‘fullfile (getenv ("HOMEDRIVE"), getenv ("HOMEPATH"))’

     See also: getenv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the current home directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
time


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 419
 -- : SECONDS = time ()
     Return the current time as the number of seconds since the epoch.

     The epoch is referenced to 00:00:00 UTC (Coordinated Universal Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at 07:15:06 UTC, the value returned by ‘time’ was 856163706.

     See also: strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the current time as the number of seconds since the epoch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gmtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 760
 -- : TM_STRUCT = gmtime (T)
     Given a value returned from ‘time’, or any non-negative integer, return a time structure corresponding to UTC (Coordinated Universal Time).

     For example:

          gmtime (time ())
               ⇒ {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 7
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     gmtoff = 0
                     zone = GMT
                  }

     See also: strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Given a value returned from ‘time’, or any non-negative integer, return a time structure corresponding to UTC (Coordinated Universal Time).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
localtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 736
 -- : TM_STRUCT = localtime (T)
     Given a value returned from ‘time’, or any non-negative integer, return a time structure corresponding to the local time zone.

          localtime (time ())
               ⇒ {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 1
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     gmtoff = -21600
                     zone = CST
                  }

     See also: strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
Given a value returned from ‘time’, or any non-negative integer, return a time structure corresponding to the local time zone.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mktime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 355
 -- : SECONDS = mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the number of seconds since the epoch.

     For example:

          mktime (localtime (time ()))
               ⇒ 856163706

     See also: strftime, strptime, localtime, gmtime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Convert a time structure corresponding to the local time to the number of seconds since the epoch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strftime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3191
 -- : strftime (FMT, TM_STRUCT)
     Format the time structure TM_STRUCT in a flexible way using the format string FMT that contains ‘%’ substitutions similar to those in ‘printf’.

     Except where noted, substituted fields have a fixed size; numeric fields are padded if necessary.  Padding is with zeros by default; for fields that display a single number, padding can be changed or inhibited by following the ‘%’ with one of the modifiers described below.  Unknown field specifiers are copied as normal characters.  All other characters are copied to the output without change.  For example:

          strftime ("%r (%Z) %A %e %B %Y", localtime (time ()))
                ⇒ "01:15:06 AM (CST) Monday 17 February 1997"

     Octave’s ‘strftime’ function supports a superset of the ANSI C field specifiers.

     Literal character fields:

     ‘%%’
          % character.

     ‘%n’
          Newline character.

     ‘%t’
          Tab character.

     Numeric modifiers (a nonstandard extension):

     ‘- (dash)’
          Do not pad the field.

     ‘_ (underscore)’
          Pad the field with spaces.

     Time fields:

     ‘%H’
          Hour (00-23).

     ‘%I’
          Hour (01-12).

     ‘%k’
          Hour (0-23).

     ‘%l’
          Hour (1-12).

     ‘%M’
          Minute (00-59).

     ‘%p’
          Locale’s AM or PM.

     ‘%r’
          Time, 12-hour (hh:mm:ss [AP]M).

     ‘%R’
          Time, 24-hour (hh:mm).

     ‘%s’
          Time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard extension).

     ‘%S’
          Second (00-61).

     ‘%T’
          Time, 24-hour (hh:mm:ss).

     ‘%X’
          Locale’s time representation (%H:%M:%S).

     ‘%z’
          Offset from UTC (Â±hhmm), or nothing if no time zone is determinable.

     ‘%Z’
          Time zone (EDT), or nothing if no time zone is determinable.

     Date fields:

     ‘%a’
          Locale’s abbreviated weekday name (Sun-Sat).

     ‘%A’
          Locale’s full weekday name, variable length (Sunday-Saturday).

     ‘%b’
          Locale’s abbreviated month name (Jan-Dec).

     ‘%B’
          Locale’s full month name, variable length (January-December).

     ‘%c’
          Locale’s date and time (Sat Nov 04 12:02:33 EST 1989).

     ‘%C’
          Century (00-99).

     ‘%d’
          Day of month (01-31).

     ‘%e’
          Day of month ( 1-31).

     ‘%D’
          Date (mm/dd/yy).

     ‘%h’
          Same as %b.

     ‘%j’
          Day of year (001-366).

     ‘%m’
          Month (01-12).

     ‘%U’
          Week number of year with Sunday as first day of week (00-53).

     ‘%w’
          Day of week (0-6).

     ‘%W’
          Week number of year with Monday as first day of week (00-53).

     ‘%x’
          Locale’s date representation (mm/dd/yy).

     ‘%y’
          Last two digits of year (00-99).

     ‘%Y’
          Year (1970-).

     See also: strptime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
Format the time structure TM_STRUCT in a flexible way using the format string FMT that contains ‘%’ substitutions similar to those in ‘printf’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strptime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 488
 -- : [TM_STRUCT, NCHARS] = strptime (STR, FMT)
     Convert the string STR to the time structure TM_STRUCT under the control of the format string FMT.

     If FMT fails to match, NCHARS is 0; otherwise, it is set to the position of last matched character plus 1.  Always check for this unless you’re absolutely sure the date string will be parsed correctly.

     See also: strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Convert the string STR to the time structure TM_STRUCT under the control of the format string FMT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
warranty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- : warranty ()
     Describe the conditions for copying and distributing Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Describe the conditions for copying and distributing Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1761
 -- : system ("STRING")
 -- : system ("STRING", RETURN_OUTPUT)
 -- : system ("STRING", RETURN_OUTPUT, TYPE)
 -- : [STATUS, OUTPUT] = system (...)
     Execute a shell command specified by STRING.

     If the optional argument TYPE is "async", the process is started in the background and the process ID of the child process is returned immediately.  Otherwise, the child process is started and Octave waits until it exits.  If the TYPE argument is omitted, it defaults to the value "sync".

     If SYSTEM is called with one or more output arguments, or if the optional argument RETURN_OUTPUT is true and the subprocess is started synchronously, then the output from the command is returned as a variable.  Otherwise, if the subprocess is executed synchronously, its output is sent to the standard output.  To send the output of a command executed with ‘system’ through the pager, use a command like

          [~, text] = system ("cmd");
          more on;
          disp (text);

     or

          more on;
          printf ("%s\n", nthargout (2, "system", "cmd"));

     The ‘system’ function can return two values.  The first is the exit status of the command and the second is any output from the command that was written to the standard output stream.  For example,

          [status, output] = system ("echo foo & exit 2");

     will set the variable OUTPUT to the string ‘foo’, and the variable STATUS to the integer ‘2’.

     For commands run asynchronously, STATUS is the process id of the command shell that is started to run the command.

     The shell used for executing commands varies with operating system and is typically ‘/bin/sh’ for UNIX systems and ‘cmd.exe’ for Windows systems.

     See also: unix, dos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Execute a shell command specified by STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tril


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1251
 -- : A_LO = tril (A)
 -- : A_LO = tril (A, K)
 -- : A_LO = tril (A, K, PACK)
     Return a new matrix formed by extracting the lower triangular part of the matrix A, and setting all other elements to zero.

     The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero.  The default value of K is zero which includes the main diagonal as part of the result.  If the value of K is a nonzero integer then the selection of elements starts at an offset of K diagonals above the main diagonal for positive K or below the main diagonal for negative K.  The absolute value of K may not be greater than the number of subdiagonals or superdiagonals.

     Example 1 : exclude main diagonal

          tril (ones (3), -1)
               ⇒  0  0  0
                   1  0  0
                   1  1  0


     Example 2 : include first superdiagonal

          tril (ones (3), 1)
               ⇒  1  1  0
                   1  1  1
                   1  1  1

     If the optional third argument "pack" is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector.

     See also: triu, istril, diag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Return a new matrix formed by extracting the lower triangular part of the matrix A, and setting all other elements to zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
triu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1249
 -- : A_UP = triu (A)
 -- : A_UP = triu (A, K)
 -- : A_UP = triu (A, K, PACK)
     Return a new matrix formed by extracting the upper triangular part of the matrix A, and setting all other elements to zero.

     The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero.  The default value of K is zero which includes the main diagonal as part of the result.  If the value of K is a nonzero integer then the selection of elements starts at an offset of K diagonals above the main diagonal for positive K or below the main diagonal for negative K.  The absolute value of K may not be greater than the number of subdiagonals or superdiagonals.

     Example 1 : exclude main diagonal

          triu (ones (3), 1)
               ⇒  0  1  1
                   0  0  1
                   0  0  0


     Example 2 : include first subdiagonal

          triu (ones (3), -1)
               ⇒  1  1  1
                   1  1  1
                   0  1  1

     If the optional third argument "pack" is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector.

     See also: tril, istriu, diag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Return a new matrix formed by extracting the upper triangular part of the matrix A, and setting all other elements to zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- : IDX = tsearch (X, Y, T, XI, YI)
     Search for the enclosing Delaunay convex hull.

     For ‘T = delaunay (X, Y)’, finds the index in T containing the points ‘(XI, YI)’.  For points outside the convex hull, IDX is NaN.

     See also: delaunay, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Search for the enclosing Delaunay convex hull.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typecast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1384
 -- : Y = typecast (X, "CLASS")
     Return a new array Y resulting from interpreting the data of X in memory as data of the numeric class CLASS.

     Both the class of X and CLASS must be one of the built-in numeric classes:

          "logical"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"
          "double complex"
          "single complex"

     the last two are only used with CLASS; they indicate that a complex-valued result is requested.  Complex arrays are stored in memory as consecutive pairs of real numbers.  The sizes of integer types are given by their bit counts.  Both logical and char are typically one byte wide; however, this is not guaranteed by C++.  If your system is IEEE conformant, single and double will be 4 bytes and 8 bytes wide, respectively.  "logical" is not allowed for CLASS.

     If the input is a row vector, the return value is a row vector, otherwise it is a column vector.

     If the bit length of X is not divisible by that of CLASS, an error occurs.

     An example of the use of typecast on a little-endian machine is

          X = uint16 ([1, 65535]);
          typecast (X, "uint8")
          ⇒ [   1,   0, 255, 255]

     See also: cast, bitpack, bitunpack, swapbytes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a new array Y resulting from interpreting the data of X in memory as data of the numeric class CLASS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bitpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 826
 -- : Y = bitpack (X, CLASS)
     Return a new array Y resulting from interpreting the logical array X as raw bit patterns for data of the numeric class CLASS.

     CLASS must be one of the built-in numeric classes:

          "double"
          "single"
          "double complex"
          "single complex"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"

     The number of elements of X should be divisible by the bit length of CLASS.  If it is not, excess bits are discarded.  Bits come in increasing order of significance, i.e., ‘x(1)’ is bit 0, ‘x(2)’ is bit 1, etc.

     The result is a row vector if X is a row vector, otherwise it is a column vector.

     See also: bitunpack, typecast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Return a new array Y resulting from interpreting the logical array X as raw bit patterns for data of the numeric class CLASS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bitunpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 487
 -- : Y = bitunpack (X)
     Return a logical array Y corresponding to the raw bit patterns of X.

     X must belong to one of the built-in numeric classes:

          "double"
          "single"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"

     The result is a row vector if X is a row vector; otherwise, it is a column vector.

     See also: bitpack, typecast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return a logical array Y corresponding to the raw bit patterns of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
urlwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1286
 -- : urlwrite (URL, LOCALFILE)
 -- : F = urlwrite (URL, LOCALFILE)
 -- : [F, SUCCESS] = urlwrite (URL, LOCALFILE)
 -- : [F, SUCCESS, MESSAGE] = urlwrite (URL, LOCALFILE)
     Download a remote file specified by its URL and save it as LOCALFILE.

     For example:

          urlwrite ("ftp://ftp.octave.org/pub/README",
                    "README.txt");

     The full path of the downloaded file is returned in F.

     The variable SUCCESS is 1 if the download was successful, otherwise it is 0 in which case MESSAGE contains an error message.

     If no output argument is specified and an error occurs, then the error is signaled through Octave’s error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP, FTP, and FILE protocols.  Username and password may be specified in the URL, for example:

          urlwrite ("http://username:password@example.com/file.txt",
                    "file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The parameter METHOD is either ‘get’ or ‘post’ and PARAM is a cell array of parameter and value pairs.  For example:

          urlwrite ("http://www.google.com/search", "search.html",
                    "get", {"query", "octave"});

     See also: urlread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Download a remote file specified by its URL and save it as LOCALFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
urlread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1138
 -- : S = urlread (URL)
 -- : [S, SUCCESS] = urlread (URL)
 -- : [S, SUCCESS, MESSAGE] = urlread (URL)
 -- : [...] = urlread (URL, METHOD, PARAM)
     Download a remote file specified by its URL and return its content in string S.

     For example:

          s = urlread ("ftp://ftp.octave.org/pub/README");

     The variable SUCCESS is 1 if the download was successful, otherwise it is 0 in which case MESSAGE contains an error message.

     If no output argument is specified and an error occurs, then the error is signaled through Octave’s error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP, FTP, and FILE protocols.  Username and password may be specified in the URL.  For example:

          s = urlread ("http://user:password@example.com/file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The parameter METHOD is either ‘get’ or ‘post’ and PARAM is a cell array of parameter and value pairs.  For example:

          s = urlread ("http://www.google.com/search", "get",
                      {"query", "octave"});

     See also: urlwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Download a remote file specified by its URL and return its content in string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isvarname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : isvarname (NAME)
     Return true if NAME is a valid variable name.

     See also: iskeyword, exist, who.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return true if NAME is a valid variable name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
file_in_loadpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 887
 -- : FNAME = file_in_loadpath (FILE)
 -- : FNAME = file_in_loadpath (FILE, "all")
     Return the absolute name of FILE if it can be found in the list of directories specified by ‘path’.

     If no file is found, return an empty character string.

     When FILE is already an absolute name, the name is checked against the file system instead of Octave’s loadpath.  In this case, if FILE exists it will be returned in FNAME, otherwise an empty string is returned.

     If the first argument is a cell array of strings, search each directory of the loadpath for element of the cell array and return the first that matches.

     If the second optional argument "all" is supplied, return a cell array containing the list of all files that have the same name in the path.  If no files are found, return an empty cell array.

     See also: file_in_path, dir_in_loadpath, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return the absolute name of FILE if it can be found in the list of directories specified by ‘path’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
file_in_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 804
 -- : file_in_path (PATH, FILE)
 -- : file_in_path (PATH, FILE, "all")
     Return the absolute name of FILE if it can be found in PATH.

     The value of PATH should be a colon-separated list of directories in the format described for ‘path’.  If no file is found, return an empty character string.  For example:

          file_in_path (EXEC_PATH, "sh")
               ⇒ "/bin/sh"

     If the second argument is a cell array of strings, search each directory of the path for element of the cell array and return the first that matches.

     If the third optional argument "all" is supplied, return a cell array containing the list of all files that have the same name in the path.  If no files are found, return an empty cell array.

     See also: file_in_loadpath, dir_in_loadpath, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the absolute name of FILE if it can be found in PATH.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
do_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- : do_string_escapes (STRING)
     Convert escape sequences in STRING to the characters they represent.

     Escape sequences begin with a leading backslash (’\’) followed by 1–3 characters (.e.g., "\n" => newline).

     See also: undo_string_escapes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Convert escape sequences in STRING to the characters they represent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
undo_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 757
 -- : undo_string_escapes (S)
     Convert special characters in strings back to their escaped forms.

     For example, the expression

          bell = "\a";

     assigns the value of the alert character (control-g, ASCII code 7) to the string variable ‘bell’.  If this string is printed, the system will ring the terminal bell (if it is possible).  This is normally the desired outcome.  However, sometimes it is useful to be able to print the original representation of the string, with the special characters replaced by their escape sequences.  For example,

          octave:13> undo_string_escapes (bell)
          ans = \a

     replaces the unprintable alert character with its printable representation.

     See also: do_string_escapes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert special characters in strings back to their escaped forms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
is_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
 -- : is_absolute_filename (FILE)
     Return true if FILE is an absolute filename.

     See also: is_rooted_relative_filename, make_absolute_filename, isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if FILE is an absolute filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
is_rooted_relative_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- : is_rooted_relative_filename (FILE)
     Return true if FILE is a rooted-relative filename.

     See also: is_absolute_filename, make_absolute_filename, isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if FILE is a rooted-relative filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
make_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 265
 -- : make_absolute_filename (FILE)
     Return the full name of FILE beginning from the root of the file system.

     No check is done for the existence of FILE.

     See also: canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the full name of FILE beginning from the root of the file system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
dir_in_loadpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 904
 -- : DIRNAME = dir_in_loadpath (DIR)
 -- : DIRNAME = dir_in_loadpath (DIR, "all")
     Return the absolute name of the loadpath element matching DIR if it can be found in the list of directories specified by ‘path’.

     If no match is found, return an empty character string.

     The match is performed at the end of each path element.  For example, if DIR is "foo/bar", it matches the path element "/some/dir/foo/bar", but not "/some/dir/foo/bar/baz" "/some/dir/allfoo/bar".  When DIR is an absolute name, rather than just a path fragment, it is matched against the file system instead of Octave’s loadpath.  In this case, if DIR exists it will be returned in DIRNAME, otherwise an empty string is returned.

     If the optional second argument is supplied, return a cell array containing all name matches rather than just the first.

     See also: file_in_path, file_in_loadpath, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
Return the absolute name of the loadpath element matching DIR if it can be found in the list of directories specified by ‘path’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
errno


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 563
 -- : ERR = errno ()
 -- : ERR = errno (VAL)
 -- : ERR = errno (NAME)
     Query or set the system-dependent variable errno.

     When called with no inputs, return the current value of errno.

     When called with a numeric input VAL, set the current value of errno to the specified value.  The previous value of errno is returned as ERR.

     When called with a character string NAME, return the numeric value of errno which corresponds to the specified error code.  If NAME is not a recognized error code then -1 is returned.

     See also: errno_list.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Query or set the system-dependent variable errno.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
errno_list


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : errno_list ()
     Return a structure containing the system-dependent errno values.

     See also: errno.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a structure containing the system-dependent errno values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 595
 -- : isindex (IND)
 -- : isindex (IND, N)
     Return true if IND is a valid index.

     Valid indices are either positive integers (although possibly of real data type), or logical arrays.

     If present, N specifies the maximum extent of the dimension to be indexed.  When possible the internal result is cached so that subsequent indexing using IND will not perform the check again.

     Implementation Note: Strings are first converted to double values before the checks for valid indices are made.  Unless a string contains the NULL character "\0", it will always be a valid index.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if IND is a valid index.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isstudent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- : isstudent ()
     Return true if running in the student edition of MATLAB.

     ‘isstudent’ always returns false in Octave.

     See also: false.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return true if running in the student edition of MATLAB.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isglobal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 199
 -- : isglobal (NAME)
     Return true if NAME is a globally visible variable.

     For example:

          global x
          isglobal ("x")
             ⇒ 1

     See also: isvarname, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if NAME is a globally visible variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
exist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1931
 -- : C = exist (NAME)
 -- : C = exist (NAME, TYPE)
     Check for the existence of NAME as a variable, function, file, directory, or class.

     The return code C is one of

     1
          NAME is a variable.

     2
          NAME is an absolute filename, an ordinary file in Octave’s ‘path’, or (after appending ‘.m’) a function file in Octave’s ‘path’.

     3
          NAME is a ‘.oct’ or ‘.mex’ file in Octave’s ‘path’.

     5
          NAME is a built-in function.

     7
          NAME is a directory.

     8
          NAME is a class.  (Note: not currently implemented)

     103
          NAME is a function not associated with a file (entered on the command line).

     0
          NAME does not exist.

     If the optional argument TYPE is supplied, check only for symbols of the specified type.  Valid types are

     "var"
          Check only for variables.

     "builtin"
          Check only for built-in functions.

     "dir"
          Check only for directories.

     "file"
          Check only for files and directories.

     "class"
          Check only for classes.  (Note: This option is accepted, but not currently implemented)

     If no type is given, and there are multiple possible matches for name, ‘exist’ will return a code according to the following priority list: variable, built-in function, oct-file, directory, file, class.

     ‘exist’ returns 2 if a regular file called NAME is present in Octave’s search path.  For information about other types of files not on the search path use some combination of the functions ‘file_in_path’ and ‘stat’ instead.

     Programming Note: If NAME is implemented by a buggy .oct/.mex file, calling EXIST may cause Octave to crash.  To maintain high performance, Octave trusts .oct/.mex files instead of sandboxing them.

     See also: file_in_loadpath, file_in_path, dir_in_loadpath, stat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Check for the existence of NAME as a variable, function, file, directory, or class.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
who


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1086
 -- : who
 -- : who pattern ...
 -- : who option pattern ...
 -- : C = who ("pattern", ...)
     List currently defined variables matching the given patterns.

     Valid pattern syntax is the same as described for the ‘clear’ command.  If no patterns are supplied, all variables are listed.

     By default, only variables visible in the local scope are displayed.

     The following are valid options, but may not be combined.

     ‘global’
          List variables in the global scope rather than the current scope.

     ‘-regexp’
          The patterns are considered to be regular expressions when matching the variables to display.  The same pattern syntax accepted by the ‘regexp’ function is used.

     ‘-file’
          The next argument is treated as a filename.  All variables found within the specified file are listed.  No patterns are accepted when reading variables from a file.

     If called as a function, return a cell array of defined variable names matching the given patterns.

     See also: whos, isglobal, isvarname, exist, regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
List currently defined variables matching the given patterns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
whos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1664
 -- : whos
 -- : whos pattern ...
 -- : whos option pattern ...
 -- : S = whos ("pattern", ...)
     Provide detailed information on currently defined variables matching the given patterns.

     Options and pattern syntax are the same as for the ‘who’ command.

     Extended information about each variable is summarized in a table with the following default entries.

     Attr
          Attributes of the listed variable.  Possible attributes are:

          blank
               Variable in local scope

          ‘a’
               Automatic variable.  An automatic variable is one created by the interpreter, for example ‘argn’.

          ‘c’
               Variable of complex type.

          ‘f’
               Formal parameter (function argument).

          ‘g’
               Variable with global scope.

          ‘p’
               Persistent variable.

     Name
          The name of the variable.

     Size
          The logical size of the variable.  A scalar is 1x1, a vector is 1xN or Nx1, a 2-D matrix is MxN.

     Bytes
          The amount of memory currently used to store the variable.

     Class
          The class of the variable.  Examples include double, single, char, uint16, cell, and struct.

     The table can be customized to display more or less information through the function ‘whos_line_format’.

     If ‘whos’ is called as a function, return a struct array of defined variable names matching the given patterns.  Fields in the structure describing each variable are: name, size, bytes, class, global, sparse, complex, nesting, persistent.

     See also: who, whos_line_format.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Provide detailed information on currently defined variables matching the given patterns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- : mlock ()
     Lock the current function into memory so that it can’t be cleared.

     See also: munlock, mislocked, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Lock the current function into memory so that it can’t be cleared.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
munlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- : munlock ()
 -- : munlock (FCN)
     Unlock the named function FCN.

     If no function is named then unlock the current function.

     See also: mlock, mislocked, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Unlock the named function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mislocked


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 224
 -- : mislocked ()
 -- : mislocked (FCN)
     Return true if the named function FCN is locked.

     If no function is named then return true if the current function is locked.

     See also: mlock, munlock, persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return true if the named function FCN is locked.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
clear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2186
 -- : clear [options] pattern ...
     Delete the names matching the given patterns from the symbol table.

     The pattern may contain the following special characters:

     ‘?’
          Match any single character.

     ‘*’
          Match zero or more characters.

     ‘[ LIST ]’
          Match the list of characters specified by LIST.  If the first character is ‘!’ or ‘^’, match all characters except those specified by LIST.  For example, the pattern ‘[a-zA-Z]’ will match all lowercase and uppercase alphabetic characters.

     For example, the command

          clear foo b*r

     clears the name ‘foo’ and all names that begin with the letter ‘b’ and end with the letter ‘r’.

     If ‘clear’ is called without any arguments, all user-defined variables (local and global) are cleared from the symbol table.

     If ‘clear’ is called with at least one argument, only the visible names matching the arguments are cleared.  For example, suppose you have defined a function ‘foo’, and then hidden it by performing the assignment ‘foo = 2’.  Executing the command ‘clear foo’ once will clear the variable definition and restore the definition of ‘foo’ as a function.  Executing ‘clear foo’ a second time will clear the function definition.

     The following options are available in both long and short form

     ‘-all, -a’
          Clear all local and global user-defined variables and all functions from the symbol table.

     ‘-exclusive, -x’
          Clear the variables that don’t match the following pattern.

     ‘-functions, -f’
          Clear the function names and the built-in symbols names.

     ‘-global, -g’
          Clear global symbol names.

     ‘-variables, -v’
          Clear local variable names.

     ‘-classes, -c’
          Clears the class structure table and clears all objects.

     ‘-regexp, -r’
          The arguments are treated as regular expressions as any variables that match will be cleared.

     With the exception of ‘exclusive’, all long options can be used without the dash as well.

     See also: who, whos, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Delete the names matching the given patterns from the symbol table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
whos_line_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1927
 -- : VAL = whos_line_format ()
 -- : OLD_VAL = whos_line_format (NEW_VAL)
 -- : whos_line_format (NEW_VAL, "local")
     Query or set the format string used by the command ‘whos’.

     A full format string is:

          %[modifier]<command>[:width[:left-min[:balance]]];

     The following command sequences are available:

     ‘%a’
          Prints attributes of variables (g=global, p=persistent, f=formal parameter, a=automatic variable).

     ‘%b’
          Prints number of bytes occupied by variables.

     ‘%c’
          Prints class names of variables.

     ‘%e’
          Prints elements held by variables.

     ‘%n’
          Prints variable names.

     ‘%s’
          Prints dimensions of variables.

     ‘%t’
          Prints type names of variables.

     Every command may also have an alignment modifier:

     ‘l’
          Left alignment.

     ‘r’
          Right alignment (default).

     ‘c’
          Column-aligned (only applicable to command %s).

     The ‘width’ parameter is a positive integer specifying the minimum number of columns used for printing.  No maximum is needed as the field will auto-expand as required.

     The parameters ‘left-min’ and ‘balance’ are only available when the column-aligned modifier is used with the command ‘%s’.  ‘balance’ specifies the column number within the field width which will be aligned between entries.  Numbering starts from 0 which indicates the leftmost column.  ‘left-min’ specifies the minimum field width to the left of the specified balance column.

     The default format is:

     " %a:4; %ln:6; %cs:16:6:1; %rb:12; %lc:-1;\n"

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: whos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Query or set the format string used by the command ‘whos’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
missing_function_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 505
 -- : VAL = missing_function_hook ()
 -- : OLD_VAL = missing_function_hook (NEW_VAL)
 -- : missing_function_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to call when an unknown identifier is requested.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     See also: missing_component_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the internal variable that specifies the function to call when an unknown identifier is requested.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
missing_component_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 974
 -- : VAL = missing_component_hook ()
 -- : OLD_VAL = missing_component_hook (NEW_VAL)
 -- : missing_component_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to call when a component of Octave is missing.

     This can be useful for packagers that may split the Octave installation into multiple sub-packages, for example, to provide a hint to users for how to install the missing components.

     When called from inside a function with the "local" option, the variable is changed locally for the function and any subroutines it calls.  The original variable value is restored when exiting the function.

     The hook function is expected to be of the form

          FCN (COMPONENT)

     Octave will call FCN with the name of the function that requires the component and a string describing the missing component.  The hook function should return an error message to be displayed.

     See also: missing_function_hook.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Query or set the internal variable that specifies the function to call when a component of Octave is missing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
autoload


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1172
 -- : AUTOLOAD_MAP = autoload ()
 -- : autoload (FUNCTION, FILE)
 -- : autoload (..., "remove")
     Define FUNCTION to autoload from FILE.

     The second argument, FILE, should be an absolute filename or a file name in the same directory as the function or script from which the autoload command was run.  FILE _should not_ depend on the Octave load path.

     Normally, calls to ‘autoload’ appear in PKG_ADD script files that are evaluated when a directory is added to Octave’s load path.  To avoid having to hardcode directory names in FILE, if FILE is in the same directory as the PKG_ADD script then

          autoload ("foo", "bar.oct");

     will load the function ‘foo’ from the file ‘bar.oct’.  The above usage when ‘bar.oct’ is not in the same directory, or usages such as

          autoload ("foo", file_in_loadpath ("bar.oct"))

     are strongly discouraged, as their behavior may be unpredictable.

     With no arguments, return a structure containing the current autoload map.

     If a third argument "remove" is given, the function is cleared and not loaded anymore during the current Octave session.

     See also: PKG_ADD.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Define FUNCTION to autoload from FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mfilename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- : mfilename ()
 -- : mfilename ("fullpath")
 -- : mfilename ("fullpathext")
     Return the name of the currently executing file.

     When called from outside an m-file return the empty string.

     Given the argument "fullpath", include the directory part of the filename, but not the extension.

     Given the argument "fullpathext", include the directory part of the filename and the extension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the name of the currently executing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
source


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 484
 -- : source (FILE)
 -- : source (FILE, CONTEXT)
     Parse and execute the contents of FILE.

     Without specifying CONTEXT, this is equivalent to executing commands from a script file, but without requiring the file to be named ‘FILE.m’ or to be on the execution path.

     Instead of the current context, the script may be executed in either the context of the function that called the present function ("caller"), or the top-level context ("base").

     See also: run.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Parse and execute the contents of FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
feval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 898
 -- : feval (NAME, ...)
     Evaluate the function named NAME.

     Any arguments after the first are passed as inputs to the named function.  For example,

          feval ("acos", -1)
               ⇒ 3.1416

     calls the function ‘acos’ with the argument ‘-1’.

     The function ‘feval’ can also be used with function handles of any sort (*note Function Handles::).  Historically, ‘feval’ was the only way to call user-supplied functions in strings, but function handles are now preferred due to the cleaner syntax they offer.  For example,

          F = @exp;
          feval (F, 1)
              ⇒ 2.7183
          F (1)
              ⇒ 2.7183

     are equivalent ways to call the function referred to by F.  If it cannot be predicted beforehand whether F is a function handle, function name in a string, or inline function then ‘feval’ can be used instead.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Evaluate the function named NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
builtin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 622
 -- : [...] = builtin (F, ...)
     Call the base function F even if F is overloaded to another function for the given type signature.

     This is normally useful when doing object-oriented programming and there is a requirement to call one of Octave’s base functions rather than the overloaded one of a new class.

     A trivial example which redefines the ‘sin’ function to be the ‘cos’ function shows how ‘builtin’ works.

          sin (0)
            ⇒ 0
          function y = sin (x), y = cos (x); endfunction
          sin (0)
            ⇒ 1
          builtin ("sin", 0)
            ⇒ 0
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Call the base function F even if F is overloaded to another function for the given type signature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
eval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1192
 -- : eval (TRY)
 -- : eval (TRY, CATCH)
     Parse the string TRY and evaluate it as if it were an Octave program.

     If execution fails, evaluate the optional string CATCH.

     The string TRY is evaluated in the current context, so any results remain available after ‘eval’ returns.

     The following example creates the variable A with the approximate value of 3.1416 in the current workspace.

          eval ("A = acos(-1);");

     If an error occurs during the evaluation of TRY then the CATCH string is evaluated, as the following example shows:

          eval ('error ("This is a bad example");',
                'printf ("This error occurred:\n%s\n", lasterr ());');
               ⊣ This error occurred:
                  This is a bad example

     Programming Note: if you are only using ‘eval’ as an error-capturing mechanism, rather than for the execution of arbitrary code strings, Consider using try/catch blocks or unwind_protect/unwind_protect_cleanup blocks instead.  These techniques have higher performance and don’t introduce the security considerations that the evaluation of arbitrary code does.

     See also: evalin, evalc, assignin, feval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Parse the string TRY and evaluate it as if it were an Octave program.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
assignin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
 -- : assignin (CONTEXT, VARNAME, VALUE)
     Assign VALUE to VARNAME in context CONTEXT, which may be either "base" or "caller".

     See also: evalin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Assign VALUE to VARNAME in context CONTEXT, which may be either "base" or "caller".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
evalin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- : evalin (CONTEXT, TRY)
 -- : evalin (CONTEXT, TRY, CATCH)
     Like ‘eval’, except that the expressions are evaluated in the context CONTEXT, which may be either "caller" or "base".

     See also: eval, assignin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Like ‘eval’, except that the expressions are evaluated in the context CONTEXT, which may be either "caller" or "base".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
evalc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 760
 -- : S = evalc (TRY)
 -- : S = evalc (TRY, CATCH)
     Parse and evaluate the string TRY as if it were an Octave program, while capturing the output into the return variable S.

     If execution fails, evaluate the optional string CATCH.

     This function behaves like ‘eval’, but any output or warning messages which would normally be written to the console are captured and returned in the string S.

     The ‘diary’ is disabled during the execution of this function.  When ‘system’ is used, any output produced by external programs is _not_ captured, unless their output is captured by the ‘system’ function itself.

          s = evalc ("t = 42"), t
            ⇒ s = t =  42

            ⇒ t =  42

     See also: eval, diary.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Parse and evaluate the string TRY as if it were an Octave program, while capturing the output into the return variable S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
amd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1150
 -- : P = amd (S)
 -- : P = amd (S, OPTS)

     Return the approximate minimum degree permutation of a matrix.

     This is a permutation such that the Cholesky factorization of ‘S (P, P)’ tends to be sparser than the Cholesky factorization of S itself.  ‘amd’ is typically faster than ‘symamd’ but serves a similar purpose.

     The optional parameter OPTS is a structure that controls the behavior of ‘amd’.  The fields of the structure are

     OPTS.dense
          Determines what ‘amd’ considers to be a dense row or column of the input matrix.  Rows or columns with more than ‘max (16, (dense * sqrt (N)))’ entries, where N is the order of the matrix S, are ignored by ‘amd’ during the calculation of the permutation.  The value of dense must be a positive scalar and the default value is 10.0

     OPTS.aggressive
          If this value is a nonzero scalar, then ‘amd’ performs aggressive absorption.  The default is not to perform aggressive absorption.

     The author of the code itself is Timothy A. Davis (see <http://faculty.cse.tamu.edu/davis/suitesparse.html>).

     See also: symamd, colamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the approximate minimum degree permutation of a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
audiodevinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1246
 -- : DEVINFO = audiodevinfo ()

 -- : DEVS = audiodevinfo (IO)
 -- : NAME = audiodevinfo (IO, ID)
 -- : ID = audiodevinfo (IO, NAME)
 -- : ID = audiodevinfo (IO, RATE, BITS, CHANS)

 -- : SUPPORTS = audiodevinfo (IO, ID, RATE, BITS, CHANS)

     Return a structure describing the available audio input and output devices.

     The DEVINFO structure has two fields "input" and "output".  The value of each field is a structure array with fields "Name", "DriverVersion" and "ID" describing an audio device.

     If the optional argument IO is 1, return information about input devices only.  If it is 0, return information about output devices only.  If IO is the only argument supplied, return the number of input or output devices available.

     If the optional argument ID is provided, return information about the corresponding device.

     If the optional argument NAME is provided, return the id of the named device.

     Given a sampling rate, bits per sample, and number of channels for an input or output device, return the ID of the first device that supports playback or recording using the specified parameters.

     If also given a device ID, return true if the device supports playback or recording using those parameters.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return a structure describing the available audio input and output devices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
audioread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 706
 -- : [Y, FS] = audioread (FILENAME)
 -- : [Y, FS] = audioread (FILENAME, SAMPLES)

 -- : [Y, FS] = audioread (FILENAME, DATATYPE)
 -- : [Y, FS] = audioread (FILENAME, SAMPLES, DATATYPE)
     Read the audio file FILENAME and return the audio data Y and sampling rate FS.

     The audio data is stored as matrix with rows corresponding to audio frames and columns corresponding to channels.

     The optional two-element vector argument SAMPLES specifies starting and ending frames.

     The optional argument DATATYPE specifies the datatype to return.  If it is "native", then the type of data depends on how the data is stored in the audio file.

     See also: audiowrite, audioformats, audioinfo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Read the audio file FILENAME and return the audio data Y and sampling rate FS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
audiowrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 885
 -- : audiowrite (FILENAME, Y, FS)
 -- : audiowrite (FILENAME, Y, FS, NAME, VALUE, ...)

     Write audio data from the matrix Y to FILENAME at sampling rate FS with the file format determined by the file extension.

     Additional name/value argument pairs may be used to specify the following options:

     ‘BitsPerSample’
          Number of bits per sample.  Valid values are 8, 16, 24, and 32.  Default is 16.

     ‘BitRate’
          Valid argument name, but ignored.  Left for compatibility with MATLAB.

     ‘Quality’
          Quality setting for the Ogg Vorbis compressor.  Values can range between 0 and 100 with 100 being the highest quality setting.  Default is 75.

     ‘Title’
          Title for the audio file.

     ‘Artist’
          Artist name.

     ‘Comment’
          Comment.

     See also: audioread, audioformats, audioinfo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Write audio data from the matrix Y to FILENAME at sampling rate FS with the file format determined by the file extension.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
audioinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1101
 -- : INFO = audioinfo (FILENAME)
     Return information about an audio file specified by FILENAME.

     The output INFO is a structure containing the following fields:

     ‘Filename’
          Name of the audio file.

     ‘CompressionMethod’
          Audio compression method.  Unused, only present for compatibility with MATLAB.

     ‘NumChannels’
          Number of audio channels.

     ‘SampleRate’
          Sample rate of the audio, in Hertz.

     ‘TotalSamples’
          Number of samples in the file.

     ‘Duration’
          Duration of the audio, in seconds.

     ‘BitsPerSample’
          Number of bits per sample.

     ‘BitRate’
          Audio bit rate.  Unused, only present for compatibility with MATLAB.

     ‘Title’
          "Title" audio metadata value as a string, or empty if not present.

     ‘Artist’
          "Artist" audio metadata value as a string, or empty if not present.

     ‘Comment’
          "Comment" audio metadata value as a string, or empty if not present.

     See also: audioread, audiowrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return information about an audio file specified by FILENAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
audioformats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- : audioformats ()
 -- : audioformats (FORMAT)
     Display information about all supported audio formats.

     If the optional argument FORMAT is given, then display only formats with names that start with FORMAT.

     See also: audioread, audiowrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Display information about all supported audio formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ccolamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3715
 -- : P = ccolamd (S)
 -- : P = ccolamd (S, KNOBS)
 -- : P = ccolamd (S, KNOBS, CMEMBER)
 -- : [P, STATS] = ccolamd (...)

     Constrained column approximate minimum degree permutation.

     ‘P = ccolamd (S)’ returns the column approximate minimum degree permutation vector for the sparse matrix S.  For a non-symmetric matrix S, ‘S(:, P)’ tends to have sparser LU factors than S.  ‘chol (S(:, P)' * S(:, P))’ also tends to be sparser than ‘chol (S' * S)’.  ‘P = ccolamd (S, 1)’ optimizes the ordering for ‘lu (S(:, P))’.  The ordering is followed by a column elimination tree post-ordering.

     KNOBS is an optional 1-element to 5-element input vector, with a default value of ‘[0 10 10 1 0]’ if not present or empty.  Entries not present are set to their defaults.

     ‘KNOBS(1)’
          if nonzero, the ordering is optimized for ‘lu (S(:, p))’.  It will be a poor ordering for ‘chol (S(:, P)' * S(:, P))’.  This is the most important knob for ccolamd.

     ‘KNOBS(2)’
          if S is m-by-n, rows with more than ‘max (16, KNOBS(2) * sqrt (n))’ entries are ignored.

     ‘KNOBS(3)’
          columns with more than ‘max (16, KNOBS(3) * sqrt (min (M, N)))’ entries are ignored and ordered last in the output permutation (subject to the cmember constraints).

     ‘KNOBS(4)’
          if nonzero, aggressive absorption is performed.

     ‘KNOBS(5)’
          if nonzero, statistics and knobs are printed.

     CMEMBER is an optional vector of length n.  It defines the constraints on the column ordering.  If ‘CMEMBER(j) = C’, then column J is in constraint set C (C must be in the range 1 to n).  In the output permutation P, all columns in set 1 appear first, followed by all columns in set 2, and so on.  ‘CMEMBER = ones (1,n)’ if not present or empty.  ‘ccolamd (S, [], 1 : n)’ returns ‘1 : n’

     ‘P = ccolamd (S)’ is about the same as ‘P = colamd (S)’.  KNOBS and its default values differ.  ‘colamd’ always does aggressive absorption, and it finds an ordering suitable for both ‘lu (S(:, P))’ and ‘chol (S(:, P)' * S(:, P))’; it cannot optimize its ordering for ‘lu (S(:, P))’ to the extent that ‘ccolamd (S, 1)’ can.

     STATS is an optional 20-element output vector that provides data about the ordering and the validity of the input matrix S.  Ordering statistics are in ‘STATS(1 : 3)’.  ‘STATS(1)’ and ‘STATS(2)’ are the number of dense or empty rows and columns ignored by CCOLAMD and ‘STATS(3)’ is the number of garbage collections performed on the internal data structure used by CCOLAMD (roughly of size ‘2.2 * nnz (S) + 4 * M + 7 * N’ integers).

     ‘STATS(4 : 7)’ provide information if CCOLAMD was able to continue.  The matrix is OK if ‘STATS(4)’ is zero, or 1 if invalid.  ‘STATS(5)’ is the rightmost column index that is unsorted or contains duplicate entries, or zero if no such column exists.  ‘STATS(6)’ is the last seen duplicate or out-of-order row index in the column index given by ‘STATS(5)’, or zero if no such row index exists.  ‘STATS(7)’ is the number of duplicate or out-of-order row indices.  ‘STATS(8 : 20)’ is always zero in the current version of CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.  See <http://faculty.cse.tamu.edu/davis/suitesparse.html> for ccolamd, csymamd, amd, colamd, symamd, and other related orderings.

     See also: colamd, csymamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Constrained column approximate minimum degree permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
csymamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2587
 -- : P = csymamd (S)
 -- : P = csymamd (S, KNOBS)
 -- : P = csymamd (S, KNOBS, CMEMBER)
 -- : [P, STATS] = csymamd (...)

     For a symmetric positive definite matrix S, return the permutation vector P such that ‘S(P,P)’ tends to have a sparser Cholesky factor than S.

     Sometimes ‘csymamd’ works well for symmetric indefinite matrices too.  The matrix S is assumed to be symmetric; only the strictly lower triangular part is referenced.  S must be square.  The ordering is followed by an elimination tree post-ordering.

     KNOBS is an optional 1-element to 3-element input vector, with a default value of ‘[10 1 0]’.  Entries not present are set to their defaults.

     ‘KNOBS(1)’
          If S is n-by-n, then rows and columns with more than ‘max(16,KNOBS(1)*sqrt(n))’ entries are ignored, and ordered last in the output permutation (subject to the cmember constraints).

     ‘KNOBS(2)’
          If nonzero, aggressive absorption is performed.

     ‘KNOBS(3)’
          If nonzero, statistics and knobs are printed.

     CMEMBER is an optional vector of length n.  It defines the constraints on the ordering.  If ‘CMEMBER(j) = S’, then row/column j is in constraint set C (C must be in the range 1 to n).  In the output permutation P, rows/columns in set 1 appear first, followed by all rows/columns in set 2, and so on.  ‘CMEMBER = ones (1,n)’ if not present or empty.  ‘csymamd (S,[],1:n)’ returns ‘1:n’.

     ‘P = csymamd (S)’ is about the same as ‘P = symamd (S)’.  KNOBS and its default values differ.

     ‘STATS(4:7)’ provide information if CCOLAMD was able to continue.  The matrix is OK if ‘STATS(4)’ is zero, or 1 if invalid.  ‘STATS(5)’ is the rightmost column index that is unsorted or contains duplicate entries, or zero if no such column exists.  ‘STATS(6)’ is the last seen duplicate or out-of-order row index in the column index given by ‘STATS(5)’, or zero if no such row index exists.  ‘STATS(7)’ is the number of duplicate or out-of-order row indices.  ‘STATS(8:20)’ is always zero in the current version of CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.  See <http://faculty.cse.tamu.edu/davis/suitesparse.html> for ccolamd, colamd, csymamd, amd, colamd, symamd, and other related orderings.

     See also: symamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
For a symmetric positive definite matrix S, return the permutation vector P such that ‘S(P,P)’ tends to have a sparser Cholesky factor than S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
chol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1947
 -- : R = chol (A)
 -- : [R, P] = chol (A)
 -- : [R, P, Q] = chol (A)
 -- : [R, P, Q] = chol (A, "vector")
 -- : [L, ...] = chol (..., "lower")
 -- : [R, ...] = chol (..., "upper")
     Compute the upper Cholesky factor, R, of the real symmetric or complex Hermitian positive definite matrix A.

     The upper Cholesky factor R is computed by using the upper triangular part of matrix A and is defined by

          R' * R = A.

     Calling ‘chol’ using the optional "upper" flag has the same behavior.  In contrast, using the optional "lower" flag, ‘chol’ returns the lower triangular factorization, computed by using the lower triangular part of matrix A, such that

          L * L' = A.

     Called with one output argument ‘chol’ fails if matrix A is not positive definite.  Note that if matrix A is not real symmetric or complex Hermitian then the lower triangular part is considered to be the (complex conjugate) transpose of the upper triangular part, or vice versa, given the "lower" flag.

     Called with two or more output arguments P flags whether the matrix A was positive definite and ‘chol’ does not fail.  A zero value of P indicates that matrix A is positive definite and R gives the factorization.  Otherwise, P will have a positive value.

     If called with three output arguments matrix A must be sparse and a sparsity preserving row/column permutation is applied to matrix A prior to the factorization.  That is R is the factorization of ‘A(Q,Q)’ such that

          R' * R = Q' * A * Q.

     The sparsity preserving permutation is generally returned as a matrix.  However, given the optional flag "vector", Q will be returned as a vector such that

          R' * R = A(Q, Q).

     In general the lower triangular factorization is significantly faster for sparse matrices.

     See also: hess, lu, qr, qz, schur, svd, ichol, cholinv, chol2inv, cholupdate, cholinsert, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Compute the upper Cholesky factor, R, of the real symmetric or complex Hermitian positive definite matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cholinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 -- : cholinv (A)
     Compute the inverse of the symmetric positive definite matrix A using the Cholesky factorization.

     See also: chol, chol2inv, inv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Compute the inverse of the symmetric positive definite matrix A using the Cholesky factorization.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
chol2inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 329
 -- : chol2inv (U)
     Invert a symmetric, positive definite square matrix from its Cholesky decomposition, U.

     Note that U should be an upper-triangular matrix with positive diagonal elements.  ‘chol2inv (U)’ provides ‘inv (U'*U)’ but it is much faster than using ‘inv’.

     See also: chol, cholinv, inv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Invert a symmetric, positive definite square matrix from its Cholesky decomposition, U.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cholupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 638
 -- : [R1, INFO] = cholupdate (R, U, OP)
     Update or downdate a Cholesky factorization.

     Given an upper triangular matrix R and a column vector U, attempt to determine another upper triangular matrix R1 such that

        • R1’*R1 = R’*R + U*U’ if OP is "+"

        • R1’*R1 = R’*R - U*U’ if OP is "-"

     If OP is "-", INFO is set to

        • 0 if the downdate was successful,

        • 1 if R’*R - U*U’ is not positive definite,

        • 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and 2.

     See also: chol, cholinsert, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Update or downdate a Cholesky factorization.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cholinsert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 741
 -- : R1 = cholinsert (R, J, U)
 -- : [R1, INFO] = cholinsert (R, J, U)
     Update a Cholesky factorization given a row or column to insert in the original factored matrix.

     Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix A = R’*R, R upper triangular, return the Cholesky factorization of A1, where A1(p,p) = A, A1(:,j) = A1(j,:)’ = u and p = [1:j-1,j+1:n+1].  u(j) should be positive.

     On return, INFO is set to

        • 0 if the insertion was successful,

        • 1 if A1 is not positive definite,

        • 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and 2.

     See also: chol, cholupdate, choldelete, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Update a Cholesky factorization given a row or column to insert in the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
choldelete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 400
 -- : R1 = choldelete (R, J)
     Update a Cholesky factorization given a row or column to delete from the original factored matrix.

     Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix A = R’*R, R upper triangular, return the Cholesky factorization of A(p,p), where p = [1:j-1,j+1:n+1].

     See also: chol, cholupdate, cholinsert, cholshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Update a Cholesky factorization given a row or column to delete from the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cholshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 520
 -- : R1 = cholshift (R, I, J)
     Update a Cholesky factorization given a range of columns to shift in the original factored matrix.

     Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix A = R’*R, R upper triangular, return the Cholesky factorization of A(p,p), where p is the permutation
     ‘p = [1:i-1, shift(i:j, 1), j+1:n]’ if I < J
     or
     ‘p = [1:j-1, shift(j:i,-1), i+1:n]’ if J < I.

     See also: chol, cholupdate, cholinsert, choldelete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Update a Cholesky factorization given a range of columns to shift in the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
colamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3340
 -- : P = colamd (S)
 -- : P = colamd (S, KNOBS)
 -- : [P, STATS] = colamd (S)
 -- : [P, STATS] = colamd (S, KNOBS)

     Compute the column approximate minimum degree permutation.

     ‘P = colamd (S)’ returns the column approximate minimum degree permutation vector for the sparse matrix S.  For a non-symmetric matrix S, ‘S(:,P)’ tends to have sparser LU factors than S.  The Cholesky factorization of ‘S(:,P)' * S(:,P)’ also tends to be sparser than that of ‘S' * S’.

     KNOBS is an optional one- to three-element input vector.  If S is m-by-n, then rows with more than ‘max(16,KNOBS(1)*sqrt(n))’ entries are ignored.  Columns with more than ‘max (16,KNOBS(2)*sqrt(min(m,n)))’ entries are removed prior to ordering, and ordered last in the output permutation P.  Only completely dense rows or columns are removed if ‘KNOBS(1)’ and ‘KNOBS(2)’ are < 0, respectively.  If ‘KNOBS(3)’ is nonzero, STATS and KNOBS are printed.  The default is ‘KNOBS = [10 10 0]’.  Note that KNOBS differs from earlier versions of colamd.

     STATS is an optional 20-element output vector that provides data about the ordering and the validity of the input matrix S.  Ordering statistics are in ‘STATS(1:3)’.  ‘STATS(1)’ and ‘STATS(2)’ are the number of dense or empty rows and columns ignored by COLAMD and ‘STATS(3)’ is the number of garbage collections performed on the internal data structure used by COLAMD (roughly of size ‘2.2 * nnz(S) + 4 * M + 7 * N’ integers).

     Octave built-in functions are intended to generate valid sparse matrices, with no duplicate entries, with ascending row indices of the nonzeros in each column, with a non-negative number of entries in each column (!)  and so on.  If a matrix is invalid, then COLAMD may or may not be able to continue.  If there are duplicate entries (a row index appears two or more times in the same column) or if the row indices in a column are out of order, then COLAMD can correct these errors by ignoring the duplicate entries and sorting each column of its internal copy of the matrix S (the input matrix S is not repaired, however).  If a matrix is invalid in other ways then COLAMD cannot continue, an error message is printed, and no output arguments (P or STATS) are returned.  COLAMD is thus a simple way to check a sparse matrix to see if it’s valid.

     ‘STATS(4:7)’ provide information if COLAMD was able to continue.  The matrix is OK if ‘STATS(4)’ is zero, or 1 if invalid.  ‘STATS(5)’ is the rightmost column index that is unsorted or contains duplicate entries, or zero if no such column exists.  ‘STATS(6)’ is the last seen duplicate or out-of-order row index in the column index given by ‘STATS(5)’, or zero if no such row index exists.  ‘STATS(7)’ is the number of duplicate or out-of-order row indices.  ‘STATS(8:20)’ is always zero in the current version of COLAMD (reserved for future use).

     The ordering is followed by a column elimination tree post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy A. Davis.  The algorithm was developed in collaboration with John Gilbert, Xerox PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see <http://faculty.cse.tamu.edu/davis/suitesparse.html>)

     See also: colperm, symamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the column approximate minimum degree permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symamd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3175
 -- : P = symamd (S)
 -- : P = symamd (S, KNOBS)
 -- : [P, STATS] = symamd (S)
 -- : [P, STATS] = symamd (S, KNOBS)

     For a symmetric positive definite matrix S, returns the permutation vector p such that ‘S(P, P)’ tends to have a sparser Cholesky factor than S.

     Sometimes ‘symamd’ works well for symmetric indefinite matrices too.  The matrix S is assumed to be symmetric; only the strictly lower triangular part is referenced.  S must be square.

     KNOBS is an optional one- to two-element input vector.  If S is n-by-n, then rows and columns with more than ‘max (16,KNOBS(1)*sqrt(n))’ entries are removed prior to ordering, and ordered last in the output permutation P.  No rows/columns are removed if ‘KNOBS(1) < 0’.  If ‘KNOBS(2)’ is nonzero, STATS and KNOBS are printed.  The default is ‘KNOBS = [10 0]’.  Note that KNOBS differs from earlier versions of ‘symamd’.

     STATS is an optional 20-element output vector that provides data about the ordering and the validity of the input matrix S.  Ordering statistics are in ‘STATS(1:3)’.  ‘STATS(1) = STATS(2)’ is the number of dense or empty rows and columns ignored by SYMAMD and ‘STATS(3)’ is the number of garbage collections performed on the internal data structure used by SYMAMD (roughly of size ‘8.4 * nnz (tril (S, -1)) + 9 * N’ integers).

     Octave built-in functions are intended to generate valid sparse matrices, with no duplicate entries, with ascending row indices of the nonzeros in each column, with a non-negative number of entries in each column (!)  and so on.  If a matrix is invalid, then SYMAMD may or may not be able to continue.  If there are duplicate entries (a row index appears two or more times in the same column) or if the row indices in a column are out of order, then SYMAMD can correct these errors by ignoring the duplicate entries and sorting each column of its internal copy of the matrix S (the input matrix S is not repaired, however).  If a matrix is invalid in other ways then SYMAMD cannot continue, an error message is printed, and no output arguments (P or STATS) are returned.  SYMAMD is thus a simple way to check a sparse matrix to see if it’s valid.

     ‘STATS(4:7)’ provide information if SYMAMD was able to continue.  The matrix is OK if ‘STATS (4)’ is zero, or 1 if invalid.  ‘STATS(5)’ is the rightmost column index that is unsorted or contains duplicate entries, or zero if no such column exists.  ‘STATS(6)’ is the last seen duplicate or out-of-order row index in the column index given by ‘STATS(5)’, or zero if no such row index exists.  ‘STATS(7)’ is the number of duplicate or out-of-order row indices.  ‘STATS(8:20)’ is always zero in the current version of SYMAMD (reserved for future use).

     The ordering is followed by a column elimination tree post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy A. Davis.  The algorithm was developed in collaboration with John Gilbert, Xerox PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see <http://faculty.cse.tamu.edu/davis/suitesparse.html>)

     See also: colperm, colamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
For a symmetric positive definite matrix S, returns the permutation vector p such that ‘S(P, P)’ tends to have a sparser Cholesky factor than S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
etree


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- : P = etree (S)
 -- : P = etree (S, TYP)
 -- : [P, Q] = etree (S, TYP)

     Return the elimination tree for the matrix S.

     By default S is assumed to be symmetric and the symmetric elimination tree is returned.  The argument TYP controls whether a symmetric or column elimination tree is returned.  Valid values of TYP are "sym" or "col", for symmetric or column elimination tree respectively.

     Called with a second argument, ‘etree’ also returns the postorder permutations on the tree.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the elimination tree for the matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
convhulln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1183
 -- : H = convhulln (PTS)
 -- : H = convhulln (PTS, OPTIONS)
 -- : [H, V] = convhulln (...)
     Compute the convex hull of the set of points PTS.

     PTS is a matrix of size [n, dim] containing n points in a space of dimension dim.

     The hull H is an index vector into the set of points and specifies which points form the enclosing hull.

     An optional second argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.  The default options depend on the dimension of the input:

        • 2D, 3D, 4D: OPTIONS = ‘{"Qt"}’

        • 5D and higher: OPTIONS = ‘{"Qt", "Qx"}’

     If OPTIONS is not present or ‘[]’ then the default arguments are used.  Otherwise, OPTIONS replaces the default argument list.  To append user options to the defaults it is necessary to repeat the default arguments in OPTIONS.  Use a null string to pass no arguments.

     If the second output V is requested the volume of the enclosing convex hull is calculated.

     See also: convhull, delaunayn, voronoin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the convex hull of the set of points PTS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dmperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 715
 -- : P = dmperm (S)
 -- : [P, Q, R, S] = dmperm (S)

     Perform a Dulmage-Mendelsohn permutation of the sparse matrix S.

     With a single output argument ‘dmperm’ performs the row permutations P such that ‘S(P,:)’ has no zero elements on the diagonal.

     Called with two or more output arguments, returns the row and column permutations, such that ‘S(P, Q)’ is in block triangular form.  The values of R and S define the boundaries of the blocks.  If S is square then ‘R == S’.

     The method used is described in: A. Pothen & C.-J. Fan.  ‘Computing the Block Triangular Form of a Sparse Matrix’.  ACM Trans.  Math.  Software, 16(4):303-324, 1990.

     See also: colamd, ccolamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Perform a Dulmage-Mendelsohn permutation of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sprank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 403
 -- : P = sprank (S)

     Calculate the structural rank of the sparse matrix S.

     Note that only the structure of the matrix is used in this calculation based on a Dulmage-Mendelsohn permutation to block triangular form.  As such the numerical rank of the matrix S is bounded by ‘sprank (S) >= rank (S)’.  Ignoring floating point errors ‘sprank (S) == rank (S)’.

     See also: dmperm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculate the structural rank of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fftw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3065
 -- : METHOD = fftw ("planner")
 -- : fftw ("planner", METHOD)
 -- : WISDOM = fftw ("dwisdom")
 -- : fftw ("dwisdom", WISDOM)
 -- : fftw ("threads", NTHREADS)
 -- : NTHREADS = fftw ("threads")

     Manage FFTW wisdom data.

     Wisdom data can be used to significantly accelerate the calculation of the FFTs, but implies an initial cost in its calculation.  When the FFTW libraries are initialized, they read a system wide wisdom file (typically in ‘/etc/fftw/wisdom’), allowing wisdom to be shared between applications other than Octave.  Alternatively, the ‘fftw’ function can be used to import wisdom.  For example,

          WISDOM = fftw ("dwisdom")

     will save the existing wisdom used by Octave to the string WISDOM.  This string can then be saved to a file and restored using the ‘save’ and ‘load’ commands respectively.  This existing wisdom can be re-imported as follows

          fftw ("dwisdom", WISDOM)

     If WISDOM is an empty string, then the wisdom used is cleared.

     During the calculation of Fourier transforms further wisdom is generated.  The fashion in which this wisdom is generated is also controlled by the ‘fftw’ function.  There are five different manners in which the wisdom can be treated:

     "estimate"
          Specifies that no run-time measurement of the optimal means of calculating a particular is performed, and a simple heuristic is used to pick a (probably sub-optimal) plan.  The advantage of this method is that there is little or no overhead in the generation of the plan, which is appropriate for a Fourier transform that will be calculated once.

     "measure"
          In this case a range of algorithms to perform the transform is considered and the best is selected based on their execution time.

     "patient"
          Similar to "measure", but a wider range of algorithms is considered.

     "exhaustive"
          Like "measure", but all possible algorithms that may be used to treat the transform are considered.

     "hybrid"
          As run-time measurement of the algorithm can be expensive, this is a compromise where "measure" is used for transforms up to the size of 8192 and beyond that the "estimate" method is used.

     The default method is "estimate".  The current method can be queried with

          METHOD = fftw ("planner")

     or set by using

          fftw ("planner", METHOD)

     Note that calculated wisdom will be lost when restarting Octave.  However, the wisdom data can be reloaded if it is saved to a file as described above.  Saved wisdom files should not be used on different platforms since they will not be efficient and the point of calculating the wisdom is lost.

     The number of threads used for computing the plans and executing the transforms can be set with

          fftw ("threads", NTHREADS)

     Note that octave must be compiled with multi-threaded FFTW support for this feature.  The number of processors available to the current process is used per default.

     See also: fft, ifft, fft2, ifft2, fftn, ifftn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Manage FFTW wisdom data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1031
 -- : FILELIST = gzip (FILES)
 -- : FILELIST = gzip (FILES, DIR)
     Compress the list of files and directories specified in FILES.

     FILES is a character array or cell array of strings.  Shell wildcards in the filename such as ‘*’ or ‘?’ are accepted and expanded.  Each file is compressed separately and a new file with a ‘".gz"’ extension is created.  The original files are not modified, but existing compressed files will be silently overwritten.  If a directory is specified then ‘gzip’ recursively compresses all files in the directory.

     If DIR is defined the compressed files are placed in this directory, rather than the original directory where the uncompressed file resides.  Note that this does not replicate a directory tree in DIR which may lead to files overwriting each other if there are multiple files with the same name.

     If DIR does not exist it is created.

     The optional output FILELIST is a list of the compressed files.

     See also: gunzip, unpack, bzip2, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compress the list of files and directories specified in FILES.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bzip2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 922
 -- : FILELIST = bzip2 (FILES)
 -- : FILELIST = bzip2 (FILES, DIR)
     Compress the list of files specified in FILES.

     FILES is a character array or cell array of strings.  Shell wildcards in the filename such as ‘*’ or ‘?’ are accepted and expanded.  Each file is compressed separately and a new file with a ‘".bz2"’ extension is created.  The original files are not modified, but existing compressed files will be silently overwritten.

     If DIR is defined the compressed files are placed in this directory, rather than the original directory where the uncompressed file resides.  Note that this does not replicate a directory tree in DIR which may lead to files overwriting each other if there are multiple files with the same name.

     If DIR does not exist it is created.

     The optional output FILELIST is a list of the compressed files.

     See also: bunzip2, unpack, gzip, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compress the list of files specified in FILES.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3632
 -- : [Q, R] = qr (A)
 -- : [Q, R, P] = qr (A) # non-sparse A
 -- : X = qr (A) # non-sparse A
 -- : R = qr (A) # sparse A
 -- : [C, R] = qr (A, B)
 -- : [...] = qr (..., 0)
 -- : [...] = qr (..., "vector")
 -- : [...] = qr (..., "matrix")
     Compute the QR factorization of A, using standard LAPACK subroutines.

     The QR factorization is

          Q * R = A

     where Q is an orthogonal matrix and R is upper triangular.

     For example, given the matrix ‘A = [1, 2; 3, 4]’,

          [Q, R] = qr (A)

     returns

          Q =

            -0.31623  -0.94868
            -0.94868   0.31623

          R =

            -3.16228  -4.42719
             0.00000  -0.63246

     which multiplied together return the original matrix

          Q * R
            ⇒
               1.0000   2.0000
               3.0000   4.0000

     If just a single return value is requested then it is either R, if A is sparse, or X, such that ‘R = triu (X)’ if A is full.  (Note: unlike most commands, the single return value is not the first return value when multiple values are requested.)

     If the matrix A is full, and a third output P is requested, then ‘qr’ calculates the permuted QR factorization

          Q * R = A * P

     where Q is an orthogonal matrix, R is upper triangular, and P is a permutation matrix.

     The permuted QR factorization has the additional property that the diagonal entries of R are ordered by decreasing magnitude.  In other words, ‘abs (diag (R))’ will be ordered from largest to smallest.

     For example, given the matrix ‘A = [1, 2; 3, 4]’,

          [Q, R, P] = qr (A)

     returns

          Q =

            -0.44721  -0.89443
            -0.89443   0.44721

          R =

            -4.47214  -3.13050
             0.00000   0.44721

          P =

             0  1
             1  0

     If the input matrix A is sparse then the sparse QR factorization is computed using CSPARSE.  Because the matrix Q is, in general, a full matrix, it is recommended to request only one return value R.  In that case, the computation avoids the construction of Q and returns R such that ‘R = chol (A' * A)’.

     If an additional matrix B is supplied and two return values are requested, then ‘qr’ returns C, where ‘C = Q' * B’.  This allows the least squares approximation of ‘A \ B’ to be calculated as

          [C, R] = qr (A, B)
          X = R \ C

     If the final argument is the string "vector" then P is a permutation vector (of the columns of A) instead of a permutation matrix.  In this case, the defining relationship is

          Q * R = A(:, P)

     The default, however, is to return a permutation matrix and this may be explicitly specified by using a final argument of "matrix".

     If the final argument is the scalar 0 an "economy" factorization is returned.  When the original matrix A has size MxN and M > N then the "economy" factorization will calculate just N rows in R and N columns in Q and omit the zeros in R.  If M ≤ N there is no difference between the economy and standard factorizations.  When calculating an "economy" factorization the output P is always a vector rather than a matrix.

     Background: The QR factorization has applications in the solution of least squares problems

          min norm (A*x - b)

     for overdetermined systems of equations (i.e., A is a tall, thin matrix).

     The permuted QR factorization ‘[Q, R, P] = qr (A)’ allows the construction of an orthogonal basis of ‘span (A)’.

     See also: chol, hess, lu, qz, schur, svd, qrupdate, qrinsert, qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Compute the QR factorization of A, using standard LAPACK subroutines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 689
 -- : [Q1, R1] = qrupdate (Q, R, U, V)
     Update a QR factorization given update vectors or matrices.

     Given a QR factorization of a real or complex matrix A = Q*R, Q unitary and R upper trapezoidal, return the QR factorization of A + U*V’, where U and V are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update).  Notice that the latter case is done as a sequence of rank-1 updates; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch.

     The QR factorization supplied may be either full (Q is square) or economized (R is square).

     See also: qr, qrinsert, qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Update a QR factorization given update vectors or matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrinsert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1102
 -- : [Q1, R1] = qrinsert (Q, R, J, X, ORIENT)
     Update a QR factorization given a row or column to insert in the original factored matrix.

     Given a QR factorization of a real or complex matrix A = Q*R, Q unitary and R upper trapezoidal, return the QR factorization of [A(:,1:j-1) x A(:,j:n)], where U is a column vector to be inserted into A (if ORIENT is "col"), or the QR factorization of [A(1:j-1,:);x;A(:,j:n)], where X is a row vector to be inserted into A (if ORIENT is "row").

     The default value of ORIENT is "col".  If ORIENT is "col", U may be a matrix and J an index vector resulting in the QR factorization of a matrix B such that B(:,J) gives U and B(:,J) = [] gives A.  Notice that the latter case is done as a sequence of k insertions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch.

     If ORIENT is "col", the QR factorization supplied may be either full (Q is square) or economized (R is square).

     If ORIENT is "row", full factorization is needed.

     See also: qr, qrupdate, qrdelete, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Update a QR factorization given a row or column to insert in the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qrdelete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1035
 -- : [Q1, R1] = qrdelete (Q, R, J, ORIENT)
     Update a QR factorization given a row or column to delete from the original factored matrix.

     Given a QR factorization of a real or complex matrix A = Q*R, Q unitary and R upper trapezoidal, return the QR factorization of [A(:,1:j-1), U, A(:,j:n)], where U is a column vector to be inserted into A (if ORIENT is "col"), or the QR factorization of [A(1:j-1,:);X;A(:,j:n)], where X is a row ORIENT is "row").  The default value of ORIENT is "col".

     If ORIENT is "col", J may be an index vector resulting in the QR factorization of a matrix B such that A(:,J) = [] gives B.  Notice that the latter case is done as a sequence of k deletions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch.

     If ORIENT is "col", the QR factorization supplied may be either full (Q is square) or economized (R is square).

     If ORIENT is "row", full factorization is needed.

     See also: qr, qrupdate, qrinsert, qrshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Update a QR factorization given a row or column to delete from the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qrshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- : [Q1, R1] = qrshift (Q, R, I, J)
     Update a QR factorization given a range of columns to shift in the original factored matrix.

     Given a QR factorization of a real or complex matrix A = Q*R, Q unitary and R upper trapezoidal, return the QR factorization of A(:,p), where p is the permutation
     ‘p = [1:i-1, shift(i:j, 1), j+1:n]’ if I < J
     or
     ‘p = [1:j-1, shift(j:i,-1), i+1:n]’ if J < I.

     See also: qr, qrupdate, qrinsert, qrdelete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Update a QR factorization given a range of columns to shift in the original factored matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
symbfact


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1552
 -- : [COUNT, H, PARENT, POST, R] = symbfact (S)
 -- : [...] = symbfact (S, TYP)
 -- : [...] = symbfact (S, TYP, MODE)

     Perform a symbolic factorization analysis of the sparse matrix S.

     The input variables are

     S
          S is a real or complex sparse matrix.

     TYP
          Is the type of the factorization and can be one of

          "sym" (default)
               Factorize S.  Assumes S is symmetric and uses the upper triangular portion of the matrix.

          "col"
               Factorize S’ * S.

          "row"
               Factorize S * S’.

          "lo"
               Factorize S’.  Assumes S is symmetric and uses the lower triangular portion of the matrix.

     MODE
          When MODE is unspecified return the Cholesky factorization for R.  If MODE is "lower" or "L" then return the conjugate transpose R’ which is a lower triangular factor.  The conjugate transpose version is faster and uses less memory, but still returns the same values for all other outputs: COUNT, H, PARENT, and POST.

     The output variables are:

     COUNT
          The row counts of the Cholesky factorization as determined by TYP.  The computational difficulty of performing the true factorization using ‘chol’ is ‘sum (COUNT .^ 2)’.

     H
          The height of the elimination tree.

     PARENT
          The elimination tree itself.

     POST
          A sparse boolean matrix whose structure is that of the Cholesky factorization as determined by TYP.

     See also: chol, etree, treelayout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Perform a symbolic factorization analysis of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symrcm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 934
 -- : P = symrcm (S)
     Return the symmetric reverse Cuthill-McKee permutation of S.

     P is a permutation vector such that ‘S(P, P)’ tends to have its diagonal elements closer to the diagonal than S.  This is a good preordering for LU or Cholesky factorization of matrices that come from “long, skinny” problems.  It works for both symmetric and asymmetric S.

     The algorithm represents a heuristic approach to the NP-complete bandwidth minimization problem.  The implementation is based in the descriptions found in

     E. Cuthill, J. McKee.  ‘Reducing the Bandwidth of Sparse Symmetric Matrices’.  Proceedings of the 24th ACM National Conference, 157–172 1969, Brandon Press, New Jersey.

     A. George, J.W.H. Liu.  ‘Computer Solution of Large Sparse Positive Definite Systems’, Prentice Hall Series in Computational Mathematics, ISBN 0-13-165274-5, 1981.

     See also: colperm, colamd, symamd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the symmetric reverse Cuthill-McKee permutation of S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
!


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 -- : !
     Logical ’not’ operator.

     See also: ~, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Logical ’not’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
~


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- : ~
     Logical ’not’ operator.

     The symbol may also be used to discard outputs of a function that are unwanted without using a temporary variable.

          [~, IDX_OF_MAX] = max (X)

     See also: !, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Logical ’not’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
!=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- : !=
     Logical ’not equals’ operator.

     See also: ~=, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Logical ’not equals’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
~=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- : ~=
     Logical ’not equals’ operator.

     See also: !=, ne.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Logical ’not equals’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
"


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- : "
     String delimiter.

     Escape sequences within double-quoted strings are expanded.  I.e., "\n" is a 1-character string representing a newline.  See the single quote delimiter (’) to create strings without escape sequence processing.

     See also: ’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
String delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
#


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- : #
     Begin comment character.

     See also: %, #{.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
%


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- : %
     Begin comment character.

     See also: #, %{.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- : #{
     Begin block comment.

     There must be no other characters, other than whitespace, on the line before and after ‘#{’.  It is possible to nest block comments.

     See also: %{, #}, #.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- : %{
     Begin block comment.

     There must be no other characters, other than whitespace, on the line before and after ‘%{’.  It is possible to nest block comments.

     See also: #{, %}, %.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- : #}
     Close block comment.

     There must be no other characters, other than whitespace, on the line before and after ‘#}’.  It is possible to nest block comments.

     See also: %}, #{, #.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- : %}
     Close block comment.

     There must be no other characters, other than whitespace, on the line before and after ‘%}’.  It is possible to nest block comments.

     See also: #}, %{, %.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
...


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- : ...
     Continuation marker.

     Joins current line with following line before parsing.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Continuation marker.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- : &
     Element by element logical ’and’ operator.

     See also: &&, and.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Element by element logical ’and’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
&&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- : &&
     Logical ’and’ operator (with short-circuit evaluation).

     See also: &, and.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Logical ’and’ operator (with short-circuit evaluation).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
’


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- : '
     Matrix transpose operator or string delimiter.

     For complex matrices, computes the complex conjugate (Hermitian) transpose.

     The single quote character may also be used to delimit strings.  Escape sequences within single-quoted strings are not expanded.  I.e., ’\n’ is a 2-character string ’\’ and ’n’ rather than "\n" which is a single character representing a newline.

     See also: .’, transpose, ".
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Matrix transpose operator or string delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
(


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 -- : (
     Array index or function argument delimiter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
)


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 -- : )
     Array index or function argument delimiter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 -- : *
     Multiplication operator.

     See also: .*, times.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 260
 -- : **
     Power operator.

     This may return complex results for real inputs.  Use ‘realsqrt’, ‘cbrt’, ‘nthroot’, or ‘realpow’ to obtain real results when possible.

     See also: power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 260
 -- : ^
     Power operator.

     This may return complex results for real inputs.  Use ‘realsqrt’, ‘cbrt’, ‘nthroot’, or ‘realpow’ to obtain real results when possible.

     See also: power, **, .^, .**, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
+


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
 -- : +
     Addition operator.

     See also: plus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Addition operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
++


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- : ++
     Increment operator.

     As in C, may be applied as a prefix or postfix operator.

     See also: –.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Increment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
,


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- : ,
     Array index, function argument, or command separator.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Array index, function argument, or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
-


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 -- : -
     Subtraction or unary negation operator.

     See also: minus.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Subtraction or unary negation operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
–


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
 -- : --
     Decrement operator.

     As in C, may be applied as a prefix or postfix operator.

     See also: ++.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Decrement operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
.’


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- : .'
     Matrix transpose operator.

     For complex matrices, computes the transpose, _not_ the complex conjugate (Hermitian) transpose.

     See also: ’, transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Matrix transpose operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- : .*
     Element by element multiplication operator.

     See also: *, times.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
.**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- : .**
     Element by element power operator.

     If several complex results are possible, returns the one with smallest non-negative argument (angle).  Use ‘realpow’, ‘realsqrt’, ‘cbrt’, or ‘nthroot’ if a real result is preferred.

     See also: **, ^, .^, power, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- : .^
     Element by element power operator.

     If several complex results are possible, returns the one with smallest non-negative argument (angle).  Use ‘realpow’, ‘realsqrt’, ‘cbrt’, or ‘nthroot’ if a real result is preferred.

     See also: .**, ^, **, power, realpow, realsqrt, cbrt, nthroot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
./


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- : ./
     Element by element right division operator.

     See also: /, .\, rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
/


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
 -- : /
     Right division operator.

     See also: ./, \, rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- : .\
     Element by element left division operator.

     See also: \, ./, rdivide, mrdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Element by element left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 213
 -- : \
     Left division operator.

     Within double-quoted strings, ‘\’ is the line continuation marker used to join the current line with the following line.

     See also: .\, /, ldivide, mldivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
:


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 -- : :
     Select entire rows or columns of matrices.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Select entire rows or columns of matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
;


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 -- : ;
     Array row or command separator.

     See also: ,.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Array row or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
<


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 -- : <
     ’Less than’ operator.

     See also: lt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
’Less than’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
<=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 -- : <=
     ’Less than’ or ’equals’ operator.

     See also: le.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
’Less than’ or ’equals’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
 -- : =
     Assignment operator.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Assignment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
==


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
 -- : ==
     Equality test operator.

     See also: eq.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Equality test operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
>


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
 -- : >
     ’Greater than’ operator.

     See also: gt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
’Greater than’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
>=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
 -- : >=
     ’Greater than’ or ’equals’ operator.

     See also: ge.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
’Greater than’ or ’equals’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
[


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
 -- : [
     Return list delimiter.

     See also: ].
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
]


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
 -- : ]
     Return list delimiter.

     See also: [.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
|


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
 -- : |
     Element by element logical ’or’ operator.

     See also: ||, or.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Element by element logical ’or’ operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
||


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- : ||
     Logical ’or’ (with short-circuit evaluation) operator.

     See also: |, or.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Logical ’or’ (with short-circuit evaluation) operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
@


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 308
 -- : @
     Return handle to a function.

     Example:

          f = @plus;
          f (2, 2)
          ⇒  4

     (Note: @ also finds use in creating classes.  See manual chapter titled Object Oriented Programming for detailed description.)

     See also: function, functions, func2str, str2func.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return handle to a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
break


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : break
     Exit the innermost enclosing do, while, or for loop.

     See also: do, while, for, parfor, continue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Exit the innermost enclosing do, while, or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
case


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 273
 -- : case VALUE
 -- : case {VALUE, ...}
     A case statement in a switch block.

     Octave cases are exclusive and do not fall-through as do C-language cases.  A switch statement must have at least one case.  See ‘switch’ for an example.

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
A case statement in a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : catch
 -- : catch VALUE
     Begin the cleanup part of a try-catch block.

     See also: try.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Begin the cleanup part of a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
classdef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- : classdef
     Begin a classdef block.

     See also: properties, methods, events, enumeration.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Begin a classdef block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
continue


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- : continue
     Jump to the end of the innermost enclosing do, while, or for loop.

     See also: break, do, while, for, parfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Jump to the end of the innermost enclosing do, while, or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
do


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 241
 -- : do
     Begin a do-until loop.

     This differs from a while loop in that the body of the loop is executed at least once.

          i = 0;
          do
            i++
          until (i == 10)

     See also: for, until, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Begin a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
else


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- : else
     Alternate action for an if block.  See ‘if’ for an example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Alternate action for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
elseif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- : elseif (CONDITION)
     Alternate conditional test for an if block.  See ‘if’ for an example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Alternate conditional test for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
end_try_catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
 -- : end_try_catch
     Mark the end of a ‘try-catch’ block.

     See also: try, catch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Mark the end of a ‘try-catch’ block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
end_unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- : end_unwind_protect
     Mark the end of an unwind_protect block.

     See also: unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Mark the end of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
endclassdef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- : endclassdef
     Mark the end of a classdef definition.

     See also: classdef.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Mark the end of a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
endenumeration


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- : endenumeration
     Mark the end of an enumeration block in a classdef definition.

     See also: enumeration.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Mark the end of an enumeration block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endevents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- : endevents
     Mark the end of an events block in a classdef definition.

     See also: events.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Mark the end of an events block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
endfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- : endfor
     Mark the end of a for loop.  See ‘for’ for an example.

     See also: for.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
endfunction


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- : endfunction
     Mark the end of a function.

     See also: function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
endif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- : endif
     Mark the end of an if block.  See ‘if’ for an example.

     See also: if.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Mark the end of an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
endmethods


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- : endmethods
     Mark the end of a methods block in a classdef definition.

     See also: methods.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Mark the end of a methods block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endparfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : endparfor
     Mark the end of a parfor loop.  See ‘parfor’ for an example.

     See also: parfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Mark the end of a parfor loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
endproperties


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- : endproperties
     Mark the end of a properties block in a classdef definition.

     See also: properties.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Mark the end of a properties block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endswitch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- : endswitch
     Mark the end of a switch block.  See ‘switch’ for an example.

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Mark the end of a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endwhile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : endwhile
     Mark the end of a while loop.  See ‘while’ for an example.

     See also: do, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Mark the end of a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
enumeration


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 -- : enumeration
     Begin an enumeration block in a classdef definition.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Begin an enumeration block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
events


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 -- : events
     Begin an events block in a classdef definition.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Begin an events block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
for


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
 -- : for I = RANGE
     Begin a for loop.

          for i = 1:10
            i
          endfor

     See also: parfor, do, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Begin a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
function


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 409
 -- : function OUTPUTS = function_name (INPUT, ...)
 -- : function function_name (INPUT, ...)
 -- : function OUTPUTS = function_name
     Begin a function body with name ‘function_name’, with OUTPUTS as results, and with INPUTS as parameters.  The function can later be invoked in Octave using the syntax

          [OUTPUT1, OUTPUT2, ...] = function_name (INPUT1, INPUT2, ...)

     See also: return.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Begin a function body with name ‘function_name’, with OUTPUTS as results, and with INPUTS as parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
global


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- : global VAR
     Declare variables to have global scope.

          global X;
          if (isempty (X))
            x = 1;
          endif

     See also: persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Declare variables to have global scope.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
if


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- : if (COND) ... endif
 -- : if (COND) ... else ... endif
 -- : if (COND) ... elseif (COND) ... endif
 -- : if (COND) ... elseif (COND) ... else ... endif
     Begin an if block.

          x = 1;
          if (x == 1)
            disp ("one");
          elseif (x == 2)
            disp ("two");
          else
            disp ("not one or two");
          endif

     See also: switch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Begin an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
otherwise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- : otherwise
     The default statement in a switch block which is executed when no other case statements match the input.

     See also: switch, case.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
The default statement in a switch block which is executed when no other case statements match the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
parfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 205
 -- : parfor I = RANGE
 -- : parfor (I = RANGE, MAXPROC)
     Begin a for loop that may execute in parallel.

          parfor i = 1:10
            i
          endparfor

     See also: for, do, while.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Begin a for loop that may execute in parallel.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
persistent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 407
 -- : persistent VAR
     Declare variables as persistent.

     A variable that has been declared persistent within a function will retain its contents in memory between subsequent calls to the same function.  The difference between persistent variables and global variables is that persistent variables are local in scope to a particular function and are not visible elsewhere.

     See also: global.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Declare variables as persistent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
properties


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- : properties
     Begin a properties block in a classdef definition.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Begin a properties block in a classdef definition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
return


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
 -- : return
     Return from a function.

     See also: function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Return from a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
static


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- : static
     This statement has been deprecated in favor of ‘persistent’.

     See also: persistent.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
This statement has been deprecated in favor of ‘persistent’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
switch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 360
 -- : switch STATEMENT
     Begin a switch block.

          yesno = "yes";

          switch (yesno)
            case {"Yes" "yes" "YES" "y" "Y"}
              value = 1;
            case {"No" "no" "NO" "n" "N"}
              value = 0;
            otherwise
              error ("invalid value");
          endswitch

     See also: if, case, otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Begin a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
try


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- : try
     Begin a try-catch block.

     If an error occurs within a try block, then the catch code will be run and execution will proceed after the catch block (though it is often recommended to use the lasterr function to re-throw the error after cleanup is completed).

     See also: catch, unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
until


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
 -- : until (COND)
     End a do-until loop.  See ‘do’ for an example.

     See also: do.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
End a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- : unwind_protect
     Begin an unwind_protect block.

     If an error occurs within the first part of an unwind_protect block the commands within the unwind_protect_cleanup block are executed before the error is thrown.  If an error is not thrown, then the unwind_protect_cleanup block is still executed.  In other words, the unwind_protect_cleanup code is guaranteed to execute regardless of success or failure in the unwind_protect block.

     See also: unwind_protect_cleanup, try.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Begin an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
unwind_protect_cleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : unwind_protect_cleanup
     Begin the cleanup section of an unwind_protect block.

     See also: unwind_protect.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Begin the cleanup section of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
varargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- : varargin
     Pass an arbitrary number of arguments into a function.

     See also: varargout, nargin, isargout, nargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Pass an arbitrary number of arguments into a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
varargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- : varargout
     Pass an arbitrary number of arguments out of a function.

     See also: varargin, nargin, isargout, nargout, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Pass an arbitrary number of arguments out of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
while


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- : while
     Begin a while loop.

          i = 0;
          while (i < 10)
            i++
          endwhile

     See also: do, endwhile, for, until.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Begin a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
containers.Map


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1586
 -- : M = containers.Map ()
 -- : M = containers.Map (KEYS, VALS)
 -- : M = containers.Map (KEYS, VALS, "UniformValues", IS_UNIFORM)
 -- : M = containers.Map ("KeyType", KT, "ValueType", VT)

     Create an object of the containers.Map class that stores a list of key/value pairs.

     KEYS is an array of _unique_ keys for the map.  The keys can be numeric scalars or strings.  The type for numeric keys may be one of "double", "single", "int32", "uint32", "int64", or "uint64".  Other numeric or logical keys will be converted to "double".  A single string key may be entered as is.  Multiple string keys are entered as a cell array of strings.

     VALS is an array of values for the map with the _same_ number of elements as KEYS.

     When called with no input arguments a default map is created with strings as the key type and "any" as the value type.

     The "UniformValues" option specifies whether the values of the map must be strictly of the same type.  If IS_UNIFORM is true, any values which would be added to the map are first validated to ensure they are of the correct type.

     When called with "KeyType" and "ValueType" arguments, create an empty map with the specified types.  The inputs KT and VT are the types for the keys and values of the map respectively.  Allowed values for KT are "char", "double", "single", "int32", "uint32", "int64", "uint64".  Allowed values for VT are "any", "char", "double", "single", "int32", "uint32", "int64", "uint64", "logical".

     The return value M is an object of the containers.Map class.

     See also: struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Create an object of the containers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lin2mu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- : Y = lin2mu (X, N)
     Convert audio data from linear to mu-law.

     Mu-law values use 8-bit unsigned integers.  Linear values use N-bit signed integers or floating point values in the range -1 ≤ X ≤ 1 if N is 0.

     If N is not specified it defaults to 0, 8, or 16 depending on the range of values in X.

     See also: mu2lin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert audio data from linear to mu-law.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mu2lin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- : Y = mu2lin (X, N)
     Convert audio data from mu-law to linear.

     Mu-law values are 8-bit unsigned integers.  Linear values use N-bit signed integers or floating point values in the range -1 ≤ Y ≤ 1 if N is 0.

     If N is not specified it defaults to 0.

     See also: lin2mu.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert audio data from mu-law to linear.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
record


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 367
 -- : record (SEC)
 -- : record (SEC, FS)
     Record SEC seconds of audio from the system’s default audio input at a sampling rate of 8000 samples per second.

     If the optional argument FS is given, it specifies the sampling rate for recording.

     For more control over audio recording, use the ‘audiorecorder’ class.

     See also: sound, soundsc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Record SEC seconds of audio from the system’s default audio input at a sampling rate of 8000 samples per second.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sound


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 553
 -- : sound (Y)
 -- : sound (Y, FS)
 -- : sound (Y, FS, NBITS)
     Play audio data Y at sample rate FS to the default audio device.

     The audio signal Y can be a vector or a two-column array, representing mono or stereo audio, respectively.

     If FS is not given, a default sample rate of 8000 samples per second is used.

     The optional argument NBITS specifies the bit depth to play to the audio device and defaults to 8 bits.

     For more control over audio playback, use the ‘audioplayer’ class.

     See also: soundsc, record.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Play audio data Y at sample rate FS to the default audio device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
soundsc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 822
 -- : soundsc (Y)
 -- : soundsc (Y, FS)
 -- : soundsc (Y, FS, NBITS)
 -- : soundsc (..., [YMIN, YMAX])
     Scale the audio data Y and play it at sample rate FS to the default audio device.

     The audio signal Y can be a vector or a two-column array, representing mono or stereo audio, respectively.

     If FS is not given, a default sample rate of 8000 samples per second is used.

     The optional argument NBITS specifies the bit depth to play to the audio device and defaults to 8 bits.

     By default, Y is automatically normalized to the range [-1, 1].  If the range [YMIN, YMAX] is given, then elements of Y that fall within the range YMIN ≤ Y ≤ YMAX are scaled to the range [-1, 1] instead.

     For more control over audio playback, use the ‘audioplayer’ class.

     See also: sound, record.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Scale the audio data Y and play it at sample rate FS to the default audio device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
@audioplayer/audioplayer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 858
 -- : PLAYER = audioplayer (Y, FS)
 -- : PLAYER = audioplayer (Y, FS, NBITS)
 -- : PLAYER = audioplayer (Y, FS, NBITS, ID)
 -- : PLAYER = audioplayer (RECORDER)
 -- : PLAYER = audioplayer (RECORDER, ID)
     Create an audioplayer object that will play back data Y at sample rate FS.

     The optional arguments NBITS, and ID specify the bit depth and player device id, respectively.  Device IDs may be found using the audiodevinfo function.  Given an audioplayer object, use the data from the object to initialize the player.

     The signal Y can be a vector or a two-dimensional array.

     The following example will create an audioplayer object that will play back one second of white noise at 44100 sample rate using 8 bits per sample.

          y = 0.25 * randn (2, 44100);
          player = audioplayer (y, 44100, 8);
          play (player);
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Create an audioplayer object that will play back data Y at sample rate FS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
@audioplayer/disp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
 -- : disp (PLAYER)
     Display the properties of the audioplayer object PLAYER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Display the properties of the audioplayer object PLAYER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
@audioplayer/get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 396
 -- : VALUE = get (PLAYER, NAME)
 -- : VALUES = get (PLAYER)
     Return the VALUE of the property identified by NAME.

     If NAME is a cell array return the values of the properties identified by the elements of the cell array.  Given only the player object, return a scalar structure with values of all properties of PLAYER.  The field names of the structure correspond to property names.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the VALUE of the property identified by NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
@audioplayer/isplaying


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- : isplaying (PLAYER)
     Return true if the audioplayer object PLAYER is currently playing back audio and false otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Return true if the audioplayer object PLAYER is currently playing back audio and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
@audioplayer/pause


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 -- : pause (PLAYER)
     Pause the audioplayer PLAYER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Pause the audioplayer PLAYER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
@audioplayer/play


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- : play (PLAYER)
 -- : play (PLAYER, START)
 -- : play (PLAYER, LIMITS)
     Play audio stored in the audioplayer object PLAYER without blocking.

     Given optional argument start, begin playing at START samples in the recording.  Given a two-element vector LIMITS, begin and end playing at the number of samples specified by the elements of the vector.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Play audio stored in the audioplayer object PLAYER without blocking.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
@audioplayer/playblocking


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 383
 -- : playblocking (PLAYER)
 -- : playblocking (PLAYER, START)
 -- : playblocking (PLAYER, LIMITS)
     Play audio stored in the audioplayer object PLAYER with blocking.

     Given optional argument start, begin playing at START samples in the recording.  Given a two-element vector LIMITS, begin and end playing at the number of samples specified by the elements of the vector.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Play audio stored in the audioplayer object PLAYER with blocking.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
@audioplayer/resume


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- : resume (PLAYER)
     Resume playback for the paused audioplayer object PLAYER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Resume playback for the paused audioplayer object PLAYER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
@audioplayer/set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 464
 -- : set (PLAYER, NAME, VALUE)
 -- : set (PLAYER, PROPERTIES)
 -- : PROPERTIES = set (PLAYER)
     Set the value of property specified by NAME to a given VALUE.

     If NAME and VALUE are cell arrays, set each property to the corresponding value.  Given a structure of PROPERTIES with fields corresponding to property names, set the value of those properties to the field values.  Given only the audioplayer object, return a structure of settable properties.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Set the value of property specified by NAME to a given VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
@audioplayer/stop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- : stop (PLAYER)
     Stop the playback for the audioplayer PLAYER and reset the relevant variables to their starting values.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Stop the playback for the audioplayer PLAYER and reset the relevant variables to their starting values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
@audioplayer/subsasgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- : VALUE = subsasgn (PLAYER, IDX, RHS)
     Perform subscripted assignment on the audio player object PLAYER.

     Assign the value of RHS to the player property named by IDX.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Perform subscripted assignment on the audio player object PLAYER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
@audioplayer/subsref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 162
 -- : VALUE = subsref (PLAYER, IDX)
     Perform subscripted selection on the audio player object PLAYER.

     Return the player property value named by IDX.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Perform subscripted selection on the audio player object PLAYER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
@audiorecorder/audiorecorder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 443
 -- : RECORDER = audiorecorder ()
 -- : RECORDER = audiorecorder (FS, NBITS, CHANNELS)
 -- : RECORDER = audiorecorder (FS, NBITS, CHANNELS, ID)
     Create an audiorecorder object recording 8 bit mono audio at 8000 Hz sample rate.

     The optional arguments FS, NBITS, CHANNELS, and ID specify the sample rate, bit depth, number of channels and recording device id, respectively.  Device IDs may be found using the audiodevinfo function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Create an audiorecorder object recording 8 bit mono audio at 8000 Hz sample rate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
@audiorecorder/disp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- : disp (RECORDER)
     Display the properties of the audiorecorder object RECORDER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Display the properties of the audiorecorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
@audiorecorder/get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 408
 -- : VALUE = get (RECORDER, NAME)
 -- : VALUES = get (RECORDER)
     Return the VALUE of the property identified by NAME.

     If NAME is a cell array, return the values of the properties corresponding to the elements of the cell array.  Given only the recorder object, return a scalar structure with values of all properties of RECORDER.  The field names of the structure correspond to property names.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the VALUE of the property identified by NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
@audiorecorder/getaudiodata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 389
 -- : DATA = getaudiodata (RECORDER)
 -- : DATA = getaudiodata (RECORDER, DATATYPE)
     Return recorder audio data as a matrix with values between -1.0 and 1.0 and with as many columns as there are channels in the recorder.

     Given the optional argument DATATYPE, convert the recorded data to the specified type, which may be one of "double", "single", "int16", "int8" or "uint8".
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return recorder audio data as a matrix with values between -1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
@audiorecorder/getplayer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- : PLAYER = getplayer (RECORDER)
     Return an audioplayer object with data recorded by the audiorecorder object RECORDER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Return an audioplayer object with data recorded by the audiorecorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
@audiorecorder/isrecording


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
 -- : isrecording (RECORDER)
     Return true if the audiorecorder object RECORDER is currently recording audio and false otherwise.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return true if the audiorecorder object RECORDER is currently recording audio and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
@audiorecorder/pause


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
 -- : pause (RECORDER)
     Pause recording with audiorecorder object RECORDER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Pause recording with audiorecorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
@audiorecorder/play


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 398
 -- : PLAYER = play (RECORDER)
 -- : PLAYER = play (RECORDER, START)
 -- : PLAYER = play (RECORDER, [START, END])
     Play the audio recorded in RECORDER and return a corresponding audioplayer object.

     If the optional argument START is provided, begin playing START seconds in to the recording.

     If the optional argument END is provided, stop playing at END seconds in the recording.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Play the audio recorded in RECORDER and return a corresponding audioplayer object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
@audiorecorder/record


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 256
 -- : record (RECORDER)
 -- : record (RECORDER, LENGTH)
     Record audio without blocking using the audiorecorder object RECORDER until stopped or paused by the STOP or PAUSE method.

     Given the optional argument LENGTH, record for LENGTH seconds.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Record audio without blocking using the audiorecorder object RECORDER until stopped or paused by the STOP or PAUSE method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
@audiorecorder/recordblocking


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- : recordblocking (RECORDER, LENGTH)
     Record audio with blocking (synchronous I/O).

     The length of the recording in seconds (LENGTH) must be specified.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Record audio with blocking (synchronous I/O).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
@audiorecorder/resume


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
 -- : resume (RECORDER)
     Resume recording with the paused audiorecorder object RECORDER.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Resume recording with the paused audiorecorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
@audiorecorder/set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 482
 -- : set (RECORDER, NAME, VALUE)
 -- : set (RECORDER, PROPERTIES)
 -- : PROPERTIES = set (RECORDER)
     Set the value of property specified by NAME to a given VALUE.

     If NAME and VALUE are cell arrays of the same size, set each property to a corresponding value.  Given a structure with fields corresponding to property names, set the value of those properties to the corresponding field values.  Given only the recorder object, return a structure of settable properties.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Set the value of property specified by NAME to a given VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
@audiorecorder/stop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- : stop (RECORDER)
     Stop the audiorecorder object RECORDER and clean up any audio streams.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Stop the audiorecorder object RECORDER and clean up any audio streams.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
@audiorecorder/subsasgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- : VALUE = subsasgn (RECORDER, IDX, RHS)
     Perform subscripted assignment on the audio recorder object RECORDER.

     Assign the value of RHS to the recorder property named by IDX.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Perform subscripted assignment on the audio recorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
@audiorecorder/subsref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 170
 -- : VALUE = subsref (RECORDER, IDX)
     Perform subscripted selection on the audio recorder object RECORDER.

     Return the recorder property value named by IDX.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Perform subscripted selection on the audio recorder object RECORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 489
 -- : R = bitmax (PRECISION)

     ‘bitmax’ is deprecated and will be removed in Octave version 5.  Use ‘flintmax (precision) - 1’ for the equivalent functionality.

     Return the largest integer R that can be represented within a floating point value.

     The default class is "double", but "single" is a valid option.  On IEEE 754 compatible systems, ‘bitmax’ is 2^{53} - 1 for "double" and 2^{24} - 1 for "single".

     See also: flintmax, intmax, realmax, realmin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
‘bitmax’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
chop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- : chop (X, NDIGITS, BASE)

     ‘chop’ is deprecated and will be removed in Octave version 6.

     Truncate elements of X to a length of NDIGITS such that the resulting numbers are exactly divisible by BASE.

     If BASE is not specified it defaults to 10.

          format long
          chop (-pi, 5, 10)
             ⇒ -3.14200000000000
          chop (-pi, 5, 5)
             ⇒ -3.14150000000000
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
‘chop’ is deprecated and will be removed in Octave version 6.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
comma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
 -- : ,
     Array index, function argument, or command separator.

     See also: semicolon.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Array index, function argument, or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
desktop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 258
 -- : USED = desktop ("-inuse")

     ‘desktop’ is deprecated and will be removed in Octave version 6.  Use ‘isguirunning’ for the equivalent functionality.

     Return true if the desktop (GUI) is currently in use.

     See also: isguirunning.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
‘desktop’ is deprecated and will be removed in Octave version 6.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- : isstr (A)
     This function has been deprecated.  Use ischar instead.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 301
 -- : java2mat (JAVAOBJ)
     ‘java2mat’ is deprecated and will be removed in Octave version 6.

     For the next two releases, use ‘__java2mat__’ if necessary, and file a bug report explaining your programming use of ‘java2mat’ and how it can’t be done with other Octave functions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
‘java2mat’ is deprecated and will be removed in Octave version 6.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
mahalanobis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- : mahalanobis (X, Y)

     ‘mahalanobis’ is deprecated and will be removed in Octave version 5.  See the ‘mahal’ function in the statistics package from Octave-Forge for equivalent functionality.

     Return the Mahalanobis’ D-square distance between the multivariate samples X and Y.

     The data X and Y must have the same number of components (columns), but may have a different number of observations (rows).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
‘mahalanobis’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
md5sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 496
 -- : md5sum (FILE)
 -- : md5sum (STR, OPT)

     ‘md5sum’ is deprecated and will be removed in Octave version 5.  For equivalent functionality replace calls like ‘md5sum (FILE)’ with:

          hash ("md5", fileread (FILE))

     And calls like ‘md5sum (STR, true)’ with:

          hash ("md5", STR)

     Calculate the MD5 sum of the file FILE.

     If the second parameter OPT exists and is true, then calculate the MD5 sum of the string STR.

     See also: hash, fileread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
‘md5sum’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
octave_config_info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 447
 -- : octave_config_info ()
 -- : octave_config_info (OPTION)

     ‘octave_config_info’ is deprecated and will be removed in Octave version 5.  Use ‘__have_feature__ (OPTION)’ or ‘__octave_config_info__’ as a replacement.

     Return a structure containing configuration and installation information for Octave.

     If OPTION is a string, return the configuration information for the specified option.

     See also: computer.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
‘octave_config_info’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
onenormest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1381
 -- : [EST, V, W, ITER] = onenormest (A, T)
 -- : [EST, V, W, ITER] = onenormest (APPLY, APPLY_T, N, T)

     ‘onenormest’ is deprecated and will be removed in Octave version 5.  Use ‘normest1’ for the equivalent functionality.

     Apply Higham and Tisseur’s randomized block 1-norm estimator to matrix A using T test vectors.

     If T exceeds 5, then only 5 test vectors are used.

     If the matrix is not explicit, e.g., when estimating the norm of ‘inv (A)’ given an LU factorization, ‘onenormest’ applies A and its conjugate transpose through a pair of functions APPLY and APPLY_T, respectively, to a dense matrix of size N by T.  The implicit version requires an explicit dimension N.

     Returns the norm estimate EST, two vectors V and W related by norm ‘(W, 1) = EST * norm (V, 1)’, and the number of iterations ITER.  The number of iterations is limited to 10 and is at least 2.

     References:

        • N.J. Higham and F. Tisseur, ‘A Block Algorithm for Matrix 1-Norm Estimation, with an Application to 1-Norm Pseudospectra’.  SIMAX vol 21, no 4, pp 1185-1201.  <http://dx.doi.org/10.1137/S0895479899356080>

        • N.J. Higham and F. Tisseur, ‘A Block Algorithm for Matrix 1-Norm Estimation, with an Application to 1-Norm Pseudospectra’.  <http://citeseer.ist.psu.edu/223007.html>

     See also: condest, norm, cond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
‘onenormest’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
paren


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 -- : (
 -- : )
     Array index or function argument delimeter.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimeter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
semicolon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
 -- : ;
     Array row or command separator.

     See also: comma.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Array row or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- Function File: setstr (S)
     This function has been deprecated.  Use char instead.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- : sleep (SECONDS)

     ‘sleep’ is deprecated and will be removed in Octave version 5.  Use ‘pause’ instead.

     Suspend the execution of the program for the given number of seconds.

     See also: pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
‘sleep’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
tmpnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1086
 -- : FNAME = tmpnam ()
 -- : FNAME = tmpnam (DIR)
 -- : FNAME = tmpnam (DIR, PREFIX)
     ‘tmpnam’ is deprecated and will be removed in Octave version 6.  Use ‘tempname’ instead.

     Return a unique temporary filename as a string.

     If PREFIX is omitted, a value of "oct-" is used.

     If DIR is also omitted, the default directory for temporary files (‘P_tmpdir’ is used.  If DIR is provided, it must exist, otherwise the default directory for temporary files is used.

     Programming Note: Because the named file is not opened by ‘tmpnam’, it is possible, though relatively unlikely, that it will not be available by the time your program attempts to open it.  If this is a concern, see ‘tmpfile’.  The functions ‘tmpnam’ and ‘tempname’ are equivalent with the latter provided for MATLAB compatibility.

     *Caution*: ‘tmpnam’ will be removed in Octave version 6, or whatever the version number is two releases from 4.4.  Use the equivalent ‘tempname’ in all new code.

     See also: tempname, mkstemp, tempdir, P_tmpdir, tmpfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
‘tmpnam’ is deprecated and will be removed in Octave version 6.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- : toascii (STR)

     ‘toascii’ is deprecated and will be removed in Octave version 6.  Use ‘double’ instead.

     Return ASCII representation of STR in a matrix.

     For example:

          toascii ("ASCII"
               ⇒ [ 65, 83, 67, 73, 73 ]


     See also: double, char.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
‘toascii’ is deprecated and will be removed in Octave version 6.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
usleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 250
 -- : usleep (MICROSECONDS)

     ‘usleep’ is deprecated and will be removed in Octave version 5.  Use ‘pause’ instead.

     Suspend the execution of the program for the given number of microseconds (1e-6 seconds).

     See also: pause.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
‘usleep’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
wavread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1359
 -- : Y = wavread (FILENAME)
 -- : [Y, FS, NBITS] = wavread (FILENAME)
 -- : [...] = wavread (FILENAME, N)
 -- : [...] = wavread (FILENAME, [N1 N2])
 -- : [...] = wavread (..., DATATYPE)
 -- : SZ = wavread (FILENAME, "size")
 -- : [N_SAMP, N_CHAN] = wavread (FILENAME, "size")

     ‘wavread’ is deprecated and will be removed in Octave version 5.  Use ‘audioread’ for the equivalent functionality.

     Read the audio signal Y from the RIFF/WAVE sound file FILENAME.

     If the file contains multichannel data, then Y is a matrix with the channels represented as columns.

     If N is specified, only the first N samples of the file are returned.  If [N1 N2] is specified, only the range of samples from N1 to N2 is returned.  A value of ‘Inf’ can be used to represent the total number of samples in the file.

     If the option "size" is given, then the size of the audio signal is returned instead of the data.  The size is returned in a row vector of the form [SAMPLES CHANNELS].  If there are two output arguments, the number of samples is assigned to the first and the number of channels is assigned to the second.

     The optional return value FS is the sample rate of the audio file in Hz.  The optional return value NBITS is the number of bits per sample as encoded in the file.

     See also: audioread, audiowrite, wavwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
‘wavread’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
wavwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 695
 -- : wavwrite (Y, FILENAME)
 -- : wavwrite (Y, FS, FILENAME)
 -- : wavwrite (Y, FS, NBITS, FILENAME)

     ‘wavwrite’ is deprecated and will be removed in Octave version 5.  Use ‘audiowrite’ for the equivalent functionality.

     Write the audio signal Y to the RIFF/WAVE sound file FILENAME.

     If Y is a matrix, the columns represent multiple audio channels.

     The optional argument FS specifies the sample rate of the audio signal in Hz.

     The optional argument NBITS specifies the number of bits per sample to write to FILENAME.

     The default sample rate is 8000 Hz and the default bit depth is 16 bits per sample.

     See also: audiowrite, audioread, wavread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
‘wavwrite’ is deprecated and will be removed in Octave version 5.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acosd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : acosd (X)
     Compute the inverse cosine in degrees for each element of X.

     See also: cosd, acos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse cosine in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- : acot (X)
     Compute the inverse cotangent in radians for each element of X.

     See also: cot, acotd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the inverse cotangent in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acotd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : acotd (X)
     Compute the inverse cotangent in degrees for each element of X.

     See also: cotd, acot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the inverse cotangent in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acoth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : acoth (X)
     Compute the inverse hyperbolic cotangent of each element of X.

     See also: coth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse hyperbolic cotangent of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acsc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- : acsc (X)
     Compute the inverse cosecant in radians for each element of X.

     See also: csc, acscd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse cosecant in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- : acscd (X)
     Compute the inverse cosecant in degrees for each element of X.

     See also: cscd, acsc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute the inverse cosecant in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acsch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- : acsch (X)
     Compute the inverse hyperbolic cosecant of each element of X.

     See also: csch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse hyperbolic cosecant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- : asec (X)
     Compute the inverse secant in radians for each element of X.

     See also: sec, asecd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse secant in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asecd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : asecd (X)
     Compute the inverse secant in degrees for each element of X.

     See also: secd, asec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse secant in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- : asech (X)
     Compute the inverse hyperbolic secant of each element of X.

     See also: sech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the inverse hyperbolic secant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- : asind (X)
     Compute the inverse sine in degrees for each element of X.

     See also: sind, asin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse sine in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
atan2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
 -- : atan2d (Y, X)
     Compute atan (Y / X) in degrees for corresponding elements from Y and X.

     See also: tand, atan2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Compute atan (Y / X) in degrees for corresponding elements from Y and X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- : atand (X)
     Compute the inverse tangent in degrees for each element of X.

     See also: tand, atan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse tangent in degrees for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cosd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- : cosd (X)
     Compute the cosine for each element of X in degrees.

     Returns zero for elements where ‘(X-90)/180’ is an integer.

     See also: acosd, cos.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the cosine for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- : cot (X)
     Compute the cotangent for each element of X in radians.

     See also: acot, cotd, coth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute the cotangent for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cotd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- : cotd (X)
     Compute the cotangent for each element of X in degrees.

     See also: acotd, cot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute the cotangent for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
coth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- : coth (X)
     Compute the hyperbolic cotangent of each element of X.

     See also: acoth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the hyperbolic cotangent of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
csc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- : csc (X)
     Compute the cosecant for each element of X in radians.

     See also: acsc, cscd, csch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the cosecant for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
 -- : cscd (X)
     Compute the cosecant for each element of X in degrees.

     See also: acscd, csc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the cosecant for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
csch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- : csch (X)
     Compute the hyperbolic cosecant of each element of X.

     See also: acsch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the hyperbolic cosecant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- : sec (X)
     Compute the secant for each element of X in radians.

     See also: asec, secd, sech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the secant for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
secd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- : secd (X)
     Compute the secant for each element of X in degrees.

     See also: asecd, sec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the secant for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
 -- : sech (X)
     Compute the hyperbolic secant of each element of X.

     See also: asech.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the hyperbolic secant of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- : sind (X)
     Compute the sine for each element of X in degrees.

     Returns zero for elements where ‘X/180’ is an integer.

     See also: asind, sin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sine for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- : tand (X)
     Compute the tangent for each element of X in degrees.

     Returns zero for elements where ‘X/180’ is an integer and ‘Inf’ for elements where ‘(X-90)/180’ is an integer.

     See also: atand, tan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the tangent for each element of X in degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
accumarray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3946
 -- : accumarray (SUBS, VALS, SZ, FUNC, FILLVAL, ISSPARSE)
 -- : accumarray (SUBS, VALS, ...)

     Create an array by accumulating the elements of a vector into the positions defined by their subscripts.

     The subscripts are defined by the rows of the matrix SUBS and the values by VALS.  Each row of SUBS corresponds to one of the values in VALS.  If VALS is a scalar, it will be used for each of the row of SUBS.  If SUBS is a cell array of vectors, all vectors must be of the same length, and the subscripts in the Kth vector must correspond to the Kth dimension of the result.

     The size of the matrix will be determined by the subscripts themselves.  However, if SZ is defined it determines the matrix size.  The length of SZ must correspond to the number of columns in SUBS.  An exception is if SUBS has only one column, in which case SZ may be the dimensions of a vector and the subscripts of SUBS are taken as the indices into it.

     The default action of ‘accumarray’ is to sum the elements with the same subscripts.  This behavior can be modified by defining the FUNC function.  This should be a function or function handle that accepts a column vector and returns a scalar.  The result of the function should not depend on the order of the subscripts.

     The elements of the returned array that have no subscripts associated with them are set to zero.  Defining FILLVAL to some other value allows these values to be defined.  This behavior changes, however, for certain values of FUNC.  If FUNC is ‘@min’ (respectively, ‘@max’) then the result will be filled with the minimum (respectively, maximum) integer if VALS is of integral type, logical false (respectively, logical true) if VALS is of logical type, zero if FILLVAL is zero and all values are non-positive (respectively, non-negative), and NaN otherwise.

     By default ‘accumarray’ returns a full matrix.  If ISSPARSE is logically true, then a sparse matrix is returned instead.

     The following ‘accumarray’ example constructs a frequency table that in the first column counts how many occurrences each number in the second column has, taken from the vector X.  Note the usage of ‘unique’ for assigning to all repeated elements of X the same index (*note unique: XREFunique.).

          X = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
          [U, ~, J] = unique (X);
          [accumarray(J', 1), U']
            ⇒  2    89
                3    90
                2    91
                2    92
                3   100

     Another example, where the result is a multi-dimensional 3-D array and the default value (zero) appears in the output:

          accumarray ([1, 1, 1;
                       2, 1, 2;
                       2, 3, 2;
                       2, 1, 2;
                       2, 3, 2], 101:105)
          ⇒ ans(:,:,1) = [101, 0, 0; 0, 0, 0]
          ⇒ ans(:,:,2) = [0, 0, 0; 206, 0, 208]

     The sparse option can be used as an alternative to the ‘sparse’ constructor (*note sparse: XREFsparse.).  Thus

          sparse (I, J, SV)

     can be written with ‘accumarray’ as

          accumarray ([I, J], SV', [], [], 0, true)

     For repeated indices, ‘sparse’ adds the corresponding value.  To take the minimum instead, use ‘min’ as an accumulator function:

          accumarray ([I, J], SV', [], @min, 0, true)

     The complexity of accumarray in general for the non-sparse case is generally O(M+N), where N is the number of subscripts and M is the maximum subscript (linearized in multi-dimensional case).  If FUNC is one of ‘@sum’ (default), ‘@max’, ‘@min’ or ‘@(x) {x}’, an optimized code path is used.  Note that for general reduction function the interpreter overhead can play a major part and it may be more efficient to do multiple accumarray calls and compute the results in a vectorized manner.

     See also: accumdim, unique, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Create an array by accumulating the elements of a vector into the positions defined by their subscripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
accumdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1593
 -- : accumdim (SUBS, VALS, DIM, N, FUNC, FILLVAL)
     Create an array by accumulating the slices of an array into the positions defined by their subscripts along a specified dimension.

     The subscripts are defined by the index vector SUBS.  The dimension is specified by DIM.  If not given, it defaults to the first non-singleton dimension.  The length of SUBS must be equal to ‘size (VALS, DIM)’.

     The extent of the result matrix in the working dimension will be determined by the subscripts themselves.  However, if N is defined it determines this extent.

     The default action of ‘accumdim’ is to sum the subarrays with the same subscripts.  This behavior can be modified by defining the FUNC function.  This should be a function or function handle that accepts an array and a dimension, and reduces the array along this dimension.  As a special exception, the built-in ‘min’ and ‘max’ functions can be used directly, and ‘accumdim’ accounts for the middle empty argument that is used in their calling.

     The slices of the returned array that have no subscripts associated with them are set to zero.  Defining FILLVAL to some other value allows these values to be defined.

     An example of the use of ‘accumdim’ is:

          accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
                                      -5, -12,   8;
                                     -12,   2,   8;
                                     -10,   9,  -3;
                                      -5,  -3, -13])
          ⇒ [-10,-11,-1;-15,-3,5]

     See also: accumarray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 130
Create an array by accumulating the slices of an array into the positions defined by their subscripts along a specified dimension.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bincoeff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 525
 -- : bincoeff (N, K)
     Return the binomial coefficient of N and K.

     The binomial coefficient is defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)
           |   |  = -------------------------
           | k |               k!
           \   /

     For example:

          bincoeff (5, 2)
             ⇒ 10

     In most cases, the ‘nchoosek’ function is faster for small scalar integer arguments.  It also warns about loss of precision for big arguments.

     See also: nchoosek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the binomial coefficient of N and K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitcmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 365
 -- : bitcmp (A, K)
     Return the K-bit complement of integers in A.

     If K is omitted ‘k = log2 (flintmax) + 1’ is assumed.

          bitcmp (7,4)
            ⇒ 8
          dec2bin (11)
            ⇒ 1011
          dec2bin (bitcmp (11, 6))
            ⇒ 110100

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the K-bit complement of integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 287
 -- : C = bitget (A, N)
     Return the status of bit(s) N of the unsigned integers in A.

     The least significant bit is N = 1.

          bitget (100, 8:-1:1)
          ⇒ 0  1  1  0  0  1  0  0

     See also: bitand, bitor, bitxor, bitset, bitcmp, bitshift, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the status of bit(s) N of the unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 388
 -- : C = bitset (A, N)
 -- : C = bitset (A, N, VAL)
     Set or reset bit(s) N of the unsigned integers in A.

     VAL = 0 resets and VAL = 1 sets the bits.  The least significant bit is N = 1.  All variables must be the same size or scalars.

          dec2bin (bitset (10, 1))
            ⇒ 1011

     See also: bitand, bitor, bitxor, bitget, bitcmp, bitshift, intmax, flintmax.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Set or reset bit(s) N of the unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
blkdiag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 285
 -- : blkdiag (A, B, C, ...)
     Build a block diagonal matrix from A, B, C, ...

     All arguments must be numeric and either two-dimensional matrices or scalars.  If any argument is of type sparse, the output will also be sparse.

     See also: diag, horzcat, vertcat, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Build a block diagonal matrix from A, B, C, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cart2pol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 739
 -- : [THETA, R] = cart2pol (X, Y)
 -- : [THETA, R, Z] = cart2pol (X, Y, Z)
 -- : [THETA, R] = cart2pol (C)
 -- : [THETA, R, Z] = cart2pol (C)
 -- : P = cart2pol (...)

     Transform Cartesian coordinates to polar or cylindrical coordinates.

     The inputs X, Y (, and Z) must be the same shape, or scalar.  If called with a single matrix argument then each row of C represents the Cartesian coordinate (X, Y (, Z)).

     THETA describes the angle relative to the positive x-axis.

     R is the distance to the z-axis (0, 0, z).

     If only a single return argument is requested then return a matrix P where each row represents one polar/(cylindrical) coordinate (THETA, PHI (, Z)).

     See also: pol2cart, cart2sph, sph2cart.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Transform Cartesian coordinates to polar or cylindrical coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cart2sph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 694
 -- : [THETA, PHI, R] = cart2sph (X, Y, Z)
 -- : [THETA, PHI, R] = cart2sph (C)
 -- : S = cart2sph (...)
     Transform Cartesian coordinates to spherical coordinates.

     The inputs X, Y, and Z must be the same shape, or scalar.  If called with a single matrix argument then each row of C represents the Cartesian coordinate (X, Y, Z).

     THETA describes the angle relative to the positive x-axis.

     PHI is the angle relative to the xy-plane.

     R is the distance to the origin (0, 0, 0).

     If only a single return argument is requested then return a matrix S where each row represents one spherical coordinate (THETA, PHI, R).

     See also: sph2cart, cart2pol, pol2cart.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Transform Cartesian coordinates to spherical coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cell2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- : M = cell2mat (C)
     Convert the cell array C into a matrix by concatenating all elements of C into a hyperrectangle.

     Elements of C must be numeric, logical, or char matrices; or cell arrays; or structs; and ‘cat’ must be able to concatenate them together.

     See also: mat2cell, num2cell.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Convert the cell array C into a matrix by concatenating all elements of C into a hyperrectangle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
celldisp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 527
 -- : celldisp (C)
 -- : celldisp (C, NAME)
     Recursively display the contents of a cell array.

     By default the values are displayed with the name of the variable C.  However, this name can be replaced with the variable NAME.  For example:

          c = {1, 2, {31, 32}};
          celldisp (c, "b")
             ⇒
                b{1} =
                 1
                b{2} =
                 2
                b{3}{1} =
                 31
                b{3}{2} =
                 32

     See also: disp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Recursively display the contents of a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
circshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 913
 -- : Y = circshift (X, N)
 -- : Y = circshift (X, N, DIM)
     Circularly shift the values of the array X.

     N must be a vector of integers no longer than the number of dimensions in X.  The values of N can be either positive or negative, which determines the direction in which the values of X are shifted.  If an element of N is zero, then the corresponding dimension of X will not be shifted.

     If a scalar DIM is given then operate along the specified dimension.  In this case N must be a scalar as well.

     Examples:

          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          circshift (x, 1)
          ⇒  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, -2)
          ⇒  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, [0,1])
          ⇒  3, 1, 2
              6, 4, 5
              9, 7, 8

     See also: permute, ipermute, shiftdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Circularly shift the values of the array X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
common_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 653
 -- : [ERR, YI, ...] = common_size (XI, ...)
     Determine if all input arguments are either scalar or of common size.

     If true, ERR is zero, and YI is a matrix of the common size with all entries equal to XI if this is a scalar or XI otherwise.  If the inputs cannot be brought to a common size, ERR is 1, and YI is XI.  For example:

          [err, a, b] = common_size ([1 2; 3 4], 5)
               ⇒ err = 0
               ⇒ a = [ 1, 2; 3, 4 ]
               ⇒ b = [ 5, 5; 5, 5 ]

     This is useful for implementing functions where arguments can either be scalars or of common size.

     See also: size, size_equal, numel, ndims.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Determine if all input arguments are either scalar or of common size.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cplxpair


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1063
 -- : cplxpair (Z)
 -- : cplxpair (Z, TOL)
 -- : cplxpair (Z, TOL, DIM)
     Sort the numbers Z into complex conjugate pairs ordered by increasing real part.

     The negative imaginary complex numbers are placed first within each pair.  All real numbers (those with ‘abs (imag (Z)) / abs (Z) < TOL’) are placed after the complex pairs.

     TOL is a weighting factor in the range [0, 1) which determines the tolerance of the matching.  The default value is ‘100 * eps’ and the resulting tolerance for a given complex pair is ‘TOL * abs (Z(i)))’.

     By default the complex pairs are sorted along the first non-singleton dimension of Z.  If DIM is specified, then the complex pairs are sorted along this dimension.

     Signal an error if some complex numbers could not be paired.  Signal an error if all complex numbers are not exact conjugates (to within TOL).  Note that there is no defined order for pairs with identical real parts but differing imaginary parts.

          cplxpair (exp (2i*pi*[0:4]'/5)) == exp (2i*pi*[3; 2; 4; 1; 0]/5)
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Sort the numbers Z into complex conjugate pairs ordered by increasing real part.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cumtrapz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 942
 -- : Q = cumtrapz (Y)
 -- : Q = cumtrapz (X, Y)
 -- : Q = cumtrapz (..., DIM)
     Cumulative numerical integration of points Y using the trapezoidal method.

     ‘cumtrapz (Y)’ computes the cumulative integral of Y along the first non-singleton dimension.  Where ‘trapz’ reports only the overall integral sum, ‘cumtrapz’ reports the current partial sum value at each point of Y.

     When the argument X is omitted an equally spaced X vector with unit spacing (1) is assumed.  ‘cumtrapz (X, Y)’ evaluates the integral with respect to the spacing in X and the values in Y.  This is useful if the points in Y have been sampled unevenly.

     If the optional DIM argument is given, operate along this dimension.

     Application Note: If X is not specified then unit spacing will be used.  To scale the integral to the correct value you must multiply by the actual spacing value (deltaX).

     See also: trapz, cumsum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Cumulative numerical integration of points Y using the trapezoidal method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
curl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 922
 -- : [CX, CY, CZ, V] = curl (X, Y, Z, FX, FY, FZ)
 -- : [CZ, V] = curl (X, Y, FX, FY)
 -- : [...] = curl (FX, FY, FZ)
 -- : [...] = curl (FX, FY)
 -- : V = curl (...)
     Calculate curl of vector field given by the arrays FX, FY, and FZ or FX, FY respectively.

                            / d         d       d         d       d         d     \
          curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                            \ dy        dz      dz        dx      dx        dy    /

     The coordinates of the vector field can be given by the arguments X, Y, Z or X, Y respectively.  V calculates the scalar component of the angular velocity vector in direction of the z-axis for two-dimensional input.  For three-dimensional input the scalar rotation is calculated at each grid point in direction of the vector field at that point.

     See also: divergence, gradient, del2, cross.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Calculate curl of vector field given by the arrays FX, FY, and FZ or FX, FY respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dblquad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1182
 -- : dblquad (F, XA, XB, YA, YB)
 -- : dblquad (F, XA, XB, YA, YB, TOL)
 -- : dblquad (F, XA, XB, YA, YB, TOL, QUADF)
 -- : dblquad (F, XA, XB, YA, YB, TOL, QUADF, ...)
     Numerically evaluate the double integral of F.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must have the form z = f(x,y) where X is a vector and Y is a scalar.  It should return a vector of the same length and orientation as X.

     XA, YA and XB, YB are the lower and upper limits of integration for x and y respectively.  The underlying integrator determines whether infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to integrate each sub-integral.  The default value is 1e-6.

     The optional argument QUADF specifies which underlying integrator function to use.  Any choice but ‘quad’ is available and the default is ‘quadcc’.

     Additional arguments, are passed directly to F.  To use the default value for TOL or QUADF one may pass ’:’ or an empty matrix ([]).

     See also: integral2, integral3, triplequad, quad, quadv, quadl, quadgk, quadcc, trapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Numerically evaluate the double integral of F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
deal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 932
 -- : [R1, R2, ..., RN] = deal (A)
 -- : [R1, R2, ..., RN] = deal (A1, A2, ..., AN)

     Copy the input parameters into the corresponding output parameters.

     If only a single input parameter is supplied, its value is copied to each of the outputs.

     For example,

          [a, b, c] = deal (x, y, z);

     is equivalent to

          a = x;
          b = y;
          c = z;

     and

          [a, b, c] = deal (x);

     is equivalent to

          a = b = c = x;

     Programming Note: ‘deal’ is often used with comma separated lists derived from cell arrays or structures.  This is unnecessary as the interpreter can perform the same action without the overhead of a function call.  For example:

          c = {[1 2], "Three", 4};
          [x, y, z] = c{:}
          ⇒
             x =

                1   2

             y = Three
             z =  4

     See also: cell2struct, struct2cell, repmat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Copy the input parameters into the corresponding output parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
deg2rad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 551
 -- : RAD = deg2rad (DEG)

     Convert degrees to radians.

     The input DEG must be a scalar, vector, or N-dimensional array of double or single floating point values.  DEG may be complex in which case the real and imaginary components are converted separately.

     The output RAD is the same size and shape as DEG with degrees converted to radians using the conversion constant ‘pi/180’.

     Example:

          deg2rad ([0, 90, 180, 270, 360])
            ⇒  0.00000   1.57080   3.14159   4.71239   6.28319

     See also: rad2deg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Convert degrees to radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
del2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1273
 -- : L = del2 (M)
 -- : L = del2 (M, H)
 -- : L = del2 (M, DX, DY, ...)

     Calculate the discrete Laplace operator.

     For a 2-dimensional matrix M this is defined as

                1    / d^2            d^2         \
          L  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /

     For N-dimensional arrays the sum in parentheses is expanded to include second derivatives over the additional higher dimensions.

     The spacing between evaluation points may be defined by H, which is a scalar defining the equidistant spacing in all dimensions.  Alternatively, the spacing in each dimension may be defined separately by DX, DY, etc.  A scalar spacing argument defines equidistant spacing, whereas a vector argument can be used to specify variable spacing.  The length of the spacing vectors must match the respective dimension of M.  The default spacing value is 1.

     Dimensions with fewer than 3 data points are skipped.  Boundary points are calculated from the linear extrapolation of interior points.

     Example: Second derivative of 2*x^3

          f = @(x) 2*x.^3;
          dd = @(x) 12*x;
          x = 1:6;
          L = 4*del2 (f(x));
          assert (L, dd (x));

     See also: gradient, diff.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Calculate the discrete Laplace operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
divergence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 600
 -- : DIV = divergence (X, Y, Z, FX, FY, FZ)
 -- : DIV = divergence (FX, FY, FZ)
 -- : DIV = divergence (X, Y, FX, FY)
 -- : DIV = divergence (FX, FY)
     Calculate divergence of a vector field given by the arrays FX, FY, and FZ or FX, FY respectively.

                            d               d               d
          div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                            dx              dy              dz

     The coordinates of the vector field can be given by the arguments X, Y, Z or X, Y respectively.

     See also: curl, gradient, del2, dot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Calculate divergence of a vector field given by the arrays FX, FY, and FZ or FX, FY respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
flip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 740
 -- : flip (X)
 -- : flip (X, DIM)
     Return a copy of array X flipped across dimension DIM.

     If DIM is unspecified it defaults to the first non-singleton dimension.

     Examples:

          ## row vector
          flip ([1  2  3  4])
                ⇒  4  3  2  1

          ## column vector
          flip ([1; 2; 3; 4])
                ⇒  4
                    3
                    2
                    1

          ## 2-D matrix along dimension 1
          flip ([1 2; 3 4])
                ⇒  3  4
                    1  2

          ## 2-D matrix along dimension 2
          flip ([1 2; 3 4], 2)
                ⇒  2  1
                    4  3

     See also: fliplr, flipud, rot90, rotdim, permute, transpose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return a copy of array X flipped across dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
flipdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 281
 -- : flipdim (X)
 -- : flipdim (X, DIM)
     Flip array across dimension DIM.

     This function is an alias for ‘flip’ and exists for backwards and MATLAB compatibility.  See ‘flip’ for complete usage information.

     See also: flip, fliplr, flipud, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Flip array across dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fliplr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- : fliplr (X)
     Flip array left to right.

     Return a copy of X with the order of the columns reversed.  In other words, X is flipped left-to-right about a vertical axis.  For example:

          fliplr ([1, 2; 3, 4])
               ⇒  2  1
                   4  3

     See also: flipud, flip, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Flip array left to right.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
flipud


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- : flipud (X)
     Flip array upside down.

     Return a copy of X with the order of the rows reversed.  In other words, X is flipped upside-down about a horizontal axis.  For example:

          flipud ([1, 2; 3, 4])
               ⇒  3  4
                   1  2

     See also: fliplr, flip, rot90, rotdim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Flip array upside down.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gradient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1711
 -- : DX = gradient (M)
 -- : [DX, DY, DZ, ...] = gradient (M)
 -- : [...] = gradient (M, S)
 -- : [...] = gradient (M, X, Y, Z, ...)
 -- : [...] = gradient (F, X0)
 -- : [...] = gradient (F, X0, S)
 -- : [...] = gradient (F, X0, X, Y, ...)

     Calculate the gradient of sampled data or a function.

     If M is a vector, calculate the one-dimensional gradient of M.  If M is a matrix the gradient is calculated for each dimension.

     ‘[DX, DY] = gradient (M)’ calculates the one-dimensional gradient for X and Y direction if M is a matrix.  Additional return arguments can be use for multi-dimensional matrices.

     A constant spacing between two points can be provided by the S parameter.  If S is a scalar, it is assumed to be the spacing for all dimensions.  Otherwise, separate values of the spacing can be supplied by the X, ... arguments.  Scalar values specify an equidistant spacing.  Vector values for the X, ... arguments specify the coordinate for that dimension.  The length must match their respective dimension of M.

     At boundary points a linear extrapolation is applied.  Interior points are calculated with the first approximation of the numerical gradient

          y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).

     If the first argument F is a function handle, the gradient of the function at the points in X0 is approximated using central difference.  For example, ‘gradient (@cos, 0)’ approximates the gradient of the cosine function in the point x0 = 0.  As with sampled data, the spacing values between the points from which the gradient is estimated can be set via the S or DX, DY, ... arguments.  By default a spacing of 1 is used.

     See also: diff, del2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculate the gradient of sampled data or a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
idivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1332
 -- : idivide (X, Y, OP)
     Integer division with different rounding rules.

     The standard behavior of integer division such as ‘A ./ B’ is to round the result to the nearest integer.  This is not always the desired behavior and ‘idivide’ permits integer element-by-element division to be performed with different treatment for the fractional part of the division as determined by the OP flag.  OP is a string with one of the values:

     "fix"
          Calculate ‘A ./ B’ with the fractional part rounded towards zero.

     "round"
          Calculate ‘A ./ B’ with the fractional part rounded towards the nearest integer.

     "floor"
          Calculate ‘A ./ B’ with the fractional part rounded towards negative infinity.

     "ceil"
          Calculate ‘A ./ B’ with the fractional part rounded towards positive infinity.

     If OP is not given it defaults to "fix".  An example demonstrating these rounding rules is

          idivide (int8 ([-3, 3]), int8 (4), "fix")
            ⇒ int8 ([0, 0])
          idivide (int8 ([-3, 3]), int8 (4), "round")
            ⇒ int8 ([-1, 1])
          idivide (int8 ([-3, 3]), int8 (4), "floor")
            ⇒ int8 ([-1, 0])
          idivide (int8 ([-3, 3]), int8 (4), "ceil")
            ⇒ int8 ([0, 1])

     See also: ldivide, rdivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Integer division with different rounding rules.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
int2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 828
 -- : int2str (N)
     Convert an integer (or array of integers) to a string (or a character array).

          int2str (123)
               ⇒ "123"

          s = int2str ([1, 2, 3; 4, 5, 6])
               ⇒ s =
                  1  2  3
                  4  5  6

          whos s
               ⇒
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x7                         14  char

     This function is not very flexible.  For better control over the results, use ‘sprintf’ (*note Formatted Output::).

     Programming Notes:

     Non-integers are rounded to integers before display.  Only the real part of complex numbers is displayed.

     See also: sprintf, num2str, mat2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Convert an integer (or array of integers) to a string (or a character array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
integral


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2956
 -- : Q = integral (F, A, B)
 -- : Q = integral (F, A, B, PROP, VAL, ...)

     Numerically evaluate the integral of F from A to B using adaptive quadrature.

     ‘integral’ is a wrapper for ‘quadcc’ (general scalar integrands), ‘quadgk’ (integrals with specified integration paths), and ‘quadv’ (array-valued integrands) that is intended to provide MATLAB compatibility.  More control of the numerical integration may be achievable by calling the various quadrature functions directly.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be vectorized and return a vector of output values when given a vector of input values.

     A and B are the lower and upper limits of integration.  Either or both limits may be infinite or contain weak end singularities.  If either or both limits are complex, ‘integral’ will perform a straight line path integral.  Alternatively, a complex domain path can be specified using the "Waypoints" option (see below).

     Additional optional parameters can be specified using "PROPERTY", VALUE pairs.  Valid properties are:

     ‘Waypoints’
          Specifies points to be used in defining subintervals of the quadrature algorithm, or if A, B, or WAYPOINTS are complex then the quadrature is calculated as a contour integral along a piecewise continuous path.  For more detail see ‘quadgk’.

     ‘ArrayValued’
          ‘integral’ expects F to return a scalar value unless ARRAYVALUED is specified as true.  This option will cause ‘integral’ to perform the integration over the entire array and return Q with the same dimensions as returned by F.  For more detail see ‘quadv’.

     ‘AbsTol’
          Define the absolute error tolerance for the quadrature.  The default absolute tolerance is 1e-10 (1e-5 for single).

     ‘RelTol’
          Define the relative error tolerance for the quadrature.  The default relative tolerance is 1e-6 (1e-4 for single).

     Adaptive quadrature is used to minimize the estimate of error until the following is satisfied:

            ERROR <= max (ABSTOL, RELTOL*|Q|).

     Known MATLAB incompatibilities:

       1. If tolerances are left unspecified, and any integration limits or waypoints are of type ‘single’, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above.  If tighter tolerances are desired they must be specified.  MATLAB leaves the tighter tolerances appropriate for ‘double’ inputs in place regardless of the class of the integration limits.

       2. As a consequence of using ‘quadcc’, ‘quadgk’, and ‘quadv’, certain option combinations are not supported.  Currently, "ArrayValued" cannot be combined with "RelTol" or "Waypoints".

     See also: integral2, integral3, quad, quadgk, quadv, quadl, quadcc, trapz, dblquad, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Numerically evaluate the integral of F from A to B using adaptive quadrature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
integral2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3377
 -- : Q = integral2 (F, XA, XB, YA, YB)
 -- : Q = integral2 (F, XA, XB, YA, YB, PROP, VAL, ...)
 -- : [Q, ERR] = integral2 (...)

     Numerically evaluate the two-dimensional integral of F using adaptive quadrature over the two-dimensional domain defined by XA, XB, YA, YB (scalars may be finite or infinite).  Additionally, YA and YB may be scalar functions of X, allowing for integration over non-rectangular domains.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be of the form z = f(x,y) where X is a vector and Y is a scalar.  It should return a vector of the same length and orientation as X.

     Additional optional parameters can be specified using "PROPERTY", VALUE pairs.  Valid properties are:

     ‘AbsTol’
          Define the absolute error tolerance for the quadrature.  The default value is 1e-10 (1e-5 for single).

     ‘RelTol’
          Define the relative error tolerance for the quadrature.  The default value is 1e-6 (1e-4 for single).

     ‘Method’
          Specify the two-dimensional integration method to be used, with valid options being "auto" (default), "tiled", or "iterated".  When using "auto", Octave will choose the "tiled" method unless any of the integration limits are infinite.

     ‘Vectorized’
          Enable or disable vectorized integration.  A value of ‘false’ forces Octave to use only scalar inputs when calling the integrand, which enables integrands f(x,y) that have not been vectorized and only accept X and Y as scalars to be used.  The default value is ‘true’.

     Adaptive quadrature is used to minimize the estimate of error until the following is satisfied:

                  ERROR <= max (ABSTOL, RELTOL*|Q|)

     ERR is an approximate bound on the error in the integral ‘abs (Q - I)’, where I is the exact value of the integral.

     Example 1 : integrate a rectangular region in x-y plane

          F = @(X,Y) 2*ones (size (X));
          Q = integral2 (F, 0, 1, 0, 1)
            ⇒ Q =  2

     The result is a volume, which for this constant-value integrand, is just ‘LENGTH * WIDTH * HEIGHT’.

     Example 2 : integrate a triangular region in x-y plane

          F = @(X,Y) 2*ones (size (X));
          YMAX = @(X) 1 - X;
          Q = integral2 (F, 0, 1, 0, YMAX)
            ⇒ Q =  1

     The result is a volume, which for this constant-value integrand, is the Triangle Area x Height or ‘1/2 * BASE * WIDTH * HEIGHT’.

     Programming Notes: If there are singularities within the integration region it is best to split the integral and place the singularities on the boundary.

     Known MATLAB incompatibility: If tolerances are left unspecified, and any integration limits are of type ‘single’, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above.  If tighter tolerances are desired they must be specified.  MATLAB leaves the tighter tolerances appropriate for ‘double’ inputs in place regardless of the class of the integration limits.

     Reference: L.F. Shampine, ‘MATLAB program for quadrature in 2D’, Applied Mathematics and Computation, pp.  266–274, Vol 1, 2008.

     See also: quad2d, dblquad, integral, quad, quadgk, quadv, quadl, quadcc, trapz, integral3, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
Numerically evaluate the two-dimensional integral of F using adaptive quadrature over the two-dimensional domain defined by XA, XB, YA, YB (scalars may be finite or infinite).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
integral3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3454
 -- : Q = integral3 (F, XA, XB, YA, YB, ZA, ZB)
 -- : Q = integral3 (F, XA, XB, YA, YB, ZA, ZB, PROP, VAL, ...)

     Numerically evaluate the three-dimensional integral of F using adaptive quadrature over the three-dimensional domain defined by XA, XB, YA, YB, ZA, ZB (scalars may be finite or infinite).  Additionally, YA and YB may be scalar functions of X and ZA, and ZB maybe be scalar functions of X and Y, allowing for integration over non-rectangular domains.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be of the form z = f(x,y) where X is a vector and Y is a scalar.  It should return a vector of the same length and orientation as X.

     Additional optional parameters can be specified using "PROPERTY", VALUE pairs.  Valid properties are:

     ‘AbsTol’
          Define the absolute error tolerance for the quadrature.  The default value is 1e-10 (1e-5 for single).

     ‘RelTol’
          Define the relative error tolerance for the quadrature.  The default value is 1e-6 (1e-4 for single).

     ‘Method’
          Specify the two-dimensional integration method to be used, with valid options being "auto" (default), "tiled", or "iterated".  When using "auto", Octave will choose the "tiled" method unless any of the integration limits are infinite.

     ‘Vectorized’
          Enable or disable vectorized integration.  A value of ‘false’ forces Octave to use only scalar inputs when calling the integrand, which enables integrands f(x,y) that have not been vectorized and only accept X and Y as scalars to be used.  The default value is ‘true’.

     Adaptive quadrature is used to minimize the estimate of error until the following is satisfied:

                  ERROR <= max (ABSTOL, RELTOL*|Q|)

     ERR is an approximate bound on the error in the integral ‘abs (Q - I)’, where I is the exact value of the integral.

     Example 1 : integrate over a rectangular volume

          F = @(X,Y,Z) ones (size (X));
          Q = integral3 (F, 0, 1, 0, 1, 0, 1)
            ⇒ Q =  1

     For this constant-value integrand, the result is a volume which is just ‘LENGTH * WIDTH * HEIGHT’.

     Example 2 : integrate over a spherical volume

          F = @(X,Y) ones (size (X));
          YMAX = @(X) sqrt (1 - X.^2);
          ZMAX = @(X) sqrt (1 - X.^2 - Y.^2);
          Q = integral3 (F, 0, 1, 0, YMAX)
            ⇒ Q =  0.52360

     For this constant-value integrand, the result is a volume which is 1/8th of a unit sphere or ‘1/8 * 4/3 * pi’.

     Programming Notes: If there are singularities within the integration region it is best to split the integral and place the singularities on the boundary.

     Known MATLAB incompatibility: If tolerances are left unspecified, and any integration limits are of type ‘single’, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above.  If tighter tolerances are desired they must be specified.  MATLAB leaves the tighter tolerances appropriate for ‘double’ inputs in place regardless of the class of the integration limits.

     Reference: L.F. Shampine, ‘MATLAB program for quadrature in 2D’, Applied Mathematics and Computation, pp.  266–274, Vol 1, 2008.

     See also: triplequad, integral, quad, quadgk, quadv, quadl, quadcc, trapz, integral2, quad2d, dblquad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 187
Numerically evaluate the three-dimensional integral of F using adaptive quadrature over the three-dimensional domain defined by XA, XB, YA, YB, ZA, ZB (scalars may be finite or infinite).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3112
 -- : YI = interp1 (X, Y, XI)
 -- : YI = interp1 (Y, XI)
 -- : YI = interp1 (..., METHOD)
 -- : YI = interp1 (..., EXTRAP)
 -- : YI = interp1 (..., "left")
 -- : YI = interp1 (..., "right")
 -- : PP = interp1 (..., "pp")

     One-dimensional interpolation.

     Interpolate input data to determine the value of YI at the points XI.  If not specified, X is taken to be the indices of Y (‘1:length (Y)’).  If Y is a matrix or an N-dimensional array, the interpolation is performed on each column of Y.

     The interpolation METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "previous"
          Return the previous neighbor.

     "next"
          Return the next neighbor.

     "linear" (default)
          Linear interpolation from nearest neighbors.

     "pchip"
          Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative.

     "cubic"
          Cubic interpolation (same as "pchip").

     "spline"
          Cubic spline interpolation—smooth first and second derivatives throughout the curve.

     Adding ’*’ to the start of any method above forces ‘interp1’ to assume that X is uniformly spaced, and only ‘X(1)’ and ‘X(2)’ are referenced.  This is usually faster, and is never slower.  The default method is "linear".

     If EXTRAP is the string "extrap", then extrapolate values beyond the endpoints using the current METHOD.  If EXTRAP is a number, then replace values beyond the endpoints with that number.  When unspecified, EXTRAP defaults to ‘NA’.

     If the string argument "pp" is specified, then XI should not be supplied and ‘interp1’ returns a piecewise polynomial object.  This object can later be used with ‘ppval’ to evaluate the interpolation.  There is an equivalence, such that ‘ppval (interp1 (X, Y, METHOD, "pp"), XI) == interp1 (X, Y, XI, METHOD, "extrap")’.

     Duplicate points in X specify a discontinuous interpolant.  There may be at most 2 consecutive points with the same value.  If X is increasing, the default discontinuous interpolant is right-continuous.  If X is decreasing, the default discontinuous interpolant is left-continuous.  The continuity condition of the interpolant may be specified by using the options "left" or "right" to select a left-continuous or right-continuous interpolant, respectively.  Discontinuous interpolation is only allowed for "nearest" and "linear" methods; in all other cases, the X-values must be unique.

     An example of the use of ‘interp1’ is

          xf = [0:0.05:10];
          yf = sin (2*pi*xf/5);
          xp = [0:10];
          yp = sin (2*pi*xp/5);
          lin = interp1 (xp, yp, xf);
          near = interp1 (xp, yp, xf, "nearest");
          pch = interp1 (xp, yp, xf, "pchip");
          spl = interp1 (xp, yp, xf, "spline");
          plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xf,pch,"c", xf,spl,"m",
                xp,yp,"r*");
          legend ("original", "nearest", "linear", "pchip", "spline");

     See also: pchip, spline, interpft, interp2, interp3, interpn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
One-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2141
 -- : ZI = interp2 (X, Y, Z, XI, YI)
 -- : ZI = interp2 (Z, XI, YI)
 -- : ZI = interp2 (Z, N)
 -- : ZI = interp2 (Z)
 -- : ZI = interp2 (..., METHOD)
 -- : ZI = interp2 (..., METHOD, EXTRAP)

     Two-dimensional interpolation.

     Interpolate reference data X, Y, Z to determine ZI at the coordinates XI, YI.  The reference data X, Y can be matrices, as returned by ‘meshgrid’, in which case the sizes of X, Y, and Z must be equal.  If X, Y are vectors describing a grid then ‘length (X) == columns (Z)’ and ‘length (Y) == rows (Z)’.  In either case the input data must be strictly monotonic.

     If called without X, Y, and just a single reference data matrix Z, the 2-D region ‘X = 1:columns (Z), Y = 1:rows (Z)’ is assumed.  This saves memory if the grid is regular and the distance between points is not important.

     If called with a single reference data matrix Z and a refinement value N, then perform interpolation over a grid where each original interval has been recursively subdivided N times.  This results in ‘2^N-1’ additional points for every interval in the original grid.  If N is omitted a value of 1 is used.  As an example, the interval [0,1] with ‘N==2’ results in a refined interval with points at [0, 1/4, 1/2, 3/4, 1].

     The interpolation METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "linear" (default)
          Linear interpolation from nearest neighbors.

     "pchip"
          Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative.

     "cubic"
          Cubic interpolation (same as "pchip").

     "spline"
          Cubic spline interpolation—smooth first and second derivatives throughout the curve.

     EXTRAP is a scalar number.  It replaces values beyond the endpoints with EXTRAP.  Note that if EXTRAP is used, METHOD must be specified as well.  If EXTRAP is omitted and the METHOD is "spline", then the extrapolated values of the "spline" are used.  Otherwise the default EXTRAP value for any other METHOD is "NA".

     See also: interp1, interp3, interpn, meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Two-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interp3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2213
 -- : VI = interp3 (X, Y, Z, V, XI, YI, ZI)
 -- : VI = interp3 (V, XI, YI, ZI)
 -- : VI = interp3 (V, N)
 -- : VI = interp3 (V)
 -- : VI = interp3 (..., METHOD)
 -- : VI = interp3 (..., METHOD, EXTRAPVAL)

     Three-dimensional interpolation.

     Interpolate reference data X, Y, Z, V to determine VI at the coordinates XI, YI, ZI.  The reference data X, Y, Z can be matrices, as returned by ‘meshgrid’, in which case the sizes of X, Y, Z, and V must be equal.  If X, Y, Z are vectors describing a cubic grid then ‘length (X) == columns (V)’, ‘length (Y) == rows (V)’, and ‘length (Z) == size (V, 3)’.  In either case the input data must be strictly monotonic.

     If called without X, Y, Z, and just a single reference data matrix V, the 3-D region ‘X = 1:columns (V), Y = 1:rows (V), Z = 1:size (V, 3)’ is assumed.  This saves memory if the grid is regular and the distance between points is not important.

     If called with a single reference data matrix V and a refinement value N, then perform interpolation over a 3-D grid where each original interval has been recursively subdivided N times.  This results in ‘2^N-1’ additional points for every interval in the original grid.  If N is omitted a value of 1 is used.  As an example, the interval [0,1] with ‘N==2’ results in a refined interval with points at [0, 1/4, 1/2, 3/4, 1].

     The interpolation METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "linear" (default)
          Linear interpolation from nearest neighbors.

     "cubic"
          Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative (not implemented yet).

     "spline"
          Cubic spline interpolation—smooth first and second derivatives throughout the curve.

     EXTRAPVAL is a scalar number.  It replaces values beyond the endpoints with EXTRAPVAL.  Note that if EXTRAPVAL is used, METHOD must be specified as well.  If EXTRAPVAL is omitted and the METHOD is "spline", then the extrapolated values of the "spline" are used.  Otherwise the default EXTRAPVAL value for any other METHOD is "NA".

     See also: interp1, interp2, interpn, meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Three-dimensional interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
interpft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 517
 -- : interpft (X, N)
 -- : interpft (X, N, DIM)

     Fourier interpolation.

     If X is a vector then X is resampled with N points.  The data in X is assumed to be equispaced.  If X is a matrix or an N-dimensional array, the interpolation is performed on each column of X.

     If DIM is specified, then interpolate along the dimension DIM.

     ‘interpft’ assumes that the interpolated function is periodic, and so assumptions are made about the endpoints of the interpolation.

     See also: interp1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Fourier interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
interpn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1925
 -- : VI = interpn (X1, X2, ..., V, Y1, Y2, ...)
 -- : VI = interpn (V, Y1, Y2, ...)
 -- : VI = interpn (V, M)
 -- : VI = interpn (V)
 -- : VI = interpn (..., METHOD)
 -- : VI = interpn (..., METHOD, EXTRAPVAL)

     Perform N-dimensional interpolation, where N is at least two.

     Each element of the N-dimensional array V represents a value at a location given by the parameters X1, X2, ..., XN.  The parameters X1, X2, ..., XN are either N-dimensional arrays of the same size as the array V in the "ndgrid" format or vectors.  The parameters Y1, etc.  respect a similar format to X1, etc., and they represent the points at which the array VI is interpolated.

     If X1, ..., XN are omitted, they are assumed to be ‘x1 = 1 : size (V, 1)’, etc.  If M is specified, then the interpolation adds a point half way between each of the interpolation points.  This process is performed M times.  If only V is specified, then M is assumed to be ‘1’.

     The interpolation METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "linear" (default)
          Linear interpolation from nearest neighbors.

     "pchip"
          Piecewise cubic Hermite interpolating polynomial—shape-preserving interpolation with smooth first derivative (not implemented yet).

     "cubic"
          Cubic interpolation (same as "pchip" [not implemented yet]).

     "spline"
          Cubic spline interpolation—smooth first and second derivatives throughout the curve.

     The default method is "linear".

     EXTRAPVAL is a scalar number.  It replaces values beyond the endpoints with EXTRAPVAL.  Note that if EXTRAPVAL is used, METHOD must be specified as well.  If EXTRAPVAL is omitted and the METHOD is "spline", then the extrapolated values of the "spline" are used.  Otherwise the default EXTRAPVAL value for any other METHOD is "NA".

     See also: interp1, interp2, interp3, spline, ndgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform N-dimensional interpolation, where N is at least two.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isequal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- : isequal (X1, X2, ...)
     Return true if all of X1, X2, ... are equal.

     See also: isequaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return true if all of X1, X2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isequaln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- : isequaln (X1, X2, ...)
     Return true if all of X1, X2, ... are equal under the additional assumption that NaN == NaN (no comparison of NaN placeholders in dataset).

     See also: isequal.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return true if all of X1, X2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
logspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- : logspace (A, B)
 -- : logspace (A, B, N)
 -- : logspace (A, pi, N)
     Return a row vector with N elements logarithmically spaced from 10^A to 10^B.

     If N is unspecified it defaults to 50.

     If B is equal to pi, the points are between 10^A and pi, _not_ 10^A and 10^pi, in order to be compatible with the corresponding MATLAB function.

     Also for compatibility with MATLAB, return the right-hand side of the range (10^B) when just a single value is requested.

     See also: linspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return a row vector with N elements logarithmically spaced from 10^A to 10^B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nextpow2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 228
 -- : nextpow2 (X)
     Compute the exponent for the smallest power of two larger than the input.

     For each element in the input array X, return the first integer N such that 2^n ≥ abs (x).

     See also: pow2, log2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Compute the exponent for the smallest power of two larger than the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
num2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1676
 -- : num2str (X)
 -- : num2str (X, PRECISION)
 -- : num2str (X, FORMAT)
     Convert a number (or array) to a string (or a character array).

     The optional second argument may either give the number of significant digits (PRECISION) to be used in the output or a format template string (FORMAT) as in ‘sprintf’ (*note Formatted Output::).  ‘num2str’ can also process complex numbers.

     Examples:

          num2str (123.456)
               ⇒ "123.46"

          num2str (123.456, 4)
               ⇒ "123.5"

          s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
               ⇒ s =
                  1.0  1.3
                  3.0  3.6
          whos s
               ⇒
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x8                         16  char

          num2str (1.234 + 27.3i)
               ⇒ "1.234+27.3i"

     The ‘num2str’ function is not very flexible.  For better control over the results, use ‘sprintf’ (*note Formatted Output::).

     Programming Notes:

     For MATLAB compatibility, leading spaces are stripped before returning the string.

     Integers larger than ‘flintmax’ may not be displayed correctly.

     For complex X, the format string may only contain one output conversion specification and nothing else.  Otherwise, results will be unpredictable.

     Any optional FORMAT specified by the programmer is used without modification.  This is in contrast to MATLAB which tampers with the FORMAT based on internal heuristics.

     See also: sprintf, int2str, mat2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Convert a number (or array) to a string (or a character array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pol2cart


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 731
 -- : [X, Y] = pol2cart (THETA, R)
 -- : [X, Y, Z] = pol2cart (THETA, R, Z)
 -- : [X, Y] = pol2cart (P)
 -- : [X, Y, Z] = pol2cart (P)
 -- : C = pol2cart (...)
     Transform polar or cylindrical coordinates to Cartesian coordinates.

     The inputs THETA, R, (and Z) must be the same shape, or scalar.  If called with a single matrix argument then each row of P represents the polar/(cylindrical) coordinate (THETA, R (, Z)).

     THETA describes the angle relative to the positive x-axis.

     R is the distance to the z-axis (0, 0, z).

     If only a single return argument is requested then return a matrix C where each row represents one Cartesian coordinate (X, Y (, Z)).

     See also: cart2pol, sph2cart, cart2sph.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Transform polar or cylindrical coordinates to Cartesian coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
polyarea


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 456
 -- : polyarea (X, Y)
 -- : polyarea (X, Y, DIM)

     Determine area of a polygon by triangle method.

     The variables X and Y define the vertex pairs, and must therefore have the same shape.  They can be either vectors or arrays.  If they are arrays then the columns of X and Y are treated separately and an area returned for each.

     If the optional DIM argument is given, then ‘polyarea’ works along this dimension of the arrays X and Y.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Determine area of a polygon by triangle method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
postpad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 571
 -- : postpad (X, L)
 -- : postpad (X, L, C)
 -- : postpad (X, L, C, DIM)
     Append the scalar value C to the vector X until it is of length L.  If C is not given, a value of 0 is used.

     If ‘length (X) > L’, elements from the end of X are removed until a vector of length L is obtained.

     If X is a matrix, elements are appended or removed from each row.

     If the optional argument DIM is given, operate along this dimension.

     If DIM is larger than the dimensions of X, the result will have DIM dimensions.

     See also: prepad, cat, resize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Append the scalar value C to the vector X until it is of length L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
prepad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 577
 -- : prepad (X, L)
 -- : prepad (X, L, C)
 -- : prepad (X, L, C, DIM)
     Prepend the scalar value C to the vector X until it is of length L.  If C is not given, a value of 0 is used.

     If ‘length (X) > L’, elements from the beginning of X are removed until a vector of length L is obtained.

     If X is a matrix, elements are prepended or removed from each row.

     If the optional argument DIM is given, operate along this dimension.

     If DIM is larger than the dimensions of X, the result will have DIM dimensions.

     See also: postpad, cat, resize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Prepend the scalar value C to the vector X until it is of length L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quad2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3580
 -- : Q = quad2d (F, XA, XB, YA, YB)
 -- : Q = quad2d (F, XA, XB, YA, YB, PROP, VAL, ...)
 -- : [Q, ERR, ITER] = quad2d (...)

     Numerically evaluate the two-dimensional integral of F using adaptive quadrature over the two-dimensional domain defined by XA, XB, YA, YB using tiled integration.  Additionally, YA and YB may be scalar functions of X, allowing for the integration over non-rectangular domains.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be of the form z = f(x,y) where X is a vector and Y is a scalar.  It should return a vector of the same length and orientation as X.

     Additional optional parameters can be specified using "PROPERTY", VALUE pairs.  Valid properties are:

     ‘AbsTol’
          Define the absolute error tolerance for the quadrature.  The default value is 1e-10 (1e-5 for single).

     ‘RelTol’
          Define the relative error tolerance for the quadrature.  The default value is 1e-6 (1e-4 for single).

     ‘MaxFunEvals’
          The maximum number of function calls to the vectorized function F.  The default value is 5000.

     ‘Singular’
          Enable/disable transforms to weaken singularities on the edge of the integration domain.  The default value is TRUE.

     ‘Vectorized’
          Option to disable vectorized integration, forcing Octave to use only scalar inputs when calling the integrand.  The default value is FALSE.

     ‘FailurePlot’
          If ‘quad2d’ fails to converge to the desired error tolerance before MaxFunEvals is reached, a plot of the areas that still need refinement is created.  The default value is FALSE.

     Adaptive quadrature is used to minimize the estimate of error until the following is satisfied:

                  ERROR <= max (ABSTOL, RELTOL*|Q|)

     The optional output ERR is an approximate bound on the error in the integral ‘abs (Q - I)’, where I is the exact value of the integral.  The optional output ITER is the number of vectorized function calls to the function F that were used.

     Example 1 : integrate a rectangular region in x-y plane

          F = @(X,Y) 2*ones (size (X));
          Q = quad2d (F, 0, 1, 0, 1)
            ⇒ Q =  2

     The result is a volume, which for this constant-value integrand, is just ‘LENGTH * WIDTH * HEIGHT’.

     Example 2 : integrate a triangular region in x-y plane

          F = @(X,Y) 2*ones (size (X));
          YMAX = @(X) 1 - X;
          Q = quad2d (F, 0, 1, 0, YMAX)
            ⇒ Q =  1

     The result is a volume, which for this constant-value integrand, is the Triangle Area x Height or ‘1/2 * BASE * WIDTH * HEIGHT’.

     Programming Notes: If there are singularities within the integration region it is best to split the integral and place the singularities on the boundary.

     Known MATLAB incompatibility: If tolerances are left unspecified, and any integration limits are of type ‘single’, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above.  If tighter tolerances are desired they must be specified.  MATLAB leaves the tighter tolerances appropriate for ‘double’ inputs in place regardless of the class of the integration limits.

     Reference: L.F. Shampine, ‘MATLAB program for quadrature in 2D’, Applied Mathematics and Computation, pp.  266–274, Vol 1, 2008.

     See also: integral2, dblquad, integral, quad, quadgk, quadv, quadl, quadcc, trapz, integral3, triplequad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
Numerically evaluate the two-dimensional integral of F using adaptive quadrature over the two-dimensional domain defined by XA, XB, YA, YB using tiled integration.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quadgk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3851
 -- : Q = quadgk (F, A, B)
 -- : Q = quadgk (F, A, B, ABSTOL)
 -- : Q = quadgk (F, A, B, ABSTOL, TRACE)
 -- : Q = quadgk (F, A, B, PROP, VAL, ...)
 -- : [Q, ERR] = quadgk (...)

     Numerically evaluate the integral of F from A to B using adaptive Gauss-Konrod quadrature.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be vectorized and return a vector of output values when given a vector of input values.

     A and B are the lower and upper limits of integration.  Either or both limits may be infinite or contain weak end singularities.  Variable transformation will be used to treat any infinite intervals and weaken the singularities.  For example:

          quadgk (@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)

     Note that the formulation of the integrand uses the element-by-element operator ‘./’ and all user functions to ‘quadgk’ should do the same.

     The optional argument TOL defines the absolute tolerance used to stop the integration procedure.  The default value is 1e-10 (1e-5 for single).

     The algorithm used by ‘quadgk’ involves subdividing the integration interval and evaluating each subinterval.  If TRACE is true then after computing each of these partial integrals display: (1) the number of subintervals at this step, (2) the current estimate of the error ERR, (3) the current estimate for the integral Q.

     Alternatively, properties of ‘quadgk’ can be passed to the function as pairs "PROP", VAL.  Valid properties are

     ‘AbsTol’
          Define the absolute error tolerance for the quadrature.  The default absolute tolerance is 1e-10 (1e-5 for single).

     ‘RelTol’
          Define the relative error tolerance for the quadrature.  The default relative tolerance is 1e-6 (1e-4 for single).

     ‘MaxIntervalCount’
          ‘quadgk’ initially subdivides the interval on which to perform the quadrature into 10 intervals.  Subintervals that have an unacceptable error are subdivided and re-evaluated.  If the number of subintervals exceeds 650 subintervals at any point then a poor convergence is signaled and the current estimate of the integral is returned.  The property "MaxIntervalCount" can be used to alter the number of subintervals that can exist before exiting.

     ‘WayPoints’
          Discontinuities in the first derivative of the function to integrate can be flagged with the "WayPoints" property.  This forces the ends of a subinterval to fall on the breakpoints of the function and can result in significantly improved estimation of the error in the integral, faster computation, or both.  For example,

               quadgk (@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)

          signals the breakpoint in the integrand at ‘X = 1’.

     ‘Trace’
          If logically true ‘quadgk’ prints information on the convergence of the quadrature at each iteration.

     If any of A, B, or WAYPOINTS is complex then the quadrature is treated as a contour integral along a piecewise continuous path defined by the above.  In this case the integral is assumed to have no edge singularities.  For example,

          quadgk (@(z) log (z), 1+1i, 1+1i, "WayPoints",
                  [1-1i, -1,-1i, -1+1i])

     integrates ‘log (z)’ along the square defined by ‘[1+1i, 1-1i, -1-1i, -1+1i]’.

     The result of the integration is returned in Q.

     ERR is an approximate bound on the error in the integral ‘abs (Q - I)’, where I is the exact value of the integral.

     Reference: L.F. Shampine, ‘"Vectorized adaptive quadrature in MATLAB"’, Journal of Computational and Applied Mathematics, pp.  131–140, Vol 211, Issue 2, Feb 2008.

     See also: quad, quadv, quadl, quadcc, trapz, dblquad, triplequad, integral, integral2, integral3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Numerically evaluate the integral of F from A to B using adaptive Gauss-Konrod quadrature.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1616
 -- : Q = quadl (F, A, B)
 -- : Q = quadl (F, A, B, TOL)
 -- : Q = quadl (F, A, B, TOL, TRACE)
 -- : Q = quadl (F, A, B, TOL, TRACE, P1, P2, ...)
 -- : [Q, NFUN] = quadl (...)

     Numerically evaluate the integral of F from A to B using an adaptive Lobatto rule.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must be vectorized and return a vector of output values when given a vector of input values.

     A and B are the lower and upper limits of integration.  Both limits must be finite.

     The optional argument TOL defines the absolute tolerance with which to perform the integration.  The default value is 1e-6.

     The algorithm used by ‘quadl’ involves recursively subdividing the integration interval.  If TRACE is defined then for each subinterval display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval.

     Additional arguments P1, etc., are passed directly to the function F.  To use default values for TOL and TRACE, one may pass empty matrices ([]).

     The result of the integration is returned in Q.

     The optional output NFUN indicates the total number of function evaluations performed.

     Reference: W. Gander and W. Gautschi, ‘Adaptive Quadrature - Revisited’, BIT Vol.  40, No.  1, March 2000, pp.  84–101.  <https://www.inf.ethz.ch/personal/gander/>

     See also: quad, quadv, quadgk, quadcc, trapz, dblquad, triplequad, integral, integral2, integral3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Numerically evaluate the integral of F from A to B using an adaptive Lobatto rule.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1746
 -- : Q = quadv (F, A, B)
 -- : Q = quadv (F, A, B, TOL)
 -- : Q = quadv (F, A, B, TOL, TRACE)
 -- : Q = quadv (F, A, B, TOL, TRACE, P1, P2, ...)
 -- : [Q, NFUN] = quadv (...)

     Numerically evaluate the integral of F from A to B using an adaptive Simpson’s rule.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  ‘quadv’ is a vectorized version of ‘quad’ and the function defined by F must accept a scalar or vector as input and return a scalar, vector, or array as output.

     A and B are the lower and upper limits of integration.  Both limits must be finite.

     The optional argument TOL defines the absolute tolerance used to stop the adaptation procedure.  The default value is 1e-6.

     The algorithm used by ‘quadv’ involves recursively subdividing the integration interval and applying Simpson’s rule on each subinterval.  If TRACE is true then after computing each of these partial integrals display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval.

     Additional arguments P1, etc., are passed directly to the function F.  To use default values for TOL and TRACE, one may pass empty matrices ([]).

     The result of the integration is returned in Q.

     The optional output NFUN indicates the total number of function evaluations performed.

     Note: ‘quadv’ is written in Octave’s scripting language and can be used recursively in ‘dblquad’ and ‘triplequad’, unlike the ‘quad’ function.

     See also: quad, quadl, quadgk, quadcc, trapz, dblquad, triplequad, integral, integral2, integral3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Numerically evaluate the integral of F from A to B using an adaptive Simpson’s rule.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rad2deg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 -- : DEG = rad2deg (RAD)

     Convert radians to degrees.

     The input RAD must be a scalar, vector, or N-dimensional array of double or single floating point values.  RAD may be complex in which case the real and imaginary components are converted separately.

     The output DEG is the same size and shape as RAD with radians converted to degrees using the conversion constant ‘180/pi’.

     Example:

          rad2deg ([0, pi/2, pi, 3/2*pi, 2*pi])
            ⇒  0    90   180   270   360

     See also: deg2rad.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Convert radians to degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1177
 -- : randi (IMAX)
 -- : randi (IMAX, N)
 -- : randi (IMAX, M, N, ...)
 -- : randi ([IMIN IMAX], ...)
 -- : randi (..., "CLASS")
     Return random integers in the range 1:IMAX.

     Additional arguments determine the shape of the return matrix.  When no arguments are specified a single random integer is returned.  If one argument N is specified then a square matrix (N x N) is returned.  Two or more arguments will return a multi-dimensional matrix (M x N x ...).

     The integer range may optionally be described by a two element matrix with a lower and upper bound in which case the returned integers will be on the interval [IMIN, IMAX].

     The optional argument CLASS will return a matrix of the requested type.  The default is "double".

     The following example returns 150 integers in the range 1–10.

          ri = randi (10, 150, 1)

     Implementation Note: ‘randi’ relies internally on ‘rand’ which uses class "double" to represent numbers.  This limits the maximum integer (IMAX) and range (IMAX - IMIN) to the value returned by the ‘flintmax’ function.  For IEEE floating point numbers this value is 2^{53} - 1.

     See also: rand.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return random integers in the range 1:IMAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
rat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- : S = rat (X, TOL)
 -- : [N, D] = rat (X, TOL)

     Find a rational approximation to X within the tolerance defined by TOL using a continued fraction expansion.

     For example:

          rat (pi) = 3 + 1/(7 + 1/16) = 355/113
          rat (e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
                  = 1457/536

     When called with two output arguments return the numerator and denominator separately as two matrices.

     See also: rats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Find a rational approximation to X within the tolerance defined by TOL using a continued fraction expansion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
repelem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3706
 -- : XXX = repelem (X, R)
 -- : XXX = repelem (X, R_1, ..., R_N)
     Construct an array of repeated elements from X and repeat instructions R_1, ....

     X must be a scalar, vector, or N-dimensional array.

     A repeat instruction R_J must either be a scalar or a vector.  If the instruction is a scalar then each component of X in dimension J is repeated R_J times.  If the instruction is a vector then it must have the same number of elements as the corresponding dimension J of X.  In this case, the Kth component of dimension J is repeated ‘R_J(K)’ times.

     If X is a scalar or vector then ‘repelem’ may be called with just a single repeat instruction R and ‘repelem’ will return a vector with the same orientation as the input.

     If X is a matrix then at least two R_Js must be specified.

     Note: Using ‘repelem’ with a vector X and a vector for R_J is equivalent to Run Length Decoding.

     Examples:

          A = [1 2 3 4 5];
          B = [2 1 0 1 2];
          repelem (A, B)
            ⇒   1   1   2   4   5   5

          A = magic (3)
            ⇒   8   1   6
                 3   5   7
                 4   9   2
          B1 = [1 2 3];
          B2 = 2;
          repelem (A, B1, B2)
            ⇒     8   8   1   1   6   6
                   3   3   5   5   7   7
                   3   3   5   5   7   7
                   4   4   9   9   2   2
                   4   4   9   9   2   2
                   4   4   9   9   2   2

     More R_J may be specified than the number of dimensions of X.  Any excess R_J must be scalars (because X’s size in those dimensions is only 1), and X will be replicated in those dimensions accordingly.

          A = [1 2 3 4 5];
          B1 = 2;
          B2 = [2 1 3 0 2];
          B3 = 3;
          repelem (A, B1, B2, B3)
            ⇒    ans(:,:,1) =
                     1   1   2   3   3   3   5   5
                     1   1   2   3   3   3   5   5

                  ans(:,:,2) =

                     1   1   2   3   3   3   5   5
                     1   1   2   3   3   3   5   5

                  ans(:,:,3) =
                     1   1   2   3   3   3   5   5
                     1   1   2   3   3   3   5   5

     R_J must be specified in order.  A placeholder of 1 may be used for dimensions which do not need replication.

          repelem ([-1, 0; 0, 1], 1, 2, 1, 2)
            ⇒  ans(:,:,1,1) =
                  -1  -1   0   0
                   0   0   1   1

                ans(:,:,1,2) =
                  -1  -1   0   0
                   0   0   1   1

     If fewer R_J are given than the number of dimensions in X, ‘repelem’ will assume R_J is 1 for those dimensions.

          A = cat (3, [-1 0; 0 1], [-1 0; 0 1])
            ⇒  ans(:,:,1) =
                  -1   0
                   0   1

                ans(:,:,2) =
                  -1   0
                   0   1

          repelem (A,2,3)
            ⇒  ans(:,:,1) =
                  -1  -1  -1   0   0   0
                  -1  -1  -1   0   0   0
                   0   0   0   1   1   1
                   0   0   0   1   1   1

                ans(:,:,2) =
                  -1  -1  -1   0   0   0
                  -1  -1  -1   0   0   0
                   0   0   0   1   1   1
                   0   0   0   1   1   1

     ‘repelem’ preserves the class of X, and works with strings, cell arrays, NA, and NAN inputs.  If any R_J is 0 the output will be an empty array.

          repelem ("Octave", 2, 3)
            ⇒    OOOccctttaaavvveee
                  OOOccctttaaavvveee

          repelem ([1 2 3; 1 2 3], 2, 0)
            ⇒    [](4x0)

     See also: cat, kron, repmat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Construct an array of repeated elements from X and repeat instructions R_1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
repmat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 497
 -- : repmat (A, M)
 -- : repmat (A, M, N)
 -- : repmat (A, M, N, P ...)
 -- : repmat (A, [M N])
 -- : repmat (A, [M N P ...])
     Repeat matrix or N-D array.

     Form a block matrix of size M by N, with a copy of matrix A as each element.

     If N is not specified, form an M by M block matrix.  For copying along more than two dimensions, specify the number of times to copy across each dimension M, N, P, ..., in a vector in the second argument.

     See also: bsxfun, kron, repelems.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Repeat matrix or N-D array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rot90


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 881
 -- : rot90 (A)
 -- : rot90 (A, K)
     Rotate array by 90 degree increments.

     Return a copy of A with the elements rotated counterclockwise in 90-degree increments.

     The second argument is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1).  Negative values of K rotate the matrix in a clockwise direction.  For example,

          rot90 ([1, 2; 3, 4], -1)
              ⇒  3  1
                  4  2

     rotates the given matrix clockwise by 90 degrees.  The following are all equivalent statements:

          rot90 ([1, 2; 3, 4], -1)
          rot90 ([1, 2; 3, 4], 3)
          rot90 ([1, 2; 3, 4], 7)

     The rotation is always performed on the plane of the first two dimensions, i.e., rows and columns.  To perform a rotation on any other plane, use ‘rotdim’.

     See also: rotdim, fliplr, flipud, flip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Rotate array by 90 degree increments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rotdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 999
 -- : rotdim (X)
 -- : rotdim (X, N)
 -- : rotdim (X, N, PLANE)
     Return a copy of X with the elements rotated counterclockwise in 90-degree increments.

     The second argument N is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1).  Negative values of N rotate the matrix in a clockwise direction.

     The third argument is also optional and defines the plane of the rotation.  If present, PLANE is a two element vector containing two different valid dimensions of the matrix.  When PLANE is not given the first two non-singleton dimensions are used.

     For example,

          rotdim ([1, 2; 3, 4], -1, [1, 2])
               ⇒  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following are all equivalent statements:

          rotdim ([1, 2; 3, 4], -1, [1, 2])
          rotdim ([1, 2; 3, 4], 3, [1, 2])
          rotdim ([1, 2; 3, 4], 7, [1, 2])

     See also: rot90, fliplr, flipud, flip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return a copy of X with the elements rotated counterclockwise in 90-degree increments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
shift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- : shift (X, B)
 -- : shift (X, B, DIM)
     If X is a vector, perform a circular shift of length B of the elements of X.

     If X is a matrix, do the same for each column of X.

     If the optional DIM argument is given, operate along this dimension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
If X is a vector, perform a circular shift of length B of the elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
shiftdim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 869
 -- : Y = shiftdim (X, N)
 -- : [Y, NS] = shiftdim (X)
     Shift the dimensions of X by N, where N must be an integer scalar.

     When N is positive, the dimensions of X are shifted to the left, with the leading dimensions circulated to the end.  If N is negative, then the dimensions of X are shifted to the right, with N leading singleton dimensions added.

     Called with a single argument, ‘shiftdim’, removes the leading singleton dimensions, returning the number of dimensions removed in the second output argument NS.

     For example:

          x = ones (1, 2, 3);
          size (shiftdim (x, -1))
             ⇒ [1, 1, 2, 3]
          size (shiftdim (x, 1))
             ⇒ [2, 3]
          [b, ns] = shiftdim (x)
             ⇒ b = [1, 1, 1; 1, 1, 1]
             ⇒ ns = 1

     See also: reshape, permute, ipermute, circshift, squeeze.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Shift the dimensions of X by N, where N must be an integer scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sortrows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 710
 -- : [S, I] = sortrows (A)
 -- : [S, I] = sortrows (A, C)
     Sort the rows of the matrix A according to the order of the columns specified in C.

     By default (C omitted, or a particular column unspecified in C) an ascending sort order is used.  However, if elements of C are negative then the corresponding column is sorted in descending order.  If the elements of A are strings then a lexicographical sort is used.

     Example: sort by column 2 in descending order, then 3 in ascending order

          x = [ 7, 1, 4;
                8, 3, 5;
                9, 3, 6 ];
          sortrows (x, [-2, 3])
             ⇒ 8  3  5
                9  3  6
                7  1  4

     See also: sort.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Sort the rows of the matrix A according to the order of the columns specified in C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sph2cart


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 694
 -- : [X, Y, Z] = sph2cart (THETA, PHI, R)
 -- : [X, Y, Z] = sph2cart (S)
 -- : C = sph2cart (...)
     Transform spherical coordinates to Cartesian coordinates.

     The inputs THETA, PHI, and R must be the same shape, or scalar.  If called with a single matrix argument then each row of S represents the spherical coordinate (THETA, PHI, R).

     THETA describes the angle relative to the positive x-axis.

     PHI is the angle relative to the xy-plane.

     R is the distance to the origin (0, 0, 0).

     If only a single return argument is requested then return a matrix C where each row represents one Cartesian coordinate (X, Y, Z).

     See also: cart2sph, pol2cart, cart2pol.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Transform spherical coordinates to Cartesian coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
structfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1853
 -- : structfun (FUNC, S)
 -- : [A, ...] = structfun (...)
 -- : structfun (..., "ErrorHandler", ERRFUNC)
 -- : structfun (..., "UniformOutput", VAL)

     Evaluate the function named NAME on the fields of the structure S.  The fields of S are passed to the function FUNC individually.

     ‘structfun’ accepts an arbitrary function FUNC in the form of an inline function, function handle, or the name of a function (in a character string).  In the case of a character string argument, the function must accept a single argument named X, and it must return a string value.  If the function returns more than one argument, they are returned as separate output variables.

     If the parameter "UniformOutput" is set to true (the default), then the function must return a single element which will be concatenated into the return value.  If "UniformOutput" is false, the outputs are placed into a structure with the same fieldnames as the input structure.

          s.name1 = "John Smith";
          s.name2 = "Jill Jones";
          structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s,
                     "UniformOutput", false)
          ⇒
             {
               name1 = Smith
               name2 = Jones
             }

     Given the parameter "ErrorHandler", ERRFUNC defines a function to call in case FUNC generates an error.  The form of the function is

          function [...] = errfunc (SE, ...)

     where there is an additional input argument to ERRFUNC relative to FUNC, given by SE.  This is a structure with the elements "identifier", "message" and "index", giving respectively the error identifier, the error message, and the index into the input arguments of the element that caused the error.  For an example on how to use an error handler, *note cellfun: XREFcellfun.

     See also: cellfun, arrayfun, spfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Evaluate the function named NAME on the fields of the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
subsindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 843
 -- : IDX = subsindex (OBJ)
     Convert an object to an index vector.

     When OBJ is a class object defined with a class constructor, then ‘subsindex’ is the overloading method that allows the conversion of this class object to a valid indexing vector.  It is important to note that ‘subsindex’ must return a zero-based real integer vector of the class "double".  For example, if the class constructor were

          function obj = myclass (a)
            obj = class (struct ("a", a), "myclass");
          endfunction

     then the ‘subsindex’ function

          function idx = subsindex (obj)
            idx = double (obj.a) - 1.0;
          endfunction

     could be used as follows

          a = myclass (1:4);
          b = 1:10;
          b(a)
          ⇒ 1  2  3  4

     See also: class, subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert an object to an index vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
trapz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1215
 -- : Q = trapz (Y)
 -- : Q = trapz (X, Y)
 -- : Q = trapz (..., DIM)

     Numerically evaluate the integral of points Y using the trapezoidal method.

     ‘trapz (Y)’ computes the integral of Y along the first non-singleton dimension.  When the argument X is omitted an equally spaced X vector with unit spacing (1) is assumed.  ‘trapz (X, Y)’ evaluates the integral with respect to the spacing in X and the values in Y.  This is useful if the points in Y have been sampled unevenly.

     If the optional DIM argument is given, operate along this dimension.

     Application Note: If X is not specified then unit spacing will be used.  To scale the integral to the correct value you must multiply by the actual spacing value (deltaX). As an example, the integral of x^3 over the range [0, 1] is x^4/4 or 0.25.  The following code uses ‘trapz’ to calculate the integral in three different ways.

          x = 0:0.1:1;
          y = x.^3;
          q = trapz (y)
            ⇒ q = 2.525   # No scaling
          q * 0.1
            ⇒ q = 0.2525  # Approximation to integral by scaling
          trapz (x, y)
            ⇒ q = 0.2525  # Same result by specifying X

     See also: cumtrapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Numerically evaluate the integral of points Y using the trapezoidal method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
triplequad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1273
 -- : triplequad (F, XA, XB, YA, YB, ZA, ZB)
 -- : triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL)
 -- : triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF)
 -- : triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF, ...)
     Numerically evaluate the triple integral of F.

     F is a function handle, inline function, or string containing the name of the function to evaluate.  The function F must have the form w = f(x,y,z) where either X or Y is a vector and the remaining inputs are scalars.  It should return a vector of the same length and orientation as X or Y.

     XA, YA, ZA and XB, YB, ZB are the lower and upper limits of integration for x, y, and z respectively.  The underlying integrator determines whether infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to integrate each sub-integral.  The default value is 1e-6.

     The optional argument QUADF specifies which underlying integrator function to use.  Any choice but ‘quad’ is available and the default is ‘quadcc’.

     Additional arguments, are passed directly to F.  To use the default value for TOL or QUADF one may pass ’:’ or an empty matrix ([]).

     See also: integral3, integral2, dblquad, quad, quadv, quadl, quadgk, quadcc, trapz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Numerically evaluate the triple integral of F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
xor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3764
 -- : Z = xor (X, Y)
 -- : Z = xor (X1, X2, ...)
     Return the “exclusive or” of X and Y.

     For boolean expressions X and Y, ‘xor (X, Y)’ is true if and only if one of X or Y is true.  Otherwise, if X and Y are both true or both false, ‘xor’ returns false.

     The truth table for the xor operation is

                                                                                                                                                                                                                                                                                                                                                                                                                                                                         X                               Y                                                   Z
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -                               -                                                   -
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0                               0                                                   0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         1                               0                                                   1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0                               1                                                   1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         1                               1                                                   0

     If more than two arguments are given the xor operation is applied cumulatively from left to right:

          (...((x1 XOR x2) XOR x3) XOR ...)

     See also: and, or, not.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return the “exclusive or” of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
convhull


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 859
 -- : H = convhull (X, Y)
 -- : H = convhull (X, Y, OPTIONS)
     Compute the convex hull of the set of points defined by the arrays X and Y.  The hull H is an index vector into the set of points and specifies which points form the enclosing hull.

     An optional third argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.  The default option is ‘{"Qt"}’.

     If OPTIONS is not present or ‘[]’ then the default arguments are used.  Otherwise, OPTIONS replaces the default argument list.  To append user options to the defaults it is necessary to repeat the default arguments in OPTIONS.  Use a null string to pass no arguments.

     See also: convhulln, delaunay, voronoi.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute the convex hull of the set of points defined by the arrays X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
delaunay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2168
 -- : TRI = delaunay (X, Y)
 -- : TETR = delaunay (X, Y, Z)
 -- : TRI = delaunay (X)
 -- : TRI = delaunay (..., OPTIONS)
     Compute the Delaunay triangulation for a 2-D or 3-D set of points.

     For 2-D sets, the return value TRI is a set of triangles which satisfies the Delaunay circum-circle criterion, i.e., no data point from [X, Y] is within the circum-circle of the defining triangle.  The set of triangles TRI is a matrix of size [n, 3].  Each row defines a triangle and the three columns are the three vertices of the triangle.  The value of ‘TRI(i,j)’ is an index into X and Y for the location of the j-th vertex of the i-th triangle.

     For 3-D sets, the return value TETR is a set of tetrahedrons which satisfies the Delaunay circum-circle criterion, i.e., no data point from [X, Y, Z] is within the circum-circle of the defining tetrahedron.  The set of tetrahedrons is a matrix of size [n, 4].  Each row defines a tetrahedron and the four columns are the four vertices of the tetrahedron.  The value of ‘TETR(i,j)’ is an index into X, Y, Z for the location of the j-th vertex of the i-th tetrahedron.

     The input X may also be a matrix with two or three columns where the first column contains x-data, the second y-data, and the optional third column contains z-data.

     The optional last argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.  The default options are ‘{"Qt", "Qbb", "Qc", "Qz"}’.

     If OPTIONS is not present or ‘[]’ then the default arguments are used.  Otherwise, OPTIONS replaces the default argument list.  To append user options to the defaults it is necessary to repeat the default arguments in OPTIONS.  Use a null string to pass no arguments.

          x = rand (1, 10);
          y = rand (1, 10);
          tri = delaunay (x, y);
          triplot (tri, x, y);
          hold on;
          plot (x, y, "r*");
          axis ([0,1,0,1]);

     See also: delaunayn, convhull, voronoi, triplot, trimesh, tetramesh, trisurf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Compute the Delaunay triangulation for a 2-D or 3-D set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
delaunayn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1444
 -- : T = delaunayn (PTS)
 -- : T = delaunayn (PTS, OPTIONS)
     Compute the Delaunay triangulation for an N-dimensional set of points.

     The Delaunay triangulation is a tessellation of the convex hull of a set of points such that no N-sphere defined by the N-triangles contains any other points from the set.

     The input matrix PTS of size [n, dim] contains n points in a space of dimension dim.  The return matrix T has size [m, dim+1].  Each row of T contains a set of indices back into the original set of points PTS which describes a simplex of dimension dim.  For example, a 2-D simplex is a triangle and 3-D simplex is a tetrahedron.

     An optional second argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.  The default options depend on the dimension of the input:

        • 2-D and 3-D: OPTIONS = ‘{"Qt", "Qbb", "Qc", "Qz"}’

        • 4-D and higher: OPTIONS = ‘{"Qt", "Qbb", "Qc", "Qx"}’

     If OPTIONS is not present or ‘[]’ then the default arguments are used.  Otherwise, OPTIONS replaces the default argument list.  To append user options to the defaults it is necessary to repeat the default arguments in OPTIONS.  Use a null string to pass no arguments.

     See also: delaunay, convhulln, voronoin, trimesh, tetramesh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the Delaunay triangulation for an N-dimensional set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 287
 -- : IDX = dsearch (X, Y, TRI, XI, YI)
 -- : IDX = dsearch (X, Y, TRI, XI, YI, S)
     Return the index IDX of the closest point in ‘X, Y’ to the elements ‘[XI(:), YI(:)]’.

     The variable S is accepted for compatibility but is ignored.

     See also: dsearchn, tsearch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return the index IDX of the closest point in ‘X, Y’ to the elements ‘[XI(:), YI(:)]’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dsearchn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 425
 -- : IDX = dsearchn (X, TRI, XI)
 -- : IDX = dsearchn (X, TRI, XI, OUTVAL)
 -- : IDX = dsearchn (X, XI)
 -- : [IDX, D] = dsearchn (...)
     Return the index IDX of the closest point in X to the elements XI.

     If OUTVAL is supplied, then the values of XI that are not contained within one of the simplices TRI are set to OUTVAL.  Generally, TRI is returned from ‘delaunayn (X)’.

     See also: dsearch, tsearch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the index IDX of the closest point in X to the elements XI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
griddata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 628
 -- : ZI = griddata (X, Y, Z, XI, YI)
 -- : ZI = griddata (X, Y, Z, XI, YI, METHOD)
 -- : [XI, YI, ZI] = griddata (...)

     Generate a regular mesh from irregular data using interpolation.

     The function is defined by ‘Z = f (X, Y)’.  Inputs ‘X, Y, Z’ are vectors of the same length or ‘X, Y’ are vectors and ‘Z’ is matrix.

     The interpolation points are all ‘(XI, YI)’.  If XI, YI are vectors then they are made into a 2-D mesh.

     The interpolation method can be "nearest", "cubic" or "linear".  If method is omitted it defaults to "linear".

     See also: griddata3, griddatan, delaunay.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Generate a regular mesh from irregular data using interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
griddata3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 721
 -- : VI = griddata3 (X, Y, Z, V, XI, YI, ZI)
 -- : VI = griddata3 (X, Y, Z, V, XI, YI, ZI, METHOD)
 -- : VI = griddata3 (X, Y, Z, V, XI, YI, ZI, METHOD, OPTIONS)

     Generate a regular mesh from irregular data using interpolation.

     The function is defined by ‘V = f (X, Y, Z)’.  The interpolation points are specified by XI, YI, ZI.

     The interpolation method can be "nearest" or "linear".  If method is omitted it defaults to "linear".

     The optional argument OPTIONS is passed directly to Qhull when computing the Delaunay triangulation used for interpolation.  See ‘delaunayn’ for information on the defaults and how to pass different values.

     See also: griddata, griddatan, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Generate a regular mesh from irregular data using interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
griddatan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 656
 -- : YI = griddatan (X, Y, XI)
 -- : YI = griddatan (X, Y, XI, METHOD)
 -- : YI = griddatan (X, Y, XI, METHOD, OPTIONS)

     Generate a regular mesh from irregular data using interpolation.

     The function is defined by ‘Y = f (X)’.  The interpolation points are all XI.

     The interpolation method can be "nearest" or "linear".  If method is omitted it defaults to "linear".

     The optional argument OPTIONS is passed directly to Qhull when computing the Delaunay triangulation used for interpolation.  See ‘delaunayn’ for information on the defaults and how to pass different values.

     See also: griddata, griddata3, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Generate a regular mesh from irregular data using interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
inpolygon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 455
 -- : IN = inpolygon (X, Y, XV, YV)
 -- : [IN, ON] = inpolygon (X, Y, XV, YV)

     For a polygon defined by vertex points ‘(XV, YV)’, return true if the points ‘(X, Y)’ are inside (or on the boundary) of the polygon; Otherwise, return false.

     The input variables X and Y, must have the same dimension.

     The optional output ON returns true if the points are exactly on the polygon edge, and false otherwise.

     See also: delaunay.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 166
For a polygon defined by vertex points ‘(XV, YV)’, return true if the points ‘(X, Y)’ are inside (or on the boundary) of the polygon; Otherwise, return false.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rectint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 917
 -- : AREA = rectint (A, B)
     Compute area or volume of intersection of rectangles or N-D boxes.

     Compute the area of intersection of rectangles in A and rectangles in B.  N-dimensional boxes are supported in which case the volume, or hypervolume is computed according to the number of dimensions.

     2-dimensional rectangles are defined as ‘[xpos ypos width height]’ where xpos and ypos are the position of the bottom left corner.  Higher dimensions are supported where the coordinates for the minimum value of each dimension follow the length of the box in that dimension, e.g., ‘[xpos ypos zpos kpos ... width height depth k_length ...]’.

     Each row of A and B define a rectangle, and if both define multiple rectangles, then the output, AREA, is a matrix where the i-th row corresponds to the i-th row of a and the j-th column corresponds to the j-th row of b.

     See also: polyarea.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Compute area or volume of intersection of rectangles or N-D boxes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tsearchn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- : IDX = tsearchn (X, T, XI)
 -- : [IDX, P] = tsearchn (X, T, XI)
     Search for the enclosing Delaunay convex hull.

     For ‘T = delaunayn (X)’, finds the index in T containing the points XI.  For points outside the convex hull, IDX is NaN.

     If requested ‘tsearchn’ also returns the Barycentric coordinates P of the enclosing triangles.

     See also: delaunay, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Search for the enclosing Delaunay convex hull.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
voronoi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1249
 -- : voronoi (X, Y)
 -- : voronoi (X, Y, OPTIONS)
 -- : voronoi (..., "linespec")
 -- : voronoi (HAX, ...)
 -- : H = voronoi (...)
 -- : [VX, VY] = voronoi (...)
     Plot the Voronoi diagram of points ‘(X, Y)’.

     The Voronoi facets with points at infinity are not drawn.

     The OPTIONS argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.

     If "linespec" is given it is used to set the color and line style of the plot.

     If an axes graphics handle HAX is supplied then the Voronoi diagram is drawn on the specified axes rather than in a new figure.

     If a single output argument is requested then the Voronoi diagram will be plotted and a graphics handle H to the plot is returned.

     [VX, VY] = voronoi (...) returns the Voronoi vertices instead of plotting the diagram.

          x = rand (10, 1);
          y = rand (size (x));
          h = convhull (x, y);
          [vx, vy] = voronoi (x, y);
          plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g");
          legend ("", "points", "hull");

     See also: voronoin, delaunay, convhull.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Plot the Voronoi diagram of points ‘(X, Y)’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
voronoin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1076
 -- : [C, F] = voronoin (PTS)
 -- : [C, F] = voronoin (PTS, OPTIONS)
     Compute N-dimensional Voronoi facets.

     The input matrix PTS of size [n, dim] contains n points in a space of dimension dim.

     C contains the points of the Voronoi facets.  The list F contains, for each facet, the indices of the Voronoi points.

     An optional second argument, which must be a string or cell array of strings, contains options passed to the underlying qhull command.  See the documentation for the Qhull library for details <http://www.qhull.org/html/qh-quick.htm#options>.

     The default options depend on the dimension of the input:

        • 2-D and 3-D: OPTIONS = ‘{"Qbb"}’

        • 4-D and higher: OPTIONS = ‘{"Qbb", "Qx"}’

     If OPTIONS is not present or ‘[]’ then the default arguments are used.  Otherwise, OPTIONS replaces the default argument list.  To append user options to the defaults it is necessary to repeat the default arguments in OPTIONS.  Use a null string to pass no arguments.

     See also: voronoi, convhulln, delaunayn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute N-dimensional Voronoi facets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dialog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1417
 -- : H = dialog ()
 -- : H = dialog ("PROPERTY", VALUE, ...)

     Create an empty modal dialog window to which other uicontrols can be added.

     The dialog box is a figure object with properties as recommended for a dialog box.

     The default properties differing from a figure are:

     buttondownfcn
          ‘if isempty (allchild(gcbf)), close (gcbf), endif’

     colormap
          []

     color
          defaultuicontrolbackgroundcolor

     dockcontrols
          off

     handlevisibility
          callback

     integerhandle
          off

     inverthardcopy
          off

     menubar
          none

     numbertitle
          off

     paperpositionmode
          auto

     resize
          off

     windowstyle
          modal

     Multiple property-value pairs may be specified for the dialog object, but they must appear in pairs.

     The return value H is a graphics handle to the created figure.

     Example:

          ## create an empty dialog window titled "Dialog Example"
          h = dialog ("name", "Dialog Example");

          ## create a button (default style)
          b = uicontrol (h, "string", "OK",
                            "position", [10 10 150 40],
                            "callback", "delete (gcf)");

          ## wait for dialog to resume or close
          uiwait (h);

     See also: errordlg, msgbox, questdlg, warndlg, figure, uiwait.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Create an empty modal dialog window to which other uicontrols can be added.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
errordlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 982
 -- : H = errordlg ()
 -- : H = errordlg (MSG)
 -- : H = errordlg (MSG, TITLE)
 -- : H = errordlg (MSG, TITLE, CREATEMODE)
     Display an error dialog box with error message MSG and caption TITLE.

     The default error message is "This is the default error string."  and the default caption is "Error Dialog".

     The error message may have multiple lines separated by newline characters ("\n"), or it may be a cellstr array with one element for each line.

     The return value H is always 1.

     Compatibility Note: The optional argument CREATEMODE is accepted for MATLAB compatibility, but is not implemented.  See ‘msgbox’ for details.

     Examples:

          errordlg ("Some fancy error occurred.");
          errordlg ("Some fancy error\nwith two lines.");
          errordlg ({"Some fancy error", "with two lines."});
          errordlg ("Some fancy error occurred.", "Fancy caption");

     See also: helpdlg, inputdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Display an error dialog box with error message MSG and caption TITLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
getappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- : VALUE = getappdata (H, NAME)
 -- : APPDATA = getappdata (H)
     Return the VALUE of the application data NAME for the graphics object with handle H.

     H may also be a vector of graphics handles.  If no second argument NAME is given then ‘getappdata’ returns a structure, APPDATA, whose fields correspond to the appdata properties.

     See also: setappdata, isappdata, rmappdata, guidata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return the VALUE of the application data NAME for the graphics object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
guidata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- : DATA = guidata (H)
 -- : guidata (H, DATA)
     Query or set user-custom GUI data.

     The GUI data is stored in the figure handle H.  If H is not a figure handle then it’s parent figure will be used for storage.

     DATA must be a single object which means it is usually preferable for it to be a data container such as a cell array or struct so that additional data items can be added easily.

     See also: getappdata, setappdata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Query or set user-custom GUI data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
guihandles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 643
 -- : HDATA = guihandles (H)
 -- : HDATA = guihandles
     Return a structure of object handles for the figure associated with handle H.

     If no handle is specified the current figure returned by ‘gcf’ is used.

     The fieldname for each entry of HDATA is taken from the "tag" property of the graphic object.  If the tag is empty then the handle is not returned.  If there are multiple graphic objects with the same tag then the entry in HDATA will be a vector of handles.  ‘guihandles’ includes all possible handles, including those for which "HandleVisibility" is "off".

     See also: guidata, findobj, findall, allchild.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return a structure of object handles for the figure associated with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
helpdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 785
 -- : H = helpdlg ()
 -- : H = helpdlg (MSG)
 -- : H = helpdlg (MSG, TITLE)
     Display a help dialog box with help message MSG and caption TITLE.

     The default help message is "This is the default help string."  and the default caption is "Help Dialog".

     The help message may have multiple lines separated by newline characters ("\n"), or it may be a cellstr array with one element for each line.

     The return value H is always 1.

     Examples:

          helpdlg ("Some helpful text for the user.");
          helpdlg ("Some helpful text\nwith two lines.");
          helpdlg ({"Some helpful text", "with two lines."});
          helpdlg ("Some helpful text for the user.", "Fancy caption");

     See also: errordlg, inputdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Display a help dialog box with help message MSG and caption TITLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
inputdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1682
 -- : CSTR = inputdlg (PROMPT)
 -- : CSTR = inputdlg (PROMPT, TITLE)
 -- : CSTR = inputdlg (PROMPT, TITLE, ROWSCOLS)
 -- : CSTR = inputdlg (PROMPT, TITLE, ROWSCOLS, DEFAULTS)
 -- : CSTR = inputdlg (PROMPT, TITLE, ROWSCOLS, DEFAULTS, OPTIONS)
     Return user input from a multi-textfield dialog box in a cell array of strings, or an empty cell array if the dialog is closed by the Cancel button.

     Inputs:

     PROMPT
          A cell array with strings labeling each text field.  This input is required.

     TITLE
          String to use for the caption of the dialog.  The default is "Input Dialog".

     ROWSCOLS
          Specifies the size of the text fields and can take three forms:

            1. a scalar value which defines the number of rows used for each text field.

            2. a vector which defines the individual number of rows used for each text field.

            3. a matrix which defines the individual number of rows and columns used for each text field.  In the matrix each row describes a single text field.  The first column specifies the number of input rows to use and the second column specifies the text field width.

     DEFAULTS
          A list of default values to place in each text fields.  It must be a cell array of strings with the same size as PROMPT.

     OPTIONS
          Not supported, only for MATLAB compatibility.

     Example:

          prompt = {"Width", "Height", "Depth"};
          defaults = {"1.10", "2.20", "3.30"};
          rowscols = [1,10; 2,20; 3,30];
          dims = inputdlg (prompt, "Enter Box Dimensions", rowscols, defaults);

     See also: errordlg, helpdlg, listdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
Return user input from a multi-textfield dialog box in a cell array of strings, or an empty cell array if the dialog is closed by the Cancel button.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- : VALID = isappdata (H, NAME)
     Return true if the named application data, NAME, exists for the graphics object with handle H.

     H may also be a vector of graphics handles.

     See also: getappdata, setappdata, rmappdata, guidata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return true if the named application data, NAME, exists for the graphics object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
listdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1804
 -- : [SEL, OK] = listdlg (KEY, VALUE, ...)
     Return user inputs from a list dialog box in a vector of selection indices (SEL) and a flag indicating how the user closed the dialog box (OK).

     The indices in SEL are 1-based.

     The value of OK is 1 if the user closed the box with the OK button, otherwise it is 0 and SEL is empty.

     Input arguments are specified in form of KEY, VALUE pairs.  The "ListString" argument pair must be specified.

     Valid KEY and VALUE pairs are:

     "ListString"
          a cell array of strings with the contents of the list.

     "SelectionMode"
          can be either "Single" or "Multiple" (default).

     "ListSize"
          a vector with two elements WIDTH and HEIGHT defining the size of the list field in pixels.  Default is [160 300].

     "InitialValue"
          a vector containing 1-based indices of preselected elements.  Default is 1 (first item).

     "Name"
          a string to be used as the dialog caption.  Default is "".

     "PromptString"
          a cell array of strings to be displayed above the list field.  Default is {}.

     "OKString"
          a string used to label the OK button.  Default is "OK".

     "CancelString"
          a string used to label the Cancel button.  Default is "Cancel".

     Example:

          my_options = {"An item", "another", "yet another"};
          [sel, ok] = listdlg ("ListString", my_options,
                               "SelectionMode", "Multiple");
          if (ok == 1)
            disp ("You selected:");
            for i = 1:numel (sel)
              disp (sprintf ("\t%s", my_options{sel(i)}));
            endfor
          else
            disp ("You cancelled.");
          endif

     See also: menu, errordlg, helpdlg, inputdlg, msgbox, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Return user inputs from a list dialog box in a vector of selection indices (SEL) and a flag indicating how the user closed the dialog box (OK).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
msgbox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1307
 -- : H = msgbox (MSG)
 -- : H = msgbox (MSG, TITLE)
 -- : H = msgbox (MSG, TITLE, ICON)
 -- : H = msgbox (..., CREATEMODE)
     Display MSG using a message dialog box.

     The message may have multiple lines separated by newline characters ("\n"), or it may be a cellstr array with one element for each line.

     The optional input TITLE (character string) can be used to decorate the dialog caption.

     The optional argument ICON selects a dialog icon.  It can be one of "none" (default), "error", "help", or "warn".

     The return value is always 1.

     Compatibility Note: The optional argument CREATEMODE is accepted for MATLAB compatibility, but is not implemented.  A valid CREATEMODE is either one of the character strings "nonmodal", "modal", or "replace", or a structure containing a field "WindowStyle" with one of the three character strings.

     Examples:

          msgbox ("Some message for the user.");
          msgbox ("Some message\nwith two lines.");
          msgbox ({"Some message", "with two lines."});
          msgbox ("Some message for the user.", "Fancy caption");

          % A message dialog box with error icon
          msgbox ("Some message for the user.", "Fancy caption", "error");

     See also: errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Display MSG using a message dialog box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
questdlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1303
 -- : BTN = questdlg (MSG)
 -- : BTN = questdlg (MSG, TITLE)
 -- : BTN = questdlg (MSG, TITLE, DEFAULT)
 -- : BTN = questdlg (MSG, TITLE, BTN1, BTN2, DEFAULT)
 -- : BTN = questdlg (MSG, TITLE, BTN1, BTN2, BTN3, DEFAULT)
     Display MSG using a question dialog box and return the caption of the activated button.

     The message may have multiple lines separated by newline characters ("\n"), or it may be a cellstr array with one element for each line.

     The optional TITLE (character string) can be used to specify the dialog caption.  It defaults to "Question Dialog".

     The dialog may contain two or three buttons which will all close the dialog.

     The string DEFAULT identifies the default button, which is activated by pressing the <ENTER> key.  It must match one of the strings given in BTN1, BTN2, or BTN3.

     If only MSG and TITLE are specified, three buttons with the default captions "Yes", "No", and "Cancel" are used.

     If only two button captions, BTN1 and BTN2, are specified the dialog will have only these two buttons.

     Examples:

          btn = questdlg ("Close Octave?", "Some fancy title", "Yes", "No", "No");
          if (strcmp (btn, "Yes"))
            exit ();
          endif

     See also: errordlg, helpdlg, inputdlg, listdlg, msgbox, warndlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Display MSG using a question dialog box and return the caption of the activated button.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rmappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 334
 -- : rmappdata (H, NAME)
 -- : rmappdata (H, NAME1, NAME2, ...)
     Delete the application data NAME from the graphics object with handle H.

     H may also be a vector of graphics handles.  Multiple application data names may be supplied to delete several properties at once.

     See also: setappdata, getappdata, isappdata.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Delete the application data NAME from the graphics object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
setappdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 605
 -- : setappdata (H, NAME, VALUE)
 -- : setappdata (H, NAME1, VALUE1, NAME2, VALUE3, ...)
 -- : setappdata (H, {NAME1, NAME2, ...}, {VALUE1, VALUE2, ...})
     Set the application data NAME to VALUE for the graphics object with handle H.

     H may also be a vector of graphics handles.  If the application data with the specified NAME does not exist, it is created.

     Multiple NAME/VALUE pairs can be specified.  Alternatively, a cell array of NAMES and a corresponding cell array of VALUES can be specified.

     See also: getappdata, isappdata, rmappdata, guidata, get, set, getpref, setpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Set the application data NAME to VALUE for the graphics object with handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
uibuttongroup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1469
 -- : HUI = uibuttongroup (PROPERTY, VALUE, ...)
 -- : HUI = uibuttongroup (PARENT, PROPERTY, VALUE, ...)
 -- : uibuttongroup (H)

     Create a uibuttongroup object and return a handle to it.

     uibuttongroups are used to create group uicontrols.

     If PARENT is omitted then a uibuttongroup for the current figure is created.  If no figure is available, a new figure is created first.

     If PARENT is given then a uibuttongroup relative to PARENT is created.

     Any provided property value pairs will override the default values of the created uibuttongroup object.

     Uibuttongroup properties are documented at *note Uibuttongroup Properties::.

     Examples:

          % create figure and panel on it
          f = figure;
          % create a button group
          gp = uibuttongroup (f, "Position", [ 0 0.5 1 1])
          % create a buttons in the group
          b1 = uicontrol (gp, "style", "radiobutton", ...
                          "string", "Choice 1", ...
                          "Position", [ 10 150 100 50 ]);
          b2 = uicontrol (gp, "style", "radiobutton", ...
                          "string", "Choice 2", ...
                          "Position", [ 10 50 100 30 ]);
          % create a button not in the group
          b3 = uicontrol (f, "style", "radiobutton", ...
                          "string", "Not in the group", ...
                          "Position", [ 10 50 100 50 ]);

     See also: figure, uipanel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create a uibuttongroup object and return a handle to it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
uicontextmenu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1028
 -- : HUI = uicontextmenu (PROPERTY, VALUE, ...)
 -- : HUI = uicontextmenu (H, PROPERTY, VALUE, ...)

     Create a uicontextmenu object and return a handle to it.

     If H is omitted then a uicontextmenu for the current figure is created.  If no figure is available, a new figure is created first.

     If H is given then a uicontextmenu relative to H is created.

     Any provided property value pairs will override the default values of the created uicontextmenu object.

     Uicontextmenu properties are documented at *note Uicontextmenu Properties::.

     Examples:

          % create figure and uicontextmenu
          f = figure;
          c = uicontextmenu (f);

          % create menus in the context menu
          m1 = uimenu ("parent",c,"label","Menu item 1","callback","disp('menu item 1')");
          m2 = uimenu ("parent",c,"label","Menu item 2","callback","disp('menu item 2')");

          % set the context menu for the figure
          set (f, "uicontextmenu", c);

     See also: figure, uimenu.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create a uicontextmenu object and return a handle to it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uicontrol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2489
 -- : HUI = uicontrol (PROPERTY, VALUE, ...)
 -- : HUI = uicontrol (PARENT, PROPERTY, VALUE, ...)
 -- : uicontrol (H)

     Create a uicontrol object and return a handle to it.

     uicontrols are used to create simple interactive controls such as push buttons, checkboxes, edit and list controls.

     If PARENT is omitted then a uicontrol for the current figure is created.  If no figure is available, a new figure is created first.

     If PARENT is given then a uicontrol relative to PARENT is created.

     Any provided property value pairs will override the default values of the created uicontrol object.

     Uicontrol properties are documented at *note Uicontrol Properties::.

     Control of the type of uicontrol created is through the use of the STYLE property.  If no style property is provided, a push button will be created.

     Valid styles for uicontrol are:

     "checkbox"
          Create a checkbox control that allows user on/off selection.

     "edit"
          Create an edit control that allows user input of single or multiple lines of text.

     "listbox"
          Create a listbox control that displays a list of items and allows user selection of single or multiple items.

     "popupmenu"
          Create a popupmenu control that displays a list of options that can be selected when the user clicks on the control.

     "pushbutton"
          Create a push button control that allows user to press to cause an action.

     "radiobutton"
          Create a radio button control intended to be used for mutually exclusive input in a group of radiobutton controls.

     "slider"
          Create a slider control that allows user selection from a range of values by sliding knob on the control.

     "text"
          Create a static text control to display single or multiple lines of text.

     "togglebutton"
          Create a toggle button control that appears like a push button but allows the user to select between two states.

     Examples:

          % create figure and panel on it
          f = figure;
          % create a button (default style)
          b1 = uicontrol (f, "string", "A Button", "position",[10 10 150 40]);
          % create an edit control
          e1 = uicontrol (f, "style", "edit", "string", "editable text", "position",[10 60 300 40]);
          % create a checkbox
          c1 = uicontrol (f, "style", "checkbox", "string", "a checkbox", "position",[10 120 150 40]);

     See also: figure, uipanel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Create a uicontrol object and return a handle to it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
uigetdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 338
 -- : DIRNAME = uigetdir ()
 -- : DIRNAME = uigetdir (INIT_PATH)
 -- : DIRNAME = uigetdir (INIT_PATH, DIALOG_NAME)
     Open a GUI dialog for selecting a directory.

     If INIT_PATH is not given the current working directory is used.

     DIALOG_NAME may be used to customize the dialog title.

     See also: uigetfile, uiputfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Open a GUI dialog for selecting a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uigetfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2293
 -- : [FNAME, FPATH, FLTIDX] = uigetfile ()
 -- : [...] = uigetfile (FLT)
 -- : [...] = uigetfile (FLT, DIALOG_NAME)
 -- : [...] = uigetfile (FLT, DIALOG_NAME, DEFAULT_FILE)
 -- : [...] = uigetfile (..., "Position", [PX PY])
 -- : [...] = uigetfile (..., "MultiSelect", MODE)

     Open a GUI dialog for selecting a file and return the filename FNAME, the path to this file FPATH, and the filter index FLTIDX.

     FLT contains a (list of) file filter string(s) in one of the following formats:

     "/path/to/filename.ext"
          If a filename is given then the file extension is extracted and used as filter.  In addition, the path is selected as current path and the filename is selected as default file.  Example: ‘uigetfile ("myfun.m")’

     A single file extension "*.ext"
          Example: ‘uigetfile ("*.ext")’

     A 2-column cell array
          containing a file extension in the first column and a brief description in the second column.  Example: ‘uigetfile ({"*.ext", "My Description";"*.xyz", "XYZ-Format"})’

          The filter string can also contain a semicolon separated list of filter extensions.  Example: ‘uigetfile ({"*.gif;*.png;*.jpg", "Supported Picture Formats"})’

     A directory name or path name
          If the folder name of path name contains a trailing file separator, the contents of that folder will be displayed.  If no trailing file separator is present the parent directory is listed.  The substring to the right of the rightmost file separator (if any) will be interpreted as a file or directory name and if that file or directory exists it will be highlighted.  If the path name or directory name is wholly or partly nonexistent, the current working directory will be displayed.  No filter will be active.

     DIALOG_NAME can be used to customize the dialog title.

     If DEFAULT_FILE is given then it will be selected in the GUI dialog.  If, in addition, a path is given it is also used as current path.

     The screen position of the GUI dialog can be set using the "Position" key and a 2-element vector containing the pixel coordinates.  Two or more files can be selected when setting the "MultiSelect" key to "on".  In that case FNAME is a cell array containing the files.

     See also: uiputfile, uigetdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
Open a GUI dialog for selecting a file and return the filename FNAME, the path to this file FPATH, and the filter index FLTIDX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uimenu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2031
 -- : HUI = uimenu (PROPERTY, VALUE, ...)
 -- : HUI = uimenu (H, PROPERTY, VALUE, ...)
     Create a uimenu object and return a handle to it.

     If H is omitted then a top-level menu for the current figure is created.  If H is given then a submenu relative to H is created.

     uimenu objects have the following specific properties:

     "accelerator"
          A string containing the key combination together with CTRL to execute this menu entry (e.g., "x" for CTRL+x).

     "callback"
          Is the function called when this menu entry is executed.  It can be either a function string (e.g., "myfun"), a function handle (e.g., @myfun) or a cell array containing the function handle and arguments for the callback function (e.g., {@myfun, arg1, arg2}).

     "checked"
          Can be set "on" or "off".  Sets a mark at this menu entry.

     "enable"
          Can be set "on" or "off".  If disabled the menu entry cannot be selected and it is grayed out.

     "foregroundcolor"
          A color value setting the text color for this menu entry.

     "label"
          A string containing the label for this menu entry.  A "&"-symbol can be used to mark the "accelerator" character (e.g., "E&xit")

     "position"
          An scalar value containing the relative menu position.  The entry with the lowest value is at the first position starting from left or top.

     "separator"
          Can be set "on" or "off".  If enabled it draws a separator line above the current position.  It is ignored for top level entries.

     The full list of properties is documented at *note Uimenu Properties: Uimenu Properties.

     Examples:

          f = uimenu ("label", "&File", "accelerator", "f");
          e = uimenu ("label", "&Edit", "accelerator", "e");
          uimenu (f, "label", "Close", "accelerator", "q", ...
                     "callback", "close (gcf)");
          uimenu (e, "label", "Toggle &Grid", "accelerator", "g", ...
                     "callback", "grid (gca)");

     See also: figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Create a uimenu object and return a handle to it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
uipanel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1105
 -- : uipanel (PROPERTY, VALUE, ...)
 -- : uipanel (PARENT, "PROPERTY, VALUE, ...)
 -- : HUI = uipanel (...)

     Create a uipanel object.

     uipanels are used as containers to group other uicontrol objects.

     If PARENT is omitted then a uipanel for the current figure is created.  If no figure is available, a new figure is created first.

     If PARENT is given then a uipanel relative to PARENT is created.

     Any provided property value pairs will override the default values of the created uipanel object.

     Uipanel properties are documented at *note Uipanel Properties::.

     The optional return value HUI is a graphics handle to the created uipanel object.

     Examples:

          % create figure and panel on it
          f = figure;
          p = uipanel ("title", "Panel Title", "position", [.25 .25 .5 .5]);

          % add two buttons to the panel
          b1 = uicontrol ("parent", p, "string", "A Button", "position",[18 10 150 36]);
          b2 = uicontrol ("parent", p, "string", "Another Button", "position",[18 60 150 36]);


     See also: figure, uicontrol.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Create a uipanel object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
uipushtool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1317
 -- : uipushtool (PROPERTY, VALUE, ...)
 -- : uipushtool (PARENT, PROPERTY, VALUE, ...)
 -- : HUI = uipushtool (...)

     Create a uipushtool object.

     uipushtools are buttons that appear on a figure toolbar.  The button is created with a border that is shown when the user hovers over the button.  An image can be set using the cdata property.

     If PARENT is omitted then a uipushtool for the current figure is created.  If no figure is available, a new figure is created first.  If a figure is available, but does not contain a uitoolbar, a uitoolbar will be created.

     If PARENT is given then a uipushtool is created on the PARENT uitoolbar.

     Any provided property value pairs will override the default values of the created uipushtool object.

     Uipushtool properties are documented at *note Uipushtool Properties::.

     The optional return value HUI is a graphics handle to the created uipushtool object.

     Examples:

          % create figure without a default toolbar
          f = figure ("toolbar", "none");
          % create empty toolbar
          t = uitoolbar (f);
          % create a 19x19x3 black square
          img=zeros(19,19,3);
          % add pushtool button to toolbar
          b = uipushtool (t, "cdata", img);

     See also: figure, uitoolbar, uitoggletool.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Create a uipushtool object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uiputfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1330
 -- : [FNAME, FPATH, FLTIDX] = uiputfile ()
 -- : [FNAME, FPATH, FLTIDX] = uiputfile (FLT)
 -- : [FNAME, FPATH, FLTIDX] = uiputfile (FLT, DIALOG_NAME)
 -- : [FNAME, FPATH, FLTIDX] = uiputfile (FLT, DIALOG_NAME, DEFAULT_FILE)
     Open a GUI dialog for selecting a file.

     FLT contains a (list of) file filter string(s) in one of the following formats:

     "/path/to/filename.ext"
          If a filename is given the file extension is extracted and used as filter.  In addition the path is selected as current path and the filename is selected as default file.  Example: ‘uiputfile ("myfun.m")’

     "*.ext"
          A single file extension.  Example: ‘uiputfile ("*.ext")’

     ‘{"*.ext", "My Description"}’
          A 2-column cell array containing the file extension in the 1st column and a brief description in the 2nd column.  Example: ‘uiputfile ({"*.ext","My Description";"*.xyz", "XYZ-Format"})’

     The filter string can also contain a semicolon separated list of filter extensions.  Example: ‘uiputfile ({"*.gif;*.png;*.jpg", "Supported Picture Formats"})’

     DIALOG_NAME can be used to customize the dialog title.  If DEFAULT_FILE is given it is preselected in the GUI dialog.  If, in addition, a path is given it is also used as current path.

     See also: uigetfile, uigetdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Open a GUI dialog for selecting a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
uiresume


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- : uiresume (H)
     Resume program execution suspended with ‘uiwait’.

     The handle H must be the same as the on specified in ‘uiwait’.  If the handle is invalid or there is no ‘uiwait’ call pending for the figure with handle H, this function does nothing.

     See also: uiwait.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Resume program execution suspended with ‘uiwait’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
uitoggletool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1348
 -- : uitoggletool (PROPERTY, VALUE, ...)
 -- : uitoggletool (PARENT, PROPERTY, VALUE, ...)
 -- : HUI = uitoggletool (...)

     Create a uitoggletool object.

     uitoggletool are togglebuttons that appear on a figure toolbar.  The button is created with a border that is shown when the user hovers over the button.  An image can be set using the cdata property.

     If PARENT is omitted then a uitoggletool for the current figure is created.  If no figure is available, a new figure is created first.  If a figure is available, but does not contain a uitoolbar, a uitoolbar will be created.

     If PARENT is given then a uitoggletool is created on the PARENT uitoolbar.

     Any provided property value pairs will override the default values of the created uitoggletool object.

     Uitoggletool properties are documented at *note Uitoggletool Properties::.

     The optional return value HUI is a graphics handle to the created uitoggletool object.

     Examples:

          % create figure without a default toolbar
          f = figure ("toolbar", "none");
          % create empty toolbar
          t = uitoolbar (f);
          % create a 19x19x3 black square
          img=zeros(19,19,3);
          % add uitoggletool button to toolbar
          b = uitoggletool (t, "cdata", img);

     See also: figure, uitoolbar, uipushtool.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Create a uitoggletool object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
uitoolbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 914
 -- : uitoolbar (PROPERTY, VALUE, ...)
 -- : uitoolbar (PARENT, PROPERTY, VALUE, ...)
 -- : HUI = uitoolbar (...)

     Create a uitoolbar object.  A uitoolbar displays uitoggletool and uipushtool buttons.

     If PARENT is omitted then a uitoolbar for the current figure is created.  If no figure is available, a new figure is created first.

     If PARENT is given then a uitoolbar relative to PARENT is created.

     Any provided property value pairs will override the default values of the created uitoolbar object.

     Uitoolbar properties are documented at *note Uitoolbar Properties::.

     The optional return value HUI is a graphics handle to the created uitoolbar object.

     Examples:

          % create figure without a default toolbar
          f = figure ("toolbar", "none");
          % create empty toolbar
          t = uitoolbar (f);

     See also: figure, uitoggletool, uipushtool.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create a uitoolbar object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uiwait


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 775
 -- : uiwait
 -- : uiwait (H)
 -- : uiwait (H, TIMEOUT)
     Suspend program execution until the figure with handle H is deleted or ‘uiresume’ is called.

     When no figure handle is specified this function uses the current figure.  If the figure handle is invalid or there is no current figure, this functions returns immediately.

     When specified, TIMEOUT defines the number of seconds to wait for the figure deletion or the ‘uiresume’ call.  The timeout value must be at least 1.  If a smaller value is specified, a warning is issued and a timeout value of 1 is used instead.  If a non-integer value is specified, it is truncated towards 0.  If TIMEOUT is not specified, the program execution is suspended indefinitely.

     See also: uiresume, waitfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Suspend program execution until the figure with handle H is deleted or ‘uiresume’ is called.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1063
 -- : H = waitbar (FRAC)
 -- : H = waitbar (FRAC, MSG)
 -- : H = waitbar (..., "createcancelbtn", FCN, ...)
 -- : H = waitbar (..., PROP, VAL, ...)
 -- : waitbar (FRAC)
 -- : waitbar (FRAC, H)
 -- : waitbar (FRAC, H, MSG)
     Return a handle H to a new progress indicator ("waitbar") object.

     The waitbar is filled to fraction FRAC which must be in the range [0, 1].

     The optional message MSG is centered and displayed above the waitbar.

     A cancel button can be added to the bottom of the waitbar using the "createcancelbtn" property of waitbar figures.  The action to be executed when the user presses the button is specified using a string or function handle FCN.

     The appearance of the waitbar figure window can be configured by passing PROP/VAL pairs to the function.

     When called with a single input the current waitbar, if it exists, is updated to the new value FRAC.  If there are multiple outstanding waitbars they can be updated individually by passing the handle H of the specific waitbar to modify.

     See also: delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return a handle H to a new progress indicator ("waitbar") object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
waitforbuttonpress


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- : waitforbuttonpress ()
 -- : B = waitforbuttonpress ()
     Wait for mouse click or key press over the current figure window.

     The return value of B is 0 if a mouse button was pressed or 1 if a key was pressed.

     See also: waitfor, ginput, kbhit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Wait for mouse click or key press over the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
warndlg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 998
 -- : H = warndlg ()
 -- : H = warndlg (MSG)
 -- : H = warndlg (MSG, TITLE)
 -- : H = warndlg (MSG, TITLE, CREATEMODE)
     Display a warning dialog box with warning message MSG and caption TITLE.

     The default warning message is "This is the default warning string."  and the default caption is "Warning Dialog".

     The warning message may have multiple lines separated by newline characters ("\n"), or it may be a cellstr array with one element for each line.

     The return value H is always 1.

     Compatibility Note: The optional argument CREATEMODE is accepted for MATLAB compatibility, but is not implemented.  See ‘msgbox’ for details.

     Examples:

          warndlg ("Some warning text for the user.");
          warndlg ("Some warning text\nwith two lines.");
          warndlg ({"Some warning text", "with two lines."});
          warndlg ("Some warning text for the user.", "Fancy caption");

     See also: errordlg, helpdlg, inputdlg, listdlg, msgbox, questdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Display a warning dialog box with warning message MSG and caption TITLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- Automatic Variable: ans
     The most recently computed result that was not explicitly assigned to a variable.

     For example, after the expression

          3^2 + 4^2

     is evaluated, the value returned by ‘ans’ is 25.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
The most recently computed result that was not explicitly assigned to a variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bessel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2187
 -- : [J, IERR] = besselj (ALPHA, X, OPT)
 -- : [Y, IERR] = bessely (ALPHA, X, OPT)
 -- : [I, IERR] = besseli (ALPHA, X, OPT)
 -- : [K, IERR] = besselk (ALPHA, X, OPT)
 -- : [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds.

     All functions begin with the prefix "bessel".  The list of functions is:

     ‘besselj’
          Bessel functions of the first kind.  If the argument OPT is supplied, the result is multiplied by ‘exp (-abs (imag (x)))’.

     ‘bessely’
          Bessel functions of the second kind.  If the argument OPT is supplied, the result is multiplied by ‘exp (-abs (imag (x)))’.

     ‘besseli’
          Modified Bessel functions of the first kind.  If the argument OPT is supplied, the result is multiplied by ‘exp (-abs (real (x)))’.

     ‘besselk’
          Modified Bessel functions of the second kind.  If the argument OPT is supplied, the result is multiplied by ‘exp (x)’.

     ‘besselh’
          Compute Hankel functions of the first (K = 1) or second (K = 2) kind.  If the argument OPT is supplied, the result is multiplied by ‘exp (-I*X)’ for K = 1 or ‘exp (I*X)’ for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a scalar, the result is the same size as ALPHA.  If ALPHA is a row vector and X is a column vector, the result is a matrix with ‘length (X)’ rows and ‘length (ALPHA)’ columns.  Otherwise, ALPHA and X must conform and the result will be the same size.

     The order of the Bessel function ALPHA must be real.  The points for evaluation X may be complex.

     If requested, IERR contains the following status information and is the same size as the result.

       0. Normal return.

       1. Input error, return ‘NaN’.

       2. Overflow, return ‘Inf’.

       3. Loss of significance by argument reduction results in less than half of machine accuracy.

       4. Loss of significance by argument reduction, output may be inaccurate.

       5. Error—no computation, algorithm termination condition not met, return ‘NaN’.

     See also: besselj, bessely, besseli, besselk, besselh.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute Bessel or Hankel functions of various kinds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
debug


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2162
 -- : debug ()
     Summary of debugging commands.

     For more information on each command and available options use ‘help CMD’.

     The debugging commands available in Octave are

     ‘dbstop’
          Add a breakpoint.

     ‘dbclear’
          Remove a breakpoint.

     ‘dbstatus’
          List all breakpoints.

     ‘dbwhere’
          Report the current file and line number where execution is stopped.

     ‘dbtype’
          Display the code of the function being debugged, enumerating the line numbers.

     ‘dblist’
          List 10 lines of code centered around the line number where execution is stopped.

     ‘dbstep’
     ‘dbnext’
          Execute (step) one or more lines, follow execution into (step into) a function call, or execute until the end of a function (step out), and re-enter debug mode.

     ‘dbcont’
          Continue normal code execution from the debug prompt.

     ‘dbquit’
          Quit debugging mode immediately and return to the main prompt.

     ‘dbstack’
          Print a backtrace of the execution stack.

     ‘dbup’
          Move up the execution stack.

     ‘dbdown’
          Move down the execution stack.

     ‘keyboard’
          Force entry into debug mode from an m-file.

     ‘debug_on_error’
          Configure whether Octave enters debug mode when it encounters an error.

     ‘debug_on_warning’
          Configure whether Octave enters debug mode when it encounters a warning.

     ‘debug_on_interrupt’
          Configure whether Octave enters debug mode when it encounters an interrupt.

     ‘isdebugmode’
          Return true if in debug mode.

     When Octave encounters a breakpoint, or other reason to enter debug mode, the prompt changes to "debug>".  The workspace of the function where the breakpoint was encountered becomes available and any Octave command that is valid in that workspace context may be executed.

     See also: dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont, dbquit, dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning, debug_on_interrupt, isdebugmode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Summary of debugging commands.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
doc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- : doc FUNCTION_NAME
 -- : doc
     Display documentation for the function FUNCTION_NAME directly from an online version of the printed manual, using the GNU Info browser.

     If invoked without an argument, the manual is shown from the beginning.

     For example, the command ‘doc rand’ starts the GNU Info browser at the ‘rand’ node in the online version of the manual.

     Once the GNU Info browser is running, help for using it is available using the command ‘C-h’.

     See also: help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Display documentation for the function FUNCTION_NAME directly from an online version of the printed manual, using the GNU Info browser.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
doc_cache_create


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 643
 -- : doc_cache_create (OUT_FILE, DIRECTORY)
 -- : doc_cache_create (OUT_FILE)
 -- : doc_cache_create ()
     Generate documentation cache for all functions in DIRECTORY.

     A documentation cache is generated for all functions in DIRECTORY which may be a single string or a cell array of strings.  The cache is used to speed up the function ‘lookfor’.

     The cache is saved in the file OUT_FILE which defaults to the value ‘doc-cache’ if not given.

     If no directory is given (or it is the empty matrix), a cache for built-in functions, operators, and keywords is generated.

     See also: doc_cache_file, lookfor, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Generate documentation cache for all functions in DIRECTORY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
error_ids


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 889
‘Octave:invalid-context’
     Indicates the error was generated by an operation that cannot be executed in the scope from which it was called.  For example, the function ‘print_usage ()’ when called from the Octave prompt raises this error.

‘Octave:invalid-input-arg’
     Indicates that a function was called with invalid input arguments.

‘Octave:invalid-fun-call’
     Indicates that a function was called in an incorrect way, e.g., wrong number of input arguments.

‘Octave:invalid-indexing’
     Indicates that a data-type was indexed incorrectly, e.g., real-value index for arrays, nonexistent field of a structure.

‘Octave:bad-alloc’
     Indicates that memory couldn’t be allocated.

‘Octave:undefined-function’
     Indicates a call to a function that is not defined.  The function may exist but Octave is unable to find it in the search path.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
‘Octave:invalid-context’  Indicates the error was generated by an operation that cannot be executed in the scope from which it was called.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
get_first_help_sentence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 844
 -- : TEXT = get_first_help_sentence (NAME)
 -- : TEXT = get_first_help_sentence (NAME, MAX_LEN)
 -- : [TEXT, STATUS] = get_first_help_sentence (...)
     Return the first sentence of a function’s help text.

     The first sentence is defined as the text after the function declaration until either the first period (".")  or the first appearance of two consecutive newlines ("\n\n").  The text is truncated to a maximum length of MAX_LEN, which defaults to 80.

     The optional output argument STATUS returns the status reported by ‘makeinfo’.  If only one output argument is requested, and STATUS is nonzero, a warning is displayed.

     As an example, the first sentence of this help text is

          get_first_help_sentence ("get_first_help_sentence")
          ⊣ ans = Return the first sentence of a function's help text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the first sentence of a function’s help text.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
help


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- : help NAME
 -- : help --list
 -- : help .
 -- : help
     Display the help text for NAME.

     For example, the command ‘help help’ prints a short message describing the ‘help’ command.

     Given the single argument ‘--list’, list all operators, keywords, built-in functions, and loadable functions available in the current session of Octave.

     Given the single argument ‘.’, list all operators available in the current session of Octave.

     If invoked without any arguments, ‘help’ displays instructions on how to access help from the command line.

     The help command can provide information about most operators, but NAME must be enclosed by single or double quotes to prevent the Octave interpreter from acting on NAME.  For example, ‘help "+"’ displays help on the addition operator.

     See also: doc, lookfor, which, info.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Display the help text for NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lookfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1342
 -- : lookfor STR
 -- : lookfor -all STR
 -- : [FCN, HELP1STR] = lookfor (STR)
 -- : [FCN, HELP1STR] = lookfor ("-all", STR)
     Search for the string STR in the documentation of all functions in the current function search path.

     By default, ‘lookfor’ looks for STR in just the first sentence of the help string for each function found.  The entire help text of each function can be searched by using the "-all" argument.  All searches are case insensitive.

     When called with no output arguments, ‘lookfor’ prints the list of matching functions to the terminal.  Otherwise, the output argument FCNS contains the function names and HELP1STR contains the first sentence from the help string of each function.

     Programming Note: The ability of ‘lookfor’ to correctly identify the first sentence of the help text is dependent on the format of the function’s help.  All Octave core functions are correctly formatted, but the same can not be guaranteed for external packages and user-supplied functions.  Therefore, the use of the "-all" argument may be necessary to find related functions that are not a part of Octave.

     The speed of lookup is greatly enhanced by having a cached documentation file.  See ‘doc_cache_create’ for more information.

     See also: help, doc, which, path, doc_cache_create.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Search for the string STR in the documentation of all functions in the current function search path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
print_usage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 260
 -- : print_usage ()
 -- : print_usage (NAME)
     Print the usage message for the function NAME.

     When called with no input arguments the ‘print_usage’ function displays the usage message of the currently executing function.

     See also: help.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Print the usage message for the function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
slash


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2018
 -- Documentation: slash
     Backslash and slash perform various sorts of division.

     ‘\’ Matrix Left Division (“backslash”)
          Solve systems of equations Ax = b for x.  ‘A \ b’ is conceptually equivalent to ‘inv (A) * b’ but is computed more efficiently and accurately, without forming the matrix inverse directly.

          Example:

               A = [1 2; 3 4];
               b = [4; 2];
               x = A \ b
                 ⇒ x =
                      -6
                       5
               isequal (A*x, b)
                 ⇒ 1

          If the system is not square, or if the matrix is singular, a minimum-norm solution is computed (‘norm (A*x - b)’).

          For dense matrices, backslash uses the Gaussian Elimination algorithm with partial pivoting.  For sparse matrices, backslash uses a direct method to compute an LU factorization (*note lu: XREFlu.).  The direct method tries to minimize “fill-in” of zeros but it could nonetheless use a lot of memory; if this is a concern, consider an iterative method (*note cgs: XREFcgs. or *note gmres: XREFgmres.).

     ‘/’ Matrix Right Division
          The forward slash notation can be used to solve systems of the form AB = C for A using ‘A = C / B’.

     ‘./’ and ‘.\’ Component-wise “Hadamard” Division
          The “dot slash” operators perform element-by-element division, for example:

               A = [1 10 12; 24 30 42];
               B = [1 5 4; 6 6 7];
               A ./ B
                 ⇒
                      1   2   3
                      4   5   6

          If the sizes are not the same, “broadcasting” may apply (*note Broadcasting::):

               420 ./ B
                 ⇒
                      420    84   105
                       70    70    60
               [20; 42] ./ B
                 ⇒
                      20    4    5
                       7    7    6

     See also: mldivide, mrdivide, ldivide, rdivide, linsolve.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Backslash and slash perform various sorts of division.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
type


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 539
 -- : type NAME ...
 -- : type -q NAME ...
 -- : text = type ("NAME", ...)
     Display the contents of NAME which may be a file, function (m-file), variable, operator, or keyword.

     ‘type’ normally prepends a header line describing the category of NAME such as function or variable; The ‘-q’ option suppresses this behavior.

     If no output variable is used the contents are displayed on screen.  Otherwise, a cell array of strings is returned, where each element corresponds to the contents of each requested function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Display the contents of NAME which may be a file, function (m-file), variable, operator, or keyword.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
warning_ids


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12354
‘Octave:abbreviated-property-match’
     By default, the ‘Octave:abbreviated-property-match’ warning is enabled.

‘Octave:addpath-pkg’
     If the ‘Octave:addpath-pkg’ warning is enabled, Octave will warn when a package directory (i.e., +package_name) is added to the ‘path’.  Typically, only the parent directory which contains the package directory should be added to the load path.  By default, the ‘Octave:addpath-pkg’ warning is enabled.

‘Octave:array-as-logical’
     If the ‘Octave:array-as-logical’ warning is enabled, Octave will warn when an array of size greater than 1x1 is used as a truth value in an if, while or until statement.  By default, the ‘Octave:array-as-logical’ warning is disabled.

‘Octave:array-to-scalar’
     If the ‘Octave:array-to-scalar’ warning is enabled, Octave will warn when an implicit conversion from an array to a scalar value is attempted.  By default, the ‘Octave:array-to-scalar’ warning is disabled.

‘Octave:array-to-vector’
     If the ‘Octave:array-to-vector’ warning is enabled, Octave will warn when an implicit conversion from an array to a vector value is attempted.  By default, the ‘Octave:array-to-vector’ warning is disabled.

‘Octave:assign-as-truth-value’
     If the ‘Octave:assign-as-truth-value’ warning is enabled, a warning is issued for statements like

          if (s = t)
            ...

     since such statements are not common, and it is likely that the intent was to write

          if (s == t)
            ...

     instead.

     There are times when it is useful to write code that contains assignments within the condition of a ‘while’ or ‘if’ statement.  For example, statements like

          while (c = getc ())
            ...

     are common in C programming.

     It is possible to avoid all warnings about such statements by disabling the ‘Octave:assign-as-truth-value’ warning, but that may also let real errors like

          if (x = 1)  # intended to test (x == 1)!
            ...

     slip by.

     In such cases, it is possible suppress errors for specific statements by writing them with an extra set of parentheses.  For example, writing the previous example as

          while ((c = getc ()))
            ...

     will prevent the warning from being printed for this statement, while allowing Octave to warn about other assignments used in conditional contexts.

     By default, the ‘Octave:assign-as-truth-value’ warning is enabled.

‘Octave:associativity-change’
     If the ‘Octave:associativity-change’ warning is enabled, Octave will warn about possible changes in the meaning of some code due to changes in associativity for some operators.  Associativity changes have typically been made for MATLAB compatibility.  By default, the ‘Octave:associativity-change’ warning is enabled.

‘Octave:autoload-relative-file-name’
     If the ‘Octave:autoload-relative-file-name’ is enabled, Octave will warn when parsing autoload() function calls with relative paths to function files.  This usually happens when using autoload() calls in PKG_ADD files, when the PKG_ADD file is not in the same directory as the .oct file referred to by the autoload() command.  By default, the ‘Octave:autoload-relative-file-name’ warning is enabled.

‘Octave:built-in-variable-assignment’
     By default, the ‘Octave:built-in-variable-assignment’ warning is enabled.

‘Octave:deprecated-function’
     If the ‘Octave:deprecated-function’ warning is enabled, a warning is issued when Octave encounters a function that is obsolete and scheduled for removal from Octave.  By default, the ‘Octave:deprecated-function’ warning is enabled.

‘Octave:deprecated-keyword’
     If the ‘Octave:deprecated-keyword’ warning is enabled, a warning is issued when Octave encounters a keyword that is obsolete and scheduled for removal from Octave.  By default, the ‘Octave:deprecated-keyword’ warning is enabled.

‘Octave:deprecated-property’
     If the ‘Octave:deprecated-property’ warning is enabled, a warning is issued when Octave encounters a graphics property that is obsolete and scheduled for removal from Octave.  By default, the ‘Octave:deprecated-property’ warning is enabled.

‘Octave:divide-by-zero’
     If the ‘Octave:divide-by-zero’ warning is enabled, a warning is issued when Octave encounters a division by zero.  By default, the ‘Octave:divide-by-zero’ warning is enabled.

‘Octave:eigs:UnconvergedEigenvalues’
     If the ‘Octave:eigs:UnconvergedEigenvalues’ warning is enabled then the eigs function will issue a warning if the number of calculated eigenvalues is less than the number of requested eigenvalues.  By default, the ‘Octave:eigs:UnconvergedEigenvalues’ warning is enabled.

‘Octave:erase:chararray’
     If the ‘Octave:erase:chararray’ warning is enabled then the erase function will issue a warning if the input pattern is a character array rather than a string or cell array of strings.  By default, the ‘Octave:erase:chararray’ warning is enabled.

‘Octave:data-file-in-path’
     If the ‘Octave:data-file-in-path’ warning is enabled, a warning is issued when Octave does not find the target of a file operation such as ‘load’ or ‘fopen’ directly, but is able to locate the file in Octave’s search ‘path’ for files.  The warning could indicate that a different file target than the programmer intended is being used.  By default, the ‘Octave:data-file-in-path’ warning is enabled.

‘Octave:function-name-clash’
     If the ‘Octave:function-name-clash’ warning is enabled, a warning is issued when Octave finds that the name of a function defined in a function file differs from the name of the file.  (If the names disagree, the name declared inside the file is ignored.)  By default, the ‘Octave:function-name-clash’ warning is enabled.

‘Octave:future-time-stamp’
     If the ‘Octave:future-time-stamp’ warning is enabled, Octave will print a warning if it finds a function file with a time stamp that is in the future.  By default, the ‘Octave:future-time-stamp’ warning is enabled.

‘Octave:glyph-render’
     By default, the ‘Octave:glyph-render’ warning is enabled.

‘Octave:imag-to-real’
     If the ‘Octave:imag-to-real’ warning is enabled, a warning is printed for implicit conversions of complex numbers to real numbers.  By default, the ‘Octave:imag-to-real’ warning is disabled.

‘Octave:language-extension’
     Print warnings when using features that are unique to the Octave language and that may still be missing in MATLAB.  By default, the ‘Octave:language-extension’ warning is disabled.  The ‘--traditional’ or ‘--braindead’ startup options for Octave may also be of use, *note Command Line Options::.

‘Octave:logical-conversion’
     By default, the ‘Octave:logical-conversion’ warning is enabled.

‘Octave:lu:sparse_input’
     If the ‘Octave:lu:sparse_input’ warning is enabled, Octave will warn when the lu function is called with a sparse input and less than four output arguments.  In this case, sparsity-preserving column permutations are not performed and the result may be inaccurate.  By default, the ‘Octave:lu:sparse_input’ warning is enabled.

‘Octave:missing-glyph’
     By default, the ‘Octave:missing-glyph’ warning is enabled.

‘Octave:missing-semicolon’
     If the ‘Octave:missing-semicolon’ warning is enabled, Octave will warn when statements in function definitions don’t end in semicolons.  By default the ‘Octave:missing-semicolon’ warning is disabled.

‘Octave:mixed-string-concat’
     If the ‘Octave:mixed-string-concat’ warning is enabled, print a warning when concatenating a mixture of double and single quoted strings.  By default, the ‘Octave:mixed-string-concat’ warning is disabled.

‘Octave:nearly-singular-matrix’
‘Octave:singular-matrix’
     By default, the ‘Octave:nearly-singular-matrix’ and ‘Octave:singular-matrix’ warnings are enabled.

‘Octave:neg-dim-as-zero’
     If the ‘Octave:neg-dim-as-zero’ warning is enabled, print a warning for expressions like

          eye (-1)

     By default, the ‘Octave:neg-dim-as-zero’ warning is disabled.

‘Octave:nested-functions-coerced’
     By default, the ‘Octave:nested-functions-coerced’ warning is enabled.

‘Octave:noninteger-range-as-index’
     By default, the ‘Octave:noninteger-range-as-index’ warning is enabled.

‘Octave:num-to-str’
     If the ‘Octave:num-to-str’ warning is enable, a warning is printed for implicit conversions of numbers to their ASCII character equivalents when strings are constructed using a mixture of strings and numbers in matrix notation.  For example,

          [ "f", 111, 111 ]
          ⇒ "foo"

     elicits a warning if the ‘Octave:num-to-str’ warning is enabled.  By default, the ‘Octave:num-to-str’ warning is enabled.

‘Octave:possible-matlab-short-circuit-operator’
     If the ‘Octave:possible-matlab-short-circuit-operator’ warning is enabled, Octave will warn about using the not short circuiting operators ‘&’ and ‘|’ inside ‘if’ or ‘while’ conditions.  They normally never short circuit, but they do short circuit when used in a condition.  By default, the ‘Octave:possible-matlab-short-circuit-operator’ warning is enabled.

‘Octave:precedence-change’
     If the ‘Octave:precedence-change’ warning is enabled, Octave will warn about possible changes in the meaning of some code due to changes in precedence for some operators.  Precedence changes have typically been made for MATLAB compatibility.  By default, the ‘Octave:precedence-change’ warning is enabled.

‘Octave:recursive-path-search’
     By default, the ‘Octave:recursive-path-search’ warning is enabled.

‘Octave:remove-init-dir’
     The ‘path’ function changes the search path that Octave uses to find functions.  It is possible to set the path to a value which excludes Octave’s own built-in functions.  If the ‘Octave:remove-init-dir’ warning is enabled then Octave will warn when the ‘path’ function has been used in a way that may render Octave unworkable.  By default, the ‘Octave:remove-init-dir’ warning is enabled.

‘Octave:reload-forces-clear’
     If several functions have been loaded from the same file, Octave must clear all the functions before any one of them can be reloaded.  If the ‘Octave:reload-forces-clear’ warning is enabled, Octave will warn you when this happens, and print a list of the additional functions that it is forced to clear.  By default, the ‘Octave:reload-forces-clear’ warning is enabled.

‘Octave:resize-on-range-error’
     If the ‘Octave:resize-on-range-error’ warning is enabled, print a warning when a matrix is resized by an indexed assignment with indices outside the current bounds.  By default, the ‘Octave:resize-on-range-error’ warning is disabled.

‘Octave:separator-insert’
     Print warning if commas or semicolons might be inserted automatically in literal matrices.  By default, the ‘Octave:separator-insert’ warning is disabled.

‘Octave:shadowed-function’
     By default, the ‘Octave:shadowed-function’ warning is enabled.

‘Octave:single-quote-string’
     Print warning if a single quote character is used to introduce a string constant.  By default, the ‘Octave:single-quote-string’ warning is disabled.

‘Octave:sqrtm:SingularMatrix’
     By default, the ‘Octave:sqrtm:SingularMatrix’ warning is enabled.

‘Octave:str-to-num’
     If the ‘Octave:str-to-num’ warning is enabled, a warning is printed for implicit conversions of strings to their numeric ASCII equivalents.  For example,

          "abc" + 0
          ⇒ 97 98 99

     elicits a warning if the ‘Octave:str-to-num’ warning is enabled.  By default, the ‘Octave:str-to-num’ warning is disabled.

‘Octave:variable-switch-label’
     If the ‘Octave:variable-switch-label’ warning is enabled, Octave will print a warning if a switch label is not a constant or constant expression.  By default, the ‘Octave:variable-switch-label’ warning is disabled.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
‘Octave:abbreviated-property-match’  By default, the ‘Octave:abbreviated-property-match’ warning is enabled.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
which


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- : which name ...
     Display the type of each NAME.

     If NAME is defined from a function file, the full name of the file is also displayed.

     See also: help, lookfor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Display the type of each NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
autumn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 267
 -- : MAP = autumn ()
 -- : MAP = autumn (N)
     Create color colormap.  This colormap ranges from red through orange to yellow.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
bone


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- : MAP = bone ()
 -- : MAP = bone (N)
     Create color colormap.  This colormap varies from black to white with gray-blue shades.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
brighten


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- : MAP_OUT = brighten (BETA)
 -- : MAP_OUT = brighten (MAP, BETA)
 -- : MAP_OUT = brighten (H, BETA)
 -- : brighten (...)
     Brighten or darken a colormap.

     The argument BETA must be a scalar between -1 and 1, where a negative value darkens and a positive value brightens the colormap.

     If the MAP argument is omitted, the function is applied to the current colormap.

     The first argument can also be a valid graphics handle H, in which case ‘brighten’ is applied to the colormap associated with this handle.

     If no output is specified then the result is written to the current colormap.

     See also: colormap, contrast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Brighten or darken a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cmpermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 570
 -- : [Y, NEWMAP] = cmpermute (X, MAP)
 -- : [Y, NEWMAP] = cmpermute (X, MAP, INDEX)
     Reorder colors in a colormap.

     When called with only two arguments, ‘cmpermute’ randomly rearranges the colormap MAP and returns a new colormap NEWMAP.  It also returns the indexed image Y which is the equivalent of the original input image X when displayed using NEWMAP.

     When called with an optional third argument the order of colors in the new colormap is defined by INDEX.

     *Caution:* INDEX should not have repeated elements or the function will fail.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Reorder colors in a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cmunique


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1342
 -- : [Y, NEWMAP] = cmunique (X, MAP)
 -- : [Y, NEWMAP] = cmunique (RGB)
 -- : [Y, NEWMAP] = cmunique (I)
     Convert an input image X to an ouput indexed image Y which uses the smallest colormap possible NEWMAP.

     When the input is an indexed image (X with colormap MAP) the output is a colormap NEWMAP from which any repeated rows have been eliminated.  The output image, Y, is the original input image with the indices adjusted to match the new, possibly smaller, colormap.

     When the input is an RGB image (an MxNx3 array), the output colormap will contain one entry for every unique color in the original image.  In the worst case the new map could have as many rows as the number of pixels in the original image.

     When the input is a grayscale image I, the output colormap will contain one entry for every unique intensity value in the original image.  In the worst case the new map could have as many rows as the number of pixels in the original image.

     Implementation Details:

     NEWMAP is always an Mx3 matrix, even if the input image is an intensity grayscale image I (all three RGB planes are assigned the same value).

     The output image is of class uint8 if the size of the new colormap is less than or equal to 256.  Otherwise, the output image is of class double.

     See also: rgb2ind, gray2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Convert an input image X to an ouput indexed image Y which uses the smallest colormap possible NEWMAP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
colorcube


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- : MAP = colorcube ()
 -- : MAP = colorcube (N)
     Create color colormap.  This colormap is composed of as many equally spaced colors (not grays) in the RGB color space as possible.

     If there are not a perfect number N of regularly spaced colors then the remaining entries in the colormap are gradients of pure red, green, blue, and gray.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colormap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7828
 -- : CMAP = colormap ()
 -- : CMAP = colormap (MAP)
 -- : CMAP = colormap ("default")
 -- : CMAP = colormap (MAP_NAME)
 -- : CMAP = colormap (HAX, ...)
 -- : colormap MAP_NAME
     Query or set the current colormap.

     With no input arguments, ‘colormap’ returns the current color map.

     ‘colormap (MAP)’ sets the current colormap to MAP.  The colormap should be an N row by 3 column matrix.  The columns contain red, green, and blue intensities respectively.  All entries must be between 0 and 1 inclusive.  The new colormap is returned.

     ‘colormap ("default")’ restores the default colormap (the ‘viridis’ map with 64 entries).  The default colormap is returned.

     The map may also be specified by a string, MAP_NAME, which is the name of a function that returns a colormap.

     If the first argument HAX is an axes handle, then the colormap for those axes is queried or set.

     For convenience, it is also possible to use this function with the command form, ‘colormap MAP_NAME’.

     The list of built-in colormaps is:

     Map                                                                                                                                                        Description
     ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     viridis                                                                                                                                                    default
     jet                                                                                                                                                        colormap traversing blue, cyan, green, yellow, red.
     cubehelix                                                                                                                                                  colormap traversing black, blue, green, red, white with increasing intensity.
     hsv                                                                                                                                                        cyclic colormap traversing Hue, Saturation, Value space.
     rainbow                                                                                                                                                    colormap traversing red, yellow, blue, green, violet.
     ————-                                                                                                                                                      ———————————————————————————————
     hot                                                                                                                                                        colormap traversing black, red, orange, yellow, white.
     cool                                                                                                                                                       colormap traversing cyan, purple, magenta.
     spring                                                                                                                                                     colormap traversing magenta to yellow.
     summer                                                                                                                                                     colormap traversing green to yellow.
     autumn                                                                                                                                                     colormap traversing red, orange, yellow.
     winter                                                                                                                                                     colormap traversing blue to green.
     ————-                                                                                                                                                      ———————————————————————————————
     gray                                                                                                                                                       colormap traversing black to white in shades of gray.
     bone                                                                                                                                                       colormap traversing black, gray-blue, white.
     copper                                                                                                                                                     colormap traversing black to light copper.
     pink                                                                                                                                                       colormap traversing black, gray-pink, white.
     ocean                                                                                                                                                      colormap traversing black, dark-blue, white.
     ————-                                                                                                                                                      ———————————————————————————————
     colorcube                                                                                                                                                  equally spaced colors in RGB color space.
     flag                                                                                                                                                       cyclic 4-color map of red, white, blue, black.
     lines                                                                                                                                                      cyclic colormap with colors from axes "ColorOrder" property.
     prism                                                                                                                                                      cyclic 6-color map of red, orange, yellow, green, blue, violet.
     ————-                                                                                                                                                      ———————————————————————————————
     white                                                                                                                                                      all white colormap (no colors).

     See also: viridis, jet, cubehelix, hsv, rainbow, hot, cool, spring, summer, autumn, winter, gray, bone, copper, pink, ocean, colorcube, flag, lines, prism, white.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Query or set the current colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contrast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 277
 -- : CMAP = contrast (X)
 -- : CMAP = contrast (X, N)
     Return a gray colormap that maximizes the contrast in an image.

     The returned colormap will have N rows.  If N is not defined then the size of the current colormap is used.

     See also: colormap, brighten.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a gray colormap that maximizes the contrast in an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 249
 -- : MAP = cool ()
 -- : MAP = cool (N)
     Create color colormap.  The colormap varies from cyan to magenta.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
copper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 267
 -- : MAP = copper ()
 -- : MAP = copper (N)
     Create color colormap.  This colormap varies from black to a light copper tone.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cubehelix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 804
 -- : MAP = cubehelix ()
 -- : MAP = cubehelix (N)
     Create cubehelix colormap.

     This colormap varies from black to white going though blue, green, and red tones while maintaining a monotonically increasing perception of intensity.  This is achieved by traversing a color cube from black to white through a helix, hence the name cubehelix, while taking into account the perceived brightness of each channel according to the NTSC specifications from 1953.

          rgbplot (cubehelix (256))

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     Reference: Green, D. A., 2011, ‘"A colour scheme for the display of astronomical intensity images"’, Bulletin of the Astronomical Society of India, 39, 289.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create cubehelix colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
flag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 -- : MAP = flag ()
 -- : MAP = flag (N)
     Create color colormap.  This colormap cycles through red, white, blue, and black with each index change.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
frame2im


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 425
 -- : [X, MAP] = frame2im (FRAME)
     Convert movie frame to indexed image.

     A movie frame is simply a struct with the fields "cdata" and "colormap".

     Support for N-dimensional images or movies is given when FRAME is a struct array.  In such cases, X will be a MxNx1xK or MxNx3xK for indexed and RGB movies respectively, with each frame concatenated along the 4th dimension.

     See also: im2frame, getframe.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert movie frame to indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getframe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1026
 -- : FRAME = getframe ()
 -- : FRAME = getframe (HAX)
 -- : FRAME = getframe (HFIG)
 -- : FRAME = getframe (..., RECT)

     Capture a figure or axes as a movie frame structure.

     Without an argument, capture the current axes excluding ticklabels, title, and x/y/zlabels.  The returned structure FRAME has a field ‘cdata’, which contains the actual image data in the form of an NxMx3 (RGB) uint8 matrix, and a field ‘colormap’ which is provided for MATLAB compatibility but is always empty.

     If the first argument HAX is an axes handle, then capture this axes, rather than the current axes returned by ‘gca’.

     If the first argument HFIG is a figure handle then the entire corresponding figure canvas is captured.

     Finally, if a second argument RECT is provided it must be a four-element vector ([left bottom width height]) defining the region inside the figure to be captured.  Regardless of the figure "units" property, RECT must be defined in *pixels*.

     See also: im2frame, frame2im.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Capture a figure or axes as a movie frame structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- : MAP = gray ()
 -- : MAP = gray (N)
     Create gray colormap.  This colormap varies from black to white with shades of gray.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Create gray colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gray2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- : IMG = gray2ind (I)
 -- : IMG = gray2ind (I, N)
 -- : IMG = gray2ind (BW)
 -- : IMG = gray2ind (BW, N)
 -- : [IMG, MAP] = gray2ind (...)
     Convert a grayscale or binary intensity image to an indexed image.

     The indexed image will consist of N different intensity values.  If not given N defaults to 64 for grayscale images or 2 for binary black and white images.

     The output IMG is of class uint8 if N is less than or equal to 256; Otherwise the return class is uint16.

     See also: ind2gray, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert a grayscale or binary intensity image to an indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
hot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 286
 -- : MAP = hot ()
 -- : MAP = hot (N)
     Create color colormap.  This colormap ranges from black through dark red, red, orange, yellow, to white.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
hsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 541
 -- : hsv (N)
     Create color colormap.  This colormap begins with red, changes through yellow, green, cyan, blue, and magenta, before returning to red.

     It is useful for displaying periodic functions.  The map is obtained by linearly varying the hue through all possible values while keeping constant maximum saturation and value.  The equivalent code is ‘hsv2rgb ([(0:N-1)'/N, ones(N,2)])’.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hsv2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 967
 -- : RGB_MAP = hsv2rgb (HSV_MAP)
 -- : RGB_IMG = hsv2rgb (HSV_IMG)
     Transform a colormap or image from HSV to RGB color space.

     A color in HSV space is represented by hue, saturation and value (brightness) levels in a cylindrical coordinate system.  Hue is the azimuth and describes the dominant color.  Saturation is the radial distance and gives the amount of hue mixed into the color.  Value is the height and is the amount of light in the color.

     The input can be both a colormap or RGB image.  In the case of floating point input, values are expected to be on the [0 1] range.  In the case of hue (azimuth), since the value corresponds to an angle, ‘mod (h, 1)’ is used.

          >> hsv2rgb ([0.5 1 1])
          ⇒ ans = 0 1 1

          >> hsv2rgb ([2.5 1 1])
          ⇒ ans = 0 1 1

          >> hsv2rgb ([3.5 1 1])
          ⇒ ans = 0 1 1

     Output class and size will be the same as input.

     See also: rgb2hsv, ind2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Transform a colormap or image from HSV to RGB color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 842
 -- : im2double (IMG)
 -- : im2double (IMG, "indexed")
     Convert image to double precision.

     The conversion of IMG to double precision, is dependent on the type of input image.  The following input classes are supported:

     ‘uint8, uint16, and int16’
          The range of values from the class is scaled to the interval [0 1].

     ‘logical’
          True and false values are assigned a value of 0 and 1 respectively.

     ‘single’
          Values are cast to double.

     ‘double’
          Returns the same image.

     If IMG is an indexed image, then the second argument should be the string "indexed".  If so, then IMG must either be of floating point class, or unsigned integer class and it will simply be cast to double.  If it is an integer class, a +1 offset is applied.

     See also: double.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Convert image to double precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
im2frame


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 408
 -- : im2frame (RGB)
 -- : im2frame (X, MAP)
     Convert image to movie frame.

     A movie frame is simply a struct with the fields "cdata" and "colormap".

     Support for N-dimensional images is given when each image projection, matrix sizes of MxN and MxNx3 for RGB images, is concatenated along the fourth dimension.  In such cases, the returned value is a struct array.

     See also: frame2im.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Convert image to movie frame.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
image


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1896
 -- : image (IMG)
 -- : image (X, Y, IMG)
 -- : image (..., "PROP", VAL, ...)
 -- : image ("PROP1", VAL1, ...)
 -- : H = image (...)
     Display a matrix as an indexed color image.

     The elements of IMG are indices into the current colormap.

     X and Y are optional 2-element vectors, ‘[min, max]’, which specify the range for the axis labels.  If a range is specified as ‘[max, min]’ then the image will be reversed along that axis.  For convenience, X and Y may be specified as N-element vectors matching the length of the data in IMG.  However, only the first and last elements will be used to determine the axis limits.

     Multiple property/value pairs may be specified for the image object, but they must appear in pairs.

     The optional return value H is a graphics handle to the image.

     Implementation Note: The origin (0, 0) for images is located in the upper left.  For ordinary plots, the origin is located in the lower left.  Octave handles this inversion by plotting the data normally, and then reversing the direction of the y-axis by setting the ‘ydir’ property to "reverse".  This has implications whenever an image and an ordinary plot need to be overlaid.  The recommended solution is to display the image and then plot the reversed ydata using, for example, ‘flipud (ydata)’.

     Calling Forms: The ‘image’ function can be called in two forms: High-Level and Low-Level.  When invoked with normal options, the High-Level form is used which first calls ‘newplot’ to prepare the graphic figure and axes.  When the only inputs to ‘image’ are property/value pairs the Low-Level form is used which creates a new instance of an image object and inserts it in the current axes.

     Graphic Properties: The full list of properties is documented at *note Image Properties: Image Properties.

     See also: imshow, imagesc, colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Display a matrix as an indexed color image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imagesc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1191
 -- : imagesc (IMG)
 -- : imagesc (X, Y, IMG)
 -- : imagesc (..., CLIMITS)
 -- : imagesc (..., "PROP", VAL, ...)
 -- : imagesc ("PROP1", VAL1, ...)
 -- : imagesc (HAX, ...)
 -- : H = imagesc (...)
     Display a scaled version of the matrix IMG as a color image.

     The colormap is scaled so that the entries of the matrix occupy the entire colormap.  If ‘CLIMITS = [LO, HI]’ is given, then that range is set to the "clim" of the current axes.

     The axis values corresponding to the matrix elements are specified in X and Y, either as pairs giving the minimum and maximum values for the respective axes, or as values for each row and column of the matrix IMG.

     The optional return value H is a graphics handle to the image.

     Calling Forms: The ‘imagesc’ function can be called in two forms: High-Level and Low-Level.  When invoked with normal options, the High-Level form is used which first calls ‘newplot’ to prepare the graphic figure and axes.  When the only inputs to ‘image’ are property/value pairs the Low-Level form is used which creates a new instance of an image object and inserts it in the current axes.

     See also: image, imshow, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Display a scaled version of the matrix IMG as a color image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imfinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3946
 -- : INFO = imfinfo (FILENAME)
 -- : INFO = imfinfo (URL)
 -- : INFO = imfinfo (..., EXT)
     Read image information from a file.

     ‘imfinfo’ returns a structure containing information about the image stored in the file FILENAME.  If there is no file FILENAME, and EXT was specified, it will look for a file named FILENAME and extension EXT, i.e., a file named FILENAME.EXT.

     The output structure INFO contains the following fields:

     ‘Filename’
          The full name of the image file.

     ‘FileModDate’
          Date of last modification to the file.

     ‘FileSize’
          Number of bytes of the image on disk

     ‘Format’
          Image format (e.g., "jpeg").

     ‘Height’
          Image height in pixels.

     ‘Width’
          Image Width in pixels.

     ‘BitDepth’
          Number of bits per channel per pixel.

     ‘ColorType’
          Image type.  Value is "grayscale", "indexed", "truecolor", "CMYK", or "undefined".

     ‘XResolution’
          X resolution of the image.

     ‘YResolution’
          Y resolution of the image.

     ‘ResolutionUnit’
          Units of image resolution.  Value is "Inch", "Centimeter", or "undefined".

     ‘DelayTime’
          Time in 1/100ths of a second (0 to 65535) which must expire before displaying the next image in an animated sequence.

     ‘LoopCount’
          Number of iterations to loop an animation.

     ‘ByteOrder’
          Endian option for formats that support it.  Value is "little-endian", "big-endian", or "undefined".

     ‘Gamma’
          Gamma level of the image.  The same color image displayed on two different workstations may look different due to differences in the display monitor.

     ‘Quality’
          JPEG/MIFF/PNG compression level.  Value is an integer in the range [0 100].

     ‘DisposalMethod’
          Only valid for GIF images, control how successive frames are rendered (how the preceding frame is disposed of) when creating a GIF animation.  Values can be "doNotSpecify", "leaveInPlace", "restoreBG", or "restorePrevious".  For non-GIF files, value is an empty string.

     ‘Chromaticities’
          Value is a 1x8 Matrix with the x,y chromaticity values for white, red, green, and blue points, in that order.

     ‘Comment’
          Image comment.

     ‘Compression’
          Compression type.  Value can be "none", "bzip", "fax3", "fax4", "jpeg", "lzw", "rle", "deflate", "lzma", "jpeg2000", "jbig2", "jbig2", or "undefined".

     ‘Colormap’
          Colormap for each image.

     ‘Orientation’
          The orientation of the image with respect to the rows and columns.  Value is an integer between 1 and 8 as defined in the TIFF 6 specifications, and for MATLAB compatibility.

     ‘Software’
          Name and version of the software or firmware of the camera or image input device used to generate the image.

     ‘Make’
          The manufacturer of the recording equipment.  This is the manufacture of the DSC, scanner, video digitizer or other equipment that generated the image.

     ‘Model’
          The model name or model number of the recording equipment as mentioned on the field "Make".

     ‘DateTime’
          The date and time of image creation as defined by the Exif standard, i.e., it is the date and time the file was changed.

     ‘ImageDescription’
          The title of the image as defined by the Exif standard.

     ‘Artist’
          Name of the camera owner, photographer or image creator.

     ‘Copyright’
          Copyright notice of the person or organization claiming rights to the image.

     ‘DigitalCamera’
          A struct with information retrieved from the Exif tag.

     ‘GPSInfo’
          A struct with geotagging information retrieved from the Exif tag.

     See also: imread, imwrite, imshow, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read image information from a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imformats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1638
 -- : imformats ()
 -- : FORMATS = imformats (EXT)
 -- : FORMATS = imformats (FORMAT)
 -- : FORMATS = imformats ("add", FORMAT)
 -- : FORMATS = imformats ("remove", EXT)
 -- : FORMATS = imformats ("update", EXT, FORMAT)
 -- : FORMATS = imformats ("factory")
     Manage supported image formats.

     FORMATS is a structure with information about each supported file format, or from a specific format EXT, the value displayed on the field EXT.  It contains the following fields:

     ext
          The name of the file format.  This may match the file extension but Octave will automatically detect the file format.

     description
          A long description of the file format.

     isa
          A function handle to confirm if a file is of the specified format.

     write
          A function handle to write if a file is of the specified format.

     read
          A function handle to open files the specified format.

     info
          A function handle to obtain image information of the specified format.

     alpha
          Logical value if format supports alpha channel (transparency or matte).

     multipage
          Logical value if format supports multipage (multiple images per file).

     It is possible to change the way Octave manages file formats with the options "add", "remove", and "update", and supplying a structure FORMAT with the required fields.  The option "factory" resets the configuration to the default.

     This can be used by Octave packages to extend the image reading capabilities Octave, through use of the PKG_ADD and PKG_DEL commands.

     See also: imfinfo, imread, imwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Manage supported image formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2533
 -- : [IMG, MAP, ALPHA] = imread (FILENAME)
 -- : [...] = imread (URL)
 -- : [...] = imread (..., EXT)
 -- : [...] = imread (..., IDX)
 -- : [...] = imread (..., PARAM1, VALUE1, ...)
     Read images from various file formats.

     Read an image as a matrix from the file FILENAME or from the online resource URL.  If neither is given, but EXT was specified, look for a file with the extension EXT.

     The size and class of the output depends on the format of the image.  A color image is returned as an MxNx3 matrix.  Grayscale and black-and-white images are of size MxN.  Multipage images will have an additional 4th dimension.

     The bit depth of the image determines the class of the output: "uint8", "uint16", or "single" for grayscale and color, and "logical" for black-and-white.  Note that indexed images always return the indexes for a colormap, independent of whether MAP is a requested output.  To obtain the actual RGB image, use ‘ind2rgb’.  When more than one indexed image is being read, MAP is obtained from the first.  In some rare cases this may be incorrect and ‘imfinfo’ can be used to obtain the colormap of each image.

     See the Octave manual for more information in representing images.

     Some file formats, such as TIFF and GIF, are able to store multiple images in a single file.  IDX can be a scalar or vector specifying the index of the images to read.  By default, Octave will read only the first page.

     Depending on the file format, it is possible to configure the reading of images with PARAMETER, VALUE pairs.  The following options are supported:

     "Frames" or "Index"
          This is an alternative method to specify IDX.  When specifying it in this way, its value can also be the string "all".

     "Info"
          This option exists for MATLAB compatibility, but has no effect.  For maximum performance when reading multiple images from a single file, use the "Index" option.

     "PixelRegion"
          Controls the image region that is read.  The value must be a cell array with two arrays of 3 elements ‘{[ROWS], [COLS]}’.  The elements in the array are the start, increment, and end pixel to be read.  If the increment value is omitted it defaults to 1.  For example, the following are all equivalent:

               imread (filename, "PixelRegion", {[200 600], [300 700]});
               imread (filename, "PixelRegion", {[200 1 600], [300 1 700]});
               imread (filename)(200:600, 300:700);

     See also: imwrite, imfinfo, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Read images from various file formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imshow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1639
 -- : imshow (IM)
 -- : imshow (IM, LIMITS)
 -- : imshow (IM, MAP)
 -- : imshow (RGB, ...)
 -- : imshow (FILENAME)
 -- : imshow (..., STRING_PARAM1, VALUE1, ...)
 -- : H = imshow (...)
     Display the image IM, where IM can be a 2-dimensional (grayscale image) or a 3-dimensional (RGB image) matrix.

     If LIMITS is a 2-element vector ‘[LOW, HIGH]’, the image is shown using a display range between LOW and HIGH.  If an empty matrix is passed for LIMITS, the display range is computed as the range between the minimal and the maximal value in the image.

     If MAP is a valid color map, the image will be shown as an indexed image using the supplied color map.

     If a filename is given instead of an image, the file will be read and shown.

     If given, the parameter STRING_PARAM1 has value VALUE1.  STRING_PARAM1 can be any of the following:

     "displayrange"
          VALUE1 is the display range as described above.

     "colormap"
          VALUE1 is the colormap to use when displaying an indexed image.

     "xdata"
          If VALUE1 is a two element vector, it must contain horizontal axis limits in the form [xmin xmax]; Otherwise VALUE1 must be a vector and only the first and last elements will be used for xmin and xmax respectively.

     "ydata"
          If VALUE1 is a two element vector, it must contain vertical axis limits in the form [ymin ymax]; Otherwise VALUE1 must be a vector and only the first and last elements will be used for ymin and ymax respectively.

     The optional return value H is a graphics handle to the image.

     See also: image, imagesc, colormap, gray2ind, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 110
Display the image IM, where IM can be a 2-dimensional (grayscale image) or a 3-dimensional (RGB image) matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3572
 -- : imwrite (IMG, FILENAME)
 -- : imwrite (IMG, FILENAME, EXT)
 -- : imwrite (IMG, MAP, FILENAME)
 -- : imwrite (..., PARAM1, VAL1, ...)
     Write images in various file formats.

     The image IMG can be a binary, grayscale, RGB, or multi-dimensional image.  The size and class of IMG should be the same as what should be expected when reading it with ‘imread’: the 3rd and 4th dimensions reserved for color space, and multiple pages respectively.  If it’s an indexed image, the colormap MAP must also be specified.

     If EXT is not supplied, the file extension of FILENAME is used to determine the format.  The actual supported formats are dependent on options made during the build of Octave.  Use ‘imformats’ to check the support of the different image formats.

     Depending on the file format, it is possible to configure the writing of images with PARAM, VAL pairs.  The following options are supported:

     ‘Alpha’
          Alpha (transparency) channel for the image.  This must be a matrix with same class, and number of rows and columns of IMG.  In case of a multipage image, the size of the 4th dimension must also match and the third dimension must be a singleton.  By default, image will be completely opaque.

     ‘Compression’
          Compression to use one the image.  Can be one of the following: "none" (default), "bzip", "fax3", "fax4", "jpeg", "lzw", "rle", or "deflate".  Note that not all compression types are available for all image formats in which it defaults to your Magick library.

     ‘DelayTime’
          For formats that accept animations (such as GIF), controls for how long a frame is displayed until it moves to the next one.  The value must be scalar (which will applied to all frames in IMG), or a vector of length equal to the number of frames in IM.  The value is in seconds, must be between 0 and 655.35, and defaults to 0.5.

     ‘DisposalMethod’
          For formats that accept animations (such as GIF), controls what happens to a frame before drawing the next one.  Its value can be one of the following strings: "doNotSpecify" (default); "leaveInPlace"; "restoreBG"; and "restorePrevious", or a cell array of those string with length equal to the number of frames in IMG.

     ‘LoopCount’
          For formats that accept animations (such as GIF), controls how many times the sequence is repeated.  A value of Inf means an infinite loop (default), a value of 0 or 1 that the sequence is played only once (loops zero times), while a value of 2 or above loops that number of times (looping twice means it plays the complete sequence 3 times).  This option is ignored when there is only a single image at the end of writing the file.

     ‘Quality’
          Set the quality of the compression.  The value should be an integer between 0 and 100, with larger values indicating higher visual quality and lower compression.  Defaults to 75.

     ‘WriteMode’
          Some file formats, such as TIFF and GIF, are able to store multiple images in a single file.  This option specifies if IMG should be appended to the file (if it exists) or if a new file should be created for it (possibly overwriting an existing file).  The value should be the string "Overwrite" (default), or "Append".

          Despite this option, the most efficient method of writing a multipage image is to pass a 4 dimensional IMG to ‘imwrite’, the same matrix that could be expected when using ‘imread’ with the option "Index" set to "all".

     See also: imread, imfinfo, imformats.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Write images in various file formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ind2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 846
 -- : I = ind2gray (X, MAP)
     Convert a color indexed image to a grayscale intensity image.

     The image X must be an indexed image which will be converted using the colormap MAP.  If MAP does not contain enough colors for the image, pixels in X outside the range are mapped to the last color in the map before conversion to grayscale.

     The output I is of the same class as the input X and may be one of ‘uint8’, ‘uint16’, ‘single’, or ‘double’.

     Implementation Note: There are several ways of converting colors to grayscale intensities.  This functions uses the luminance value obtained from ‘rgb2gray’ which is ‘I = 0.299*R + 0.587*G + 0.114*B’.  Other possibilities include the value component from ‘rgb2hsv’ or using a single color channel from ‘ind2rgb’.

     See also: gray2ind, ind2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Convert a color indexed image to a grayscale intensity image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ind2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 731
 -- : RGB = ind2rgb (X, MAP)
 -- : [R, G, B] = ind2rgb (X, MAP)
     Convert an indexed image to red, green, and blue color components.

     The image X must be an indexed image which will be converted using the colormap MAP.  If MAP does not contain enough colors for the image, pixels in X outside the range are mapped to the last color in the map.

     The output may be a single RGB image (MxNx3 matrix where M and N are the original image X dimensions, one for each of the red, green and blue channels).  Alternatively, the individual red, green, and blue color matrices of size MxN may be returned.

     Multi-dimensional indexed images (of size MxNx1xK) are also supported.

     See also: rgb2ind, ind2gray, hsv2rgb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert an indexed image to red, green, and blue color components.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
iscolormap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 442
 -- : iscolormap (CMAP)
     Return true if CMAP is a colormap.

     A colormap is a real matrix, of class single or double, with 3 columns.  Each row represents a single color.  The 3 columns contain red, green, and blue intensities respectively.

     All values in a colormap should be in the [0 1] range but this is not enforced.  Each function must decide what to do for values outside this range.

     See also: colormap, rgbplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if CMAP is a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
jet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 294
 -- : MAP = jet ()
 -- : MAP = jet (N)
     Create color colormap.  This colormap ranges from dark blue through blue, cyan, green, yellow, red, to dark red.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lines


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- : MAP = lines ()
 -- : MAP = lines (N)
     Create color colormap.  This colormap is composed of the list of colors in the current axes "ColorOrder" property.  The default is blue, orange, yellow, purple, green, light blue, and dark red.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ocean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- : MAP = ocean ()
 -- : MAP = ocean (N)
     Create color colormap.  This colormap varies from black to white with shades of blue.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 344
 -- : MAP = pink ()
 -- : MAP = pink (N)
     Create color colormap.  This colormap varies from black to white with shades of gray-pink.

     This colormap gives a sepia tone when used on grayscale images.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
prism


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 306
 -- : MAP = prism ()
 -- : MAP = prism (N)
     Create color colormap.  This colormap cycles through red, orange, yellow, green, blue and violet with each index change.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rainbow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 291
 -- : MAP = rainbow ()
 -- : MAP = rainbow (N)
     Create color colormap.  This colormap ranges from red through orange, yellow, green, blue, to violet.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rgb2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- : I = rgb2gray (RGB_IMG)
 -- : GRAY_MAP = rgb2gray (RGB_MAP)
     Transform an image or colormap from red-green-blue (RGB) color space to a grayscale intensity image.

     The input may be of class uint8, int8, uint16, int16, single, or double.  The output is of the same class as the input.

     Implementation Note: The grayscale intensity is calculated as

          I = 0.298936*R + 0.587043*G + 0.114021*B

     which corresponds to the luminance channel when RGB is translated to YIQ as documented in <https://en.wikipedia.org/wiki/YIQ>.

     See also: rgb2hsv, rgb2ind.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Transform an image or colormap from red-green-blue (RGB) color space to a grayscale intensity image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2hsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 639
 -- : HSV_MAP = rgb2hsv (RGB_MAP)
 -- : HSV_IMG = rgb2hsv (RGB_IMG)
     Transform a colormap or image from RGB to HSV color space.

     A color in the RGB space consists of red, green, and blue intensities.

     A color in HSV space is represented by hue, saturation and value (brightness) levels in a cylindrical coordinate system.  Hue is the azimuth and describes the dominant color.  Saturation is the radial distance and gives the amount of hue mixed into the color.  Value is the height and is the amount of light in the color.

     Output class and size will be the same as input.

     See also: hsv2rgb, rgb2ind, rgb2gray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Transform a colormap or image from RGB to HSV color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 900
 -- : [X, MAP] = rgb2ind (RGB)
 -- : [X, MAP] = rgb2ind (R, G, B)
     Convert an image in red-green-blue (RGB) color space to an indexed image.

     The input image RGB can be specified as a single matrix of size MxNx3, or as three separate variables, R, G, and B, its three color channels, red, green, and blue.

     It outputs an indexed image X and a colormap MAP to interpret an image exactly the same as the input.  No dithering or other form of color quantization is performed.  The output class of the indexed image X can be uint8, uint16 or double, whichever is required to specify the number of unique colors in the image (which will be equal to the number of rows in MAP) in order.

     Multi-dimensional indexed images (of size MxNx3xK) are also supported, both via a single input (RGB) or its three color channels as separate variables.

     See also: ind2rgb, rgb2hsv, rgb2gray.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Convert an image in red-green-blue (RGB) color space to an indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgbplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
 -- : rgbplot (CMAP)
 -- : rgbplot (CMAP, STYLE)
 -- : H = rgbplot (...)
     Plot the components of a colormap.

     Two different STYLEs are available for displaying the CMAP:

     profile (default)
          Plot the RGB line profile of the colormap for each of the channels (red, green and blue) with the plot lines colored appropriately.  Each line represents the intensity of an RGB component across the colormap.

     composite
          Draw the colormap across the X-axis so that the actual index colors are visible rather than the individual color components.

     The optional return value H is a graphics handle to the created plot.

     Run ‘demo rgbplot’ to see an example of ‘rgbplot’ and each style option.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Plot the components of a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spinmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 579
 -- : spinmap ()
 -- : spinmap (T)
 -- : spinmap (T, INC)
 -- : spinmap ("inf")
     Cycle the colormap for T seconds with a color increment of INC.

     Both parameters are optional.  The default cycle time is 5 seconds and the default increment is 2.  If the option "inf" is given then cycle continuously until ‘Control-C’ is pressed.

     When rotating, the original color 1 becomes color 2, color 2 becomes color 3, etc.  A positive or negative increment is allowed and a higher value of INC will cause faster cycling through the colormap.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Cycle the colormap for T seconds with a color increment of INC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spring


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 256
 -- : MAP = spring ()
 -- : MAP = spring (N)
     Create color colormap.  This colormap varies from magenta to yellow.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
summer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 254
 -- : MAP = summer ()
 -- : MAP = summer (N)
     Create color colormap.  This colormap varies from green to yellow.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
viridis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 290
 -- : MAP = viridis ()
 -- : MAP = viridis (N)
     Create color colormap.  This colormap ranges from dark purplish-blue through blue, green, to yellow.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
white


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 244
 -- : MAP = white ()
 -- : MAP = white (N)
     Create color colormap.  This colormap is completely white.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
winter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- : MAP = winter ()
 -- : MAP = winter (N)
     Create color colormap.  This colormap varies from blue to green.

     The argument N must be a scalar.  If unspecified, the length of the current colormap, or 64, is used.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Create color colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
beep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- : beep ()
     Produce a beep from the speaker (or visual bell).

     This function sends the alarm character "\a" to the terminal.  Depending on the user’s configuration this may produce an audible beep, a visual bell, or nothing at all.

     See also: puts, fputs, printf, fprintf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Produce a beep from the speaker (or visual bell).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
csvread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 469
 -- : X = csvread (FILENAME)
 -- : X = csvread (FILENAME, DLM_OPT1, ...)
     Read the comma-separated-value (CSV) file FILENAME into the matrix X.

     Note: only CSV files containing numeric data can be read.

     This function is equivalent to

          X = dlmread (FILENAME, "," , DLM_OPT1, ...)

     Any optional arguments are passed directly to ‘dlmread’ (*note dlmread: XREFdlmread.).

     See also: dlmread, textread, textscan, csvwrite, dlmwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Read the comma-separated-value (CSV) file FILENAME into the matrix X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
csvwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 403
 -- : csvwrite (FILENAME, X)
 -- : csvwrite (FILENAME, X, DLM_OPT1, ...)
     Write the numeric matrix X to the file FILENAME in comma-separated-value (CSV) format.

     This function is equivalent to

          dlmwrite (FILENAME, X, ",", DLM_OPT1, ...)

     Any optional arguments are passed directly to ‘dlmwrite’ (*note dlmwrite: XREFdlmwrite.).

     See also: csvread, dlmwrite, dlmread.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Write the numeric matrix X to the file FILENAME in comma-separated-value (CSV) format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dlmwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1613
 -- : dlmwrite (FILE, M)
 -- : dlmwrite (FILE, M, DELIM, R, C)
 -- : dlmwrite (FILE, M, KEY, VAL ...)
 -- : dlmwrite (FILE, M, "-append", ...)
 -- : dlmwrite (FID, ...)
     Write the numeric matrix M to the text file FILE using a delimiter.

     FILE should be a filename or a writable file ID given by ‘fopen’.

     The parameter DELIM specifies the delimiter to use to separate values on a row.  If no delimiter is specified the comma character ‘,’ is used.

     The value of R specifies the number of delimiter-only lines to add to the start of the file.

     The value of C specifies the number of delimiters to prepend to each line of data.

     If the argument "-append" is given, append to the end of FILE.

     In addition, the following keyword value pairs may appear at the end of the argument list:

     "append"
          Either "on" or "off".  See "-append" above.

     "delimiter"
          See DELIM above.

     "newline"
          The character(s) to separate each row.  Three special cases exist for this option.  "unix" is changed into "\n", "pc" is changed into "\r\n", and "mac" is changed into "\r".  Any other value is used directly as the newline separator.

     "roffset"
          See R above.

     "coffset"
          See C above.

     "precision"
          The precision to use when writing the file.  It can either be a format string (as used by fprintf) or a number of significant digits.

          dlmwrite ("file.csv", reshape (1:16, 4, 4));

          dlmwrite ("file.tex", a, "delimiter", "&", "newline", "\n")

     See also: dlmread, csvread, csvwrite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Write the numeric matrix M to the text file FILE using a delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fileread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- : STR = fileread (FILENAME)
     Read the contents of FILENAME and return it as a string.

     See also: fread, textread, sscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Read the contents of FILENAME and return it as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
importdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 913
 -- : A = importdata (FNAME)
 -- : A = importdata (FNAME, DELIMITER)
 -- : A = importdata (FNAME, DELIMITER, HEADER_ROWS)
 -- : [A, DELIMITER] = importdata (...)
 -- : [A, DELIMITER, HEADER_ROWS] = importdata (...)
     Import data from the file FNAME.

     Input parameters:

        • FNAME The name of the file containing data.

        • DELIMITER The character separating columns of data.  Use ‘\t’ for tab.  (Only valid for ASCII files)

        • HEADER_ROWS The number of header rows before the data begins.  (Only valid for ASCII files)

     Different file types are supported:

        • ASCII table

          Import ASCII table using the specified number of header rows and the specified delimiter.

        • Image file

        • MATLAB file

        • Spreadsheet files (depending on external software)

        • WAV file

     See also: textscan, dlmread, csvread, load.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Import data from the file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
is_valid_file_id


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- : is_valid_file_id (FID)
     Return true if FID refers to an open file.

     See also: freport, fopen.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return true if FID refers to an open file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5382
 -- : [A, ...] = strread (STR)
 -- : [A, ...] = strread (STR, FORMAT)
 -- : [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT)
 -- : [A, ...] = strread (STR, FORMAT, PROP1, VALUE1, ...)
 -- : [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT, PROP1, VALUE1, ...)
     Read data from a string.

     The string STR is split into words that are repeatedly matched to the specifiers in FORMAT.  The first word is matched to the first specifier, the second to the second specifier and so forth.  If there are more words than specifiers, the process is repeated until all words have been processed.

     The string FORMAT describes how the words in STR should be parsed.  It may contain any combination of the following specifiers:

     ‘%s’
          The word is parsed as a string.

     ‘%f’
     ‘%n’
          The word is parsed as a number and converted to double.

     ‘%d’
     ‘%u’
          The word is parsed as a number and converted to int32.

     ‘%*’
     ‘%*f’
     ‘%*s’
          The word is skipped.

          For %s and %d, %f, %n, %u and the associated %*s ... specifiers an optional width can be specified as %Ns, etc. where N is an integer > 1.  For %f, format specifiers like %N.Mf are allowed.

     ‘literals’
          In addition the format may contain literal character strings; these will be skipped during reading.

     Parsed word corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers.

     By default, FORMAT is "%f", meaning that numbers are read from STR.  This will do if STR contains only numeric fields.

     For example, the string

          STR = "\
          Bunny Bugs   5.5\n\
          Duck Daffy  -7.5e-5\n\
          Penguin Tux   6"

     can be read using

          [A, B, C] = strread (STR, "%s %s %f");

     Optional numeric argument FORMAT_REPEAT can be used for limiting the number of items read:

     -1
          (default) read all of the string until the end.

     N
          Read N times NARGOUT items.  0 (zero) is an acceptable value for FORMAT_REPEAT.

     The behavior of ‘strread’ can be changed via property-value pairs.  The following properties are recognized:

     "commentstyle"
          Parts of STR are considered comments and will be skipped.  VALUE is the comment style and can be any of the following.

             • "shell" Everything from ‘#’ characters to the nearest end-of-line is skipped.

             • "c" Everything between ‘/*’ and ‘*/’ is skipped.

             • "c++" Everything from ‘//’ characters to the nearest end-of-line is skipped.

             • "matlab" Everything from ‘%’ characters to the nearest end-of-line is skipped.

             • user-supplied.  Two options: (1) One string, or 1x1 cell string: Skip everything to the right of it; (2) 2x1 cell string array: Everything between the left and right strings is skipped.

     "delimiter"
          Any character in VALUE will be used to split STR into words (default value = any whitespace).  Note that whitespace is implicitly added to the set of delimiter characters unless a "%s" format conversion specifier is supplied; see "whitespace" parameter below.  The set of delimiter characters cannot be empty; if needed Octave substitutes a space as delimiter.

     "emptyvalue"
          Value to return for empty numeric values in non-whitespace delimited data.  The default is NaN.  When the data type does not support NaN (int32 for example), then default is zero.

     "multipledelimsasone"
          Treat a series of consecutive delimiters, without whitespace in between, as a single delimiter.  Consecutive delimiter series need not be vertically "aligned".

     "treatasempty"
          Treat single occurrences (surrounded by delimiters or whitespace) of the string(s) in VALUE as missing values.

     "returnonerror"
          If VALUE true (1, default), ignore read errors and return normally.  If false (0), return an error.

     "whitespace"
          Any character in VALUE will be interpreted as whitespace and trimmed; the string defining whitespace must be enclosed in double quotes for proper processing of special characters like "\t".  In each data field, multiple consecutive whitespace characters are collapsed into one space and leading and trailing whitespace is removed.  The default value for whitespace is " \b\r\n\t" (note the space).  Whitespace is always added to the set of delimiter characters unless at least one "%s" format conversion specifier is supplied; in that case only whitespace explicitly specified in "delimiter" is retained as delimiter and removed from the set of whitespace characters.  If whitespace characters are to be kept as-is (in e.g., strings), specify an empty value (i.e., "") for "whitespace"; obviously, whitespace cannot be a delimiter then.

     When the number of words in STR doesn’t match an exact multiple of the number of format conversion specifiers, strread’s behavior depends on the last character of STR:

     last character = "\n"
          Data columns are padded with empty fields or NaN so that all columns have equal length

     last character is not "\n"
          Data columns are not padded; strread returns columns of unequal length

     See also: textscan, textread, load, dlmread, fscanf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Read data from a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
textread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2680
 -- : [A, ...] = textread (FILENAME)
 -- : [A, ...] = textread (FILENAME, FORMAT)
 -- : [A, ...] = textread (FILENAME, FORMAT, N)
 -- : [A, ...] = textread (FILENAME, FORMAT, PROP1, VALUE1, ...)
 -- : [A, ...] = textread (FILENAME, FORMAT, N, PROP1, VALUE1, ...)
     Read data from a text file.

     The file FILENAME is read and parsed according to FORMAT.  The function behaves like ‘strread’ except it works by parsing a file instead of a string.  See the documentation of ‘strread’ for details.

     In addition to the options supported by ‘strread’, this function supports two more:

        • "headerlines": The first VALUE number of lines of FILENAME are skipped.

        • "endofline": Specify a single character or "\r\n".  If no value is given, it will be inferred from the file.  If set to "" (empty string) EOLs are ignored as delimiters.

     The optional input N (format repeat count) specifies the number of times the format string is to be used or the number of lines to be read, whichever happens first while reading.  The former is equivalent to requesting that the data output vectors should be of length N.  Note that when reading files with format strings referring to multiple lines, N should rather be the number of lines to be read than the number of format string uses.

     If the format string is empty (not just omitted) and the file contains only numeric data (excluding headerlines), textread will return a rectangular matrix with the number of columns matching the number of numeric fields on the first data line of the file.  Empty fields are returned as zero values.

     Examples:

            Assume a data file like:
            1 a 2 b
            3 c 4 d
            5 e

            [a, b] = textread (f, "%f %s")
            returns two columns of data, one with doubles, the other a
            cellstr array:
            a = [1; 2; 3; 4; 5]
            b = {"a"; "b"; "c"; "d"; "e"}

            [a, b] = textread (f, "%f %s", 3)
            (read data into two culumns, try to use the format string
            three times)
            returns
            a = [1; 2; 3]
            b = {"a"; "b"; "c"}


            With a data file like:
            1
            a
            2
            b

            [a, b] = textread (f, "%f %s", 2)
            returns a = 1 and b = {"a"}; i.e., the format string is used
            only once because the format string refers to 2 lines of the
            data file.  To obtain 2x1 data output columns, specify N = 4
            (number of data lines containing all requested data) rather
            than 2.

     See also: strread, load, dlmread, fscanf, textscan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Read data from a text file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
javaArray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- : JARY = javaArray (CLASSNAME, SZ)
 -- : JARY = javaArray (CLASSNAME, M, N, ...)

     Create a Java array of size SZ with elements of class CLASSNAME.

     CLASSNAME may be a Java object representing a class or a string containing the fully qualified class name.  The size of the object may also be specified with individual integer arguments M, N, etc.

     The generated array is uninitialized.  All elements are set to null if CLASSNAME is a reference type, or to a default value (usually 0) if CLASSNAME is a primitive type.

     Sample code:

          jary = javaArray ("java.lang.String", 2, 2);
          jary(1,1) = "Hello";

     See also: javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Create a Java array of size SZ with elements of class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java_get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- : VAL = java_get (OBJ, NAME)
     Get the value of the field NAME of the Java object OBJ.

     For static fields, OBJ can be a string representing the fully qualified name of the corresponding class.

     When OBJ is a regular Java object, structure-like indexing can be used as a shortcut syntax.  For instance, the following two statements are equivalent

            java_get (x, "field1")
            x.field1

     See also: java_set, javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Get the value of the field NAME of the Java object OBJ.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java_set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- : OBJ = java_set (OBJ, NAME, VAL)
     Set the value of the field NAME of the Java object OBJ to VAL.

     For static fields, OBJ can be a string representing the fully qualified named of the corresponding Java class.

     When OBJ is a regular Java object, structure-like indexing can be used as a shortcut syntax.  For instance, the following two statements are equivalent

            java_set (x, "field1", val)
            x.field1 = val

     See also: java_get, javaMethod, javaObject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Set the value of the field NAME of the Java object OBJ to VAL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
javaaddpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 375
 -- : javaaddpath (CLSPATH)
 -- : javaaddpath (CLSPATH1, ...)
     Add CLSPATH to the dynamic class path of the Java virtual machine.

     CLSPATH may either be a directory where ‘.class’ files are found, or a ‘.jar’ file containing Java classes.  Multiple paths may be added at once by specifying additional arguments.

     See also: javarmpath, javaclasspath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Add CLSPATH to the dynamic class path of the Java virtual machine.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
javachk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1490
 -- : javachk (FEATURE)
 -- : javachk (FEATURE, COMPONENT)
 -- : MSG = javachk (...)
     Check for the presence of the Java FEATURE in the current session and print or return an error message if it is not.

     Possible features are:

     "awt"
          Abstract Window Toolkit for GUIs.

     "desktop"
          Interactive desktop is running.

     "jvm"
          Java Virtual Machine.

     "swing"
          Swing components for lightweight GUIs.

     If FEATURE is supported and

        • no output argument is requested:

          Return an empty string

        • an output argument is requested:

          Return a struct with fields "feature" and "identifier" both empty

     If FEATURE is not supported and

        • no output argument is requested:

          Emit an error message

        • an output argument is requested:

          Return a struct with field "feature" set to FEATURE and field "identifier" set to COMPONENT

     The optional input COMPONENT will be used in place of FEATURE in any error messages for greater specificity.

     ‘javachk’ determines if specific Java features are available in an Octave session.  This function is provided for scripts which may alter their behavior based on the availability of Java.  The feature "desktop" is never available as Octave has no Java-based desktop.  Other features may be available if Octave was compiled with the Java Interface and Java is installed.

     See also: usejava, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
Check for the presence of the Java FEATURE in the current session and print or return an error message if it is not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
javaclasspath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 923
 -- : javaclasspath ()
 -- : DPATH = javaclasspath ()
 -- : [DPATH, SPATH] = javaclasspath ()
 -- : CLSPATH = javaclasspath (WHAT)
     Return the class path of the Java virtual machine in the form of a cell array of strings.

     If called with no inputs:

        • If no output is requested, the dynamic and static classpaths are printed to the standard output.

        • If one output value DPATH is requested, the result is the dynamic classpath.

        • If two output valuesDPATH and SPATH are requested, the first variable will contain the dynamic classpath and the second will contain the static classpath.

     If called with a single input parameter WHAT:

     "-dynamic"
          Return the dynamic classpath.

     "-static"
          Return the static classpath.

     "-all"
          Return both the static and dynamic classpath in a single cellstr.

     See also: javaaddpath, javarmpath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Return the class path of the Java virtual machine in the form of a cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
javamem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1638
 -- : javamem ()
 -- : JMEM = javamem ()
     Show the current memory usage of the Java virtual machine (JVM) and run the garbage collector.

     When no return argument is given the info is printed to the screen.  Otherwise, the output cell array JMEM contains Maximum, Total, and Free memory (in bytes).

     All Java-based routines are run in the JVM’s shared memory pool, a dedicated and separate part of memory claimed by the JVM from your computer’s total memory (which comprises physical RAM and virtual memory / swap space on hard disk).

     The maximum allowable memory usage can be configured using the file ‘java.opts’.  The directory where this file resides is determined by the environment variable ‘OCTAVE_JAVA_DIR’.  If unset, the directory where ‘javaaddpath.m’ resides is used instead (typically ‘OCTAVE_HOME/share/octave/OCTAVE_VERSION/m/java/’).

     ‘java.opts’ is a plain text file with one option per line.  The default initial memory size and default maximum memory size (which are both system dependent) can be overridden like so:

     -Xms64m

     -Xmx512m

     (in megabytes in this example).  You can adapt these values to your own requirements if your system has limited available physical memory or if you get Java memory errors.

     "Total memory" is what the operating system has currently assigned to the JVM and depends on actual and active memory usage.  "Free memory" is self-explanatory.  During operation of Java-based Octave functions the amount of Total and Free memory will vary, due to Java’s own cleaning up and your operating system’s memory management.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Show the current memory usage of the Java virtual machine (JVM) and run the garbage collector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javarmpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 381
 -- : javarmpath (CLSPATH)
 -- : javarmpath (CLSPATH1, ...)
     Remove CLSPATH from the dynamic class path of the Java virtual machine.

     CLSPATH may either be a directory where ‘.class’ files are found, or a ‘.jar’ file containing Java classes.  Multiple paths may be removed at once by specifying additional arguments.

     See also: javaaddpath, javaclasspath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Remove CLSPATH from the dynamic class path of the Java virtual machine.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
usejava


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 749
 -- : usejava (FEATURE)
     Return true if the Java element FEATURE is available.

     Possible features are:

     "awt"
          Abstract Window Toolkit for GUIs.

     "desktop"
          Interactive desktop is running.

     "jvm"
          Java Virtual Machine.

     "swing"
          Swing components for lightweight GUIs.

     ‘usejava’ determines if specific Java features are available in an Octave session.  This function is provided for scripts which may alter their behavior based on the availability of Java.  The feature "desktop" always returns ‘false’ as Octave has no Java-based desktop.  Other features may be available if Octave was compiled with the Java Interface and Java is installed.

     See also: javachk.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the Java element FEATURE is available.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bandwidth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- : BW = bandwidth (A, TYPE)
 -- : [LOWER, UPPER] = bandwidth (A)
     Compute the bandwidth of A.

     The TYPE argument is the string "lower" for the lower bandwidth and "upper" for the upper bandwidth.  If no TYPE is specified return both the lower and upper bandwidth of A.

     The lower/upper bandwidth of a matrix is the number of subdiagonals/superdiagonals with nonzero entries.

     See also: isbanded, isdiag, istril, istriu.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the bandwidth of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
commutation_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 361
 -- : commutation_matrix (M, N)
     Return the commutation matrix K(m,n) which is the unique M*N by M*N matrix such that K(m,n) * vec(A) = vec(A') for all m by n matrices A.

     If only one argument M is given, K(m,m) is returned.

     See Magnus and Neudecker (1988), ‘Matrix Differential Calculus with Applications in Statistics and Econometrics.’
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Return the commutation matrix K(m,n) which is the unique M*N by M*N matrix such that K(m,n) * vec(A) = vec(A') for all m by n matrices A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cond


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 923
 -- : cond (A)
 -- : cond (A, P)
     Compute the P-norm condition number of a matrix with respect to inversion.

     ‘cond (A)’ is defined as ‘norm (A, P) * norm (inv (A), P)’.

     By default, ‘P = 2’ is used which implies a (relatively slow) singular value decomposition.  Other possible selections are ‘P = 1, Inf, "fro"’ which are generally faster.  See ‘norm’ for a full discussion of possible P values.

     The condition number of a matrix quantifies the sensitivity of the matrix inversion operation when small changes are made to matrix elements.  Ideally the condition number will be close to 1.  When the number is large this indicates small changes (such as underflow or round-off error) will produce large changes in the resulting output.  In such cases the solution results from numerical computing are not likely to be accurate.

     See also: condest, rcond, condeig, norm, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Compute the P-norm condition number of a matrix with respect to inversion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
condeig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 860
 -- : C = condeig (A)
 -- : [V, LAMBDA, C] = condeig (A)
     Compute condition numbers of a matrix with respect to eigenvalues.

     The condition numbers are the reciprocals of the cosines of the angles between the left and right eigenvectors; Large values indicate that the matrix has multiple distinct eigenvalues.

     The input A must be a square numeric matrix.

     The outputs are:

        • C is a vector of condition numbers for the eigenvalues of A.

        • V is the matrix of right eigenvectors of A.  The result is equivalent to calling ‘[V, LAMBDA] = eig (A)’.

        • LAMBDA is the diagonal matrix of eigenvalues of A.  The result is equivalent to calling ‘[V, LAMBDA] = eig (A)’.

     Example

          a = [1, 2; 3, 4];
          c = condeig (a)
          ⇒ [1.0150; 1.0150]

     See also: eig, cond, balance.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Compute condition numbers of a matrix with respect to eigenvalues.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
condest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2182
 -- : CEST = condest (A)
 -- : CEST = condest (A, T)
 -- : CEST = condest (A, SOLVEFUN, T, P1, P2, ...)
 -- : CEST = condest (AFCN, SOLVEFUN, T, P1, P2, ...)
 -- : [CEST, V] = condest (...)

     Estimate the 1-norm condition number of a square matrix A using T test vectors and a randomized 1-norm estimator.

     The optional input T specifies the number of test vectors (default 5).

     If the matrix is not explicit, e.g., when estimating the condition number of A given an LU factorization, ‘condest’ uses the following functions:

        − AFCN which must return

             • the dimension N of A, if FLAG is "dim"

             • true if A is a real operator, if FLAG is "real"

             • the result ‘A * X’, if FLAG is "notransp"

             • the result ‘A' * X’, if FLAG is "transp"

        − SOLVEFUN which must return

             • the dimension N of A, if FLAG is "dim"

             • true if A is a real operator, if FLAG is "real"

             • the result ‘A \ X’, if FLAG is "notransp"

             • the result ‘A' \ X’, if FLAG is "transp"

     The parameters P1, P2, ... are arguments of ‘AFCN (FLAG, X, P1, P2, ...)’ and ‘SOLVEFCN (FLAG, X, P1, P2, ...)’.

     The principal output is the 1-norm condition number estimate CEST.

     The optional second output is an approximate null vector when CEST is large; it satisfies the equation ‘norm (A*v, 1) == norm (A, 1) * norm (V, 1) / EST’.

     Algorithm Note: ‘condest’ uses a randomized algorithm to approximate the 1-norms.  Therefore, if consistent results are required, the "state" of the random generator should be fixed before invoking ‘condest’.

     References:

        • N.J. Higham and F. Tisseur, ‘A Block Algorithm for Matrix 1-Norm Estimation, with an Application to 1-Norm Pseudospectra’.  SIMAX vol 21, no 4, pp 1185-1201.  <https://dx.doi.org/10.1137/S0895479899356080>

        • N.J. Higham and F. Tisseur, ‘A Block Algorithm for Matrix 1-Norm Estimation, with an Application to 1-Norm Pseudospectra’.  <https://citeseer.ist.psu.edu/223007.html>

     See also: cond, norm, normest1, normest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Estimate the 1-norm condition number of a square matrix A using T test vectors and a randomized 1-norm estimator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
cross


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- : cross (X, Y)
 -- : cross (X, Y, DIM)
     Compute the vector cross product of two 3-dimensional vectors X and Y.

     If X and Y are matrices, the cross product is applied along the first dimension with three elements.

     The optional argument DIM forces the cross product to be calculated along the specified dimension.

     Example Code:

          cross ([1,1,0], [0,1,1])
               ⇒ [ 1; -1; 1 ]

     See also: dot, curl, divergence.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the vector cross product of two 3-dimensional vectors X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
duplication_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 307
 -- : duplication_matrix (N)
     Return the duplication matrix Dn which is the unique n^2 by n*(n+1)/2 matrix such that Dn vech (A) = vec (A) for all symmetric n by n matrices A.

     See Magnus and Neudecker (1988), ‘Matrix Differential Calculus with Applications in Statistics and Econometrics.’
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
Return the duplication matrix Dn which is the unique n^2 by n*(n+1)/2 matrix such that Dn vech (A) = vec (A) for all symmetric n by n matrices A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
expm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 912
 -- : expm (A)
     Return the exponential of a matrix.

     The matrix exponential is defined as the infinite Taylor series

          expm (A) = I + A + A^2/2! + A^3/3! + ...

     However, the Taylor series is _not_ the way to compute the matrix exponential; see Moler and Van Loan, ‘Nineteen Dubious Ways to Compute the Exponential of a Matrix’, SIAM Review, 1978.  This routine uses Ward’s diagonal Padé approximation method with three step preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal Padé approximations are rational polynomials of matrices

               -1
          D (A)   N (A)

     whose Taylor series matches the first ‘2q+1’ terms of the Taylor series above; direct evaluation of the Taylor series (with the same preconditioning steps) may be desirable in lieu of the Padé approximation when ‘Dq(A)’ is ill-conditioned.

     See also: logm, sqrtm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return the exponential of a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1105
 -- : [BETA, V, R] = gls (Y, X, O)
     Generalized least squares (GLS) model.

     Perform a generalized least squares estimation for the multivariate model Y = X*B + E where Y is a t-by-p matrix, X is a t-by-k matrix, B is a k-by-p matrix and E is a t-by-p matrix.

     Each row of Y is a p-variate observation in which each column represents a variable.  Likewise, the rows of X represent k-variate observations or possibly designed values.  Furthermore, the collection of observations X must be of adequate rank, k, otherwise B cannot be uniquely estimated.

     The observation errors, E, are assumed to originate from an underlying p-variate distribution with zero mean but possibly heteroscedastic observations.  That is, in general, ‘mean (E) = 0’ and ‘cov (vec (E)) = (s^2)*O’ in which s is a scalar and O is a t*p-by-t*p matrix.

     The return values BETA, V, and R are defined as follows.

     BETA
          The GLS estimator for matrix B.

     V
          The GLS estimator for scalar s^2.

     R
          The matrix of GLS residuals, R = Y - X*BETA.

     See also: ols.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Generalized least squares (GLS) model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
housh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 589
 -- : [HOUSV, BETA, ZER] = housh (X, J, Z)
     Compute Householder reflection vector HOUSV to reflect X to be the j-th column of identity, i.e.,

          (I - beta*housv*housv')x =  norm (x)*e(j) if x(j) < 0,
          (I - beta*housv*housv')x = -norm (x)*e(j) if x(j) >= 0

     Inputs

     X
          vector

     J
          index into vector

     Z
          threshold for zero (usually should be the number 0)

     Outputs (see Golub and Van Loan):

     BETA
          If beta = 0, then no reflection need be applied (zer set to 0)

     HOUSV
          householder vector
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Compute Householder reflection vector HOUSV to reflect X to be the j-th column of identity, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isbanded


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- : isbanded (A, LOWER, UPPER)
     Return true if A is a matrix with entries confined between LOWER diagonals below the main diagonal and UPPER diagonals above the main diagonal.

     LOWER and UPPER must be non-negative integers.

     See also: isdiag, istril, istriu, bandwidth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Return true if A is a matrix with entries confined between LOWER diagonals below the main diagonal and UPPER diagonals above the main diagonal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isdefinite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- : isdefinite (A)
 -- : isdefinite (A, TOL)
     Return 1 if A is symmetric positive definite within the tolerance specified by TOL or 0 if A is symmetric positive semi-definite.  Otherwise, return -1.

     If TOL is omitted, use a tolerance of ‘100 * eps * norm (A, "fro")’

     See also: issymmetric, ishermitian.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Return 1 if A is symmetric positive definite within the tolerance specified by TOL or 0 if A is symmetric positive semi-definite.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isdiag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- : isdiag (A)
     Return true if A is a diagonal matrix.

     See also: isbanded, istril, istriu, diag, bandwidth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if A is a diagonal matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
ishermitian


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- : ishermitian (A)
 -- : ishermitian (A, TOL)
     Return true if A is Hermitian within the tolerance specified by TOL.

     The default tolerance is zero (uses faster code).

     Matrix A is considered symmetric if ‘norm (A - A', Inf) / norm (A, Inf) < TOL’.

     See also: issymmetric, isdefinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return true if A is Hermitian within the tolerance specified by TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
issymmetric


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 323
 -- : issymmetric (A)
 -- : issymmetric (A, TOL)
     Return true if A is a symmetric matrix within the tolerance specified by TOL.

     The default tolerance is zero (uses faster code).

     Matrix A is considered symmetric if ‘norm (A - A.', Inf) / norm (A, Inf) < TOL’.

     See also: ishermitian, isdefinite.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return true if A is a symmetric matrix within the tolerance specified by TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
istril


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 220
 -- : istril (A)
     Return true if A is a lower triangular matrix.

     A lower triangular matrix has nonzero entries only on the main diagonal and below.

     See also: istriu, isbanded, isdiag, tril, bandwidth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return true if A is a lower triangular matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
istriu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 222
 -- : istriu (A)
     Return true if A is an upper triangular matrix.

     An upper triangular matrix has nonzero entries only on the main diagonal and above.

     See also: isdiag, isbanded, istril, triu, bandwidth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return true if A is an upper triangular matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
krylov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1276
 -- : [U, H, NU] = krylov (A, V, K, EPS1, PFLG)
     Construct an orthogonal basis U of a block Krylov subspace.

     The block Krylov subspace has the following form:

          [v a*v a^2*v ... a^(k+1)*v]

     The construction is made with Householder reflections to guard against loss of orthogonality.

     If V is a vector, then H contains the Hessenberg matrix such that a*u == u*h+rk*ek’, in which ‘rk = a*u(:,k)-u*h(:,k)’, and ek’ is the vector ‘[0, 0, ..., 1]’ of length K.  Otherwise, H is meaningless.

     If V is a vector and K is greater than ‘length (A) - 1’, then H contains the Hessenberg matrix such that ‘a*u == u*h’.

     The value of NU is the dimension of the span of the Krylov subspace (based on EPS1).

     If B is a vector and K is greater than M-1, then H contains the Hessenberg decomposition of A.

     The optional parameter EPS1 is the threshold for zero.  The default value is 1e-12.

     If the optional parameter PFLG is nonzero, row pivoting is used to improve numerical behavior.  The default value is 0.

     Reference: A. Hodel, P. Misra, ‘Partial Pivoting in the Computation of Krylov Subspaces of Large Sparse Systems’, Proceedings of the 42nd IEEE Conference on Decision and Control, December 2003.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Construct an orthogonal basis U of a block Krylov subspace.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linsolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1608
 -- : X = linsolve (A, B)
 -- : X = linsolve (A, B, OPTS)
 -- : [X, R] = linsolve (...)
     Solve the linear system ‘A*x = b’.

     With no options, this function is equivalent to the left division operator (‘x = A \ b’) or the matrix-left-divide function (‘x = mldivide (A, b)’).

     Octave ordinarily examines the properties of the matrix A and chooses a solver that best matches the matrix.  By passing a structure OPTS to ‘linsolve’ you can inform Octave directly about the matrix A.  In this case Octave will skip the matrix examination and proceed directly to solving the linear system.

     *Warning:* If the matrix A does not have the properties listed in the OPTS structure then the result will not be accurate AND no warning will be given.  When in doubt, let Octave examine the matrix and choose the appropriate solver as this step takes little time and the result is cached so that it is only done once per linear system.

     Possible OPTS fields (set value to true/false):

     LT
          A is lower triangular

     UT
          A is upper triangular

     UHESS
          A is upper Hessenberg (currently makes no difference)

     SYM
          A is symmetric or complex Hermitian (currently makes no difference)

     POSDEF
          A is positive definite

     RECT
          A is general rectangular (currently makes no difference)

     TRANSA
          Solve ‘A'*x = b’ if true rather than ‘A*x = b’

     The optional second output R is the inverse condition number of A (zero if matrix is singular).

     See also: mldivide, matrix_type, rcond.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Solve the linear system ‘A*x = b’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
logm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- : S = logm (A)
 -- : S = logm (A, OPT_ITERS)
 -- : [S, ITERS] = logm (...)
     Compute the matrix logarithm of the square matrix A.

     The implementation utilizes a Padé approximant and the identity

          logm (A) = 2^k * logm (A^(1 / 2^k))

     The optional input OPT_ITERS is the maximum number of square roots to compute and defaults to 100.

     The optional output ITERS is the number of square roots actually computed.

     See also: expm, sqrtm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the matrix logarithm of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lscov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1230
 -- : X = lscov (A, B)
 -- : X = lscov (A, B, V)
 -- : X = lscov (A, B, V, ALG)
 -- : [X, STDX, MSE, S] = lscov (...)

     Compute a generalized linear least squares fit.

     Estimate X under the model B = AX + W, where the noise W is assumed to follow a normal distribution with covariance matrix {\sigma^2} V.

     If the size of the coefficient matrix A is n-by-p, the size of the vector/array of constant terms B must be n-by-k.

     The optional input argument V may be an n-element vector of positive weights (inverse variances), or an n-by-n symmetric positive semi-definite matrix representing the covariance of B.  If V is not supplied, the ordinary least squares solution is returned.

     The ALG input argument, a guidance on solution method to use, is currently ignored.

     Besides the least-squares estimate matrix X (p-by-k), the function also returns STDX (p-by-k), the error standard deviation of estimated X; MSE (k-by-1), the estimated data error covariance scale factors (\sigma^2); and S (p-by-p, or p-by-p-by-k if k > 1), the error covariance of X.

     Reference: Golub and Van Loan (1996), ‘Matrix Computations (3rd Ed.)’, Johns Hopkins, Section 5.6.3

     See also: ols, gls, lsqnonneg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Compute a generalized linear least squares fit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
normest


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 572
 -- : NEST = normest (A)
 -- : NEST = normest (A, TOL)
 -- : [NEST, ITER] = normest (...)
     Estimate the 2-norm of the matrix A using a power series analysis.

     This is typically used for large matrices, where the cost of calculating ‘norm (A)’ is prohibitive and an approximation to the 2-norm is acceptable.

     TOL is the tolerance to which the 2-norm is calculated.  By default TOL is 1e-6.

     The optional output ITER returns the number of iterations that were required for ‘normest’ to converge.

     See also: normest1, norm, cond, condest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Estimate the 2-norm of the matrix A using a power series analysis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
normest1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2469
 -- : NEST = normest1 (A)
 -- : NEST = normest1 (A, T)
 -- : NEST = normest1 (A, T, X0)
 -- : NEST = normest1 (AFUN, T, X0, P1, P2, ...)
 -- : [NEST, V] = normest1 (A, ...)
 -- : [NEST, V, W] = normest1 (A, ...)
 -- : [NEST, V, W, ITER] = normest1 (A, ...)
     Estimate the 1-norm of the matrix A using a block algorithm.

     ‘normest1’ is best for large sparse matrices where only an estimate of the norm is required.  For small to medium sized matrices, consider using ‘norm (A, 1)’.  In addition, ‘normest1’ can be used for the estimate of the 1-norm of a linear operator A when matrix-vector products ‘A * X’ and ‘A' * X’ can be cheaply computed.  In this case, instead of the matrix A, a function ‘AFUN (FLAG, X)’ is used; it must return:

        • the dimension N of A, if FLAG is "dim"

        • true if A is a real operator, if FLAG is "real"

        • the result ‘A * X’, if FLAG is "notransp"

        • the result ‘A' * X’, if FLAG is "transp"

     A typical case is A defined by ‘B ^ M’, in which the result ‘A * X’ can be computed without even forming explicitly ‘B ^ M’ by:

          Y = X;
          for I = 1:M
            Y = B * Y;
          endfor

     The parameters P1, P2, ... are arguments of ‘AFUN (FLAG, X, P1, P2, ...)’.

     The default value for T is 2.  The algorithm requires matrix-matrix products with sizes N x N and N x T.

     The initial matrix X0 should have columns of unit 1-norm.  The default initial matrix X0 has the first column ‘ones (N, 1) / N’ and, if T > 1, the remaining columns with random elements ‘-1 / N’, ‘1 / N’, divided by N.

     On output, NEST is the desired estimate, V and W are vectors such that ‘W = A * V’, with ‘norm (W, 1)’ = ‘C * norm (V, 1)’.  ITER contains in ‘ITER(1)’ the number of iterations (the maximum is hardcoded to 5) and in ‘ITER(2)’ the total number of products ‘A * X’ or ‘A' * X’ performed by the algorithm.

     Algorithm Note: ‘normest1’ uses random numbers during evaluation.  Therefore, if consistent results are required, the "state" of the random generator should be fixed before invoking ‘normest1’.

     Reference: N. J. Higham and F. Tisseur, ‘A block algorithm for matrix 1-norm estimation, with and application to 1-norm pseudospectra’, SIAM J. Matrix Anal.  Appl., pp.  1185–1201, Vol 21, No.  4, 2000.

     See also: normest, norm, cond, condest.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Estimate the 1-norm of the matrix A using a block algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
null


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 323
 -- : null (A)
 -- : null (A, TOL)
     Return an orthonormal basis of the null space of A.

     The dimension of the null space is taken as the number of singular values of A not greater than TOL.  If the argument TOL is missing, it is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: orth.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return an orthonormal basis of the null space of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ols


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1528
 -- : [BETA, SIGMA, R] = ols (Y, X)
     Ordinary least squares (OLS) estimation.

     OLS applies to the multivariate model Y = X*B + E where Y is a t-by-p matrix, X is a t-by-k matrix, B is a k-by-p matrix, and E is a t-by-p matrix.

     Each row of Y is a p-variate observation in which each column represents a variable.  Likewise, the rows of X represent k-variate observations or possibly designed values.  Furthermore, the collection of observations X must be of adequate rank, k, otherwise B cannot be uniquely estimated.

     The observation errors, E, are assumed to originate from an underlying p-variate distribution with zero mean and p-by-p covariance matrix S, both constant conditioned on X.  Furthermore, the matrix S is constant with respect to each observation such that ‘mean (E) = 0’ and ‘cov (vec (E)) = kron (S, I)’.  (For cases that don’t meet this criteria, such as autocorrelated errors, see generalized least squares, gls, for more efficient estimations.)

     The return values BETA, SIGMA, and R are defined as follows.

     BETA
          The OLS estimator for matrix B.  BETA is calculated directly via ‘inv (X'*X) * X' * Y’ if the matrix ‘X'*X’ is of full rank.  Otherwise, ‘BETA = pinv (X) * Y’ where ‘pinv (X)’ denotes the pseudoinverse of X.

     SIGMA
          The OLS estimator for the matrix S,

               SIGMA = (Y-X*BETA)' * (Y-X*BETA) / (t-rank(X))

     R
          The matrix of OLS residuals, ‘R = Y - X*BETA’.

     See also: gls, pinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Ordinary least squares (OLS) estimation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
orth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 321
 -- : orth (A)
 -- : orth (A, TOL)
     Return an orthonormal basis of the range space of A.

     The dimension of the range space is taken as the number of singular values of A greater than TOL.  If the argument TOL is missing, it is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: null.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return an orthonormal basis of the range space of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
planerot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- : [G, Y] = planerot (X)
     Compute the Givens rotation matrix for the two-element column vector X.

     The Givens matrix is a 2-by-2 orthogonal matrix

          G = [ C , S
               -S', C]

     such that

          Y = G * [X(1); X(2)] ≡ [*; 0]

     Note: The Givens matrix represents a counterclockwise rotation of a 2-D plane and can be used to introduce zeros into a matrix prior to complete factorization.

     See also: givens, qr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Compute the Givens rotation matrix for the two-element column vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qzhess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 786
 -- : [AA, BB, Q, Z] = qzhess (A, B)
     Compute the Hessenberg-triangular decomposition of the matrix pencil ‘(A, B)’, returning ‘AA = Q * A * Z’, ‘BB = Q * B * Z’, with Q and Z orthogonal.

     For example:

          [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
               ⇒ aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
               ⇒ bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
               ⇒  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
               ⇒  z = [ 1, 0; 0, 1 ]

     The Hessenberg-triangular decomposition is the first step in Moler and Stewart’s QZ decomposition algorithm.

     Algorithm taken from Golub and Van Loan, ‘Matrix Computations, 2nd edition’.

     See also: lu, chol, hess, qr, qz, schur, svd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
Compute the Hessenberg-triangular decomposition of the matrix pencil ‘(A, B)’, returning ‘AA = Q * A * Z’, ‘BB = Q * B * Z’, with Q and Z orthogonal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1331
 -- : rank (A)
 -- : rank (A, TOL)
     Compute the rank of matrix A, using the singular value decomposition.

     The rank is taken to be the number of singular values of A that are greater than the specified tolerance TOL.  If the second argument is omitted, it is taken to be

          tol = max (size (A)) * sigma(1) * eps;

     where ‘eps’ is machine precision and ‘sigma(1)’ is the largest singular value of A.

     The rank of a matrix is the number of linearly independent rows or columns and equals the dimension of the row and column space.  The function ‘orth’ may be used to compute an orthonormal basis of the column space.

     For testing if a system ‘A*X = B’ of linear equations is solvable, one can use

          rank (A) == rank ([A B])

     In this case, ‘X = A \ B’ finds a particular solution X.  The general solution is X plus the null space of matrix A.  The function ‘null’ may be used to compute a basis of the null space.

     Example:

          A = [1 2 3
               4 5 6
               7 8 9];
          rank (A)
            ⇒ 2

     In this example, the number of linearly independent rows is only 2 because the final row is a linear combination of the first two rows:

          A(3,:) == -A(1,:) + 2 * A(2,:)

     See also: null, orth, sprank, svd, eps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Compute the rank of matrix A, using the singular value decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- : rref (A)
 -- : rref (A, TOL)
 -- : [R, K] = rref (...)
     Return the reduced row echelon form of A.

     TOL defaults to ‘eps * max (size (A)) * norm (A, inf)’.

     The optional return argument K contains the vector of "bound variables", which are those columns on which elimination has been performed.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return the reduced row echelon form of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- : ANGLE = subspace (A, B)
     Determine the largest principal angle between two subspaces spanned by the columns of matrices A and B.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Determine the largest principal angle between two subspaces spanned by the columns of matrices A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
trace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- : trace (A)
     Compute the trace of A, the sum of the elements along the main diagonal.

     The implementation is straightforward: ‘sum (diag (A))’.

     See also: eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Compute the trace of A, the sum of the elements along the main diagonal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
vech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 334
 -- : vech (X)
     Return the vector obtained by eliminating all superdiagonal elements of the square matrix X and stacking the result one column above the other.

     This has uses in matrix calculus where the underlying matrix is symmetric and it would be pointless to keep values above the main diagonal.

     See also: vec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
Return the vector obtained by eliminating all superdiagonal elements of the square matrix X and stacking the result one column above the other.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecnorm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 446
 -- : N = vecnorm (A)
 -- : N = vecnorm (A, P)
 -- : N = vecnorm (A, P, DIM)
     Return the p-norm of the elements of A along dimension DIM.

     The p-norm of a vector is defined as

          P-NORM (A, P) = sum (abs (A) .^ P)) ^ (1/P)

     If P is omitted it defaults to 2 (Euclidean norm).  P can be ‘Inf’ (absolute value of largest element).

     If DIM is omitted the first non-singleton dimension is used.

     See also: norm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the p-norm of the elements of A along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bug_report


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- : bug_report ()
     Display information about how to submit bug reports for Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Display information about how to submit bug reports for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bunzip2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 351
 -- : FILELIST = bunzip2 (BZFILE)
 -- : FILELIST = bunzip2 (BZFILE, DIR)
     Unpack the bzip2 archive BZFILE.

     If DIR is specified the files are unpacked in this directory rather than the one where BZFILE is located.

     The optional output FILELIST is a list of the uncompressed files.

     See also: bzip2, unpack, gunzip, unzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Unpack the bzip2 archive BZFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1184
 -- : cast (VAL, "TYPE")
     Convert VAL to data type TYPE.

     Both VAL and TYPE are typically one of the following built-in classes:

          "double"
          "single"
          "logical"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"

     The value VAL may be modified to fit within the range of the new type.

     Examples:

          cast (-5, "uint8")
             ⇒ 0
          cast (300, "int8")
             ⇒ 127

     Programming Note: This function relies on the object VAL having a conversion method named TYPE.  User-defined classes may implement only a subset of the full list of types shown above.  In that case, it may be necessary to call cast twice in order to reach the desired type.  For example, the conversion to double is nearly always implemented, but the conversion to uint8 might not be.  In that case, the following code will work

          cast (cast (USER_DEFINED_VAL, "double"), "uint8")

     See also: typecast, int8, uint8, int16, uint16, int32, uint32, int64, uint64, double, single, logical, char, class, typeinfo.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Convert VAL to data type TYPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
citation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 650
 -- : citation
 -- : citation PACKAGE
     Display instructions for citing GNU Octave or its packages in publications.

     When called without an argument, display information on how to cite the core GNU Octave system.

     When given a package name PACKAGE, display information on citing the specific named package.  Note that some packages may not yet have instructions on how to cite them.

     The GNU Octave developers and its active community of package authors have invested a lot of time and effort in creating GNU Octave as it is today.  Please give credit where credit is due and cite GNU Octave and its packages when you use them.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Display instructions for citing GNU Octave or its packages in publications.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
compare_versions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1147
 -- : compare_versions (V1, V2, OPERATOR)
     Compare two version strings using the given OPERATOR.

     This function assumes that versions V1 and V2 are arbitrarily long strings made of numeric and period characters possibly followed by an arbitrary string (e.g., "1.2.3", "0.3", "0.1.2+", or "1.2.3.4-test1").

     The version is first split into numeric and character portions and then the parts are padded to be the same length (i.e., "1.1" would be padded to be "1.1.0" when being compared with "1.1.1", and separately, the character parts of the strings are padded with nulls).

     The operator can be any logical operator from the set

        • "==" equal

        • "<" less than

        • "<=" less than or equal to

        • ">" greater than

        • ">=" greater than or equal to

        • "!=" not equal

        • "~=" not equal

     Note that version "1.1-test2" will compare as greater than "1.1-test10".  Also, since the numeric part is compared first, "a" compares less than "1a" because the second string starts with a numeric part even though ‘double ("a")’ is greater than ‘double ("1").’
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compare two version strings using the given OPERATOR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
computer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1021
 -- : computer ()
 -- : C = computer ()
 -- : [C, MAXSIZE] = computer ()
 -- : [C, MAXSIZE, ENDIAN] = computer ()
 -- : ARCH = computer ("arch")
     Print or return a string of the form CPU-VENDOR-OS that identifies the type of computer that Octave is running on.

     If invoked with an output argument, the value is returned instead of printed.  For example:

          computer ()
             ⊣ i586-pc-linux-gnu

          mycomp = computer ()
             ⇒ mycomp = "i586-pc-linux-gnu"

     If two output arguments are requested, also return the maximum number of elements for an array.  This will depend on whether Octave has been compiled with 32-bit or 64-bit index vectors.

     If three output arguments are requested, also return the byte order of the current system as a character ("B" for big-endian or "L" for little-endian).

     If the argument "arch" is specified, return a string indicating the architecture of the computer on which Octave is running.

     See also: isunix, ismac, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
Print or return a string of the form CPU-VENDOR-OS that identifies the type of computer that Octave is running on.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
copyfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 799
 -- : copyfile F1 F2
 -- : copyfile F1 F2 f
 -- : copyfile (F1, F2)
 -- : copyfile (F1, F2, 'f')
 -- : [STATUS, MSG, MSGID] = copyfile (...)
     Copy the source file(s) or directory F1 to the destination F2.

     The name F1 may contain globbing patterns, or may be a cell array of strings.  If F1 expands to multiple filenames, F2 must be a directory.

     When the force flag ’f’ is given any existing files will be overwritten without prompting.

     If successful, STATUS is 1, and MSG, MSGID are empty character strings ("").  Otherwise, STATUS is 0, MSG contains a system-dependent error message, and MSGID contains a unique message identifier.  Note that the status code is exactly opposite that of the ‘system’ command.

     See also: movefile, rename, unlink, delete, glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Copy the source file(s) or directory F1 to the destination F2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
delete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- : delete (FILE)
 -- : delete (FILE1, FILE2, ...)
 -- : delete (HANDLE)
     Delete the named file or graphics handle.

     FILE may contain globbing patterns such as ‘*’.  Multiple files to be deleted may be specified in the same function call.

     HANDLE may be a scalar or vector of graphic handles to delete.

     Programming Note: Deleting graphics objects is the proper way to remove features from a plot without clearing the entire figure.

     See also: clf, cla, unlink, rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Delete the named file or graphics handle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1393
 -- : dir
 -- : dir (DIRECTORY)
 -- : [LIST] = dir (DIRECTORY)
     Display file listing for directory DIRECTORY.

     If DIRECTORY is not specified then list the present working directory.

     If a return value is requested, return a structure array with the fields

     name
          File or directory name.

     folder
          Location of file or directory

     date
          Timestamp of file modification (string value).

     bytes
          File size in bytes.

     isdir
          True if name is a directory.

     datenum
          Timestamp of file modification as serial date number (double).

     statinfo
          Information structure returned from ‘stat’.

     If DIRECTORY is a filename, rather than a directory, then return information about the named file.  DIRECTORY may also be a list rather than a single directory or file.

     DIRECTORY is subject to shell expansion if it contains any wildcard characters ‘*’, ‘?’, ‘[]’.  To find a literal example of a wildcard character the wildcard must be escaped using the backslash operator ‘\’.

     Note that for symbolic links, ‘dir’ returns information about the file that the symbolic link points to rather than the link itself.  However, if the link points to a nonexistent file, ‘dir’ returns information about the link.

     See also: ls, readdir, glob, what, stat, lstat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Display file listing for directory DIRECTORY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- : dos ("COMMAND")
 -- : STATUS = dos ("COMMAND")
 -- : [STATUS, TEXT] = dos ("COMMAND")
 -- : [...] = dos ("COMMAND", "-echo")
     Execute a system command if running under a Windows-like operating system, otherwise do nothing.

     Octave waits for the external command to finish before returning the exit status of the program in STATUS and any output in TEXT.

     When called with no output argument, or the "-echo" argument is given, then TEXT is also sent to standard output.

     See also: unix, system, isunix, ismac, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
Execute a system command if running under a Windows-like operating system, otherwise do nothing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
edit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3773
 -- : edit NAME
 -- : edit FIELD VALUE
 -- : VALUE = edit ("get", FIELD)
 -- : VALUE = edit ("get", "all")
     Edit the named function, or change editor settings.

     If ‘edit’ is called with the name of a file or function as its argument it will be opened in the text editor defined by ‘EDITOR’.

        • If the function NAME is available in a file on your path and that file is modifiable, then it will be edited in place.  If it is a system function, then it will first be copied to the directory ‘HOME’ (see below) and then edited.  If no file is found, then the m-file variant, ending with ".m", will be considered.  If still no file is found, then variants with a leading "@" and then with both a leading "@" and trailing ".m" will be considered.

        • If NAME is the name of a function defined in the interpreter but not in an m-file, then an m-file will be created in ‘HOME’ to contain that function along with its current definition.

        • If ‘NAME.cc’ is specified, then it will search for ‘NAME.cc’ in the path and try to modify it, otherwise it will create a new ‘.cc’ file in the current directory.  If NAME happens to be an m-file or interpreter defined function, then the text of that function will be inserted into the .cc file as a comment.

        • If ‘NAME.ext’ is on your path then it will be edited, otherwise the editor will be started with ‘NAME.ext’ in the current directory as the filename.  If ‘NAME.ext’ is not modifiable, it will be copied to ‘HOME’ before editing.

          *Warning:* You may need to clear NAME before the new definition is available.  If you are editing a .cc file, you will need to execute ‘mkoctfile NAME.cc’ before the definition will be available.

     If ‘edit’ is called with FIELD and VALUE variables, the value of the control field FIELD will be set to VALUE.

     If an output argument is requested and the first input argument is ‘get’ then ‘edit’ will return the value of the control field FIELD.  If the control field does not exist, edit will return a structure containing all fields and values.  Thus, ‘edit ("get", "all")’ returns a complete control structure.

     The following control fields are used:

     ‘home’
          This is the location of user local m-files.  Be sure it is in your path.  The default is ‘~/octave’.

     ‘author’
          This is the name to put after the "## Author:" field of new functions.  By default it guesses from the ‘gecos’ field of the password database.

     ‘email’
          This is the e-mail address to list after the name in the author field.  By default it guesses ‘<$LOGNAME@$HOSTNAME>’, and if ‘$HOSTNAME’ is not defined it uses ‘uname -n’.  You probably want to override this.  Be sure to use the format ‘<user@host>’.

     ‘license’

          ‘gpl’
               GNU General Public License (default).

          ‘bsd’
               BSD-style license without advertising clause.

          ‘pd’
               Public domain.

          ‘"text"’
               Your own default copyright and license.

          Unless you specify ‘pd’, edit will prepend the copyright statement with "Copyright (C) YYYY Author".

     ‘mode’
          This value determines whether the editor should be started in async mode (editor is started in the background and Octave continues) or sync mode (Octave waits until the editor exits).  Set it to "sync" to start the editor in sync mode.  The default is "async" (*note system: XREFsystem.).

     ‘editinplace’
          Determines whether files should be edited in place, without regard to whether they are modifiable or not.  The default is ‘false’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Edit the named function, or change editor settings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fact


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
 -- : fact
 -- : TRUTH = fact ()
     Display an amazing and random fact about the world’s greatest hacker.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Display an amazing and random fact about the world’s greatest hacker.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fieldnames


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 667
 -- : NAMES = fieldnames (STRUCT)
 -- : NAMES = fieldnames (OBJ)
 -- : NAMES = fieldnames (JAVAOBJ)
 -- : NAMES = fieldnames ("JAVACLASSNAME")
     Return a cell array of strings with the names of the fields in the specified input.

     When the input is a structure STRUCT, the names are the elements of the structure.

     When the input is an Octave object OBJ, the names are the public properties of the object.

     When the input is a Java object JAVAOBJ or a string containing the name of a Java class JAVACLASSNAME, the names are the public fields (data members) of the object or class.

     See also: numfields, isfield, orderfields, struct, methods.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return a cell array of strings with the names of the fields in the specified input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fileattrib


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1392
 -- : fileattrib (FILE)
 -- : fileattrib ()
 -- : [STATUS, MSG, MSGID] = fileattrib (...)
     Return information about FILE.

     If successful, STATUS is 1 and MSG is a structure with the following fields:

     ‘Name’
          Full name of FILE.

     ‘archive’
          True if FILE is an archive (Windows).

     ‘system’
          True if FILE is a system file (Windows).

     ‘hidden’
          True if FILE is a hidden file (Windows).

     ‘directory’
          True if FILE is a directory.

     ‘UserRead’
     ‘GroupRead’
     ‘OtherRead’
          True if the user (group; other users) has read permission for FILE.

     ‘UserWrite’
     ‘GroupWrite’
     ‘OtherWrite’
          True if the user (group; other users) has write permission for FILE.

     ‘UserExecute’
     ‘GroupExecute’
     ‘OtherExecute’
          True if the user (group; other users) has execute permission for FILE.

     If an attribute does not apply (i.e., archive on a Unix system) then the field is set to NaN.

     If ‘attrib’ fails, MSG is a non-empty string containing an error message and MSG_ID is the non-empty string "fileattrib".

     With no input arguments, return information about the current directory.

     If FILE contains globbing characters, return information about all the matching files.

     See also: glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return information about FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
fileparts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- : [DIR, NAME, EXT] = fileparts (FILENAME)
     Return the directory, name, and extension components of FILENAME.

     The input FILENAME is a string which is parsed.  There is no attempt to check whether the filename or directory specified actually exists.

     See also: fullfile, filesep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the directory, name, and extension components of FILENAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fullfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1038
 -- : FILENAME = fullfile (DIR1, DIR2, ..., FILE)
 -- : FILENAMES = fullfile (..., FILES)
     Build complete filename from separate parts.

     Joins any number of path components intelligently.  The return value is the concatenation of each component with exactly one file separator between each non empty part and at most one leading and/or trailing file separator.

     If the last component part is a cell array, returns a cell array of filepaths, one for each element in the last component, e.g.:

          fullfile ("/home/username", "data", {"f1.csv", "f2.csv", "f3.csv"})
          ⇒  /home/username/data/f1.csv
              /home/username/data/f2.csv
              /home/username/data/f3.csv

     On Windows systems, while forward slash file separators do work, they are replaced by backslashes; in addition drive letters are stripped of leading file separators to obtain a valid file path.

     Note: ‘fullfile’ does not perform any validation of the resulting full filename.

     See also: fileparts, filesep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Build complete filename from separate parts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
genvarname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2023
 -- : VARNAME = genvarname (STR)
 -- : VARNAME = genvarname (STR, EXCLUSIONS)
     Create valid unique variable name(s) from STR.

     If STR is a cellstr, then a unique variable is created for each cell in STR.

          genvarname ({"foo", "foo"})
            ⇒
               {
                 [1,1] = foo
                 [1,2] = foo1
               }

     If EXCLUSIONS is given, then the variable(s) will be unique to each other and to EXCLUSIONS (EXCLUSIONS may be either a string or a cellstr).

          x = 3.141;
          genvarname ("x", who ())
            ⇒ x1

     Note that the result is a char array or cell array of strings, not the variables themselves.  To define a variable, ‘eval()’ can be used.  The following trivial example sets ‘x’ to 42.

          name = genvarname ("x");
          eval ([name " = 42"]);
            ⇒ x =  42

     This can be useful for creating unique struct field names.

          x = struct ();
          for i = 1:3
            x.(genvarname ("a", fieldnames (x))) = i;
          endfor
            ⇒ x =
               {
                 a =  1
                 a1 =  2
                 a2 =  3
               }

     Since variable names may only contain letters, digits, and underscores, ‘genvarname’ will replace any sequence of disallowed characters with an underscore.  Also, variables may not begin with a digit; in this case an ‘x’ is added before the variable name.

     Variable names beginning and ending with two underscores "__" are valid, but they are used internally by Octave and should generally be avoided; therefore, ‘genvarname’ will not generate such names.

     ‘genvarname’ will also ensure that returned names do not clash with keywords such as "for" and "if".  A number will be appended if necessary.  Note, however, that this does *not* include function names such as "sin".  Such names should be included in EXCLUSIONS if necessary.

     See also: isvarname, iskeyword, exist, who, tempname, eval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Create valid unique variable name(s) from STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 551
 -- : VAL = getfield (S, FIELD)
 -- : VAL = getfield (S, SIDX1, FIELD1, FIDX1, ...)
     Get the value of the field named FIELD from a structure or nested structure S.

     If S is a structure array then SIDX selects an element of the structure array, FIELD specifies the field name of the selected element, and FIDX selects which element of the field (in the case of an array or cell array).  See ‘setfield’ for a more complete description of the syntax.

     See also: setfield, rmfield, orderfields, isfield, fieldnames, isstruct, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Get the value of the field named FIELD from a structure or nested structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
grabcode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 954
 -- : grabcode (URL)
 -- : grabcode (FILENAME)
 -- : CODE_STR = grabcode (...)

     Grab the code from a report created by the ‘publish’ function.

     The grabbed code inside the published report must be enclosed by the strings ‘##### SOURCE BEGIN #####’ and ‘##### SOURCE END #####’.  The ‘publish’ function creates this format automatically.

     If no return value is requested the code is saved to a temporary file and opened in the default editor.  NOTE: The temporary file must be saved under a new or the code will be lost.

     If an output is requested the grabbed code will be returned as string CODE_STR.

     Example:

          publish ("my_script.m");
          grabcode ("html/my_script.html");

     The example above publishes ‘my_script.m’ to the default location ‘html/my_script.html’.  Next, the published Octave script is grabbed to edit its content in a new temporary file.

     See also: publish.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Grab the code from a report created by the ‘publish’ function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gunzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 439
 -- : FILELIST = gunzip (GZFILE)
 -- : FILELIST = gunzip (GZFILE, DIR)
     Unpack the gzip archive GZFILE.

     If GZFILE is a directory, all gzfiles in the directory will be recursively unpacked.

     If DIR is specified the files are unpacked in this directory rather than the one where GZFILE is located.

     The optional output FILELIST is a list of the uncompressed files.

     See also: gzip, unpack, bunzip2, unzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Unpack the gzip archive GZFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- : info ()
     Display contact information for the GNU Octave community.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Display contact information for the GNU Octave community.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
inputParser


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4688
 -- : P = inputParser ()
     Create object P of the inputParser class.

     This class is designed to allow easy parsing of function arguments.  The class supports four types of arguments:

       1. mandatory (see ‘addRequired’);

       2. optional (see ‘addOptional’);

       3. named (see ‘addParameter’);

       4. switch (see ‘addSwitch’).

     After defining the function API with these methods, the supplied arguments can be parsed with the ‘parse’ method and the parsing results accessed with the ‘Results’ accessor.

 -- : inputParser.Parameters
     Return list of parameter names already defined.

 -- : inputParser.Results
     Return structure with argument names as fieldnames and corresponding values.

 -- : inputParser.Unmatched
     Return structure similar to ‘Results’, but for unmatched parameters.  See the ‘KeepUnmatched’ property.

 -- : inputParser.UsingDefaults
     Return cell array with the names of arguments that are using default values.

 -- : inputParser.CaseSensitive = BOOLEAN
     Set whether matching of argument names should be case sensitive.  Defaults to false.

 -- : inputParser.FunctionName = NAME
     Set function name to be used in error messages; Defaults to empty string.

 -- : inputParser.KeepUnmatched = BOOLEAN
     Set whether an error should be given for non-defined arguments.  Defaults to false.  If set to true, the extra arguments can be accessed through ‘Unmatched’ after the ‘parse’ method.  Note that since ‘Switch’ and ‘Parameter’ arguments can be mixed, it is not possible to know the unmatched type.  If argument is found unmatched it is assumed to be of the ‘Parameter’ type and it is expected to be followed by a value.

 -- : inputParser.StructExpand = BOOLEAN
     Set whether a structure can be passed to the function instead of parameter/value pairs.  Defaults to true.

     The following example shows how to use this class:

          function check (varargin)
            p = inputParser ();                      # create object
            p.FunctionName = "check";                # set function name
            p.addRequired ("pack", @ischar);         # mandatory argument
            p.addOptional ("path", pwd(), @ischar);  # optional argument

            ## create a function handle to anonymous functions for validators
            val_mat = @(x) isvector (x) && all (x <= 1) && all (x >= 0);
            p.addOptional ("mat", [0 0], val_mat);

            ## create two arguments of type "Parameter"
            val_type = @(x) any (strcmp (x, {"linear", "quadratic"}));
            p.addParameter ("type", "linear", val_type);
            val_verb = @(x) any (strcmp (x, {"low", "medium", "high"}));
            p.addParameter ("tolerance", "low", val_verb);

            ## create a switch type of argument
            p.addSwitch ("verbose");

            p.parse (varargin{:});  # Run created parser on inputs

            ## the rest of the function can access inputs by using p.Results.
            ## for example, get the tolerance input with p.Results.tolerance
          endfunction

          check ("mech");           # valid, use defaults for other arguments
          check ();                 # error, one argument is mandatory
          check (1);                # error, since ! ischar
          check ("mech", "~/dev");  # valid, use defaults for other arguments

          check ("mech", "~/dev", [0 1 0 0], "type", "linear");  # valid

          ## following is also valid.  Note how the Switch argument type can
          ## be mixed into or before the Parameter argument type (but it
          ## must still appear after any Optional argument).
          check ("mech", "~/dev", [0 1 0 0], "verbose", "tolerance", "high");

          ## following returns an error since not all optional arguments,
          ## `path' and `mat', were given before the named argument `type'.
          check ("mech", "~/dev", "type", "linear");

     _Note 1_: A function can have any mixture of the four API types but they must appear in a specific order.  ‘Required’ arguments must be first and can be followed by any ‘Optional’ arguments.  Only the ‘Parameter’ and ‘Switch’ arguments may be mixed together and they must appear at the end.

     _Note 2_: If both ‘Optional’ and ‘Parameter’ arguments are mixed in a function API then once a string Optional argument fails to validate it will be considered the end of the ‘Optional’ arguments.  The remaining arguments will be compared against any ‘Parameter’ or ‘Switch’ arguments.

     See also: nargin, validateattributes, validatestring, varargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Create object P of the inputParser class.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
inputname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 441
 -- : inputname (N)
     Return the name of the N-th argument to the calling function.

     If the argument is not a simple variable name, return an empty string.  As an example, a reference to a field in a structure such as ‘s.field’ is not a simple name and will return "".

     ‘inputname’ is only useful within a function.  When used at the command line it always returns an empty string.

     See also: nargin, nthargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the name of the N-th argument to the calling function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isdeployed


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- : isdeployed ()
     Return true if the current program has been compiled and is running separately from the Octave interpreter and false if it is running in the Octave interpreter.

     Currently, this function always returns false in Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
Return true if the current program has been compiled and is running separately from the Octave interpreter and false if it is running in the Octave interpreter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- : isdir (F)
     Return true if F is a directory.

     See also: exist, stat, is_absolute_filename, is_rooted_relative_filename.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return true if F is a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ismac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- : ismac ()
     Return true if Octave is running on a Mac OS X system and false otherwise.

     See also: isunix, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if Octave is running on a Mac OS X system and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ispc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- : ispc ()
     Return true if Octave is running on a Windows system and false otherwise.

     See also: isunix, ismac.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return true if Octave is running on a Windows system and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isunix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
 -- : isunix ()
     Return true if Octave is running on a Unix-like system and false otherwise.

     See also: ismac, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if Octave is running on a Unix-like system and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
license


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1403
 -- : license
 -- : license inuse
 -- : license inuse FEATURE
 -- : license ("inuse")
 -- : RETVAL = license ("inuse")
 -- : RETVAL = license ("test", FEATURE)
 -- : RETVAL = license ("checkout", FEATURE)
 -- : [RETVAL, ERRMSG] = license ("checkout", FEATURE)
     Get license information for Octave and Octave packages.

     GNU Octave is free software distributed under the GNU General Public License (GPL), and a license manager makes no sense.  This function is provided only for MATLAB compatibility.

     When called with no extra input arguments, it returns the Octave license, otherwise the first input defines the operation mode and must be one of the following strings: ‘inuse’, ‘test’, and ‘checkout’.  The optional FEATURE argument can either be "octave" (core), or an Octave package.

     "inuse"
          Returns a list of loaded features, i.e., octave and the list of loaded packages.  If an output is requested, it returns a struct array with the fields "feature", and "user".

     "test"
          Return true if the specified FEATURE is installed, false otherwise.

          An optional third argument "enable" or "disable" is accepted but ignored.

     "checkout"
          Return true if the specified FEATURE is installed, false otherwise.  An optional second output will have an error message if a package is not installed.

     See also: pkg, ver, version.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Get license information for Octave and Octave packages.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
list_primes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- : list_primes ()
 -- : list_primes (N)
     List the first N primes.

     If N is unspecified, the first 25 primes are listed.

     See also: primes, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
List the first N primes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
loadobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- : B = loadobj (A)
     Method of a class to manipulate an object after loading it from a file.

     The function ‘loadobj’ is called when the object A is loaded using the ‘load’ function.  An example of the use of ‘saveobj’ might be to add fields to an object that don’t make sense to be saved.  For example:

          function b = loadobj (a)
            b = a;
            b.addmissingfield = addfield (b);
          endfunction

     See also: saveobj, class.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Method of a class to manipulate an object after loading it from a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 952
 -- : ls
 -- : ls FILENAMES
 -- : ls OPTIONS
 -- : ls OPTIONS FILENAMES
 -- : LIST = ls (...)

     List directory contents.

     The ‘ls’ command is implemented by calling the native operating system’s directory listing command—available OPTIONS will vary from system to system.

     Filenames are subject to shell expansion if they contain any wildcard characters ‘*’, ‘?’, ‘[]’.  To find a literal example of a wildcard character the wildcard must be escaped using the backslash operator ‘\’.

     If the optional output LIST is requested then ‘ls’ returns a character array with one row for each file/directory name.

     Example usage on a UNIX-like system:

          ls -l
               ⊣ total 12
               ⊣ -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
               ⊣ -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m

     See also: dir, readdir, glob, what, stat, filesep, ls_command.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
List directory contents.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ls_command


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- : VAL = ls_command ()
 -- : OLD_VAL = ls_command (NEW_VAL)
     Query or set the shell command used by Octave’s ‘ls’ command.

     See also: ls.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Query or set the shell command used by Octave’s ‘ls’ command.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
menu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 835
 -- : CHOICE = menu (TITLE, OPT1, ...)
 -- : CHOICE = menu (TITLE, {OPT1, ...})
     Display a menu with heading TITLE and options OPT1, ..., and wait for user input.

     If the GUI is running, the menu is displayed graphically using ‘listdlg’.  Otherwise, the title and menu options are printed on the console.

     TITLE is a string and the options may be input as individual strings or as a cell array of strings.

     The return value CHOICE is the number of the option selected by the user counting from 1.  If the user aborts the dialog or makes an invalid selection then 0 is returned.

     This function is useful for interactive programs.  There is no limit to the number of options that may be passed in, but it may be confusing to present more than will fit easily on one screen.

     See also: input, listdlg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Display a menu with heading TITLE and options OPT1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
methods


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 506
 -- : methods (OBJ)
 -- : methods ("CLASSNAME")
 -- : MTDS = methods (...)
     List the names of the public methods for the object OBJ or the named class CLASSNAME.

     OBJ may be an Octave class object or a Java object.  CLASSNAME may be the name of an Octave class or a Java class.

     When called with no output arguments, ‘methods’ prints the list of method names to the screen.  Otherwise, the output argument MTDS contains the list in a cell array of strings.

     See also: fieldnames.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
List the names of the public methods for the object OBJ or the named class CLASSNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
 -- : mex [options] file ...
     Compile source code written in C, C++, or Fortran, to a MEX file.

     This is equivalent to ‘mkoctfile --mex [options] file’.

     See also: mkoctfile, mexext.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compile source code written in C, C++, or Fortran, to a MEX file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mexext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- : mexext ()
     Return the filename extension used for MEX files.

     See also: mex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the filename extension used for MEX files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mkdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 687
 -- : mkdir DIRNAME
 -- : mkdir PARENT DIRNAME
 -- : mkdir (DIRNAME)
 -- : mkdir (PARENT, DIRNAME)
 -- : [STATUS, MSG, MSGID] = mkdir (...)
     Create a directory named DIRNAME in the directory PARENT, creating any intermediate directories if necessary.

     If DIR is a relative path, and no PARENT directory is specified, then the present working directory is used.

     If successful, STATUS is 1, and MSG and MSGID are empty strings ("").  Otherwise, STATUS is 0, MSG contains a system-dependent error message, and MSGID contains a unique message identifier.

     When creating a directory permissions will be set to ‘0777 - UMASK’.

     See also: rmdir, pwd, cd, umask.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Create a directory named DIRNAME in the directory PARENT, creating any intermediate directories if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mkoctfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4214
 -- : mkoctfile [-options] file ...
 -- : [OUTPUT, STATUS] = mkoctfile (...)

     The ‘mkoctfile’ function compiles source code written in C, C++, or Fortran.  Depending on the options used with ‘mkoctfile’, the compiled code can be called within Octave or can be used as a stand-alone application.

     ‘mkoctfile’ can be called from the shell prompt or from the Octave prompt.  Calling it from the Octave prompt simply delegates the call to the shell prompt.  The output is stored in the OUTPUT variable and the exit status in the STATUS variable.

     ‘mkoctfile’ accepts the following options, all of which are optional except for the filename of the code you wish to compile:

     ‘-I DIR’
          Add the include directory DIR to compile commands.

     ‘-D DEF’
          Add the definition DEF to the compiler call.

     ‘-l LIB’
          Add the library LIB to the link command.

     ‘-L DIR’
          Add the library directory DIR to the link command.

     ‘-M’
     ‘--depend’
          Generate dependency files (.d) for C and C++ source files.

     ‘-R DIR’
          Add the run-time path to the link command.

     ‘-Wl,...’
          Pass options to the linker like "-Wl,-rpath=...".  The quotes are needed since commas are interpreted as command separators.

     ‘-W...’
          Pass options to the assembler like "-Wa,OPTION".

     ‘-c’
          Compile but do not link.

     ‘-g’
          Enable debugging options for compilers.

     ‘-o FILE’
     ‘--output FILE’
          Output filename.  Default extension is .oct (or .mex if ‘--mex’ is specified) unless linking a stand-alone executable.

     ‘-p VAR’
     ‘--print VAR’
          Print the configuration variable VAR.  Recognized variables are:

                  ALL_CFLAGS                  INCFLAGS
                  ALL_CXXFLAGS                INCLUDEDIR
                  ALL_FFLAGS                  LAPACK_LIBS
                  ALL_LDFLAGS                 LD_CXX
                  AR                          LDFLAGS
                  BLAS_LIBS                   LD_STATIC_FLAG
                  CC                          LFLAGS
                  CFLAGS                      LIBDIR
                  CPICFLAG                    LIBOCTAVE
                  CPPFLAGS                    LIBOCTINTERP
                  CXX                         LIBS
                  CXXFLAGS                    OCTAVE_HOME
                  CXXPICFLAG                  OCTAVE_LIBS
                  DEPEND_EXTRA_SED_PATTERN    OCTAVE_LINK_DEPS
                  DEPEND_FLAGS                OCTAVE_LINK_OPTS
                  DL_LD                       OCTAVE_PREFIX
                  DL_LDFLAGS                  OCTINCLUDEDIR
                  F77                         OCTLIBDIR
                  F77_INTEGER8_FLAG           OCT_LINK_DEPS
                  FFLAGS                      OCT_LINK_OPTS
                  FFTW3F_LDFLAGS              RANLIB
                  FFTW3F_LIBS                 RDYNAMIC_FLAG
                  FFTW3_LDFLAGS               READLINE_LIBS
                  FFTW3_LIBS                  SED
                  FFTW_LIBS                   SPECIAL_MATH_LIB
                  FLIBS                       XTRA_CFLAGS
                  FPICFLAG                    XTRA_CXXFLAGS

     ‘--link-stand-alone’
          Link a stand-alone executable file.

     ‘--mex’
          Assume we are creating a MEX file.  Set the default output extension to ".mex".

     ‘-s’
     ‘--strip’
          Strip the output file.

     ‘-v’
     ‘--verbose’
          Echo commands as they are executed.

     ‘file’
          The file to compile or link.  Recognized file types are

                  .c    C source
                  .cc   C++ source
                  .C    C++ source
                  .cpp  C++ source
                  .f    Fortran source (fixed form)
                  .F    Fortran source (fixed form)
                  .f90  Fortran source (free form)
                  .F90  Fortran source (free form)
                  .o    object file
                  .a    library file

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
The ‘mkoctfile’ function compiles source code written in C, C++, or Fortran.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
movefile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 976
 -- : movefile F1
 -- : movefile F1 F2
 -- : movefile F1 F2 f
 -- : movefile (F1)
 -- : movefile (F1, F2)
 -- : movefile (F1, F2, 'f')
 -- : [STATUS, MSG, MSGID] = movefile (...)
     Move the source file or directory F1 to the destination F2.

     The name F1 may contain globbing patterns, or may be a cell array of strings.  If F1 expands to multiple filenames, F2 must be a directory.

     If no destination F2 is specified then the destination is the present working directory.  If F2 is a filename then F1 is renamed to F2.

     When the force flag ’f’ is given any existing files will be overwritten without prompting.

     If successful, STATUS is 1, and MSG, MSGID are empty character strings ("").  Otherwise, STATUS is 0, MSG contains a system-dependent error message, and MSGID contains a unique message identifier.  Note that the status code is exactly opposite that of the ‘system’ command.

     See also: rename, copyfile, unlink, delete, glob.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Move the source file or directory F1 to the destination F2.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
namelengthmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- : namelengthmax ()
     Return the MATLAB compatible maximum variable name length.

     Octave is capable of storing strings up to 2^{31} - 1 in length.  However for MATLAB compatibility all variable, function, and structure field names should be shorter than the length returned by ‘namelengthmax’.  In particular, variables stored to a MATLAB file format (‘*.mat’) will have their names truncated to this length.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the MATLAB compatible maximum variable name length.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nargchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 574
 -- : MSGSTR = nargchk (MINARGS, MAXARGS, NARGS)
 -- : MSGSTR = nargchk (MINARGS, MAXARGS, NARGS, "string")
 -- : MSGSTRUCT = nargchk (MINARGS, MAXARGS, NARGS, "struct")
     Return an appropriate error message string (or structure) if the number of inputs requested is invalid.

     This is useful for checking to see that the number of input arguments supplied to a function is within an acceptable range.

     *Caution*: ‘nargchk’ is scheduled for deprecation.  Use ‘narginchk’ in all new code.

     See also: narginchk, nargoutchk, error, nargin, nargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return an appropriate error message string (or structure) if the number of inputs requested is invalid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
narginchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 506
 -- : narginchk (MINARGS, MAXARGS)
     Check for correct number of input arguments.

     Generate an error message if the number of arguments in the calling function is outside the range MINARGS and MAXARGS.  Otherwise, do nothing.

     Both MINARGS and MAXARGS must be scalar numeric values.  Zero, Inf, and negative values are all allowed, and MINARGS and MAXARGS may be equal.

     Note that this function evaluates ‘nargin’ on the caller.

     See also: nargoutchk, error, nargout, nargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Check for correct number of input arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nargoutchk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 984
 -- : nargoutchk (MINARGS, MAXARGS)
 -- : MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS)
 -- : MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS, "string")
 -- : MSGSTRUCT = nargoutchk (MINARGS, MAXARGS, NARGS, "struct")
     Check for correct number of output arguments.

     In the first form, return an error if the number of arguments is not between MINARGS and MAXARGS.  Otherwise, do nothing.  Note that this function evaluates the value of ‘nargout’ on the caller so its value must have not been tampered with.

     Both MINARGS and MAXARGS must be numeric scalars.  Zero, Inf, and negative are all valid, and they can have the same value.

     For backwards compatibility, the other forms return an appropriate error message string (or structure) if the number of outputs requested is invalid.

     This is useful for checking to that the number of output arguments supplied to a function is within an acceptable range.

     See also: narginchk, error, nargout, nargin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Check for correct number of output arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
news


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- : news
 -- : news PACKAGE
     Display the current NEWS file for Octave or an installed package.

     When called without an argument, display the NEWS file for Octave.

     When given a package name PACKAGE, display the current NEWS file for that package.

     See also: ver, pkg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Display the current NEWS file for Octave or an installed package.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nthargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1235
 -- : nthargout (N, FUNC, ...)
 -- : nthargout (N, NTOT, FUNC, ...)
     Return the Nth output argument of the function specified by the function handle or string FUNC.

     Any additional arguments are passed directly to FUNC.  The total number of arguments to call FUNC with can be passed in NTOT; by default NTOT is N.  The input N can also be a vector of indices of the output, in which case the output will be a cell array of the requested output arguments.

     The intended use ‘nthargout’ is to avoid intermediate variables.  For example, when finding the indices of the maximum entry of a matrix, the following two compositions of nthargout

          M = magic (5);
          cell2mat (nthargout ([1, 2], @ind2sub, size (M),
                               nthargout (2, @max, M(:))))
          ⇒ 5   3

     are completely equivalent to the following lines:

          M = magic (5);
          [~, idx] = max (M(:));
          [i, j] = ind2sub (size (M), idx);
          [i, j]
          ⇒ 5   3

     It can also be helpful to have all output arguments in a single cell in the following manner:

          USV = nthargout ([1:3], @svd, hilb (5));

     See also: nargin, nargout, varargin, varargout, isargout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return the Nth output argument of the function specified by the function handle or string FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
open


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 469
 -- : open FILE
 -- : OUTPUT = open (FILE)
     Open the file FILE in Octave or in an external application based on the file type as determined by the filename extension.

     Recognized file types are

     ‘.m’
          Open file in the editor.

     ‘.mat’
          Load the file in the base workspace.

     ‘.exe’
          Execute the program (on Windows systems only).

     Other file types are opened in the appropriate external application.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
Open the file FILE in Octave or in an external application based on the file type as determined by the filename extension.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
orderfields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1898
 -- : SOUT = orderfields (S1)
 -- : SOUT = orderfields (S1, S2)
 -- : SOUT = orderfields (S1, {CELLSTR})
 -- : SOUT = orderfields (S1, P)
 -- : [SOUT, P] = orderfields (...)
     Return a _copy_ of S1 with fields arranged alphabetically, or as specified by the second input.

     Given one input struct S1, arrange field names alphabetically.

     If a second struct argument is given, arrange field names in S1 as they appear in S2.  The second argument may also specify the order in a cell array of strings CELLSTR.  The second argument may also be a permutation vector.

     The optional second output argument P is the permutation vector which converts the original name order to the new name order.

     Examples:

          s = struct ("d", 4, "b", 2, "a", 1, "c", 3);
          t1 = orderfields (s)
               ⇒ t1 =
                  {
                    a =  1
                    b =  2
                    c =  3
                    d =  4
                  }

          t = struct ("d", {}, "c", {}, "b", {}, "a", {});
          t2 = orderfields (s, t)
               ⇒ t2 =
                  {
                    d =  4
                    c =  3
                    b =  2
                    a =  1
                  }

          t3 = orderfields (s, [3, 2, 4, 1])
               ⇒ t3 =
                  {
                    a =  1
                    b =  2
                    c =  3
                    d =  4
                  }

          [t4, p] = orderfields (s, {"d", "c", "b", "a"})
               ⇒ t4 =
                  {
                    d =  4
                    c =  3
                    b =  2
                    a =  1
                  }
                  p =
                     1
                     4
                     2
                     3

     See also: fieldnames, getfield, setfield, rmfield, isfield, isstruct, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return a _copy_ of S1 with fields arranged alphabetically, or as specified by the second input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- : pack ()
     Consolidate workspace memory in MATLAB.

     This function is provided for compatibility, but does nothing in Octave.

     See also: clear.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Consolidate workspace memory in MATLAB.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
parseparams


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1146
 -- : [REG, PROP] = parseparams (PARAMS)
 -- : [REG, VAR1, ...] = parseparams (PARAMS, NAME1, DEFAULT1, ...)
     Return in REG the cell elements of PARAM up to the first string element and in PROP all remaining elements beginning with the first string element.

     For example:

          [reg, prop] = parseparams ({1, 2, "linewidth", 10})
          reg =
          {
            [1,1] = 1
            [1,2] = 2
          }
          prop =
          {
            [1,1] = linewidth
            [1,2] = 10
          }

     The parseparams function may be used to separate regular numeric arguments from additional arguments given as property/value pairs of the VARARGIN cell array.

     In the second form of the call, available options are specified directly with their default values given as name-value pairs.  If PARAMS do not form name-value pairs, or if an option occurs that does not match any of the available options, an error occurs.

     When called from an m-file function, the error is prefixed with the name of the caller function.

     The matching of options is case-insensitive.

     See also: varargin, inputParser.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
Return in REG the cell elements of PARAM up to the first string element and in PROP all remaining elements beginning with the first string element.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
perl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- : OUTPUT = perl (SCRIPTFILE)
 -- : OUTPUT = perl (SCRIPTFILE, ARGUMENT1, ARGUMENT2, ...)
 -- : [OUTPUT, STATUS] = perl (...)
     Invoke Perl script SCRIPTFILE, possibly with a list of command line arguments.

     Return output in OUTPUT and optional status in STATUS.  If SCRIPTFILE is not an absolute filename it is searched for in the current directory and then in the Octave loadpath.

     See also: system, python.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Invoke Perl script SCRIPTFILE, possibly with a list of command line arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
publish


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4964
 -- : publish (FILE)
 -- : publish (FILE, OUTPUT_FORMAT)
 -- : publish (FILE, OPTION1, VALUE1, ...)
 -- : publish (FILE, OPTIONS)
 -- : OUTPUT_FILE = publish (FILE, ...)

     Generate a report from the Octave script file FILE in one of several output formats.

     The generated reports interpret any Publishing Markup in comments, which is explained in detail in the GNU Octave manual.  Assume the following example, using some Publishing Markup, to be the contents of the script file ‘pub_example.m’:

          ## Headline title
          #
          # Some *bold*, _italic_, or |monospaced| Text with
          # a <https://www.octave.org link to *GNU Octave*>.
          ##

          # "Real" Octave commands to be evaluated
          sombrero ()

          %% MATLAB comment style ('%') is supported as well
          %
          % * Bulleted list item 1
          % * Bulleted list item 2
          %
          % # Numbered list item 1
          % # Numbered list item 2

     To publish this script file, type ‘publish ("pub_example.m")’.

     With only FILE given, a HTML report is generated in a subdirectory ‘html’ relative to the current working directory.  The Octave commands are evaluated in a separate context and any figures created while executing the script file are included in the report.  All formatting syntax of FILE is treated according to the specified output format and included in the report.

     Using ‘publish (FILE, OUTPUT_FORMAT)’ is equivalent to the function call using a structure

          OPTIONS.format = OUTPUT_FORMAT;
          publish (FILE, OPTIONS)

     which is described below.  The same holds for using option/value pairs

          OPTIONS.OPTION1 = VALUE1;
          publish (FILE, OPTIONS)

     The structure OPTIONS can have the following field names.  If a field name is not specified, the default value is used:

        • ‘format’ — Output format of the published script file, one of

          ‘html’ (default), ‘doc’, ‘latex’, ‘ppt’, ‘pdf’, or ‘xml’.

          The output formats ‘doc’, ‘ppt’, and ‘xml’ are not currently supported.  To generate a ‘doc’ report, open a generated ‘html’ report with your office suite.

          In Octave custom formats are supported by implementing all callback subfunctions in a function file named ‘__publish_<custom format>_output__.m’.  To obtain a template for the HTML format type:

               edit (fullfile (fileparts (which ("publish")), ...
                     "private", "__publish_html_output__.m"))

        • ‘outputDir’ — Full path of the directory where the generated report will be located.  If no directory is given, the report is generated in a subdirectory ‘html’ relative to the current working directory.

        • ‘stylesheet’ — Not supported, only for MATLAB compatibility.

        • ‘createThumbnail’ — Not supported, only for MATLAB compatibility.

        • ‘figureSnapMethod’ — Not supported, only for MATLAB compatibility.

        • ‘imageFormat’ — Desired format for any images produced while evaluating the code.  The allowed image formats depend on the output format:

             • ‘html’, ‘xml’ — ‘png’ (default), any image format supported by Octave

             • ‘latex’ — ‘epsc2’ (default), any image format supported by Octave

             • ‘pdf’ — ‘jpg’ (default) or ‘bmp’, note MATLAB uses ‘bmp’ as default

             • ‘doc’ or ‘ppt’ — ‘png’ (default), ‘jpg’, ‘bmp’, or ‘tiff’

        • ‘maxWidth’ and ‘maxHeight’ — Maximum width (height) of the produced images in pixels.  An empty value means no restriction.  Both values must be set in order for the option to work properly.

          ‘[]’ (default), integer value ≥ 0

        • ‘useNewFigure’ — Use a new figure window for figures created by the evaluated code.  This avoids side effects with already opened figure windows.

          ‘true’ (default) or ‘false’

        • ‘evalCode’ — Evaluate code of the Octave source file

          ‘true’ (default) or ‘false’

        • ‘catchError’ — Catch errors while evaluating code and continue

          ‘true’ (default) or ‘false’

        • ‘codeToEvaluate’ — Octave commands that should be evaluated prior to publishing the script file.  These Octave commands do not appear in the generated report.

        • ‘maxOutputLines’ — Maximum number of output lines from code evaluation which are included in output.

          ‘Inf’ (default) or integer value > 0

        • ‘showCode’ — Show the evaluated Octave commands in the generated report

          ‘true’ (default) or ‘false’

     The option output OUTPUT_FILE is a string with path and file name of the generated report.

     See also: grabcode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Generate a report from the Octave script file FILE in one of several output formats.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
python


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 435
 -- : OUTPUT = python (SCRIPTFILE)
 -- : OUTPUT = python (SCRIPTFILE, ARGUMENT1, ARGUMENT2, ...)
 -- : [OUTPUT, STATUS] = python (...)
     Invoke Python script SCRIPTFILE, possibly with a list of command line arguments.

     Return output in OUTPUT and optional status in STATUS.  If SCRIPTFILE is not an absolute filename it is searched for in the current directory and then in the Octave loadpath.

     See also: system, perl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Invoke Python script SCRIPTFILE, possibly with a list of command line arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
recycle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 540
 -- : VAL = recycle ()
 -- : OLD_VAL = recycle (NEW_VAL)
     Query or set the preference for recycling deleted files.

     When recycling is enabled, commands which would permanently erase files instead move them to a temporary location (such as the directory labeled Trash).

     Programming Note: This function is provided for MATLAB compatibility, but recycling is not implemented in Octave.  To help avoid accidental data loss an error will be raised if an attempt is made to enable file recycling.

     See also: delete, rmdir.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Query or set the preference for recycling deleted files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
run


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 919
 -- : run SCRIPT
 -- : run ("SCRIPT")
     Run SCRIPT in the current workspace.

     Scripts which reside in directories specified in Octave’s load path, and which end with the extension ‘".m"’, can be run simply by typing their name.  For scripts not located on the load path, use ‘run’.

     The filename SCRIPT can be a bare, fully qualified, or relative filename and with or without a file extension.  If no extension is specified, Octave will first search for a script with the ‘".m"’ extension before falling back to the script name without an extension.

     Implementation Note: If SCRIPT includes a path component, then ‘run’ first changes the working directory to the directory where SCRIPT is found.  Next, the script is executed.  Finally, ‘run’ returns to the original working directory unless SCRIPT has specifically changed directories.

     See also: path, addpath, source.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Run SCRIPT in the current workspace.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
saveobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 643
 -- : B = saveobj (A)
     Method of a class to manipulate an object prior to saving it to a file.

     The function ‘saveobj’ is called when the object A is saved using the ‘save’ function.  An example of the use of ‘saveobj’ might be to remove fields of the object that don’t make sense to be saved or it might be used to ensure that certain fields of the object are initialized before the object is saved.  For example:

          function b = saveobj (a)
            b = a;
            if (isempty (b.field))
               b.field = initfield (b);
            endif
          endfunction

     See also: loadobj, class.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Method of a class to manipulate an object prior to saving it to a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2569
 -- : SOUT = setfield (S, FIELD, VAL)
 -- : SOUT = setfield (S, SIDX1, FIELD1, FIDX1, SIDX2, FIELD2, FIDX2, ..., VAL)

     Return a _copy_ of the structure S with the field member FIELD set to the value VAL.

     For example:

          S = struct ();
          S = setfield (S, "foo bar", 42);

     This is equivalent to

          S.("foo bar") = 42;

     Note that ordinary structure syntax ‘S.foo bar = 42’ cannot be used here, as the field name is not a valid Octave identifier because of the space character.  Using arbitrary strings for field names is incompatible with MATLAB, and this usage will emit a warning if the warning ID ‘Octave:language-extension’ is enabled.  *Note warning_ids: XREFwarning_ids.

     With the second calling form, set a field of a structure array.  The input SIDX selects an element of the structure array, FIELD specifies the field name of the selected element, and FIDX selects which element of the field (in the case of an array or cell array).  The SIDX, FIELD, and FIDX inputs can be repeated to address nested structure array elements.  The structure array index and field element index must be cell arrays while the field name must be a string.

     For example:

          S = struct ("baz", 42);
          setfield (S, {1}, "foo", {1}, "bar", 54)
          ⇒
            ans =
              scalar structure containing the fields:
                baz =  42
                foo =
                  scalar structure containing the fields:
                    bar =  54

     The example begins with an ordinary scalar structure to which a nested scalar structure is added.  In all cases, if the structure index SIDX is not specified it defaults to 1 (scalar structure).  Thus, the example above could be written more concisely as ‘setfield (S, "foo", "bar", 54)’

     Finally, an example with nested structure arrays:

          SA.foo = 1;
          SA = setfield (SA, {2}, "bar", {3}, "baz", {1, 4}, 5);
          SA(2).bar(3)
          ⇒
            ans =
              scalar structure containing the fields:
                baz =  0   0   0   5

     Here SA is a structure array whose field at elements 1 and 2 is in turn another structure array whose third element is a simple scalar structure.  The terminal scalar structure has a field which contains a matrix value.

     Note that the same result as in the above example could be achieved by:

          SA.foo = 1;
          SA(2).bar(3).baz(1,4) = 5

     See also: getfield, rmfield, orderfields, isfield, fieldnames, isstruct, struct.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return a _copy_ of the structure S with the field member FIELD set to the value VAL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
substruct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 580
 -- : substruct (TYPE, SUBS, ...)
     Create a subscript structure for use with ‘subsref’ or ‘subsasgn’.

     For example:

          idx = substruct ("()", {3, ":"})
               ⇒
                 idx =
                 {
                   type = ()
                   subs =
                   {
                     [1,1] =  3
                     [1,2] = :
                   }
                 }
          x = [1, 2, 3;
               4, 5, 6;
               7, 8, 9];
          subsref (x, idx)
             ⇒ 7  8  9

     See also: subsref, subsasgn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Create a subscript structure for use with ‘subsref’ or ‘subsasgn’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
swapbytes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 247
 -- : swapbytes (X)
     Swap the byte order on values, converting from little endian to big endian and vice versa.

     For example:

          swapbytes (uint16 (1:4))
          ⇒ [   256   512   768  1024]

     See also: typecast, cast.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Swap the byte order on values, converting from little endian to big endian and vice versa.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 479
 -- : VARS = symvar (STR)
     Identify the symbolic variable names in the string STR.

     Common constant names such as ‘i’, ‘j’, ‘pi’, ‘Inf’ and Octave functions such as ‘sin’ or ‘plot’ are ignored.

     Any names identified are returned in a cell array of strings.  The array is empty if no variables were found.

     Example:

          symvar ("x^2 + y^2 == 4")
          ⇒ {
               [1,1] = x
               [2,1] = y
             }
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Identify the symbolic variable names in the string STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 685
 -- : FILELIST = tar (TARFILE, FILES)
 -- : FILELIST = tar (TARFILE, FILES, ROOTDIR)
     Pack the list of files and directories specified in FILES into the TAR archive TARFILE.

     FILES is a character array or cell array of strings.  Shell wildcards in the filename such as ‘*’ or ‘?’ are accepted and expanded.  Directories are recursively traversed and all files are added to the archive.

     If ROOTDIR is defined then any files without absolute pathnames are located relative to ROOTDIR rather than the current directory.

     The optional output FILELIST is a list of the files that were included in the archive.

     See also: untar, unpack, bzip2, gzip, zip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Pack the list of files and directories specified in FILES into the TAR archive TARFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tempdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
 -- : DIR = tempdir ()
     Return the name of the host system’s directory for temporary files.

     The directory name is taken first from the environment variable ‘TMPDIR’.  If that does not exist the system default returned by ‘P_tmpdir’ is used.

     See also: P_tmpdir, tempname, mkstemp, tmpfile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the name of the host system’s directory for temporary files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
unix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- : unix ("COMMAND")
 -- : STATUS = unix ("COMMAND")
 -- : [STATUS, TEXT] = unix ("COMMAND")
 -- : [...] = unix ("COMMAND", "-echo")
     Execute a system command if running under a Unix-like operating system, otherwise do nothing.

     Octave waits for the external command to finish before returning the exit status of the program in STATUS and any output in TEXT.

     When called with no output argument, or the "-echo" argument is given, then TEXT is also sent to standard output.

     See also: dos, system, isunix, ismac, ispc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Execute a system command if running under a Unix-like operating system, otherwise do nothing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1222
 -- : FILES = unpack (FILE)
 -- : FILES = unpack (FILE, DIR)
 -- : FILES = unpack (FILE, DIR, FILETYPE)
     Unpack the archive FILE based on its extension to the directory DIR.

     If FILE is a list of strings, then each file is unpacked individually.  Shell wildcards in the filename such as ‘*’ or ‘?’ are accepted and expanded.

     If DIR is not specified or is empty (‘[]’), it defaults to the current directory.  If a directory is in the file list, then FILETYPE must also be specified.

     The specific archive filetype is inferred from the extension of the file.  The FILETYPE may also be specified directly using a string which corresponds to a known extension.

     Valid filetype extensions:

     ‘bz’
     ‘bz2’
          bzip archive

     ‘gz’
          gzip archive

     ‘tar’
          tar archive

     ‘tarbz’
     ‘tarbz2’
     ‘tbz’
     ‘tbz2’
          tar + bzip archive

     ‘targz’
     ‘tgz’
          tar + gzip archive

     ‘z’
          compress archive

     ‘zip’
          zip archive

     The optional return value is a list of FILES unpacked.

     See also: bunzip2, gunzip, unzip, untar, bzip2, gzip, zip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Unpack the archive FILE based on its extension to the directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
untar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 327
 -- : untar (TARFILE)
 -- : untar (TARFILE, DIR)
     Unpack the TAR archive TARFILE.

     If DIR is specified the files are unpacked in this directory rather than the one where TARFILE is located.

     The optional output FILELIST is a list of the uncompressed files.

     See also: tar, unpack, bunzip2, gunzip, unzip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Unpack the TAR archive TARFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
unzip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 349
 -- : FILELIST = unzip (ZIPFILE)
 -- : FILELIST = unzip (ZIPFILE, DIR)
     Unpack the ZIP archive ZIPFILE.

     If DIR is specified the files are unpacked in this directory rather than the one where ZIPFILE is located.

     The optional output FILELIST is a list of the uncompressed files.

     See also: zip, unpack, bunzip2, gunzip, untar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Unpack the ZIP archive ZIPFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
validateattributes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4150
 -- : validateattributes (A, CLASSES, ATTRIBUTES)
 -- : validateattributes (A, CLASSES, ATTRIBUTES, ARG_IDX)
 -- : validateattributes (A, CLASSES, ATTRIBUTES, FUNC_NAME)
 -- : validateattributes (A, CLASSES, ATTRIBUTES, FUNC_NAME, ARG_NAME)
 -- : validateattributes (A, CLASSES, ATTRIBUTES, FUNC_NAME, ARG_NAME, ARG_IDX)
     Check validity of input argument.

     Confirms that the argument A is valid by belonging to one of CLASSES, and holding all of the ATTRIBUTES.  If it does not, an error is thrown, with a message formatted accordingly.  The error message can be made further complete by the function name FUN_NAME, the argument name ARG_NAME, and its position in the input ARG_IDX.

     CLASSES must be a cell array of strings (an empty cell array is allowed) with the name of classes (remember that a class name is case sensitive).  In addition to the class name, the following categories names are also valid:

     "float"
          Floating point value comprising classes "double" and "single".

     "integer"
          Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.

     "numeric"
          Numeric value comprising either a floating point or integer value.

     ATTRIBUTES must be a cell array with names of checks for A.  Some of them require an additional value to be supplied right after the name (see details for each below).

     "<="
          All values are less than or equal to the following value in ATTRIBUTES.

     "<"
          All values are less than the following value in ATTRIBUTES.

     ">="
          All values are greater than or equal to the following value in ATTRIBUTES.

     ">"
          All values are greater than the following value in ATTRIBUTES.

     "2d"
          A 2-dimensional matrix.  Note that vectors and empty matrices have 2 dimensions, one of them being of length 1, or both length 0.

     "3d"
          Has no more than 3 dimensions.  A 2-dimensional matrix is a 3-D matrix whose 3rd dimension is of length 1.

     "binary"
          All values are either 1 or 0.

     "column"
          Values are arranged in a single column.

     "decreasing"
          No value is NAN, and each is less than the preceding one.

     "diag"
          Value is a diagonal matrix.

     "even"
          All values are even numbers.

     "finite"
          All values are finite.

     "increasing"
          No value is NAN, and each is greater than the preceding one.

     "integer"
          All values are integer.  This is different than using ‘isinteger’ which only checks its an integer type.  This checks that each value in A is an integer value, i.e., it has no decimal part.

     "ncols"
          Has exactly as many columns as the next value in ATTRIBUTES.

     "ndims"
          Has exactly as many dimensions as the next value in ATTRIBUTES.

     "nondecreasing"
          No value is NAN, and each is greater than or equal to the preceding one.

     "nonempty"
          It is not empty.

     "nonincreasing"
          No value is NAN, and each is less than or equal to the preceding one.

     "nonnan"
          No value is a ‘NaN’.

     "nonnegative"
          All values are non negative.

     "nonsparse"
          It is not a sparse matrix.

     "nonzero"
          No value is zero.

     "nrows"
          Has exactly as many rows as the next value in ATTRIBUTES.

     "numel"
          Has exactly as many elements as the next value in ATTRIBUTES.

     "odd"
          All values are odd numbers.

     "positive"
          All values are positive.

     "real"
          It is a non-complex matrix.

     "row"
          Values are arranged in a single row.

     "scalar"
          It is a scalar.

     "size"
          Its size has length equal to the values of the next in ATTRIBUTES.  The next value must is an array with the length for each dimension.  To ignore the check for a certain dimension, the value of ‘NaN’ can be used.

     "square"
          Is a square matrix.

     "vector"
          Values are arranged in a single vector (column or vector).

     See also: isa, validatestring, inputParser.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Check validity of input argument.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 771
 -- : ver
 -- : ver Octave
 -- : ver PACKAGE
 -- : v = ver (...)

     Display a header containing the current Octave version number, license string, and operating system.  The header is followed by a list of installed packages, versions, and installation directories.

     Use the package name PACKAGE or Octave to limit the listing to a desired component.

     When called with an output argument, return a vector of structures describing Octave and each installed package.  The structure includes the following fields.

     ‘Name’
          Package name.

     ‘Version’
          Version of the package.

     ‘Release’
          Release of the package.

     ‘Date’
          Date of the version/release.

     See also: version, usejava, pkg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Display a header containing the current Octave version number, license string, and operating system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
version


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1114
 -- : V = version ()
 -- : [V, D] = version ()
 -- : V = version (FEATURE)
     Get version information for Octave.

     If called without input argument, the first return value V gives the version number of Octave as a string.  The second return value D holds the release date as a string.

     The following options can be passed for FEATURE:

     "-date"
          for the release date of the running build,

     "-description"
          for a description of the release (always an empty string),

     "-release"
          for the name of the running build (always an empty string),

     "-java"
          for version information of the Java VM,

     "-fftw"
          for version information for the linked FFTW,

     "-blas"
          for version information for the linked BLAS,

     "-lapack"
          for version information for the linked LAPACK.

     "-hgid"
          the mercurial ID of the sources used to build Octave.

     The variant with no input and output argument is an alias for the function ‘OCTAVE_VERSION’ provided for compatibility.

     See also: OCTAVE_VERSION, ver.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Get version information for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
what


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1022
 -- : what
 -- : what DIR
 -- : w = what (DIR)
     List the Octave specific files in directory DIR.

     If DIR is not specified then the current directory is used.

     If a return argument is requested, the files found are returned in the structure W.  The structure contains the following fields:

     path
          Full path to directory DIR

     m
          Cell array of m-files

     mat
          Cell array of mat files

     mex
          Cell array of mex files

     oct
          Cell array of oct files

     mdl
          Cell array of mdl files

     slx
          Cell array of slx files

     p
          Cell array of p-files

     classes
          Cell array of class directories (‘@CLASSNAME/’)

     packages
          Cell array of package directories (‘+PKGNAME/’)

     Compatibility Note: Octave does not support mdl, slx, and p files; nor does it support package directories.  ‘what’ will always return an empty list for these categories.

     See also: which, ls, exist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
List the Octave specific files in directory DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
zip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 704
 -- : FILELIST = zip (ZIPFILE, FILES)
 -- : FILELIST = zip (ZIPFILE, FILES, ROOTDIR)
     Compress the list of files and directories specified in FILES into the ZIP archive ZIPFILE.

     FILES is a character array or cell array of strings.  Shell wildcards in the filename such as ‘*’ or ‘?’ are accepted and expanded.  Directories are recursively traversed and all files are compressed and added to the archive.

     If ROOTDIR is defined then any files without absolute pathnames are located relative to ROOTDIR rather than the current directory.

     The optional output FILELIST is a list of the files that were included in the archive.

     See also: unzip, unpack, bzip2, gzip, tar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Compress the list of files and directories specified in FILES into the ZIP archive ZIPFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
decic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2651
 -- : [Y0_NEW, YP0_NEW] = decic (FUN, T0, Y0, FIXED_Y0, YP0, FIXED_YP0)
 -- : [Y0_NEW, YP0_NEW] = decic (FUN, T0, Y0, FIXED_Y0, YP0, FIXED_YP0, OPTIONS)
 -- : [Y0_NEW, YP0_NEW, RESNORM] = decic (...)

     Compute consistent implicit ODE initial conditions Y0_NEW and YP0_NEW given initial guesses Y0 and YP0.

     A maximum of ‘length (Y0)’ components between FIXED_Y0 and FIXED_YP0 may be chosen as fixed values.

     FUN is a function handle.  The function must accept three inputs where the first is time T, the second is a column vector of unknowns Y, and the third is a column vector of unknowns YP.

     T0 is the initial time such that ‘FUN(T0, Y0_NEW, YP0_NEW) = 0’, specified as a scalar.

     Y0 is a vector used as the initial guess for Y.

     FIXED_Y0 is a vector which specifies the components of Y0 to hold fixed.  Choose a maximum of ‘length (Y0)’ components between FIXED_Y0 and FIXED_YP0 as fixed values.  Set FIXED_Y0(i) component to 1 if you want to fix the value of Y0(i).  Set FIXED_Y0(i) component to 0 if you want to allow the value of Y0(i) to change.

     YP0 is a vector used as the initial guess for YP.

     FIXED_YP0 is a vector which specifies the components of YP0 to hold fixed.  Choose a maximum of ‘length (YP0)’ components between FIXED_Y0 and FIXED_YP0 as fixed values.  Set FIXED_YP0(i) component to 1 if you want to fix the value of YP0(i).  Set FIXED_YP0(i) component to 0 if you want to allow the value of YP0(i) to change.

     The optional seventh argument OPTIONS is a structure array.  Use ‘odeset’ to generate this structure.  The relevant options are ‘RelTol’ and ‘AbsTol’ which specify the error thresholds used to compute the initial conditions.

     The function typically returns two outputs.  Variable Y0_NEW is a column vector and contains the consistent initial value of Y.  The output YP0_NEW is a column vector and contains the consistent initial value of YP.

     The optional third output RESNORM is the norm of the vector of residuals.  If RESNORM is small, ‘decic’ has successfully computed the initial conditions.  If the value of RESNORM is large, use ‘RelTol’ and ‘AbsTol’ to adjust it.

     Example: Compute initial conditions for Robertson’s equations:

          function r = robertson_dae (T, Y, YP)
            r = [ -(YP(1) + 0.04*Y(1) - 1e4*Y(2)*Y(3))
                  -(YP(2) - 0.04*Y(1) + 1e4*Y(2)*Y(3) + 3e7*Y(2)^2)
          Y(1) + Y(2) + Y(3) - 1 ];
          endfunction
          [Y0_NEW,YP0_NEW] = decic (@robertson_dae, 0, [1; 0; 0], [1; 1; 0],
          [-1e-4; 1; 0], [0; 0; 0]);

     See also: ode15i, odeset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Compute consistent implicit ODE initial conditions Y0_NEW and YP0_NEW given initial guesses Y0 and YP0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode15i


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3126
 -- : [T, Y] = ode15i (FUN, TRANGE, Y0, YP0)
 -- : [T, Y] = ode15i (FUN, TRANGE, Y0, YP0, ODE_OPT)
 -- : [T, Y, TE, YE, IE] = ode15i (...)
 -- : SOLUTION = ode15i (...)
 -- : ode15i (...)
     Solve a set of fully-implicit Ordinary Differential Equations (ODEs) or index 1 Differential Algebraic Equations (DAEs).

     ‘ode15i’ uses a variable step, variable order BDF (Backward Differentiation Formula) method that ranges from order 1 to 5.

     FUN is a function handle, inline function, or string containing the name of the function that defines the ODE: ‘0 = f(t,y,yp)’.  The function must accept three inputs where the first is time T, the second is the function value Y (a column vector), and the third is the derivative value YP (a column vector).

     TRANGE specifies the time interval over which the ODE will be evaluated.  Typically, it is a two-element vector specifying the initial and final times (‘[tinit, tfinal]’).  If there are more than two elements then the solution will also be evaluated at these intermediate time instances.

     Y0 and YP0 contain the initial values for the unknowns Y and YP.  If they are row vectors then the solution Y will be a matrix in which each column is the solution for the corresponding initial value in Y0 and YP0.

     Y0 and YP0 must be consistent initial conditions, meaning that ‘f(t,y0,yp0) = 0’ is satisfied.  The function ‘decic’ may be used to compute consistent initial conditions given initial guesses.

     The optional fifth argument ODE_OPT specifies non-default options to the ODE solver.  It is a structure generated by ‘odeset’.

     The function typically returns two outputs.  Variable T is a column vector and contains the times where the solution was found.  The output Y is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has a field X containing a row vector of times where the solution was evaluated and a field Y containing the solution matrix such that each column corresponds to a time in X.  Use ‘fieldnames (SOLUTION)’ to see the other fields and additional information returned.

     If no output arguments are requested, and no ‘OutputFcn’ is specified in ODE_OPT, then the ‘OutputFcn’ is set to ‘odeplot’ and the results of the solver are plotted immediately.

     If using the "Events" option then three additional outputs may be returned.  TE holds the time when an Event function returned a zero.  YE holds the value of the solution at time TE.  IE contains an index indicating which Event function was triggered in the case of multiple Event functions.

     Example: Solve Robertson’s equations:

          function r = robertson_dae (T, Y, YP)
            r = [ -(YP(1) + 0.04*Y(1) - 1e4*Y(2)*Y(3))
                  -(YP(2) - 0.04*Y(1) + 1e4*Y(2)*Y(3) + 3e7*Y(2)^2)
          Y(1) + Y(2) + Y(3) - 1 ];
          endfunction
          [T,Y] = ode15i (@robertson_dae, [0, 1e3], [1; 0; 0], [-1e-4; 1e-4; 0]);

     See also: decic, odeset, odeget.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
Solve a set of fully-implicit Ordinary Differential Equations (ODEs) or index 1 Differential Algebraic Equations (DAEs).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode15s


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2889
 -- : [T, Y] = ode15s (FUN, TRANGE, Y0)
 -- : [T, Y] = ode15s (FUN, TRANGE, Y0, ODE_OPT)
 -- : [T, Y, TE, YE, IE] = ode15s (...)
 -- : SOLUTION = ode15s (...)
 -- : ode15s (...)
     Solve a set of stiff Ordinary Differential Equations (ODEs) or stiff semi-explicit index 1 Differential Algebraic Equations (DAEs).

     ‘ode15s’ uses a variable step, variable order BDF (Backward Differentiation Formula) method that ranges from order 1 to 5.

     FUN is a function handle, inline function, or string containing the name of the function that defines the ODE: ‘y' = f(t,y)’.  The function must accept two inputs where the first is time T and the second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be evaluated.  Typically, it is a two-element vector specifying the initial and final times (‘[tinit, tfinal]’).  If there are more than two elements then the solution will also be evaluated at these intermediate time instances.

     INIT contains the initial value for the unknowns.  If it is a row vector then the solution Y will be a matrix in which each column is the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options to the ODE solver.  It is a structure generated by ‘odeset’.

     The function typically returns two outputs.  Variable T is a column vector and contains the times where the solution was found.  The output Y is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has a field X containing a row vector of times where the solution was evaluated and a field Y containing the solution matrix such that each column corresponds to a time in X.  Use ‘fieldnames (SOLUTION)’ to see the other fields and additional information returned.

     If no output arguments are requested, and no ‘OutputFcn’ is specified in ODE_OPT, then the ‘OutputFcn’ is set to ‘odeplot’ and the results of the solver are plotted immediately.

     If using the "Events" option then three additional outputs may be returned.  TE holds the time when an Event function returned a zero.  YE holds the value of the solution at time TE.  IE contains an index indicating which Event function was triggered in the case of multiple Event functions.

     Example: Solve Robertson’s equations:

          function r = robertson_dae (T, Y)
            r = [ -0.04*Y(1) + 1e4*Y(2)*Y(3)
                   0.04*Y(1) - 1e4*Y(2)*Y(3) - 3e7*Y(2)^2
          Y(1) + Y(2) + Y(3) - 1 ];
          endfunction
          opt = odeset ("Mass", [1 0 0; 0 1 0; 0 0 0], "MStateDependence", "none");
          [T,Y] = ode15s (@robertson_dae, [0, 1e3], [1; 0; 0], opt);

     See also: decic, odeset, odeget, ode23, ode45.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
Solve a set of stiff Ordinary Differential Equations (ODEs) or stiff semi-explicit index 1 Differential Algebraic Equations (DAEs).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode23


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2836
 -- : [T, Y] = ode23 (FUN, TRANGE, INIT)
 -- : [T, Y] = ode23 (FUN, TRANGE, INIT, ODE_OPT)
 -- : [T, Y, TE, YE, IE] = ode23 (...)
 -- : SOLUTION = ode23 (...)
 -- : ode23 (...)

     Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Bogacki-Shampine method of order 3.

     FUN is a function handle, inline function, or string containing the name of the function that defines the ODE: ‘y' = f(t,y)’.  The function must accept two inputs where the first is time T and the second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be evaluated.  Typically, it is a two-element vector specifying the initial and final times (‘[tinit, tfinal]’).  If there are more than two elements then the solution will also be evaluated at these intermediate time instances.

     By default, ‘ode23’ uses an adaptive timestep with the ‘integrate_adaptive’ algorithm.  The tolerance for the timestep computation may be changed by using the options "RelTol" and "AbsTol".

     INIT contains the initial value for the unknowns.  If it is a row vector then the solution Y will be a matrix in which each column is the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options to the ODE solver.  It is a structure generated by ‘odeset’.

     The function typically returns two outputs.  Variable T is a column vector and contains the times where the solution was found.  The output Y is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has a field X containing a row vector of times where the solution was evaluated and a field Y containing the solution matrix such that each column corresponds to a time in X.  Use ‘fieldnames (SOLUTION)’ to see the other fields and additional information returned.

     If no output arguments are requested, and no ‘OutputFcn’ is specified in ODE_OPT, then the ‘OutputFcn’ is set to ‘odeplot’ and the results of the solver are plotted immediately.

     If using the "Events" option then three additional outputs may be returned.  TE holds the time when an Event function returned a zero.  YE holds the value of the solution at time TE.  IE contains an index indicating which Event function was triggered in the case of multiple Event functions.

     Example: Solve the Van der Pol equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = ode23 (fvdp, [0, 20], [2, 0]);

     Reference: For the definition of this method see <https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods>.

     See also: odeset, odeget, ode45, ode15s.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Bogacki-Shampine method of order 3.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode45


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2710
 -- : [T, Y] = ode45 (FUN, TRANGE, INIT)
 -- : [T, Y] = ode45 (FUN, TRANGE, INIT, ODE_OPT)
 -- : [T, Y, TE, YE, IE] = ode45 (...)
 -- : SOLUTION = ode45 (...)
 -- : ode45 (...)

     Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Dormand-Prince method of order 4.

     FUN is a function handle, inline function, or string containing the name of the function that defines the ODE: ‘y' = f(t,y)’.  The function must accept two inputs where the first is time T and the second is a column vector of unknowns Y.

     TRANGE specifies the time interval over which the ODE will be evaluated.  Typically, it is a two-element vector specifying the initial and final times (‘[tinit, tfinal]’).  If there are more than two elements then the solution will also be evaluated at these intermediate time instances.

     By default, ‘ode45’ uses an adaptive timestep with the ‘integrate_adaptive’ algorithm.  The tolerance for the timestep computation may be changed by using the options "RelTol" and "AbsTol".

     INIT contains the initial value for the unknowns.  If it is a row vector then the solution Y will be a matrix in which each column is the solution for the corresponding initial value in INIT.

     The optional fourth argument ODE_OPT specifies non-default options to the ODE solver.  It is a structure generated by ‘odeset’.

     The function typically returns two outputs.  Variable T is a column vector and contains the times where the solution was found.  The output Y is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in T.

     The output can also be returned as a structure SOLUTION which has a field X containing a row vector of times where the solution was evaluated and a field Y containing the solution matrix such that each column corresponds to a time in X.  Use ‘fieldnames (SOLUTION)’ to see the other fields and additional information returned.

     If no output arguments are requested, and no ‘OutputFcn’ is specified in ODE_OPT, then the ‘OutputFcn’ is set to ‘odeplot’ and the results of the solver are plotted immediately.

     If using the "Events" option then three additional outputs may be returned.  TE holds the time when an Event function returned a zero.  YE holds the value of the solution at time TE.  IE contains an index indicating which Event function was triggered in the case of multiple Event functions.

     Example: Solve the Van der Pol equation

          fvdp = @(T,Y) [Y(2); (1 - Y(1)^2) * Y(2) - Y(1)];
          [T,Y] = ode45 (fvdp, [0, 20], [2, 0]);

     See also: odeset, odeget, ode23, ode15s.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Dormand-Prince method of order 4.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odeget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 589
 -- : VAL = odeget (ODE_OPT, FIELD)
 -- : VAL = odeget (ODE_OPT, FIELD, DEFAULT)

     Query the value of the property FIELD in the ODE options structure ODE_OPT.

     If called with two input arguments and the first input argument ODE_OPT is an ODE option structure and the second input argument FIELD is a string specifying an option name, then return the option value VAL corresponding to FIELD from ODE_OPT.

     If called with an optional third input argument, and FIELD is not set in the structure ODE_OPT, then return the default value DEFAULT instead.

     See also: odeset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Query the value of the property FIELD in the ODE options structure ODE_OPT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
odeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1779
 -- : STOP_SOLVE = odeplot (T, Y, FLAG)

     Open a new figure window and plot the solution of an ode problem at each time step during the integration.

     The types and values of the input parameters T and Y depend on the input FLAG that is of type string.  Valid values of FLAG are:

     ‘"init"’
          The input T must be a column vector of length 2 with the first and last time step (‘[TFIRST TLAST]’.  The input Y contains the initial conditions for the ode problem (Y0).

     ‘""’
          The input T must be a scalar double specifying the time for which the solution in input Y was calculated.

     ‘"done"’
          The inputs should be empty, but are ignored if they are present.

     ‘odeplot’ always returns false, i.e., don’t stop the ode solver.

     Example: solve an anonymous implementation of the "Van der Pol" equation and display the results while solving.

          fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];

          opt = odeset ("OutputFcn", @odeplot, "RelTol", 1e-6);
          sol = ode45 (fvdp, [0 20], [2 0], opt);

     Background Information: This function is called by an ode solver function if it was specified in the "OutputFcn" property of an options structure created with ‘odeset’.  The ode solver will initially call the function with the syntax ‘odeplot ([TFIRST, TLAST], Y0, "init")’.  The function initializes internal variables, creates a new figure window, and sets the x limits of the plot.  Subsequently, at each time step during the integration the ode solver calls ‘odeplot (T, Y, [])’.  At the end of the solution the ode solver calls ‘odeplot ([], [], "done")’ so that odeplot can perform any clean-up actions required.

     See also: odeset, odeget, ode23, ode45.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Open a new figure window and plot the solution of an ode problem at each time step during the integration.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odeset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3951
 -- : ODESTRUCT = odeset ()
 -- : ODESTRUCT = odeset ("FIELD1", VALUE1, "FIELD2", VALUE2, ...)
 -- : ODESTRUCT = odeset (OLDSTRUCT, "FIELD1", VALUE1, "FIELD2", VALUE2, ...)
 -- : ODESTRUCT = odeset (OLDSTRUCT, NEWSTRUCT)
 -- : odeset ()

     Create or modify an ODE options structure.

     When called with no input argument and one output argument, return a new ODE options structure that contains all possible fields initialized to their default values.  If no output argument is requested, display a list of the common ODE solver options along with their default value.

     If called with name-value input argument pairs "FIELD1", "VALUE1", "FIELD2", "VALUE2", ... return a new ODE options structure with all the most common option fields initialized, *and* set the values of the fields "FIELD1", "FIELD2", ... to the values VALUE1, VALUE2, ....

     If called with an input structure OLDSTRUCT then overwrite the values of the options "FIELD1", "FIELD2", ... with new values VALUE1, VALUE2, ... and return the modified structure.

     When called with two input ODE options structures OLDSTRUCT and NEWSTRUCT overwrite all values from the structure OLDSTRUCT with new values from the structure NEWSTRUCT.  Empty values in NEWSTRUCT will not overwrite values in OLDSTRUCT.

     The most commonly used ODE options, which are always assigned a value by ‘odeset’, are the following:

     AbsTol
          Absolute error tolerance.

     BDF
          Use BDF formulas in implicit multistep methods.  _Note_: This option is not yet implemented.

     Events
          Event function.  An event function must have the form ‘[value, isterminal, direction] = my_events_f (t, y)’

     InitialSlope
          Consistent initial slope vector for DAE solvers.

     InitialStep
          Initial time step size.

     Jacobian
          Jacobian matrix, specified as a constant matrix or a function of time and state.

     JConstant
          Specify whether the Jacobian is a constant matrix or depends on the state.

     JPattern
          If the Jacobian matrix is sparse and non-constant but maintains a constant sparsity pattern, specify the sparsity pattern.

     Mass
          Mass matrix, specified as a constant matrix or a function of time and state.

     MassSingular
          Specify whether the mass matrix is singular.  Accepted values include "yes", "no", "maybe".

     MaxOrder
          Maximum order of formula.

     MaxStep
          Maximum time step value.

     MStateDependence
          Specify whether the mass matrix depends on the state or only on time.

     MvPattern
          If the mass matrix is sparse and non-constant but maintains a constant sparsity pattern, specify the sparsity pattern.  _Note_: This option is not yet implemented.

     NonNegative
          Specify elements of the state vector that are expected to remain non-negative during the simulation.

     NormControl
          Control error relative to the 2-norm of the solution, rather than its absolute value.

     OutputFcn
          Function to monitor the state during the simulation.  For the form of the function to use see ‘odeplot’.

     OutputSel
          Indices of elements of the state vector to be passed to the output monitoring function.

     Refine
          Specify whether output should be returned only at the end of each time step or also at intermediate time instances.  The value should be a scalar indicating the number of equally spaced time points to use within each timestep at which to return output.  _Note_: This option is not yet implemented.

     RelTol
          Relative error tolerance.

     Stats
          Print solver statistics after simulation.

     Vectorized
          Specify whether ‘odefun’ can be passed multiple values of the state at once.

     Field names that are not in the above list are also accepted and added to the result structure.

     See also: odeget.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Create or modify an ODE options structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fminbnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1193
 -- : [X, FVAL, INFO, OUTPUT] = fminbnd (FUN, A, B, OPTIONS)
     Find a minimum point of a univariate function.

     FUN should be a function handle or name.  A, B specify a starting interval.  OPTIONS is a structure specifying additional options.  Currently, ‘fminbnd’ recognizes these options: "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a description of these options, see *note optimset: XREFoptimset.

     On exit, the function returns X, the approximate minimum point and FVAL, the function value thereof.

     INFO is an exit flag that can have these values:

        • 1 The algorithm converged to a solution.

        • 0 Maximum number of iterations or function evaluations has been exhausted.

        • -1 The algorithm has been terminated from user output function.

     Notes: The search for a minimum is restricted to be in the interval bound by A and B.  If you only have an initial point to begin searching from you will need to use an unconstrained minimization algorithm such as ‘fminunc’ or ‘fminsearch’.  ‘fminbnd’ internally uses a Golden Section search strategy.

     See also: fzero, fminunc, fminsearch, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Find a minimum point of a univariate function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fminsearch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1971
 -- : X = fminsearch (FUN, X0)
 -- : X = fminsearch (FUN, X0, OPTIONS)
 -- : X = fminsearch (FUN, X0, OPTIONS, FUN_ARG1, FUN_ARG2, ...)
 -- : [X, FVAL, EXITFLAG, OUTPUT] = fminsearch (...)

     Find a value of X which minimizes the function FUN.

     The search begins at the point X0 and iterates using the Nelder & Mead Simplex algorithm (a derivative-free method).  This algorithm is better-suited to functions which have discontinuities or for which a gradient-based search such as ‘fminunc’ fails.

     Options for the search are provided in the parameter OPTIONS using the function ‘optimset’.  Currently, ‘fminsearch’ accepts the options: "TolX", "TolFun", "MaxFunEvals", "MaxIter", "Display", "FunValCheck", and "OutputFcn".  For a description of these options, see ‘optimset’.

     Additional inputs for the function FUN can be passed as the fourth and higher arguments.  To pass function arguments while using the default OPTIONS values, use ‘[]’ for OPTIONS.

     On exit, the function returns X, the minimum point, and FVAL, the function value at the minimum.

     The third return value EXITFLAG is

     1
          if the algorithm converged (size of the simplex is smaller than ‘OPTIONS.TolX’ *AND* the step in the function value between iterations is smaller than ‘OPTIONS.TolFun’).

     0
          if the maximum number of iterations or the maximum number of function evaluations are exceeded.

     -1
          if the iteration is stopped by the "OutputFcn".

     The fourth return value is a structure OUTPUT with the fields, ‘funcCount’ containing the number of function calls to FUN, ‘iterations’ containing the number of iteration steps, ‘algorithm’ with the name of the search algorithm (always: "Nelder-Mead simplex direct search"), and ‘message’ with the exit message.

     Example:

          fminsearch (@(x) (x(1)-5).^2+(x(2)-8).^4, [0;0])

     See also: fminbnd, fminunc, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find a value of X which minimizes the function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fminunc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2587
 -- : fminunc (FCN, X0)
 -- : fminunc (FCN, X0, OPTIONS)
 -- : [X, FVAL, INFO, OUTPUT, GRAD, HESS] = fminunc (FCN, ...)
     Solve an unconstrained optimization problem defined by the function FCN.

     FCN should accept a vector (array) defining the unknown variables, and return the objective function value, optionally with gradient.  ‘fminunc’ attempts to determine a vector X such that ‘FCN (X)’ is a local minimum.

     X0 determines a starting guess.  The shape of X0 is preserved in all calls to FCN, but otherwise is treated as a column vector.

     OPTIONS is a structure specifying additional options.  Currently, ‘fminunc’ recognizes these options: "FunValCheck", "OutputFcn", "TolX", "TolFun", "MaxIter", "MaxFunEvals", "GradObj", "FinDiffType", "TypicalX", "AutoScaling".

     If "GradObj" is "on", it specifies that FCN, when called with two output arguments, also returns the Jacobian matrix of partial first derivatives at the requested point.  ‘TolX’ specifies the termination tolerance for the unknown variables X, while ‘TolFun’ is a tolerance for the objective function value FVAL.  The default is ‘1e-7’ for both options.

     For a description of the other options, see ‘optimset’.

     On return, X is the location of the minimum and FVAL contains the value of the objective function at X.

     INFO may be one of the following values:

     1
          Converged to a solution point.  Relative gradient error is less than specified by ‘TolFun’.

     2
          Last relative step size was less than ‘TolX’.

     3
          Last relative change in function value was less than ‘TolFun’.

     0
          Iteration limit exceeded—either maximum number of algorithm iterations ‘MaxIter’ or maximum number of function evaluations ‘MaxFunEvals’.

     -1
          Algorithm terminated by ‘OutputFcn’.

     -3
          The trust region radius became excessively small.

     Optionally, ‘fminunc’ can return a structure with convergence statistics (OUTPUT), the output gradient (GRAD) at the solution X, and approximate Hessian (HESS) at the solution X.

     Application Notes: If the objective function is a single nonlinear equation of one variable then using ‘fminbnd’ is usually a better choice.

     The algorithm used by ‘fminunc’ is a gradient search which depends on the objective function being differentiable.  If the function has discontinuities it may be better to use a derivative-free algorithm such as ‘fminsearch’.

     See also: fminbnd, fminsearch, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Solve an unconstrained optimization problem defined by the function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fsolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4351
 -- : fsolve (FCN, X0, OPTIONS)
 -- : [X, FVEC, INFO, OUTPUT, FJAC] = fsolve (FCN, ...)
     Solve a system of nonlinear equations defined by the function FCN.

     FCN should accept a vector (array) defining the unknown variables, and return a vector of left-hand sides of the equations.  Right-hand sides are defined to be zeros.  In other words, this function attempts to determine a vector X such that ‘FCN (X)’ gives (approximately) all zeros.

     X0 determines a starting guess.  The shape of X0 is preserved in all calls to FCN, but otherwise it is treated as a column vector.

     OPTIONS is a structure specifying additional options.  Currently, ‘fsolve’ recognizes these options: "FunValCheck", "OutputFcn", "TolX", "TolFun", "MaxIter", "MaxFunEvals", "Jacobian", "Updating", "ComplexEqn" "TypicalX", "AutoScaling" and "FinDiffType".

     If "Jacobian" is "on", it specifies that FCN, called with 2 output arguments also returns the Jacobian matrix of right-hand sides at the requested point.  "TolX" specifies the termination tolerance in the unknown variables, while "TolFun" is a tolerance for equations.  Default is ‘1e-7’ for both "TolX" and "TolFun".

     If "AutoScaling" is on, the variables will be automatically scaled according to the column norms of the (estimated) Jacobian.  As a result, TolF becomes scaling-independent.  By default, this option is off because it may sometimes deliver unexpected (though mathematically correct) results.

     If "Updating" is "on", the function will attempt to use Broyden updates to update the Jacobian, in order to reduce the amount of Jacobian calculations.  If your user function always calculates the Jacobian (regardless of number of output arguments) then this option provides no advantage and should be set to false.

     "ComplexEqn" is "on", ‘fsolve’ will attempt to solve complex equations in complex variables, assuming that the equations possess a complex derivative (i.e., are holomorphic).  If this is not what you want, you should unpack the real and imaginary parts of the system to get a real system.

     For description of the other options, see ‘optimset’.

     On return, FVAL contains the value of the function FCN evaluated at X.

     INFO may be one of the following values:

     1
          Converged to a solution point.  Relative residual error is less than specified by TolFun.

     2
          Last relative step size was less that TolX.

     3
          Last relative decrease in residual was less than TolF.

     0
          Iteration limit exceeded.

     -3
          The trust region radius became excessively small.

     Note: If you only have a single nonlinear equation of one variable, using ‘fzero’ is usually a much better idea.

     Note about user-supplied Jacobians: As an inherent property of the algorithm, a Jacobian is always requested for a solution vector whose residual vector is already known, and it is the last accepted successful step.  Often this will be one of the last two calls, but not always.  If the savings by reusing intermediate results from residual calculation in Jacobian calculation are significant, the best strategy is to employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is called with that vector, then the intermediate results should be saved for future Jacobian evaluation, and should be kept until a Jacobian evaluation is requested or until OutputFcn is called with a different vector, in which case they should be dropped in favor of this most recent vector.  A short example how this can be achieved follows:

          function [fvec, fjac] = user_func (x, optimvalues, state)
          persistent sav = [], sav0 = [];
          if (nargin == 1)
            ## evaluation call
            if (nargout == 1)
              sav0.x = x; # mark saved vector
              ## calculate fvec, save results to sav0.
            elseif (nargout == 2)
              ## calculate fjac using sav.
            endif
          else
            ## outputfcn call.
            if (all (x == sav0.x))
              sav = sav0;
            endif
            ## maybe output iteration status, etc.
          endif
          endfunction

          ## ...

          fsolve (@user_func, x0, optimset ("OutputFcn", @user_func, ...))

     See also: fzero, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Solve a system of nonlinear equations defined by the function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fzero


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1849
 -- : fzero (FUN, X0)
 -- : fzero (FUN, X0, OPTIONS)
 -- : [X, FVAL, INFO, OUTPUT] = fzero (...)
     Find a zero of a univariate function.

     FUN is a function handle, inline function, or string containing the name of the function to evaluate.

     X0 should be a two-element vector specifying two points which bracket a zero.  In other words, there must be a change in sign of the function between X0(1) and X0(2).  More mathematically, the following must hold

          sign (FUN(X0(1))) * sign (FUN(X0(2))) <= 0

     If X0 is a single scalar then several nearby and distant values are probed in an attempt to obtain a valid bracketing.  If this is not successful, the function fails.

     OPTIONS is a structure specifying additional options.  Currently, ‘fzero’ recognizes these options: "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a description of these options, see *note optimset: XREFoptimset.

     On exit, the function returns X, the approximate zero point and FVAL, the function value thereof.

     INFO is an exit flag that can have these values:

        • 1 The algorithm converged to a solution.

        • 0 Maximum number of iterations or function evaluations has been reached.

        • -1 The algorithm has been terminated from user output function.

        • -5 The algorithm may have converged to a singular point.

     OUTPUT is a structure containing runtime information about the ‘fzero’ algorithm.  Fields in the structure are:

        • iterations Number of iterations through loop.

        • nfev Number of function evaluations.

        • bracketx A two-element vector with the final bracketing of the zero along the x-axis.

        • brackety A two-element vector with the final bracketing of the zero along the y-axis.

     See also: optimset, fsolve.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Find a zero of a univariate function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
glpk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11349
 -- : [XOPT, FMIN, ERRNUM, EXTRA] = glpk (C, A, B, LB, UB, CTYPE, VARTYPE, SENSE, PARAM)
     Solve a linear program using the GNU GLPK library.

     Given three arguments, ‘glpk’ solves the following standard LP:

          min C'*x

     subject to

          A*x  = b
            x >= 0

     but may also solve problems of the form

          [ min | max ] C'*x

     subject to

          A*x [ "=" | "<=" | ">=" ] b
            x >= LB
            x <= UB

     Input arguments:

     C
          A column array containing the objective function coefficients.

     A
          A matrix containing the constraints coefficients.

     B
          A column array containing the right-hand side value for each constraint in the constraint matrix.

     LB
          An array containing the lower bound on each of the variables.  If LB is not supplied, the default lower bound for the variables is zero.

     UB
          An array containing the upper bound on each of the variables.  If UB is not supplied, the default upper bound is assumed to be infinite.

     CTYPE
          An array of characters containing the sense of each constraint in the constraint matrix.  Each element of the array may be one of the following values

          "F"
               A free (unbounded) constraint (the constraint is ignored).

          "U"
               An inequality constraint with an upper bound (‘A(i,:)*x <= b(i)’).

          "S"
               An equality constraint (‘A(i,:)*x = b(i)’).

          "L"
               An inequality with a lower bound (‘A(i,:)*x >= b(i)’).

          "D"
               An inequality constraint with both upper and lower bounds (‘A(i,:)*x >= -b(i)’) _and_ (‘A(i,:)*x <= b(i)’).

     VARTYPE
          A column array containing the types of the variables.

          "C"
               A continuous variable.

          "I"
               An integer variable.

     SENSE
          If SENSE is 1, the problem is a minimization.  If SENSE is -1, the problem is a maximization.  The default value is 1.

     PARAM
          A structure containing the following parameters used to define the behavior of solver.  Missing elements in the structure take on default values, so you only need to set the elements that you wish to change from the default.

          Integer parameters:

          ‘msglev (default: 1)’
               Level of messages output by solver routines:

               0 (‘GLP_MSG_OFF’)
                    No output.

               1 (‘GLP_MSG_ERR’)
                    Error and warning messages only.

               2 (‘GLP_MSG_ON’)
                    Normal output.

               3 (‘GLP_MSG_ALL’)
                    Full output (includes informational messages).

          ‘scale (default: 16)’
               Scaling option.  The values can be combined with the bitwise OR operator and may be the following:

               1 (‘GLP_SF_GM’)
                    Geometric mean scaling.

               16 (‘GLP_SF_EQ’)
                    Equilibration scaling.

               32 (‘GLP_SF_2N’)
                    Round scale factors to power of two.

               64 (‘GLP_SF_SKIP’)
                    Skip if problem is well scaled.

               Alternatively, a value of 128 (‘GLP_SF_AUTO’) may be also specified, in which case the routine chooses the scaling options automatically.

          ‘dual (default: 1)’
               Simplex method option:

               1 (‘GLP_PRIMAL’)
                    Use two-phase primal simplex.

               2 (‘GLP_DUALP’)
                    Use two-phase dual simplex, and if it fails, switch to the primal simplex.

               3 (‘GLP_DUAL’)
                    Use two-phase dual simplex.

          ‘price (default: 34)’
               Pricing option (for both primal and dual simplex):

               17 (‘GLP_PT_STD’)
                    Textbook pricing.

               34 (‘GLP_PT_PSE’)
                    Steepest edge pricing.

          ‘itlim (default: intmax)’
               Simplex iterations limit.  It is decreased by one each time when one simplex iteration has been performed, and reaching zero value signals the solver to stop the search.

          ‘outfrq (default: 200)’
               Output frequency, in iterations.  This parameter specifies how frequently the solver sends information about the solution to the standard output.

          ‘branch (default: 4)’
               Branching technique option (for MIP only):

               1 (‘GLP_BR_FFV’)
                    First fractional variable.

               2 (‘GLP_BR_LFV’)
                    Last fractional variable.

               3 (‘GLP_BR_MFV’)
                    Most fractional variable.

               4 (‘GLP_BR_DTH’)
                    Heuristic by Driebeck and Tomlin.

               5 (‘GLP_BR_PCH’)
                    Hybrid pseudocost heuristic.

          ‘btrack (default: 4)’
               Backtracking technique option (for MIP only):

               1 (‘GLP_BT_DFS’)
                    Depth first search.

               2 (‘GLP_BT_BFS’)
                    Breadth first search.

               3 (‘GLP_BT_BLB’)
                    Best local bound.

               4 (‘GLP_BT_BPH’)
                    Best projection heuristic.

          ‘presol (default: 1)’
               If this flag is set, the simplex solver uses the built-in LP presolver.  Otherwise the LP presolver is not used.

          ‘lpsolver (default: 1)’
               Select which solver to use.  If the problem is a MIP problem this flag will be ignored.

               1
                    Revised simplex method.

               2
                    Interior point method.

          ‘rtest (default: 34)’
               Ratio test technique:

               17 (‘GLP_RT_STD’)
                    Standard ("textbook").

               34 (‘GLP_RT_HAR’)
                    Harris’ two-pass ratio test.

          ‘tmlim (default: intmax)’
               Searching time limit, in milliseconds.

          ‘outdly (default: 0)’
               Output delay, in seconds.  This parameter specifies how long the solver should delay sending information about the solution to the standard output.

          ‘save (default: 0)’
               If this parameter is nonzero, save a copy of the problem in CPLEX LP format to the file ‘"outpb.lp"’.  There is currently no way to change the name of the output file.

          Real parameters:

          ‘tolbnd (default: 1e-7)’
               Relative tolerance used to check if the current basic solution is primal feasible.  It is not recommended that you change this parameter unless you have a detailed understanding of its purpose.

          ‘toldj (default: 1e-7)’
               Absolute tolerance used to check if the current basic solution is dual feasible.  It is not recommended that you change this parameter unless you have a detailed understanding of its purpose.

          ‘tolpiv (default: 1e-10)’
               Relative tolerance used to choose eligible pivotal elements of the simplex table.  It is not recommended that you change this parameter unless you have a detailed understanding of its purpose.

          ‘objll (default: -DBL_MAX)’
               Lower limit of the objective function.  If the objective function reaches this limit and continues decreasing, the solver stops the search.  This parameter is used in the dual simplex method only.

          ‘objul (default: +DBL_MAX)’
               Upper limit of the objective function.  If the objective function reaches this limit and continues increasing, the solver stops the search.  This parameter is used in the dual simplex only.

          ‘tolint (default: 1e-5)’
               Relative tolerance used to check if the current basic solution is integer feasible.  It is not recommended that you change this parameter unless you have a detailed understanding of its purpose.

          ‘tolobj (default: 1e-7)’
               Relative tolerance used to check if the value of the objective function is not better than in the best known integer feasible solution.  It is not recommended that you change this parameter unless you have a detailed understanding of its purpose.

     Output values:

     XOPT
          The optimizer (the value of the decision variables at the optimum).

     FOPT
          The optimum value of the objective function.

     ERRNUM
          Error code.

          0
               No error.

          1 (‘GLP_EBADB’)
               Invalid basis.

          2 (‘GLP_ESING’)
               Singular matrix.

          3 (‘GLP_ECOND’)
               Ill-conditioned matrix.

          4 (‘GLP_EBOUND’)
               Invalid bounds.

          5 (‘GLP_EFAIL’)
               Solver failed.

          6 (‘GLP_EOBJLL’)
               Objective function lower limit reached.

          7 (‘GLP_EOBJUL’)
               Objective function upper limit reached.

          8 (‘GLP_EITLIM’)
               Iterations limit exhausted.

          9 (‘GLP_ETMLIM’)
               Time limit exhausted.

          10 (‘GLP_ENOPFS’)
               No primal feasible solution.

          11 (‘GLP_ENODFS’)
               No dual feasible solution.

          12 (‘GLP_EROOT’)
               Root LP optimum not provided.

          13 (‘GLP_ESTOP’)
               Search terminated by application.

          14 (‘GLP_EMIPGAP’)
               Relative MIP gap tolerance reached.

          15 (‘GLP_ENOFEAS’)
               No primal/dual feasible solution.

          16 (‘GLP_ENOCVG’)
               No convergence.

          17 (‘GLP_EINSTAB’)
               Numerical instability.

          18 (‘GLP_EDATA’)
               Invalid data.

          19 (‘GLP_ERANGE’)
               Result out of range.

     EXTRA
          A data structure containing the following fields:

          ‘lambda’
               Dual variables.

          ‘redcosts’
               Reduced Costs.

          ‘time’
               Time (in seconds) used for solving LP/MIP problem.

          ‘status’
               Status of the optimization.

               1 (‘GLP_UNDEF’)
                    Solution status is undefined.

               2 (‘GLP_FEAS’)
                    Solution is feasible.

               3 (‘GLP_INFEAS’)
                    Solution is infeasible.

               4 (‘GLP_NOFEAS’)
                    Problem has no feasible solution.

               5 (‘GLP_OPT’)
                    Solution is optimal.

               6 (‘GLP_UNBND’)
                    Problem has no unbounded solution.

     Example:

          c = [10, 6, 4]';
          A = [ 1, 1, 1;
               10, 4, 5;
                2, 2, 6];
          b = [100, 600, 300]';
          lb = [0, 0, 0]';
          ub = [];
          ctype = "UUU";
          vartype = "CCC";
          s = -1;

          param.msglev = 1;
          param.itlim = 100;

          [xmin, fmin, status, extra] = ...
             glpk (c, A, b, lb, ub, ctype, vartype, s, param);
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Solve a linear program using the GNU GLPK library.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
humps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 990
 -- : Y = humps (X)
 -- : [X, Y] = humps (X)
     Evaluate a function with multiple minima, maxima, and zero crossings.

     The output Y is the evaluation of the rational function:

                  1200*X^4 - 2880*X^3 + 2036*X^2 - 348*X - 88
           Y = - ---------------------------------------------
                   200*X^4 - 480*X^3 + 406*X^2 - 138*X + 17

     X may be a scalar, vector or array.  If X is omitted, the default range [0:0.05:1] is used.

     When called with two output arguments, [X, Y], X will contain the input values, and Y will contain the output from ‘humps’.

     Programming Notes: ‘humps’ has two local maxima located near X = 0.300 and 0.893, a local minimum near X = 0.637, and zeros near X = -0.132 and 1.300.  ‘humps’ is a useful function for testing algorithms which find zeros or local minima and maxima.

     Try ‘demo humps’ to see a plot of the ‘humps’ function.

     See also: fzero, fminbnd, fminunc, fminsearch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Evaluate a function with multiple minima, maxima, and zero crossings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lsqnonneg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1380
 -- : X = lsqnonneg (C, D)
 -- : X = lsqnonneg (C, D, X0)
 -- : X = lsqnonneg (C, D, X0, OPTIONS)
 -- : [X, RESNORM] = lsqnonneg (...)
 -- : [X, RESNORM, RESIDUAL] = lsqnonneg (...)
 -- : [X, RESNORM, RESIDUAL, EXITFLAG] = lsqnonneg (...)
 -- : [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT] = lsqnonneg (...)
 -- : [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT, LAMBDA] = lsqnonneg (...)

     Minimize ‘norm (C*X - D)’ subject to ‘X >= 0’.

     C and D must be real matrices.

     X0 is an optional initial guess for the solution X.

     OPTIONS is an options structure to change the behavior of the algorithm (*note optimset: XREFoptimset.).  ‘lsqnonneg’ recognizes these options: "MaxIter", "TolX".

     Outputs:

     RESNORM
          The squared 2-norm of the residual: ‘norm (C*X-D)^2’

     RESIDUAL
          The residual: ‘D-C*X’

     EXITFLAG
          An indicator of convergence.  0 indicates that the iteration count was exceeded, and therefore convergence was not reached; >0 indicates that the algorithm converged.  (The algorithm is stable and will converge given enough iterations.)

     OUTPUT
          A structure with two fields:

             • "algorithm": The algorithm used ("nnls")

             • "iterations": The number of iterations taken.

     LAMBDA
          Undocumented output

     See also: pqpnonneg, lscov, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Minimize ‘norm (C*X - D)’ subject to ‘X >= 0’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
optimget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- : optimget (OPTIONS, PARNAME)
 -- : optimget (OPTIONS, PARNAME, DEFAULT)
     Return the specific option PARNAME from the optimization options structure OPTIONS created by ‘optimset’.

     If PARNAME is not defined then return DEFAULT if supplied, otherwise return an empty matrix.

     See also: optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return the specific option PARNAME from the optimization options structure OPTIONS created by ‘optimset’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
optimset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3000
 -- : optimset ()
 -- : OPTIONS = optimset ()
 -- : OPTIONS = optimset (PAR, VAL, ...)
 -- : OPTIONS = optimset (OLD, PAR, VAL, ...)
 -- : OPTIONS = optimset (OLD, NEW)
     Create options structure for optimization functions.

     When called without any input or output arguments, ‘optimset’ prints a list of all valid optimization parameters.

     When called with one output and no inputs, return an options structure with all valid option parameters initialized to ‘[]’.

     When called with a list of parameter/value pairs, return an options structure with only the named parameters initialized.

     When the first input is an existing options structure OLD, the values are updated from either the PAR/VAL list or from the options structure NEW.

     Valid parameters are:

     AutoScaling

     ComplexEqn

     Display
          Request verbose display of results from optimizations.  Values are:

          "off" [default]
               No display.

          "iter"
               Display intermediate results for every loop iteration.

          "final"
               Display the result of the final loop iteration.

          "notify"
               Display the result of the final loop iteration if the function has failed to converge.

     FinDiffType

     FunValCheck
          When enabled, display an error if the objective function returns an invalid value (a complex number, NaN, or Inf).  Must be set to "on" or "off" [default].  Note: the functions ‘fzero’ and ‘fminbnd’ correctly handle Inf values and only complex values or NaN will cause an error in this case.

     GradObj
          When set to "on", the function to be minimized must return a second argument which is the gradient, or first derivative, of the function at the point X.  If set to "off" [default], the gradient is computed via finite differences.

     Jacobian
          When set to "on", the function to be minimized must return a second argument which is the Jacobian, or first derivative, of the function at the point X.  If set to "off" [default], the Jacobian is computed via finite differences.

     MaxFunEvals
          Maximum number of function evaluations before optimization stops.  Must be a positive integer.

     MaxIter
          Maximum number of algorithm iterations before optimization stops.  Must be a positive integer.

     OutputFcn
          A user-defined function executed once per algorithm iteration.

     TolFun
          Termination criterion for the function output.  If the difference in the calculated objective function between one algorithm iteration and the next is less than ‘TolFun’ the optimization stops.  Must be a positive scalar.

     TolX
          Termination criterion for the function input.  If the difference in X, the current search point, between one algorithm iteration and the next is less than ‘TolX’ the optimization stops.  Must be a positive scalar.

     TypicalX

     Updating

     See also: optimget.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Create options structure for optimization functions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
pqpnonneg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1331
 -- : X = pqpnonneg (C, D)
 -- : X = pqpnonneg (C, D, X0)
 -- : X = pqpnonneg (C, D, X0, OPTIONS)
 -- : [X, MINVAL] = pqpnonneg (...)
 -- : [X, MINVAL, EXITFLAG] = pqpnonneg (...)
 -- : [X, MINVAL, EXITFLAG, OUTPUT] = pqpnonneg (...)
 -- : [X, MINVAL, EXITFLAG, OUTPUT, LAMBDA] = pqpnonneg (...)

     Minimize ‘1/2*X'*C*X + D'*X’ subject to ‘X >= 0’.

     C and D must be real matrices, and C must be symmetric and positive definite.

     X0 is an optional initial guess for the solution X.

     OPTIONS is an options structure to change the behavior of the algorithm (*note optimset: XREFoptimset.).  ‘pqpnonneg’ recognizes one option: "MaxIter".

     Outputs:

     X
          The solution matrix

     MINVAL
          The minimum attained model value, ‘1/2*XMIN'*C*XMIN + D'*XMIN’

     EXITFLAG
          An indicator of convergence.  0 indicates that the iteration count was exceeded, and therefore convergence was not reached; >0 indicates that the algorithm converged.  (The algorithm is stable and will converge given enough iterations.)

     OUTPUT
          A structure with two fields:

             • "algorithm": The algorithm used ("nnls")

             • "iterations": The number of iterations taken.

     LAMBDA
          Undocumented output

     See also: lsqnonneg, qp, optimset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Minimize ‘1/2*X'*C*X + D'*X’ subject to ‘X >= 0’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1987
 -- : [X, OBJ, INFO, LAMBDA] = qp (X0, H)
 -- : [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q)
 -- : [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B)
 -- : [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB)
 -- : [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB, A_LB, A_IN, A_UB)
 -- : [X, OBJ, INFO, LAMBDA] = qp (..., OPTIONS)
     Solve a quadratic program (QP).

     Solve the quadratic program defined by

          min 0.5 x'*H*x + x'*q
           x

     subject to

          A*x = b
          lb <= x <= ub
          A_lb <= A_in*x <= A_ub

     using a null-space active-set method.

     Any bound (A, B, LB, UB, A_IN, A_LB, A_UB) may be set to the empty matrix (‘[]’) if not present.  The constraints A and A_IN are matrices with each row representing a single constraint.  The other bounds are scalars or vectors depending on the number of constraints.  The algorithm is faster if the initial guess is feasible.

     OPTIONS
          An optional structure containing the following parameter(s) used to define the behavior of the solver.  Missing elements in the structure take on default values, so you only need to set the elements that you wish to change from the default.

          ‘MaxIter (default: 200)’
               Maximum number of iterations.

     INFO
          Structure containing run-time information about the algorithm.  The following fields are defined:

          ‘solveiter’
               The number of iterations required to find the solution.

          ‘info’
               An integer indicating the status of the solution.

               0
                    The problem is feasible and convex.  Global solution found.

               1
                    The problem is not convex.  Local solution found.

               2
                    The problem is not convex and unbounded.

               3
                    Maximum number of iterations reached.

               6
                    The problem is infeasible.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Solve a quadratic program (QP).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sqp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4117
 -- : [X, OBJ, INFO, ITER, NF, LAMBDA] = sqp (X0, PHI)
 -- : [...] = sqp (X0, PHI, G)
 -- : [...] = sqp (X0, PHI, G, H)
 -- : [...] = sqp (X0, PHI, G, H, LB, UB)
 -- : [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER)
 -- : [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER, TOL)
     Minimize an objective function using sequential quadratic programming (SQP).

     Solve the nonlinear program

          min phi (x)
           x

     subject to

          g(x)  = 0
          h(x) >= 0
          lb <= x <= ub

     using a sequential quadratic programming method.

     The first argument is the initial guess for the vector X0.

     The second argument is a function handle pointing to the objective function PHI.  The objective function must accept one vector argument and return a scalar.

     The second argument may also be a 2- or 3-element cell array of function handles.  The first element should point to the objective function, the second should point to a function that computes the gradient of the objective function, and the third should point to a function that computes the Hessian of the objective function.  If the gradient function is not supplied, the gradient is computed by finite differences.  If the Hessian function is not supplied, a BFGS update formula is used to approximate the Hessian.

     When supplied, the gradient function ‘PHI{2}’ must accept one vector argument and return a vector.  When supplied, the Hessian function ‘PHI{3}’ must accept one vector argument and return a matrix.

     The third and fourth arguments G and H are function handles pointing to functions that compute the equality constraints and the inequality constraints, respectively.  If the problem does not have equality (or inequality) constraints, then use an empty matrix ([]) for G (or H).  When supplied, these equality and inequality constraint functions must accept one vector argument and return a vector.

     The third and fourth arguments may also be 2-element cell arrays of function handles.  The first element should point to the constraint function and the second should point to a function that computes the gradient of the constraint function:

                      [ d f(x)   d f(x)        d f(x) ]
          transpose ( [ ------   -----   ...   ------ ] )
                      [  dx_1     dx_2          dx_N  ]

     The fifth and sixth arguments, LB and UB, contain lower and upper bounds on X.  These must be consistent with the equality and inequality constraints G and H.  If the arguments are vectors then X(i) is bound by LB(i) and UB(i).  A bound can also be a scalar in which case all elements of X will share the same bound.  If only one bound (lb, ub) is specified then the other will default to (-REALMAX, +REALMAX).

     The seventh argument MAXITER specifies the maximum number of iterations.  The default value is 100.

     The eighth argument TOL specifies the tolerance for the stopping criteria.  The default value is ‘sqrt (eps)’.

     The value returned in INFO may be one of the following:

     101
          The algorithm terminated normally.  All constraints meet the specified tolerance.

     102
          The BFGS update failed.

     103
          The maximum number of iterations was reached.

     104
          The stepsize has become too small, i.e., delta X, is less than ‘TOL * norm (x)’.

     An example of calling ‘sqp’:

          function r = g (x)
            r = [ sumsq(x)-10;
                  x(2)*x(3)-5*x(4)*x(5);
                  x(1)^3+x(2)^3+1 ];
          endfunction

          function obj = phi (x)
            obj = exp (prod (x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
          endfunction

          x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];

          [x, obj, info, iter, nf, lambda] = sqp (x0, @phi, @g, [])

          x =

            -1.71714
             1.59571
             1.82725
            -0.76364
            -0.76364

          obj = 0.053950
          info = 101
          iter = 8
          nf = 10
          lambda =

            -0.0401627
             0.0379578
            -0.0052227

     See also: qp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Minimize an objective function using sequential quadratic programming (SQP).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
import


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 852
 -- : import PACKAGE.FUNCTION
 -- : import PACKAGE.CLASS
 -- : import PACKAGE.*
 -- : import
 -- : LIST = import

     Import function or classes into the current scope.

     *Warning:* This functionality is not yet implemented, and invoking the function will emit an error.

     When invoked with the name of a PACKAGE and a FUNCTION or CLASS name, that name is made available in the current code without having to use namespace qualifiers.  This can facilitate the readability of the code, and require less typing by programmers.

     Example

          import containers.Map;

          m = Map ({"A", "B"}, {[1], [2]});

     When called with no inputs and no outputs ‘import’ prints a list of any import definitions.

     When called with no inputs and one output, a cell array of strings LIST is returned with any import definitions.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Import function or classes into the current scope.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
matlabroot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- : matlabroot ()
     Return the name of the top-level Octave installation directory.

     This is an alias for the function ‘OCTAVE_HOME’ provided for compatibility.

     See also: OCTAVE_HOME.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the name of the top-level Octave installation directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pathdef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- : VAL = pathdef ()
     Return the default path for Octave.

     The path information is extracted from one of four sources.  The possible sources, in order of preference, are:

       1. ‘.octaverc’

       2. ‘~/.octaverc’

       3. ‘<OCTAVE_HOME>/.../<version>/m/startup/octaverc’

       4. Octave’s path prior to changes by any octaverc file.

     See also: path, addpath, rmpath, genpath, savepath.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return the default path for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
savepath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 976
 -- : savepath ()
 -- : savepath (FILE)
 -- : STATUS = savepath (...)
     Save the unique portion of the current function search path that is not set during Octave’s initialization process to FILE.

     If FILE is omitted, Octave looks in the current directory for a project-specific ‘.octaverc’ file in which to save the path information.  If no such file is present then the user’s configuration file ‘~/.octaverc’ is used.

     If successful, ‘savepath’ returns 0.

     The ‘savepath’ function makes it simple to customize a user’s configuration file to restore the working paths necessary for a particular instance of Octave.  Assuming no filename is specified, Octave will automatically restore the saved directory paths from the appropriate ‘.octaverc’ file when starting up.  If a filename has been specified then the paths may be restored manually by calling ‘source FILE’.

     See also: path, addpath, rmpath, genpath, pathdef.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Save the unique portion of the current function search path that is not set during Octave’s initialization process to FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7579
 -- : pkg COMMAND PKG_NAME
 -- : pkg COMMAND OPTION PKG_NAME
 -- : [OUT1, ...] = pkg (COMMAND, ... )
     Manage or query packages (groups of add-on functions) for Octave.

     Different actions are available depending on the value of COMMAND and on return arguments.

     Available commands:

     ‘install’
          Install named packages.  For example,

               pkg install image-1.0.0.tar.gz

          installs the package found in the file ‘image-1.0.0.tar.gz’.  The file containing the package can be an url, e.g.

               pkg install 'http://somewebsite.org/image-1.0.0.tar.gz'

          installs the package found in the given url.  This requires an internet connection and the cURL library.

          _Security risk_: no verification of the package is performed before the installation.  It has the same security issues as manually downloading the package from the given url and installing it.

          _No support_: the GNU Octave community is not responsible for packages installed from foreign sites.  For support or for reporting bugs you need to contact the maintainers of the installed package directly (see the ‘DESCRIPTION’ file of the package)

          The OPTION variable can contain options that affect the manner in which a package is installed.  These options can be one or more of

          ‘-nodeps’
               The package manager will disable dependency checking.  With this option it is possible to install a package even when it depends on another package which is not installed on the system.  *Use this option with care.*

          ‘-local’
               A local installation (package available only to current user) is forced, even if the user has system privileges.

          ‘-global’
               A global installation (package available to all users) is forced, even if the user doesn’t normally have system privileges.

          ‘-forge’
               Install a package directly from the Octave-Forge repository.  This requires an internet connection and the cURL library.

               _Security risk_: no verification of the package is performed before the installation.  There are no signature for packages, or checksums to confirm the correct file was downloaded.  It has the same security issues as manually downloading the package from the Octave Forge repository and installing it.

          ‘-verbose’
               The package manager will print the output of all commands as they are performed.

     ‘update’
          Check installed Octave-Forge packages against repository and update any outdated items.  This requires an internet connection and the cURL library.  Usage:

               pkg update

     ‘uninstall’
          Uninstall named packages.  For example,

               pkg uninstall image

          removes the ‘image’ package from the system.  If another installed package depends on the ‘image’ package an error will be issued.  The package can be uninstalled anyway by using the ‘-nodeps’ option.

     ‘load’
          Add named packages to the path.  After loading a package it is possible to use the functions provided by the package.  For example,

               pkg load image

          adds the ‘image’ package to the path.

     ‘unload’
          Remove named packages from the path.  After unloading a package it is no longer possible to use the functions provided by the package.

     ‘list’
          Show the list of currently installed packages.  For example,

               pkg list

          will produce a short report with the package name, version, and installation directory for each installed package.  Supply a package name to limit reporting to a particular package.  For example:

               pkg list image

          If a single return argument is requested then ‘pkg’ returns a cell array where each element is a structure with information on a single package.

               installed_packages = pkg ("list")

          If two output arguments are requested ‘pkg’ splits the list of installed packages into those which were installed by the current user, and those which were installed by the system administrator.

               [user_packages, system_packages] = pkg ("list")

          The "-forge" option lists packages available at the Octave-Forge repository.  This requires an internet connection and the cURL library.  For example:

               oct_forge_pkgs = pkg ("list", "-forge")

     ‘describe’
          Show a short description of installed packages.  With the option "-verbose" also list functions provided by the package.  For example,

               pkg describe -verbose

          will describe all installed packages and the functions they provide.  Display can be limited to a set of packages:

               pkg describe control signal # describe control and signal packages

          If one output is requested a cell of structure containing the description and list of functions of each package is returned as output rather than printed on screen:

               desc = pkg ("describe", "secs1d", "image")

          If any of the requested packages is not installed, ‘pkg’ returns an error, unless a second output is requested:

               [desc, flag] = pkg ("describe", "secs1d", "image")

          FLAG will take one of the values "Not installed", "Loaded", or "Not loaded" for each of the named packages.

     ‘prefix’
          Set the installation prefix directory.  For example,

               pkg prefix ~/my_octave_packages

          sets the installation prefix to ‘~/my_octave_packages’.  Packages will be installed in this directory.

          It is possible to get the current installation prefix by requesting an output argument.  For example:

               pfx = pkg ("prefix")

          The location in which to install the architecture dependent files can be independently specified with an addition argument.  For example:

               pkg prefix ~/my_octave_packages ~/my_arch_dep_pkgs

     ‘local_list’
          Set the file in which to look for information on locally installed packages.  Locally installed packages are those that are available only to the current user.  For example:

               pkg local_list ~/.octave_packages

          It is possible to get the current value of local_list with the following

               pkg local_list

     ‘global_list’
          Set the file in which to look for information on globally installed packages.  Globally installed packages are those that are available to all users.  For example:

               pkg global_list /usr/share/octave/octave_packages

          It is possible to get the current value of global_list with the following

               pkg global_list

     ‘build’
          Build a binary form of a package or packages.  The binary file produced will itself be an Octave package that can be installed normally with ‘pkg’.  The form of the command to build a binary package is

               pkg build builddir image-1.0.0.tar.gz ...

          where ‘builddir’ is the name of a directory where the temporary installation will be produced and the binary packages will be found.  The options ‘-verbose’ and ‘-nodeps’ are respected, while all other options are ignored.

     ‘rebuild’
          Rebuild the package database from the installed directories.  This can be used in cases where the package database has been corrupted.

     See also: ver, news.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Manage or query packages (groups of add-on functions) for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
annotation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4708
 -- : annotation (TYPE)
 -- : annotation ("line", X, Y)
 -- : annotation ("arrow", X, Y)
 -- : annotation ("doublearrow", X, Y)
 -- : annotation ("textarrow", X, Y)
 -- : annotation ("textbox", POS)
 -- : annotation ("rectangle", POS)
 -- : annotation ("ellipse", POS)
 -- : annotation (..., PROP, VAL)
 -- : annotation (HF, ...)
 -- : H = annotation (...)
     Draw annotations to emphasize parts of a figure.

     You may build a default annotation by specifying only the TYPE of the annotation.

     Otherwise you can select the type of annotation and then set its position using either X and Y coordinates for line-based annotations or a position vector POS for others.  In either case, coordinates are interpreted using the "units" property of the annotation object.  The default is "normalized", which means the lower left hand corner of the figure has coordinates ‘[0 0]’ and the upper right hand corner ‘[1 1]’.

     If the first argument HF is a figure handle, then plot into this figure, rather than the current figure returned by ‘gcf’.

     Further arguments can be provided in the form of PROP/VAL pairs to customize the annotation appearance.

     The optional return value H is a graphics handle to the created annotation object.  This can be used with the ‘set’ function to customize an existing annotation object.

     All annotation objects share two properties:

        • "units": the units in which coordinates are interpreted.
          Its value may be one of "centimeters" | "characters" | "inches" | "{normalized}" | "pixels" | "points".

        • "position": a four-element vector [x0 y0 width height].
          The vector specifies the coordinates (x0,y0) of the origin of the annotation object, its width, and its height.  The width and height may be negative, depending on the orientation of the object.

     Valid annotation types and their specific properties are described below:

     "line"
          Constructs a line.  X and Y must be two-element vectors specifying the x and y coordinates of the two ends of the line.

          The line can be customized using "linewidth", "linestyle", and "color" properties the same way as for ‘line’ objects.

     "arrow"
          Construct an arrow.  The second point in vectors X and Y specifies the arrowhead coordinates.

          Besides line properties, the arrowhead can be customized using "headlength", "headwidth", and "headstyle" properties.  Supported values for "headstyle" property are: ["diamond" | "ellipse" | "plain" | "rectangle" | "vback1" | "{vback2}" | "vback3"]

     "doublearrow"
          Construct a double arrow.  Vectors X and Y specify the arrowhead coordinates.

          The line and the arrowhead can be customized as for arrow annotations, but some property names are duplicated: "head1length"/"head2length", "head1width"/"head2width", etc.  The index 1 marks the properties of the arrowhead at the first point in X and Y coordinates.

     "textarrow"
          Construct an arrow with a text label at the opposite end from the arrowhead.

          Use the "string" property to change the text string.  The line and the arrowhead can be customized as for arrow annotations, and the text can be customized using the same properties as ‘text’ graphics objects.  Note, however, that some text property names are prefixed with "text" to distinguish them from arrow properties: "textbackgroundcolor", "textcolor", "textedgecolor", "textlinewidth", "textmargin", "textrotation".

     "textbox"
          Construct a box with text inside.  POS specifies the "position" property of the annotation.

          Use the "string" property to change the text string.  You may use "backgroundcolor", "edgecolor", "linestyle", and "linewidth" properties to customize the box background color and edge appearance.  A limited set of ‘text’ objects properties are also available; Besides "font..." properties, you may also use "horizontalalignment" and "verticalalignment" to position the text inside the box.

          Finally, the "fitboxtotext" property controls the actual extent of the box.  If "on" (the default) the box limits are fitted to the text extent.

     "rectangle"
          Construct a rectangle.  POS specifies the "position" property of the annotation.

          You may use "facecolor", "color", "linestyle", and "linewidth" properties to customize the rectangle background color and edge appearance.

     "ellipse"
          Construct an ellipse.  POS specifies the "position" property of the annotation.

          See "rectangle" annotations for customization.

     See also: xlabel, ylabel, zlabel, title, text, gtext, legend, colorbar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Draw annotations to emphasize parts of a figure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
axis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3070
 -- : axis ()
 -- : axis ([X_LO X_HI])
 -- : axis ([X_LO X_HI Y_LO Y_HI])
 -- : axis ([X_LO X_HI Y_LO Y_HI Z_LO Z_HI])
 -- : axis ([X_LO X_HI Y_LO Y_HI Z_LO Z_HI C_LO C_HI])
 -- : axis (OPTION)
 -- : axis (OPTION1, OPTION2, ...)
 -- : axis (HAX, ...)
 -- : LIMITS = axis ()
     Set axis limits and appearance.

     The argument LIMITS should be a 2-, 4-, 6-, or 8-element vector.  The first and second elements specify the lower and upper limits for the x-axis.  The third and fourth specify the limits for the y-axis, the fifth and sixth specify the limits for the z-axis, and the seventh and eighth specify the limits for the color axis.  The special values -Inf and Inf may be used to indicate that the limit should be automatically computed based on the data in the axes.

     Without any arguments, ‘axis’ turns autoscaling on.

     With one output argument, ‘LIMITS = axis’ returns the current axis limits.

     The vector argument specifying limits is optional, and additional string arguments may be used to specify various axis properties.

     The following options control the aspect ratio of the axes.

     "square"
          Force a square axis aspect ratio.

     "equal"
          Force x-axis unit distance to equal y-axis (and z-axis) unit distance.

     "normal"
          Restore default aspect ratio.

     The following options control the way axis limits are interpreted.

     "auto"
     "auto[xyz]"
          Set the specified axes to have nice limits around the data or all if no axes are specified.

     "manual"
          Fix the current axes limits.

     "tight"
          Fix axes to the limits of the data.

     "image"
          Equivalent to "tight" and "equal".

     "vis3d"
          Set aspect ratio modes to "manual" for rotation without stretching.

     The following options affect the appearance of tick marks.

     "tic[xyz]"
          Turn tick marks on for all axes, or turn them on for the specified axes and off for the remainder.

     "label[xyz]"
          Turn tick labels on for all axes, or turn them on for the specified axes and off for the remainder.

     "nolabel"
          Turn tick labels off for all axes.

     Note: If there are no tick marks for an axes then there can be no labels.

     The following options affect the direction of increasing values on the axes.

     "xy"
          Default y-axis, larger values are near the top.

     "ij"
          Reverse y-axis, smaller values are near the top.

     The following options affects the visibility of the axes.

     "on"
          Make the axes visible.

     "off"
          Hide the axes.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     Example 1: set X/Y limits and force a square aspect ratio

          axis ([1, 2, 3, 4], "square");

     Example 2: enable tick marks on all axes, enable tick mark labels only on the y-axis

          axis ("tic", "labely");

     See also: xlim, ylim, zlim, caxis, daspect, pbaspect, box, grid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Set axis limits and appearance.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
box


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 360
 -- : box
 -- : box on
 -- : box off
 -- : box (HAX, ...)
     Control display of the axes border.

     The argument may be either "on" or "off".  If it is omitted, the current box state is toggled.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     See also: axis, grid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Control display of the axes border.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
camlookat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1023
 -- : camlookat ()
 -- : camlookat (H)
 -- : camlookat (HANDLE_LIST)
 -- : camlookat (HAX)
     Move the camera and adjust its properties to look at objects.

     When the input is a handle H, the camera is set to point toward the center of the bounding box of H.  The camera’s position is adjusted so the bounding box approximately fills the field of view.

     This command fixes the camera’s viewing direction (‘camtarget() - campos()’), camera up vector (*note camup: XREFcamup.) and viewing angle (*note camva: XREFcamva.).  The camera target (*note camtarget: XREFcamtarget.) and camera position (*note campos: XREFcampos.) are changed.

     If the argument is a list HANDLE_LIST, then a single bounding box for all the objects is computed and the camera is then adjusted as above.

     If the argument is an axis object HAX, then the children of the axis are used as HANDLE_LIST.  When called with no inputs, it uses the current axis (*note gca: XREFgca.).

     See also: camorbit, camzoom, camroll.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Move the camera and adjust its properties to look at objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
camorbit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1951
 -- : camorbit (THETA, PHI)
 -- : camorbit (THETA, PHI, COORSYS)
 -- : camorbit (THETA, PHI, COORSYS, DIR)
 -- : camorbit (THETA, PHI, "data")
 -- : camorbit (THETA, PHI, "data", "z")
 -- : camorbit (THETA, PHI, "data", "x")
 -- : camorbit (THETA, PHI, "data", "y")
 -- : camorbit (THETA, PHI, "data", [X Y Z])
 -- : camorbit (THETA, PHI, "camera")
 -- : camorbit (HAX, ...)
     Rotate the camera up/down and left/right around its target.

     Move the camera PHI degrees up and THETA degrees to the right, as if it were in an orbit around its target.  Example:

          sphere ()
          camorbit (30, 20)

     These rotations are centered around the camera target (*note camtarget: XREFcamtarget.).  First the camera position is pitched up or down by rotating it PHI degrees around an axis orthogonal to both the viewing direction (specifically ‘camtarget() - campos()’) and the camera “up vector” (*note camup: XREFcamup.).  Example:

          camorbit (0, 20)

     The second rotation depends on the coordinate system COORSYS and direction DIR inputs.  The default for COORSYS is "data".  In this case, the camera is yawed left or right by rotating it THETA degrees around an axis specified by DIR.  The default for DIR is "z", corresponding to the vector ‘[0, 0, 1]’.  Example:

          camorbit (30, 0)

     When COORSYS is set to "camera", the camera is moved left or right by rotating it around an axis parallel to the camera up vector (*note camup: XREFcamup.).  The input DIR should not be specified in this case.  Example:

          camorbit (30, 0, "camera")

     (Note: the rotation by PHI is unaffected by "camera".)

     The ‘camorbit’ command modifies two camera properties: *note campos: XREFcampos. and *note camup: XREFcamup.

     By default, this command affects the current axis; alternatively, an axis can be specified by the optional argument HAX.

     See also: camzoom, camroll, camlookat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Rotate the camera up/down and left/right around its target.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
campos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1043
 -- : P = campos ()
 -- : campos ([X Y Z])
 -- : MODE = campos ("mode")
 -- : campos (MODE)
 -- : campos (AX, ...)
     Set or get the camera position.

     The default camera position is determined automatically based on the scene.  For example, to get the camera position:

          hf = figure();
          peaks()
          p = campos ()
            ⇒ p =
                -27.394  -35.701   64.079

     We can then move the camera further up the z-axis:

          campos (p + [0 0 10])
          campos ()
            ⇒ ans =
                -27.394  -35.701   74.079

     Having made that change, the camera position MODE is now manual:

          campos ("mode")
            ⇒ manual

     We can set it back to automatic:

          campos ("auto")
          campos ()
            ⇒ ans =
                -27.394  -35.701   64.079
          close (hf)

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: camup, camtarget, camva.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Set or get the camera position.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
camroll


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- : camroll (THETA)
 -- : camroll (AX, THETA)
     Roll the camera.

     Roll the camera clockwise by THETA degrees.  For example, the following command will roll the camera by 30 degrees clockwise (to the right); this will cause the scene to appear to roll by 30 degrees to the left:

          peaks ()
          camroll (30)

     Roll the camera back:

          camroll (-30)

     The following command restores the default camera roll:

          camup ("auto")

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: camzoom, camorbit, camlookat, camup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Roll the camera.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
camtarget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1175
 -- : T = camtarget ()
 -- : camtarget ([X Y Z])
 -- : MODE = camtarget ("mode")
 -- : camtarget (MODE)
 -- : camtarget (AX, ...)
     Set or get where the camera is pointed.

     The camera target is a point in space where the camera is pointing.  Usually, it is determined automatically based on the scene:

          hf = figure();
          sphere (36)
          v = camtarget ()
            ⇒ v =
                0   0   0

     We can turn the camera to point at a new target:

          camtarget ([1 1 1])
          camtarget ()
            ⇒   1   1   1

     Having done so, the camera target MODE is manual:

          camtarget ("mode")
            ⇒ manual

     This means, for example, adding new objects to the scene will not retarget the camera:

          hold on;
          peaks ()
          camtarget ()
            ⇒   1   1   1

     We can reset it to be automatic:

          camtarget ("auto")
          camtarget ()
            ⇒   0   0   0.76426
          close (hf)

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: campos, camup, camva.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Set or get where the camera is pointed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
camup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1471
 -- : UP = camup ()
 -- : camup ([X Y Z])
 -- : MODE = camup ("mode")
 -- : camup (MODE)
 -- : camup (AX, ...)
     Set or get the camera up vector.

     By default, the camera is oriented so that “up” corresponds to the positive z-axis:

          hf = figure ();
          sphere (36)
          v = camup ()
            ⇒ v =
                0   0   1

     Specifying a new “up vector” rolls the camera and sets the mode to manual:

          camup ([1 1 0])
          camup ()
            ⇒   1   1   0
          camup ("mode")
            ⇒ manual

     Modifying the up vector does not modify the camera target (*note camtarget: XREFcamtarget.).  Thus, the camera up vector might not be orthogonal to the direction of the camera’s view:

          camup ([1 2 3])
          dot (camup (), camtarget () - campos ())
            ⇒ 6...

     A consequence is that “pulling back” on the up vector does not pitch the camera view (as that would require changing the target).  Setting the up vector is thus typically used only to roll the camera.  A more intuitive command for this purpose is *note camroll: XREFcamroll.

     Finally, we can reset the up vector to automatic mode:

          camup ("auto")
          camup ()
            ⇒   0   0   1
          close (hf)

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: campos, camtarget, camva.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Set or get the camera up vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
camva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 874
 -- : A = camva ()
 -- : camva (A)
 -- : MODE = camva ("mode")
 -- : camva (MODE)
 -- : camva (AX, ...)
     Set or get the camera viewing angle.

     The camera has a viewing angle which determines how much can be seen.  By default this is:

          hf = figure();
          sphere (36)
          a = camva ()
            ⇒ a =  10.340

     To get a wider-angle view, we could double the viewing angle.  This will also set the mode to manual:

          camva (2*a)
          camva ("mode")
            ⇒ manual

     We can set it back to automatic:

          camva ("auto")
          camva ("mode")
            ⇒ auto
          camva ()
            ⇒ ans =  10.340
          close (hf)

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: campos, camtarget, camup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Set or get the camera viewing angle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
camzoom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 -- : camzoom (ZF)
 -- : camzoom (AX, ZF)
     Zoom the camera in or out.

     A value of ZF larger than 1 “zooms in” such that the scene appears magnified:

          hf = figure ();
          sphere (36)
          camzoom (1.2)

     A value smaller than 1 “zooms out” so the camera can see more of the scene:

          camzoom (0.5)

     Technically speaking, zooming affects the “viewing angle”.  The following command resets to the default zoom:

          camva ("auto")
          close (hf)

     By default, these commands affect the current axis; alternatively, an axis can be specified by the optional argument AX.

     See also: camroll, camorbit, camlookat, camva.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Zoom the camera in or out.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
caxis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1258
 -- : caxis ([cmin cmax])
 -- : caxis ("auto")
 -- : caxis ("manual")
 -- : caxis (HAX, ...)
 -- : LIMITS = caxis ()
     Query or set color axis limits for plots.

     The limits argument should be a 2-element vector specifying the lower and upper limits to assign to the first and last value in the colormap.  Data values outside this range are clamped to the first and last colormap entries.

     If the "auto" option is given then automatic colormap limits are applied.  The automatic algorithm sets CMIN to the minimum data value and CMAX to the maximum data value.  If "manual" is specified then the "climmode" property is set to "manual" and the numeric values in the "clim" property are used for limits.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     Called without arguments the current color axis limits are returned.

     Programming Note: The color axis affects the display of image, patch, and surface graphics objects, but *only* if the "cdata" property has indexed data and the "cdatamapping" property is set to "scaled".  Graphic objects with true color ‘cdata’, or "direct" ‘cdatamapping’ are not affected.

     See also: colormap, axis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set color axis limits for plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
clabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1598
 -- : clabel (C, H)
 -- : clabel (C, H, V)
 -- : clabel (C, H, "manual")
 -- : clabel (C)
 -- : clabel (..., PROP, VAL, ...)
 -- : H = clabel (...)
     Add labels to the contours of a contour plot.

     The contour levels are specified by the contour matrix C which is returned by ‘contour’, ‘contourc’, ‘contourf’, and ‘contour3’.  Contour labels are rotated to match the local line orientation and centered on the line.  The position of labels along the contour line is chosen randomly.

     If the argument H is a handle to a contour group object, then label this plot rather than the one in the current axes returned by ‘gca’.

     By default, all contours are labeled.  However, the contours to label can be specified by the vector V.  If the "manual" argument is given then the contours to label can be selected with the mouse.

     Additional property/value pairs that are valid properties of text objects can be given and are passed to the underlying text objects.  Moreover, the contour group property "LabelSpacing" is available which determines the spacing between labels on a contour to be specified.  The default is 144 points, or 2 inches.

     The optional return value H is a vector of graphics handles to the text objects representing each label.  The "userdata" property of the text objects contains the numerical value of the contour label.

     An example of the use of ‘clabel’ is

          [c, h] = contour (peaks (), -4 : 6);
          clabel (c, h, -4:2:6, "fontsize", 12);

     See also: contour, contourf, contour3, meshc, surfc, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Add labels to the contours of a contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
daspect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 700
 -- : DATA_ASPECT_RATIO = daspect ()
 -- : daspect (DATA_ASPECT_RATIO)
 -- : daspect (MODE)
 -- : DATA_ASPECT_RATIO_MODE = daspect ("mode")
 -- : daspect (HAX, ...)
     Query or set the data aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the span of the x, y, and z-axis limits.

     ‘daspect (MODE)’

     Set the data aspect ratio mode of the current axes.  MODE is either "auto" or "manual".

     ‘daspect ("mode")’

     Return the data aspect ratio mode of the current axes.

     ‘daspect (HAX, ...)’

     Operate on the axes in handle HAX instead of the current axes.

     See also: axis, pbaspect, xlim, ylim, zlim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Query or set the data aspect ratio of the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
datetick


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 710
 -- : datetick ()
 -- : datetick (AXIS_STR)
 -- : datetick (DATE_FORMAT)
 -- : datetick (AXIS_STR, DATE_FORMAT)
 -- : datetick (..., "keeplimits")
 -- : datetick (..., "keepticks")
 -- : datetick (HAX, ...)
     Add date-formatted tick labels to an axis.

     The axis to apply the ticks to is determined by AXIS_STR which can take the values "x", "y", or "z".  The default value is "x".

     The formatting of the labels is determined by the variable DATE_FORMAT, which can either be a string or positive integer that ‘datestr’ accepts.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: datenum, datestr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Add date-formatted tick labels to an axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
diffuse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- : diffuse (SX, SY, SZ, LV)
     Calculate the diffuse reflection strength of a surface defined by the normal vector elements SX, SY, SZ.

     The light source location vector LV can be given as a 2-element vector [azimuth, elevation] in degrees or as a 3-element vector [x, y, z].

     See also: specular, surfl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Calculate the diffuse reflection strength of a surface defined by the normal vector elements SX, SY, SZ.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
grid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 687
 -- : grid
 -- : grid on
 -- : grid off
 -- : grid minor
 -- : grid minor on
 -- : grid minor off
 -- : grid (HAX, ...)
     Control the display of plot grid lines.

     The function state input may be either "on" or "off".  If it is omitted, the current grid state is toggled.

     When the first argument is "minor" all subsequent commands modify the minor grid rather than the major grid.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     To control the grid lines for an individual axes use the ‘set’ function.  For example:

          set (gca, "ygrid", "on");

     See also: axis, box.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Control the display of plot grid lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gtext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 661
 -- : gtext (S)
 -- : gtext ({S1, S2, ...})
 -- : gtext ({S1; S2; ...})
 -- : gtext (..., PROP, VAL, ...)
 -- : H = gtext (...)
     Place text on the current figure using the mouse.

     The text is defined by the string S.  If S is a cell string organized as a row vector then each string of the cell array is written to a separate line.  If S is organized as a column vector then one string element of the cell array is placed for every mouse click.

     Optional property/value pairs are passed directly to the underlying text objects.

     The optional return value H is a graphics handle to the created text object(s).

     See also: ginput, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Place text on the current figure using the mouse.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hidden


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 753
 -- : hidden
 -- : hidden on
 -- : hidden off
 -- : MODE = hidden (...)
     Control mesh hidden line removal.

     When called with no argument the hidden line removal state is toggled.

     When called with one of the modes "on" or "off" the state is set accordingly.

     The optional output argument MODE is the current state.

     Hidden Line Removal determines what graphic objects behind a mesh plot are visible.  The default is for the mesh to be opaque and lines behind the mesh are not visible.  If hidden line removal is turned off then objects behind the mesh can be seen through the faces (openings) of the mesh, although the mesh grid lines are still opaque.

     See also: mesh, meshc, meshz, ezmesh, ezmeshc, trimesh, waterfall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Control mesh hidden line removal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
legend


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7354
 -- : legend ()
 -- : legend (STR1, STR2, ...)
 -- : legend (CHARMAT)
 -- : legend ({CELLSTR})
 -- : legend (..., "location", POS)
 -- : legend (..., "orientation", ORIENT)
 -- : legend (HAX, ...)
 -- : legend (HOBJS, ...)
 -- : legend (HAX, HOBJS, ...)
 -- : legend ("OPTION")
 -- : legend (..., {CELLSTR}, PROPERTY, VALUE, ...)
 -- : [HLEG, HLEG_OBJ, HPLOT, LABELS] = legend (...)

     Display a legend for the current axes using the specified strings as labels.

     Legend entries may be specified as individual character string arguments, a character array, or a cell array of character strings.  When label names might be confused with options to ‘legend’, the labels should be protected by specifying them as a cell array of strings.

     If the first argument HAX is an axes handle, then add a legend to this axes, rather than the current axes returned by ‘gca’.

     Legend labels are associated with the axes’ children; The first label is assigned to the first object that was plotted in the axes, the second label to the next object plotted, etc.  To label specific data objects, without labeling all objects, provide their graphic handles in the input HOBJS.

     The optional parameter POS specifies the location of the legend as follows:

                                                                   pos                                                                                                                                             location of the legend
     ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                   north                                                                                                                                           center top
                                                                   south                                                                                                                                           center bottom
                                                                   east                                                                                                                                            right center
                                                                   west                                                                                                                                            left center
                                                                   northeast                                                                                                                                       right top (default)
                                                                   northwest                                                                                                                                       left top
                                                                   southeast                                                                                                                                       right bottom
                                                                   southwest                                                                                                                                       left bottom
                                                                                                                                                                                                                   
                                                                   outside                                                                                                                                         can be appended to any location string
                                                                                                                                                                                                                   which will place the legend outside the axes

     The optional parameter ORIENT determines if the legend elements are placed vertically or horizontally.  The allowed values are "vertical" (default) or "horizontal".

     The following customizations are available using OPTION:

     "show"
          Show legend on the plot

     "hide"
          Hide legend on the plot

     "toggle"
          Toggle between "hide" and "show"

     "boxon"
          Show a box around legend (default)

     "boxoff"
          Hide the box around legend

     "right"
          Place label text to the right of the keys (default)

     "left"
          Place label text to the left of the keys

     "off"
          Delete the legend object

     The ‘legend’ function creates a graphics object which has various properties that can be manipulated with ‘get’/‘set’.  Alternatively, properties can be set directly when calling ‘legend’ by including PROPERTY/VALUE pairs.  If using this calling form, the labels must be specified as a cell array of strings.

     The optional output values are

     HLEG
          The graphics handle of the legend object.

     HLEG_OBJ
          Graphics handles to the text, patch, and line objects which form the legend.

     HPLOT
          Graphics handles to the plot objects which were used in making the legend.

     LABELS
          A cell array of strings of the labels in the legend.

     Implementation Note: The legend label text is either provided in the call to ‘legend’ or is taken from the ‘DisplayName’ property of the graphics objects.  Only data objects, such as line, patch, and surface, have this property whereas axes, figures, etc. do not so they are never present in a legend.  If no labels or ‘DisplayName’ properties are available, then the label text is simply "data1", "data2", ..., "dataN". No more than 20 data labels will be automatically generated.  To label more, call ‘legend’ explicitly and provide all labels.

     The legend ‘FontSize’ property is initially set to 90% of the axes ‘FontSize’ to which it is attached.  Use ‘set’ to override this if necessary.

     A legend is implemented as an additional axes object with the ‘tag’ property set to "legend".  Properties of the legend object may be manipulated directly by using ‘set’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Display a legend for the current axes using the specified strings as labels.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lighting


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 743
 -- : lighting (TYPE)
 -- : lighting (HAX, TYPE)
     Set the lighting of patch or surface graphic objects.

     Valid arguments for TYPE are

     "flat"
          Draw objects with faceted lighting effects.

     "gouraud"
          Draw objects with linear interpolation of the lighting effects between the vertices.

     "none"
          Draw objects without light and shadow effects.

     If the first argument HAX is an axes handle, then change the lighting effects of objects in this axes, rather than the current axes returned by ‘gca’.

     The lighting effects are only visible if at least one light object is present and visible in the same axes.

     See also: light, fill, mesh, patch, pcolor, surf, surface, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Set the lighting of patch or surface graphic objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
material


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6994
 -- : material shiny
 -- : material dull
 -- : material metal
 -- : material default
 -- : material ([AS, DS, SS])
 -- : material ([AS, DS, SS, SE])
 -- : material ([AS, DS, SS, SE, SCR])
 -- : material (HLIST, ...)
 -- : MTYPES = material ()
 -- : REFL_PROPS = material (MTYPE_STRING)
     Set reflectance properties for the lighting of surfaces and patches.

     This function changes the ambient, diffuse, and specular strengths, as well as the specular exponent and specular color reflectance, of all ‘patch’ and ‘surface’ objects in the current axes.  This can be used to simulate, to some extent, the reflectance properties of certain materials when used with ‘light’.

     When called with a string, the aforementioned properties are set according to the values in the following table:

      MTYPE                                                                                                                                                                                                         ambient- strength                                                                                                                                          diffuse- strength                                                                                                                                          specular- strength                                                                                                                                         specular- exponent                                                                                                                                         specular- color- reflectance
     -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      "shiny"                                                                                                                                                                                                       0.3                                                                                                                                                        0.6                                                                                                                                                        0.9                                                                                                                                                        20                                                                                                                                                         1.0
      "dull"                                                                                                                                                                                                        0.3                                                                                                                                                        0.8                                                                                                                                                        0.0                                                                                                                                                        10                                                                                                                                                         1.0
      "metal"                                                                                                                                                                                                       0.3                                                                                                                                                        0.3                                                                                                                                                        1.0                                                                                                                                                        25                                                                                                                                                         0.5
      "default"                                                                                                                                                                                                     "default"                                                                                                                                                  "default"                                                                                                                                                  "default"                                                                                                                                                  "default"                                                                                                                                                  "default"

     When called with a vector of three elements, the ambient, diffuse, and specular strengths of all ‘patch’ and ‘surface’ objects in the current axes are updated.  An optional fourth vector element updates the specular exponent, and an optional fifth vector element updates the specular color reflectance.

     A list of graphic handles can also be passed as the first argument.  In this case, the properties of these handles and all child ‘patch’ and ‘surface’ objects will be updated.

     Additionally, ‘material’ can be called with a single output argument.  If called without input arguments, a column cell vector MTYPES with the strings for all available materials is returned.  If the one input argument MTYPE_STRING is the name of a material, a 1x5 cell vector REFL_PROPS with the reflectance properties of that material is returned.  In both cases, no graphic properties are changed.

     See also: light, fill, mesh, patch, pcolor, surf, surface.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Set reflectance properties for the lighting of surfaces and patches.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
orient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 966
 -- : orient (ORIENTATION)
 -- : orient (HFIG, ORIENTATION)
 -- : ORIENTATION = orient ()
 -- : ORIENTATION = orient (HFIG)
     Query or set the print orientation for figure HFIG.

     Valid values for ORIENTATION are "portrait", "landscape", and "tall".

     The "landscape" option changes the orientation so the plot width is larger than the plot height.  The "paperposition" is also modified so that the plot fills the page, while leaving a 0.25 inch border.

     The "tall" option sets the orientation to "portrait" and fills the page with the plot, while leaving a 0.25 inch border.

     The "portrait" option (default) changes the orientation so the plot height is larger than the plot width.  It also restores the default "paperposition" property.

     When called with no arguments, return the current print orientation.

     If the argument HFIG is omitted, then operate on the current figure returned by ‘gcf’.

     See also: print, saveas.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Query or set the print orientation for figure HFIG.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pbaspect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- : PLOT_BOX_ASPECT_RATIO = pbaspect ( )
 -- : pbaspect (PLOT_BOX_ASPECT_RATIO)
 -- : pbaspect (MODE)
 -- : PLOT_BOX_ASPECT_RATIO_MODE = pbaspect ("mode")
 -- : pbaspect (HAX, ...)

     Query or set the plot box aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the rendered lengths of the x, y, and z axes.

     ‘pbaspect(MODE)’

     Set the plot box aspect ratio mode of the current axes.  MODE is either "auto" or "manual".

     ‘pbaspect ("mode")’

     Return the plot box aspect ratio mode of the current axes.

     ‘pbaspect (HAX, ...)’

     Operate on the axes in handle HAX instead of the current axes.

     See also: axis, daspect, xlim, ylim, zlim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the plot box aspect ratio of the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rticks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 906
 -- : TICKVAL = rticks
 -- : rticks (TICKVAL)
 -- : ... = rticks (HAX, ...)
     Query or set the tick values on the r-axis of the current axis.

     When called without argument, return the current tick locations as specified in the "rtick" axes property.  These locations can be changed by calling ‘rticks’ with a vector of tick values.  Note: ascending order is not required.

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘rticks’ to set a property value will result in an error.

     NOTE: Octave does not currently implement polaraxes objects.  It is therefore not possible to query or set a "mode" for the "rtick" property as can be done with the equivalent functions for X, Y, and Z axes.

     See also: thetaticks, xticks, yticks, zticks, polar, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick values on the r-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
shading


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 590
 -- : shading (TYPE)
 -- : shading (HAX, TYPE)
     Set the shading of patch or surface graphic objects.

     Valid arguments for TYPE are

     "flat"
          Single colored patches with invisible edges.

     "faceted"
          Single colored patches with black edges.

     "interp"
          Colors between patch vertices are interpolated and the patch edges are invisible.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: fill, mesh, patch, pcolor, surf, surface, hidden, lighting.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Set the shading of patch or surface graphic objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
specular


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- : specular (SX, SY, SZ, LV, VV)
 -- : specular (SX, SY, SZ, LV, VV, SE)
     Calculate the specular reflection strength of a surface defined by the normal vector elements SX, SY, SZ using Phong’s approximation.

     The light source location and viewer location vectors are specified using parameters LV and VV respectively.  The location vectors can given as 2-element vectors [azimuth, elevation] in degrees or as 3-element vectors [x, y, z].

     An optional sixth argument specifies the specular exponent (spread) SE.  If not given, SE defaults to 10.

     See also: diffuse, surfl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
Calculate the specular reflection strength of a surface defined by the normal vector elements SX, SY, SZ using Phong’s approximation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 698
 -- : text (X, Y, STRING)
 -- : text (X, Y, Z, STRING)
 -- : text (..., PROP, VAL, ...)
 -- : H = text (...)
     Create a text object with text STRING at position X, Y, (Z) on the current axes.

     Multiple locations can be specified if X, Y, (Z) are vectors.  Multiple strings can be specified with a character matrix or a cell array of strings.

     Optional property/value pairs may be used to control the appearance of the text.

     The optional return value H is a vector of graphics handles to the created text objects.

     Programming Note: The full list of properties is documented at *note Text Properties: Text Properties.

     See also: gtext, title, xlabel, ylabel, zlabel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a text object with text STRING at position X, Y, (Z) on the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
thetaticks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 930
 -- : TICKVAL = thetaticks
 -- : thetaticks (TICKVAL)
 -- : ... = thetaticks (HAX, ...)
     Query or set the tick values on the theta-axis of the current axis.

     When called without argument, return the current tick locations as specified in the "ttick" axes property.  These locations can be changed by calling ‘thetaticks’ with a vector of tick values.  Note: ascending order is not required.

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘thetaticks’ to set a property value will result in an error.

     NOTE: Octave does not currently implement polaraxes objects.  It is therefore not possible to query or set a "mode" for the "thetatick" property as can be done with the equivalent functions for X, Y, and Z axes.

     See also: rticks, xticks, yticks, zticks, polar, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Query or set the tick values on the theta-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
title


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 544
 -- : title (STRING)
 -- : title (STRING, PROP, VAL, ...)
 -- : title (HAX, ...)
 -- : H = title (...)
     Specify the string used as a title for the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the appearance of the created title text object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created text object.

     See also: xlabel, ylabel, zlabel, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Specify the string used as a title for the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
view


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 853
 -- : view (AZIMUTH, ELEVATION)
 -- : view ([AZIMUTH ELEVATION])
 -- : view ([X Y Z])
 -- : view (2)
 -- : view (3)
 -- : view (HAX, ...)
 -- : [AZIMUTH, ELEVATION] = view ()
     Query or set the viewpoint for the current axes.

     The parameters AZIMUTH and ELEVATION can be given as two arguments or as 2-element vector.  The viewpoint can also be specified with Cartesian coordinates X, Y, and Z.

     The call ‘view (2)’ sets the viewpoint to AZIMUTH = 0 and ELEVATION = 90, which is the default for 2-D graphs.

     The call ‘view (3)’ sets the viewpoint to AZIMUTH = -37.5 and ELEVATION = 30, which is the default for 3-D graphs.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     If no inputs are given, return the current AZIMUTH and ELEVATION.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Query or set the viewpoint for the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
whitebg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1431
 -- : whitebg ()
 -- : whitebg (COLOR)
 -- : whitebg ("none")
 -- : whitebg (HFIG)
 -- : whitebg (HFIG, COLOR)
 -- : whitebg (HFIG, "none")
     Invert the colors in the current color scheme.

     The root properties are also inverted such that all subsequent plots will use the new color scheme.

     If the optional argument COLOR is present then the background color is set to COLOR rather than inverted.  COLOR may be a string representing one of the eight known colors or an RGB triplet.  The special string argument "none" restores the plot to the factory default colors.

     If the first argument HFIG is a figure handle or list of figure handles, then operate on these figures rather than the current figure returned by ‘gcf’.  The root properties will not be changed unless 0 is in the list of figures.

     Programming Note: ‘whitebg’ operates by changing the color properties of the children of the specified figures.  Only objects with a single color are affected.  For example, a patch with a single "FaceColor" will be changed, but a patch with shading ("interp") will not be modified.  For inversion, the new color is simply the inversion in RGB space: ‘CNEW = [1-R 1-G 1-B]’.  When a color is specified, the axes and figure are set to the new color, and the color of child objects are then adjusted to have some contrast (visibility) against the new background.

     See also: reset, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Invert the colors in the current color scheme.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
xlabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 562
 -- : xlabel (STRING)
 -- : xlabel (STRING, PROPERTY, VAL, ...)
 -- : xlabel (HAX, ...)
 -- : H = xlabel (...)
     Specify the string used to label the x-axis of the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created text object.

     See also: ylabel, zlabel, datetick, title, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
xlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1174
 -- : XLIMITS = xlim ()
 -- : XMODE = xlim ("mode")
 -- : xlim ([X_LO X_HI])
 -- : xlim ("auto")
 -- : xlim ("manual")
 -- : xlim (HAX, ...)
     Query or set the limits of the x-axis for the current plot.

     Called without arguments ‘xlim’ returns the x-axis limits of the current plot.

     With the input query "mode", return the current x-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [X_LO X_HI], the limits of the x-axis are set to these values and the mode is set to "manual".  The special values -Inf and Inf can be used to indicate that either the lower axis limit or upper axis limit should be automatically calculated.

     The current plotting mode can be changed by using either "auto" or "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     Programming Note: The ‘xlim’ function operates by modifying the "xlim" and "xlimmode" properties of an axes object.  These properties can be directly inspected and altered with ‘get’/‘set’.

     See also: ylim, zlim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the x-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
xticks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1163
 -- : TICKVAL = xticks
 -- : MODE = xticks ("mode")
 -- : xticks (TICKVAL)
 -- : xticks ("auto")
 -- : xticks ("manual")
 -- : ... = xticks (HAX, ...)
     Query or set the tick values on the x-axis of the current axis.

     When called without an argument, return the current tick locations as specified in the "xtick" axes property.  These locations can be changed by calling ‘xticks’ with a vector of tick values.  Note: ascending order is not required.

     When called with argument "mode", ‘xticks’ returns the current value of the axes property "xtickmode".  This property can be changed by calling ‘xticks’ with either "auto" (algorithm determines tick positions) or "manual" (tick values remain fixed regardless of axes resizing or rotation).  Note: Specifying xtick values will also set the property "xtickmode" to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘xticks’ to set a property value will result in an error.

     See also: xticklabels, yticks, zticks, rticks, thetaticks, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick values on the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
xticklabels


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1350
 -- : TICKVAL = xticklabels
 -- : MODE = xticklabels ("mode")
 -- : xticklabels (TICKVAL)
 -- : xticklabels ("auto")
 -- : xticklabels ("manual")
 -- : ... = xticklabels (HAX, ...)
     Query or set the tick labels on the x-axis of the current axis.

     When called without an argument, return a cell array of strings of the current tick labels as specified in the "xticklabel" axes property.  These labels can be changed by calling ‘xticklabels’ with a cell array of strings.  Note: a vector of numbers will be mapped to a cell array of strings.  If fewer labels are specified than the current number of ticks, blank labels will be appended to the array.

     When called with argument "mode", ‘xticklabels’ returns the current value of the axes property "xticklabelmode".  This property can be changed by calling ‘xticklabels’ with either "auto" (algorithm determines tick labels) or "manual" (tick labels remain fixed).  Note: Specifying xticklabel values will also set the "xticklabelmode" and "xticks" properties to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘xticklabels’ to set a property value will result in an error.

     See also: xticks, yticklabels, zticklabels, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick labels on the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ylabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 624
 -- : ylabel (STRING)
 -- : ylabel (STRING, PROPERTY, VAL, ...)
 -- : ylabel (HAX, ...)
 -- : H = ylabel (...)
     Specify the string used to label the y-axis of the current axis.

     If HAX is specified then label the axis defined by HAX.

     An optional list of PROPERTY/VALUE pairs can be used to change the properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created text object.

     See also: xlabel, zlabel, datetick, title, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the y-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ylim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1174
 -- : YLIMITS = ylim ()
 -- : XMODE = ylim ("mode")
 -- : ylim ([Y_LO Y_HI])
 -- : ylim ("auto")
 -- : ylim ("manual")
 -- : ylim (HAX, ...)
     Query or set the limits of the y-axis for the current plot.

     Called without arguments ‘ylim’ returns the y-axis limits of the current plot.

     With the input query "mode", return the current y-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [Y_LO Y_HI], the limits of the y-axis are set to these values and the mode is set to "manual".  The special values -Inf and Inf can be used to indicate that either the lower axis limit or upper axis limit should be automatically calculated.

     The current plotting mode can be changed by using either "auto" or "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     Programming Note: The ‘ylim’ function operates by modifying the "ylim" and "ylimmode" properties of an axes object.  These properties can be directly inspected and altered with ‘get’/‘set’.

     See also: xlim, zlim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the y-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
yticks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1163
 -- : TICKVAL = yticks
 -- : MODE = yticks ("mode")
 -- : yticks (TICKVAL)
 -- : yticks ("auto")
 -- : yticks ("manual")
 -- : ... = yticks (HAX, ...)
     Query or set the tick values on the y-axis of the current axis.

     When called without an argument, return the current tick locations as specified in the "ytick" axes property.  These locations can be changed by calling ‘yticks’ with a vector of tick values.  Note: ascending order is not required.

     When called with argument "mode", ‘yticks’ returns the current value of the axes property "ytickmode".  This property can be changed by calling ‘yticks’ with either "auto" (algorithm determines tick positions) or "manual" (tick values remain fixed regardless of axes resizing or rotation).  Note: Specifying ytick values will also set the property "ytickmode" to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘yticks’ to set a property value will result in an error.

     See also: yticklabels, xticks, zticks, rticks, thetaticks, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick values on the y-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
yticklabels


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1350
 -- : TICKVAL = yticklabels
 -- : MODE = yticklabels ("mode")
 -- : yticklabels (TICKVAL)
 -- : yticklabels ("auto")
 -- : yticklabels ("manual")
 -- : ... = yticklabels (HAX, ...)
     Query or set the tick labels on the x-axis of the current axis.

     When called without an argument, return a cell array of strings of the current tick labels as specified in the "yticklabel" axes property.  These labels can be changed by calling ‘yticklabels’ with a cell array of strings.  Note: a vector of numbers will be mapped to a cell array of strings.  If fewer labels are specified than the current number of ticks, blank labels will be appended to the array.

     When called with argument "mode", ‘yticklabels’ returns the current value of the axes property "yticklabelmode".  This property can be changed by calling ‘yticklabels’ with either "auto" (algorithm determines tick labels) or "manual" (tick labels remain fixed).  Note: Specifying yticklabel values will also set the "yticklabelmode" and "yticks" properties to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘xticklabels’ to set a property value will result in an error.

     See also: yticks, xticklabels, zticklabels, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick labels on the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zlabel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 574
 -- : zlabel (STRING)
 -- : zlabel (STRING, PROPERTY, VAL, ...)
 -- : zlabel (HAX, ...)
 -- : H = zlabel (...)
     Specify the string used to label the z-axis of the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created text object.

     See also: xlabel, ylabel, datetick, title, text.
   Author: jwe 


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Specify the string used to label the z-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
zlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1174
 -- : ZLIMITS = zlim ()
 -- : XMODE = zlim ("mode")
 -- : zlim ([Z_LO Z_HI])
 -- : zlim ("auto")
 -- : zlim ("manual")
 -- : zlim (HAX, ...)
     Query or set the limits of the z-axis for the current plot.

     Called without arguments ‘zlim’ returns the z-axis limits of the current plot.

     With the input query "mode", return the current z-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [Z_LO Z_HI], the limits of the z-axis are set to these values and the mode is set to "manual".  The special values -Inf and Inf can be used to indicate that either the lower axis limit or upper axis limit should be automatically calculated.

     The current plotting mode can be changed by using either "auto" or "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     Programming Note: The ‘zlim’ function operates by modifying the "zlim" and "zlimmode" properties of an axes object.  These properties can be directly inspected and altered with ‘get’/‘set’.

     See also: xlim, ylim, axis, set, get, gca.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Query or set the limits of the z-axis for the current plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zticks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1163
 -- : TICKVAL = zticks
 -- : MODE = zticks ("mode")
 -- : zticks (TICKVAL)
 -- : zticks ("auto")
 -- : zticks ("manual")
 -- : ... = zticks (HAX, ...)
     Query or set the tick values on the z-axis of the current axis.

     When called without an argument, return the current tick locations as specified in the "ztick" axes property.  These locations can be changed by calling ‘zticks’ with a vector of tick values.  Note: ascending order is not required.

     When called with argument "mode", ‘zticks’ returns the current value of the axes property "ztickmode".  This property can be changed by calling ‘zticks’ with either "auto" (algorithm determines tick positions) or "manual" (tick values remain fixed regardless of axes resizing or rotation).  Note: Specifying ztick values will also set the property "ztickmode" to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘zticks’ to set a property value will result in an error.

     See also: zticklabels, xticks, yticks, rticks, thetaticks, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick values on the z-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
zticklabels


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1350
 -- : TICKVAL = zticklabels
 -- : MODE = zticklabels ("mode")
 -- : zticklabels (TICKVAL)
 -- : zticklabels ("auto")
 -- : zticklabels ("manual")
 -- : ... = zticklabels (HAX, ...)
     Query or set the tick labels on the x-axis of the current axis.

     When called without an argument, return a cell array of strings of the current tick labels as specified in the "zticklabel" axes property.  These labels can be changed by calling ‘zticklabels’ with a cell array of strings.  Note: a vector of numbers will be mapped to a cell array of strings.  If fewer labels are specified than the current number of ticks, blank labels will be appended to the array.

     When called with argument "mode", ‘zticklabels’ returns the current value of the axes property "zticklabelmode".  This property can be changed by calling ‘zticklabels’ with either "auto" (algorithm determines tick labels) or "manual" (tick labels remain fixed).  Note: Specifying zticklabel values will also set the "zticklabelmode" and "zticks" properties to "manual".

     If the first argument HAX is an axes handle, then operate on this axis rather than the current axes returned by ‘gca’.

     Requesting a return value when calling ‘xticklabels’ to set a property value will result in an error.

     See also: zticks, xticklabels, zticklabels, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Query or set the tick labels on the x-axis of the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
area


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1240
 -- : area (Y)
 -- : area (X, Y)
 -- : area (..., LVL)
 -- : area (..., PROP, VAL, ...)
 -- : area (HAX, ...)
 -- : H = area (...)
     Area plot of the columns of Y.

     This plot shows the contributions of each column value to the row sum.  It is functionally similar to ‘plot (X, cumsum (Y, 2))’, except that the area under the curve is shaded.

     If the X argument is omitted it defaults to ‘1:rows (Y)’.  A value LVL can be defined that determines where the base level of the shading under the curve should be defined.  The default level is 0.

     Additional property/value pairs are passed directly to the underlying patch object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the hggroup object comprising the area patch objects.  The "BaseValue" property of the hggroup can be used to adjust the level where shading begins.

     Example: Verify identity sin^2 + cos^2 = 1

          t = linspace (0, 2*pi, 100)';
          y = [sin(t).^2, cos(t).^2];
          area (t, y);
          legend ("sin^2", "cos^2", "location", "NorthEastOutside");

     See also: plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Area plot of the columns of Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
bar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2480
 -- : bar (Y)
 -- : bar (X, Y)
 -- : bar (..., W)
 -- : bar (..., STYLE)
 -- : bar (..., PROP, VAL, ...)
 -- : bar (HAX, ...)
 -- : H = bar (..., PROP, VAL, ...)
     Produce a bar graph from two vectors of X-Y data.

     If only one argument is given, Y, it is taken as a vector of Y values and the X coordinates are the range ‘1:numel (Y)’.

     The optional input W controls the width of the bars.  A value of 1.0 will cause each bar to exactly touch any adjacent bars.  The default width is 0.8.

     If Y is a matrix, then each column of Y is taken to be a separate bar graph plotted on the same graph.  By default the columns are plotted side-by-side.  This behavior can be changed by the STYLE argument which can take the following values:

     "grouped" (default)
          Side-by-side bars with a gap between bars and centered over the X-coordinate.

     "stacked"
          Bars are stacked so that each X value has a single bar composed of multiple segments.

     "hist"
          Side-by-side bars with no gap between bars and centered over the X-coordinate.

     "histc"
          Side-by-side bars with no gap between bars and left-aligned to the X-coordinate.

     Optional property/value pairs are passed directly to the underlying patch objects.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of handles to the created "bar series" hggroups with one handle per column of the variable Y.  This series makes it possible to change a common element in one bar series object and have the change reflected in the other "bar series".  For example,

          h = bar (rand (5, 10));
          set (h(1), "basevalue", 0.5);

     changes the position on the base of all of the bar series.

     The following example modifies the face and edge colors using property/value pairs.

          bar (randn (1, 100), "facecolor", "r", "edgecolor", "b");

     The color of the bars is taken from the figure’s colormap, such that

          bar (rand (10, 3));
          colormap (summer (64));

     will change the colors used for the bars.  The color of bars can also be set manually using the "facecolor" property as shown below.

          h = bar (rand (10, 3));
          set (h(1), "facecolor", "r")
          set (h(2), "facecolor", "g")
          set (h(3), "facecolor", "b")

     See also: barh, hist, pie, plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Produce a bar graph from two vectors of X-Y data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
barh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1627
 -- : barh (Y)
 -- : barh (X, Y)
 -- : barh (..., W)
 -- : barh (..., STYLE)
 -- : barh (..., PROP, VAL, ...)
 -- : barh (HAX, ...)
 -- : H = barh (..., PROP, VAL, ...)
     Produce a horizontal bar graph from two vectors of X-Y data.

     If only one argument is given, it is taken as a vector of Y values and the X coordinates are the range ‘1:numel (Y)’.

     The optional input W controls the width of the bars.  A value of 1.0 will cause each bar to exactly touch any adjacent bars.  The default width is 0.8.

     If Y is a matrix, then each column of Y is taken to be a separate bar graph plotted on the same graph.  By default the columns are plotted side-by-side.  This behavior can be changed by the STYLE argument which can take the following values:

     "grouped" (default)
          Side-by-side bars with a gap between bars and centered over the Y-coordinate.

     "stacked"
          Bars are stacked so that each Y value has a single bar composed of multiple segments.

     "hist"
          Side-by-side bars with no gap between bars and centered over the Y-coordinate.

     "histc"
          Side-by-side bars with no gap between bars and left-aligned to the Y-coordinate.

     Optional property/value pairs are passed directly to the underlying patch objects.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created bar series hggroup.  For a description of the use of the bar series, *note bar: XREFbar.

     See also: bar, hist, pie, plot, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a horizontal bar graph from two vectors of X-Y data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
camlight


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1873
 -- : camlight
 -- : camlight right
 -- : camlight left
 -- : camlight headlight
 -- : camlight (AZ, EL)
 -- : camlight (..., STYLE)
 -- : camlight (HL, ...)
 -- : H = camlight (...)
     Add a light object to a figure using a simple interface.

     When called with no arguments, a light object is added to the current plot and is placed slightly above and to the right of the camera’s current position: this is equivalent to ‘camlight right’.  The commands ‘camlight left’ and ‘camlight headlight’ behave similarly with the placement being either left of the camera position or centered on the camera position.

     For more control, the light position can be specified by an azimuthal rotation AZ and an elevation angle EL, both in degrees, relative to the current properties of the camera.

     The optional string STYLE specifies whether the light is a local point source ("local", the default) or placed at infinite distance ("infinite").

     If the first argument HL is a handle to a light object, then act on this light object rather than creating a new object.

     The optional return value H is a graphics handle to the light object.  This can be used to move or further change properties of the light object.

     Examples:

     Add a light object to a plot

          sphere (36);
          camlight

     Position the light source exactly

          camlight (45, 30);

     Here the light is first pitched upwards (*note camup: XREFcamup.) from the camera position (*note campos: XREFcampos.) by 30 degrees.  It is then yawed by 45 degrees to the right.  Both rotations are centered around the camera target (*note camtarget: XREFcamtarget.).

     Return a handle to further manipulate the light object

          clf
          sphere (36);
          hl = camlight ("left");
          set (hl, "color", "r");

     See also: light.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Add a light object to a figure using a simple interface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colorbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2199
 -- : colorbar
 -- : colorbar (..., LOC)
 -- : colorbar (DELETE_OPTION)
 -- : colorbar (HCB, ...)
 -- : colorbar (HAX, ...)
 -- : colorbar (..., "peer", HAX, ...)
 -- : colorbar (..., "location", LOC, ...)
 -- : colorbar (..., PROP, VAL, ...)
 -- : H = colorbar (...)
     Add a colorbar to the current axes.

     A colorbar displays the current colormap along with numerical rulings so that the color scale can be interpreted.

     The optional input LOC determines the location of the colorbar.  If present, it must be the last argument to ‘colorbar’.  Valid values for LOC are

     "EastOutside"
          Place the colorbar outside the plot to the right.  This is the default.

     "East"
          Place the colorbar inside the plot to the right.

     "WestOutside"
          Place the colorbar outside the plot to the left.

     "West"
          Place the colorbar inside the plot to the left.

     "NorthOutside"
          Place the colorbar above the plot.

     "North"
          Place the colorbar at the top of the plot.

     "SouthOutside"
          Place the colorbar under the plot.

     "South"
          Place the colorbar at the bottom of the plot.

     To remove a colorbar from a plot use any one of the following keywords for the DELETE_OPTION: "off", "delete", "hide".

     If the first argument HAX is an axes handle, then the colorbar is added to this axes, rather than the current axes returned by ‘gca’.  Alternatively, If the argument "peer" is given, then the following argument is treated as the axes handle in which to add the colorbar.  The "peer" calling syntax may be removed in the future and is not recommended.

     If the first argument HCB is a handle to a colorbar object, then operate on this colorbar directly.

     Additional property/value pairs are passed directly to the underlying axes object.

     The optional return value H is a graphics handle to the created colorbar object.

     Implementation Note: A colorbar is created as an additional axes object with the "tag" property set to "colorbar".  The created object has the extra property "location" which controls the positioning of the colorbar.

     See also: colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Add a colorbar to the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
comet


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 580
 -- : comet (Y)
 -- : comet (X, Y)
 -- : comet (X, Y, P)
 -- : comet (HAX, ...)
     Produce a simple comet style animation along the trajectory provided by the input coordinate vectors (X, Y).

     If X is not specified it defaults to the indices of Y.

     The speed of the comet may be controlled by P, which represents the time each point is displayed before moving to the next one.  The default for P is 0.1 seconds.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: comet3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Produce a simple comet style animation along the trajectory provided by the input coordinate vectors (X, Y).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
comet3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- : comet3 (Z)
 -- : comet3 (X, Y, Z)
 -- : comet3 (X, Y, Z, P)
 -- : comet3 (HAX, ...)
     Produce a simple comet style animation along the trajectory provided by the input coordinate vectors (X, Y, Z).

     If only Z is specified then X, Y default to the indices of Z.

     The speed of the comet may be controlled by P, which represents the time each point is displayed before moving to the next one.  The default for P is 0.1 seconds.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: comet.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Produce a simple comet style animation along the trajectory provided by the input coordinate vectors (X, Y, Z).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
compass


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 911
 -- : compass (U, V)
 -- : compass (Z)
 -- : compass (..., STYLE)
 -- : compass (HAX, ...)
 -- : H = compass (...)

     Plot the ‘(U, V)’ components of a vector field emanating from the origin of a polar plot.

     The arrow representing each vector has one end at the origin and the tip at [U(i), V(i)].  If a single complex argument Z is given, then ‘U = real (Z)’ and ‘V = imag (Z)’.

     The style to use for the plot can be defined with a line style STYLE of the same format as the ‘plot’ command.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the line objects representing the drawn vectors.

          a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
          compass (eig (a));

     See also: polar, feather, quiver, rose, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Plot the ‘(U, V)’ components of a vector field emanating from the origin of a polar plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
contour


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1096
 -- : contour (Z)
 -- : contour (Z, VN)
 -- : contour (X, Y, Z)
 -- : contour (X, Y, Z, VN)
 -- : contour (..., STYLE)
 -- : contour (HAX, ...)
 -- : [C, H] = contour (...)
     Create a 2-D contour plot.

     Plot level curves (contour lines) of the matrix Z, using the contour matrix C computed by ‘contourc’ from the same arguments; see the latter for their interpretation.

     The appearance of contour lines can be defined with a line style STYLE in the same manner as ‘plot’.  Only line style and color are used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional output C contains the contour levels in ‘contourc’ format.

     The optional return value H is a graphics handle to the hggroup comprising the contour lines.

     Example:

          x = 0:2;
          y = x;
          z = x' * y;
          contour (x, y, z, 2:3)

     See also: ezcontour, contourc, contourf, contour3, clabel, meshc, surfc, caxis, colormap, plot.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create a 2-D contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contour3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1353
 -- : contour3 (Z)
 -- : contour3 (Z, VN)
 -- : contour3 (X, Y, Z)
 -- : contour3 (X, Y, Z, VN)
 -- : contour3 (..., STYLE)
 -- : contour3 (HAX, ...)
 -- : [C, H] = contour3 (...)
     Create a 3-D contour plot.

     ‘contour3’ plots level curves (contour lines) of the matrix Z at a Z level corresponding to each contour.  This is in contrast to ‘contour’ which plots all of the contour lines at the same Z level and produces a 2-D plot.

     The level curves are taken from the contour matrix C computed by ‘contourc’ for the same arguments; see the latter for their interpretation.

     The appearance of contour lines can be defined with a line style STYLE in the same manner as ‘plot’.  Only line style and color are used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional output C are the contour levels in ‘contourc’ format.

     The optional return value H is a graphics handle to the hggroup comprising the contour lines.

     Example:

          contour3 (peaks (19));
          colormap cool;
          hold on;
          surf (peaks (19), "facecolor", "none", "edgecolor", "black");

     See also: contour, contourc, contourf, clabel, meshc, surfc, caxis, colormap, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Create a 3-D contour plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contourc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1438
 -- : [C, LEV] = contourc (Z)
 -- : [C, LEV] = contourc (Z, VN)
 -- : [C, LEV] = contourc (X, Y, Z)
 -- : [C, LEV] = contourc (X, Y, Z, VN)
     Compute contour lines (isolines of constant Z value).

     The matrix Z contains height values above the rectangular grid determined by X and Y.  If only a single input Z is provided then X is taken to be ‘1:columns (Z)’ and Y is taken to be ‘1:rows (Z)’.

     The optional input VN is either a scalar denoting the number of contour lines to compute or a vector containing the Z values where lines will be computed.  When VN is a vector the number of contour lines is ‘numel (VN)’.  However, to compute a single contour line at a given value use ‘VN = [val, val]’.  If VN is omitted it defaults to 10.

     The return value C is a 2xN matrix containing the contour lines in the following format

          C = [lev1, x1, x2, ..., levn, x1, x2, ...
               len1, y1, y2, ..., lenn, y1, y2, ...]

     in which contour line N has a level (height) of LEVN and length of LENN.

     The optional return value LEV is a vector with the Z values of the contour levels.

     Example:

          x = 0:2;
          y = x;
          z = x' * y;
          contourc (x, y, z, 2:3)
             ⇒   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
                  2.0000   1.0000   2.0000   2.0000   2.0000   1.5000

     See also: contour, contourf, contour3, clabel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute contour lines (isolines of constant Z value).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contourf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1269
 -- : contourf (Z)
 -- : contourf (Z, VN)
 -- : contourf (X, Y, Z)
 -- : contourf (X, Y, Z, VN)
 -- : contourf (..., STYLE)
 -- : contourf (HAX, ...)
 -- : [C, H] = contourf (...)
     Create a 2-D contour plot with filled intervals.

     Plot level curves (contour lines) of the matrix Z and fill the region between lines with colors from the current colormap.

     The level curves are taken from the contour matrix C computed by ‘contourc’ for the same arguments; see the latter for their interpretation.

     The appearance of contour lines can be defined with a line style STYLE in the same manner as ‘plot’.  Only line style and color are used; Any markers defined by STYLE are ignored.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional output C contains the contour levels in ‘contourc’ format.

     The optional return value H is a graphics handle to the hggroup comprising the contour lines.

     The following example plots filled contours of the ‘peaks’ function.

          [x, y, z] = peaks (50);
          contourf (x, y, z, -7:9)

     See also: ezcontourf, contour, contourc, contour3, clabel, meshc, surfc, caxis, colormap, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Create a 2-D contour plot with filled intervals.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cylinder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 882
 -- : cylinder
 -- : cylinder (R)
 -- : cylinder (R, N)
 -- : cylinder (HAX, ...)
 -- : [X, Y, Z] = cylinder (...)
     Plot a 3-D unit cylinder.

     The optional input R is a vector specifying the radius along the unit z-axis.  The default is [1 1] indicating radius 1 at ‘Z == 0’ and at ‘Z == 1’.

     The optional input N determines the number of faces around the circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If outputs are requested ‘cylinder’ returns three matrices in ‘meshgrid’ format, such that ‘surf (X, Y, Z)’ generates a unit cylinder.

     Example:

          [x, y, z] = cylinder (10:-1:0, 50);
          surf (x, y, z);
          title ("a cone");

     See also: ellipsoid, rectangle, sphere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Plot a 3-D unit cylinder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ellipsoid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 -- : ellipsoid (XC, YC, ZC, XR, YR, ZR, N)
 -- : ellipsoid (..., N)
 -- : ellipsoid (HAX, ...)
 -- : [X, Y, Z] = ellipsoid (...)
     Plot a 3-D ellipsoid.

     The inputs XC, YC, ZC specify the center of the ellipsoid.  The inputs XR, YR, ZR specify the semi-major axis lengths.

     The optional input N determines the number of faces around the circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If outputs are requested ‘ellipsoid’ returns three matrices in ‘meshgrid’ format, such that ‘surf (X, Y, Z)’ generates the ellipsoid.

     See also: cylinder, rectangle, sphere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 3-D ellipsoid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
errorbar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4071
 -- : errorbar (Y, EY)
 -- : errorbar (Y, ..., FMT)
 -- : errorbar (X, Y, EY)
 -- : errorbar (X, Y, ERR, FMT)
 -- : errorbar (X, Y, LERR, UERR, FMT)
 -- : errorbar (X, Y, EX, EY, FMT)
 -- : errorbar (X, Y, LX, UX, LY, UY, FMT)
 -- : errorbar (X1, Y1, ..., FMT, XN, YN, ...)
 -- : errorbar (HAX, ...)
 -- : H = errorbar (...)
     Create a 2-D plot with errorbars.

     Many different combinations of arguments are possible.  The simplest form is

          errorbar (Y, EY)

     where the first argument is taken as the set of Y coordinates, the second argument EY are the errors around the Y values, and the X coordinates are taken to be the indices of the elements (‘1:numel (Y)’).

     The general form of the function is

          errorbar (X, Y, ERR1, ..., FMT, ...)

     After the X and Y arguments there can be 1, 2, or 4 parameters specifying the error values depending on the nature of the error values and the plot format FMT.

     ERR (scalar)
          When the error is a scalar all points share the same error value.  The errorbars are symmetric and are drawn from DATA-ERR to DATA+ERR.  The FMT argument determines whether ERR is in the x-direction, y-direction (default), or both.

     ERR (vector or matrix)
          Each data point has a particular error value.  The errorbars are symmetric and are drawn from DATA(n)-ERR(n) to DATA(n)+ERR(n).

     LERR, UERR (scalar)
          The errors have a single low-side value and a single upper-side value.  The errorbars are not symmetric and are drawn from DATA-LERR to DATA+UERR.

     LERR, UERR (vector or matrix)
          Each data point has a low-side error and an upper-side error.  The errorbars are not symmetric and are drawn from DATA(n)-LERR(n) to DATA(n)+UERR(n).

     Any number of data sets (X1,Y1, X2,Y2, ...) may appear as long as they are separated by a format string FMT.

     If Y is a matrix, X and the error parameters must also be matrices having the same dimensions.  The columns of Y are plotted versus the corresponding columns of X and errorbars are taken from the corresponding columns of the error parameters.

     If FMT is missing, the yerrorbars ("~") plot style is assumed.

     If the FMT argument is supplied then it is interpreted, as in normal plots, to specify the line style, marker, and color.  In addition, FMT may include an errorbar style which *must precede* the ordinary format codes.  The following errorbar styles are supported:

     ‘~’
          Set yerrorbars plot style (default).

     ‘>’
          Set xerrorbars plot style.

     ‘~>’
          Set xyerrorbars plot style.

     ‘#~’
          Set yboxes plot style.

     ‘#’
          Set xboxes plot style.

     ‘#~>’
          Set xyboxes plot style.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a handle to the hggroup object representing the data plot and errorbars.

     Note: For compatibility with MATLAB a line is drawn through all data points.  However, most scientific errorbar plots are a scatter plot of points with errorbars.  To accomplish this, add a marker style to the FMT argument such as ".".  Alternatively, remove the line by modifying the returned graphic handle with ‘set (h, "linestyle", "none")’.

     Examples:

          errorbar (X, Y, EX, ">.r")

     produces an xerrorbar plot of Y versus X with X errorbars drawn from X-EX to X+EX.  The marker "."  is used so no connecting line is drawn and the errorbars appear in red.

          errorbar (X, Y1, EY, "~",
                    X, Y2, LY, UY)

     produces yerrorbar plots with Y1 and Y2 versus X.  Errorbars for Y1 are drawn from Y1-EY to Y1+EY, errorbars for Y2 from Y2-LY to Y2+UY.

          errorbar (X, Y, LX, UX,
                    LY, UY, "~>")

     produces an xyerrorbar plot of Y versus X in which X errorbars are drawn from X-LX to X+UX and Y errorbars from Y-LY to Y+UY.

     See also: semilogxerr, semilogyerr, loglogerr, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Create a 2-D plot with errorbars.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ezcontour


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1041
 -- : ezcontour (F)
 -- : ezcontour (..., DOM)
 -- : ezcontour (..., N)
 -- : ezcontour (HAX, ...)
 -- : H = ezcontour (...)

     Plot the contour lines of a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontour (f, [-3, 3]);

     See also: contour, ezcontourf, ezplot, ezmeshc, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Plot the contour lines of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ezcontourf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1054
 -- : ezcontourf (F)
 -- : ezcontourf (..., DOM)
 -- : ezcontourf (..., N)
 -- : ezcontourf (HAX, ...)
 -- : H = ezcontourf (...)

     Plot the filled contour lines of a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontourf (f, [-3, 3]);

     See also: contourf, ezcontour, ezplot, ezmeshc, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Plot the filled contour lines of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1575
 -- : ezmesh (F)
 -- : ezmesh (FX, FY, FZ)
 -- : ezmesh (..., DOM)
 -- : ezmesh (..., N)
 -- : ezmesh (..., "circ")
 -- : ezmesh (HAX, ...)
 -- : H = ezmesh (...)

     Plot the mesh defined by a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If three functions are passed, then plot the parametrically defined function ‘[FX(S, T), FY(S, T), FZ(S, T)]’.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the argument "circ" is given, then the function is plotted over a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmesh (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: mesh, ezmeshc, ezplot, ezsurf, ezsurfc, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Plot the mesh defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezmeshc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1444
 -- : ezmeshc (F)
 -- : ezmeshc (FX, FY, FZ)
 -- : ezmeshc (..., DOM)
 -- : ezmeshc (..., N)
 -- : ezmeshc (..., "circ")
 -- : ezmeshc (HAX, ...)
 -- : H = ezmeshc (...)

     Plot the mesh and contour lines defined by a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If three functions are passed, then plot the parametrically defined function ‘[FX(S, T), FY(S, T), FZ(S, T)]’.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the argument "circ" is given, then the function is plotted over a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a 2-element vector with a graphics handle for the created mesh plot and a second handle for the created contour plot.

     Example: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmeshc (f, [-3, 3]);

     See also: meshc, ezmesh, ezplot, ezsurf, ezsurfc, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot the mesh and contour lines defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1508
 -- : ezplot (F)
 -- : ezplot (F2V)
 -- : ezplot (FX, FY)
 -- : ezplot (..., DOM)
 -- : ezplot (..., N)
 -- : ezplot (HAX, ...)
 -- : H = ezplot (...)

     Plot the 2-D curve defined by the function F.

     The function F may be a string, inline function, or function handle and can have either one or two variables.  If F has one variable, then the function is plotted over the domain ‘-2*pi < X < 2*pi’ with 500 points.

     If F2V is a function of two variables then the implicit function ‘F(X,Y) = 0’ is calculated over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     For example:

          ezplot (@(X, Y) X.^2 - Y.^2 - 1)

     If two functions are passed as inputs then the parametric function

          X = FX (T)
          Y = FY (T)

     is plotted over the domain ‘-2*pi <= T <= 2*pi’ with 500 points.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y, or T for a parametric plot.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in plotting the function.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the created line objects.

     See also: plot, ezplot3, ezpolar, ezcontour, ezcontourf, ezmesh, ezmeshc, ezsurf, ezsurfc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Plot the 2-D curve defined by the function F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezplot3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1074
 -- : ezplot3 (FX, FY, FZ)
 -- : ezplot3 (..., DOM)
 -- : ezplot3 (..., N)
 -- : ezplot3 (..., "animate")
 -- : ezplot3 (HAX, ...)
 -- : H = ezplot3 (...)

     Plot a parametrically defined curve in three dimensions.

     FX, FY, and FZ are strings, inline functions, or function handles with one argument defining the function.  By default the plot is over the domain ‘0 <= T <= 2*pi’ with 500 points.

     If DOM is a two element vector, it represents the minimum and maximum values of T.

     N is a scalar defining the number of points to use in plotting the function.

     If the "animate" option is given then the plotting is animated in the style of ‘comet3’.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

          fx = @(t) cos (t);
          fy = @(t) sin (t);
          fz = @(t) t;
          ezplot3 (fx, fy, fz, [0, 10*pi], 100);

     See also: plot3, comet3, ezplot, ezmesh, ezsurf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Plot a parametrically defined curve in three dimensions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezpolar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 881
 -- : ezpolar (F)
 -- : ezpolar (..., DOM)
 -- : ezpolar (..., N)
 -- : ezpolar (HAX, ...)
 -- : H = ezpolar (...)

     Plot a 2-D function in polar coordinates.

     The function F is a string, inline function, or function handle with a single argument.  The expected form of the function is ‘RHO = F(THETA)’.  By default the plot is over the domain ‘0 <= THETA <= 2*pi’ with 500 points.

     If DOM is a two element vector, it represents the minimum and maximum values of THETA.

     N is a scalar defining the number of points to use in plotting the function.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     Example:

          ezpolar (@(t) sin (5/4 * t), [0, 8*pi]);

     See also: polar, ezplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Plot a 2-D function in polar coordinates.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ezsurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1579
 -- : ezsurf (F)
 -- : ezsurf (FX, FY, FZ)
 -- : ezsurf (..., DOM)
 -- : ezsurf (..., N)
 -- : ezsurf (..., "circ")
 -- : ezsurf (HAX, ...)
 -- : H = ezsurf (...)

     Plot the surface defined by a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If three functions are passed, then plot the parametrically defined function ‘[FX(S, T), FY(S, T), FZ(S, T)]’.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the argument "circ" is given, then the function is plotted over a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurf (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: surf, ezsurfc, ezplot, ezmesh, ezmeshc, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Plot the surface defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ezsurfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1431
 -- : ezsurfc (F)
 -- : ezsurfc (FX, FY, FZ)
 -- : ezsurfc (..., DOM)
 -- : ezsurfc (..., N)
 -- : ezsurfc (..., "circ")
 -- : ezsurfc (HAX, ...)
 -- : H = ezsurfc (...)

     Plot the surface and contour lines defined by a function.

     F is a string, inline function, or function handle with two arguments defining the function.  By default the plot is over the meshed domain ‘-2*pi <= X | Y <= 2*pi’ with 60 points in each dimension.

     If three functions are passed, then plot the parametrically defined function ‘[FX(S, T), FY(S, T), FZ(S, T)]’.

     If DOM is a two element vector, it represents the minimum and maximum values of both X and Y.  If DOM is a four element vector, then the minimum and maximum values are ‘[xmin xmax ymin ymax]’.

     N is a scalar defining the number of points to use in each dimension.

     If the argument "circ" is given, then the function is plotted over a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a 2-element vector with a graphics handle for the created surface plot and a second handle for the created contour plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurfc (f, [-3, 3]);

     See also: surfc, ezsurf, ezplot, ezmesh, ezmeshc, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Plot the surface and contour lines defined by a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
feather


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 810
 -- : feather (U, V)
 -- : feather (Z)
 -- : feather (..., STYLE)
 -- : feather (HAX, ...)
 -- : H = feather (...)

     Plot the ‘(U, V)’ components of a vector field emanating from equidistant points on the x-axis.

     If a single complex argument Z is given, then ‘U = real (Z)’ and ‘V = imag (Z)’.

     The style to use for the plot can be defined with a line style STYLE of the same format as the ‘plot’ command.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the line objects representing the drawn vectors.

          phi = [0 : 15 : 360] * pi/180;
          feather (sin (phi), cos (phi));

     See also: plot, quiver, compass.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
Plot the ‘(U, V)’ components of a vector field emanating from equidistant points on the x-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1619
 -- : fill (X, Y, C)
 -- : fill (X1, Y1, C1, X2, Y2, C2)
 -- : fill (..., PROP, VAL)
 -- : fill (HAX, ...)
 -- : H = fill (...)
     Create one or more filled 2-D polygons.

     The inputs X and Y are the coordinates of the polygon vertices.  If the inputs are matrices then the rows represent different vertices and each column produces a different polygon.  ‘fill’ will close any open polygons before plotting.

     The input C determines the color of the polygon.  The simplest form is a single color specification such as a ‘plot’ format or an RGB-triple.  In this case the polygon(s) will have one unique color.  If C is a vector or matrix then the color data is first scaled using ‘caxis’ and then indexed into the current colormap.  A row vector will color each polygon (a column from matrices X and Y) with a single computed color.  A matrix C of the same size as X and Y will compute the color of each vertex and then interpolate the face color between the vertices.

     Multiple property/value pairs for the underlying patch object may be specified, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the created patch objects.

     Example: red square

          vertices = [0 0
                      1 0
                      1 1
                      0 1];
          fill (vertices(:,1), vertices(:,2), "r");
          axis ([-0.5 1.5, -0.5 1.5])
          axis equal

     See also: patch, caxis, colormap.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Create one or more filled 2-D polygons.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1842
 -- : fplot (FN, LIMITS)
 -- : fplot (..., TOL)
 -- : fplot (..., N)
 -- : fplot (..., FMT)
 -- : [X, Y] = fplot (...)
     Plot a function FN within the range defined by LIMITS.

     FN is a function handle, inline function, or string containing the name of the function to evaluate.

     The limits of the plot are of the form ‘[XLO, XHI]’ or ‘[XLO, XHI, YLO, YHI]’.

     The next three arguments are all optional and any number of them may be given in any order.

     TOL is the relative tolerance to use for the plot and defaults to 2e-3 (.2%).

     N is the minimum number of points to use.  When N is specified, the maximum stepsize will be ‘(XHI - XLO) / N’.  More than N points may still be used in order to meet the relative tolerance requirement.

     The FMT argument specifies the linestyle to be used by the plot command.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     With no output arguments the results are immediately plotted.  With two output arguments the 2-D plot data is returned.  The data can subsequently be plotted manually with ‘plot (X, Y)’.

     Example:

          fplot (@cos, [0, 2*pi])
          fplot ("[cos(x), sin(x)]", [0, 2*pi])

     Programming Notes:

     ‘fplot’ works best with continuous functions.  Functions with discontinuities are unlikely to plot well.  This restriction may be removed in the future.

     ‘fplot’ performance is better when the function accepts and returns a vector argument.  Consider this when writing user-defined functions and use element-by-element operators such as ‘.*’, ‘./’, etc.  See the function ‘vectorize’ for potentially converting inline or anonymous functions to vectorized versions.

     See also: ezplot, plot, vectorize.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot a function FN within the range defined by LIMITS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1685
 -- : hist (Y)
 -- : hist (Y, NBINS)
 -- : hist (Y, X)
 -- : hist (Y, X, NORM)
 -- : hist (..., PROP, VAL, ...)
 -- : hist (HAX, ...)
 -- : [NN, XX] = hist (...)
     Produce histogram counts or plots.

     With one vector input argument, Y, plot a histogram of the values with 10 bins.  The range of the histogram bins is determined by the range of the data (difference between maximum and minimum value in Y).  Extreme values are lumped into the first and last bins.  If Y is a matrix then plot a histogram where each bin contains one bar per input column of Y.

     If the optional second argument is a scalar, NBINS, it defines the number of bins.

     If the optional second argument is a vector, X, it defines the centers of the bins.  The width of the bins is determined from the adjacent values in the vector.  The total number of bins is ‘numel (X)’.

     If a third argument is provided, the histogram is normalized such that the sum of the bars is equal to NORM.

     The histogram’s appearance may be modified by specifying property/value pairs.  For example, the face and edge color may be modified:

          hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b");

     The histogram’s colors also depend upon the current colormap.

          hist (rand (10, 3));
          colormap (summer ());

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If an output is requested then no plot is made.  Instead, return the values NN (numbers of elements) and XX (bin centers) such that ‘bar (XX, NN)’ will plot the histogram.

     See also: histc, bar, pie, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Produce histogram counts or plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isocaps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2790
 -- : FVC = isocaps (V, ISOVAL)
 -- : FVC = isocaps (V)
 -- : FVC = isocaps (X, Y, Z, V, ISOVAL)
 -- : FVC = isocaps (X, Y, Z, V)
 -- : FVC = isocaps (..., WHICH_CAPS)
 -- : FVC = isocaps (..., WHICH_PLANE)
 -- : FVC = isocaps (..., "verbose")
 -- : [FACES, VERTICES, FVCDATA] = isocaps (...)
 -- : isocaps (...)

     Create end-caps for isosurfaces of 3-D data.

     This function places caps at the open ends of isosurfaces.

     The input argument V is a three-dimensional array that contains data sampled over a volume.

     The input ISOVAL is a scalar that specifies the value for the isosurface.  If ISOVAL is omitted or empty, a "good" value for an isosurface is determined from V.

     When called with a single output argument, ‘isocaps’ returns a structure array FVC with the fields: ‘faces’, ‘vertices’, and ‘facevertexcdata’.  The results are computed at the points ‘[X, Y, Z] = meshgrid (1:l, 1:m, 1:n)’ where ‘[l, m, n] = size (V)’.  The output FVC can be used directly as input to the ‘patch’ function.

     If called with additional input arguments X, Y, and Z that are three-dimensional arrays with the same size as V or vectors with lengths corresponding to the dimensions of V, then the volume data is taken at the specified points.  If X, Y, or Z are empty, the grid corresponds to the indices (‘1:n’) in the respective direction (*note meshgrid: XREFmeshgrid.).

     The optional parameter WHICH_CAPS can have one of the following string values which defines how the data will be enclosed:

     "above", "a" (default)
          for end-caps that enclose the data above ISOVAL.

     "below", "b"
          for end-caps that enclose the data below ISOVAL.

     The optional parameter WHICH_PLANE can have one of the following string values to define which end-cap should be drawn:

     "all" (default)
          for all of the end-caps.

     "xmin"
          for end-caps at the lower x-plane of the data.

     "xmax"
          for end-caps at the upper x-plane of the data.

     "ymin"
          for end-caps at the lower y-plane of the data.

     "ymax"
          for end-caps at the upper y-plane of the data.

     "zmin"
          for end-caps at the lower z-plane of the data.

     "zmax"
          for end-caps at the upper z-plane of the data.

     The string input argument "verbose" is supported for MATLAB compatibility, but has no effect.

     If called with two or three output arguments, the data for faces FACES, vertices VERTICES, and the color data FACEVERTEXCDATA are returned in separate arrays instead of a single structure.

     If called with no output argument, the end-caps are drawn directly in the current figure with the ‘patch’ command.

     See also: isosurface, isonormals, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Create end-caps for isosurfaces of 3-D data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isocolors


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1393
 -- : CDAT = isocolors (C, V)
 -- : CDAT = isocolors (X, Y, Z, C, V)
 -- : CDAT = isocolors (X, Y, Z, R, G, B, V)
 -- : CDAT = isocolors (R, G, B, V)
 -- : CDAT = isocolors (..., P)
 -- : isocolors (...)

     Compute isosurface colors.

     If called with one output argument, and the first input argument C is a three-dimensional array that contains indexed color values, and the second input argument V are the vertices of an isosurface geometry, then return a matrix CDAT with color data information for the geometry at computed points ‘[x, y, z] = meshgrid (1:l, 1:m, 1:n)’.  The output argument CDAT can be used to manually set the "FaceVertexCData" property of an isosurface patch object.

     If called with additional input arguments X, Y and Z which are three-dimensional arrays of the same size as C then the color data is taken at those specified points.

     Instead of indexed color data C, ‘isocolors’ can also be called with RGB values R, G, B.  If input arguments X, Y, Z are not given then ‘meshgrid’ computed values are used.

     Optionally, a patch handle P can be given as the last input argument to all function call variations and the vertex data will be extracted from the isosurface patch object.  Finally, if no output argument is given then the colors of the patch given by the patch handle P are changed.

     See also: isosurface, isonormals.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Compute isosurface colors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isonormals


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1497
 -- : VN = isonormals (VAL, VERT)
 -- : VN = isonormals (VAL, HP)
 -- : VN = isonormals (X, Y, Z, VAL, VERT)
 -- : VN = isonormals (X, Y, Z, VAL, HP)
 -- : VN = isonormals (..., "negate")
 -- : isonormals (VAL, HP)
 -- : isonormals (X, Y, Z, VAL, HP)
 -- : isonormals (..., "negate")

     Calculate normals to an isosurface.

     The vertex normals VN are calculated from the gradient of the 3-dimensional array VAL (size: lxmxn) containing the data for an isosurface geometry.  The normals point towards smaller values in VAL.

     If called with one output argument VN, and the second input argument VERT holds the vertices of an isosurface, then the normals VN are calculated at the vertices VERT on a grid given by ‘[x, y, z] = meshgrid (1:l, 1:m, 1:n)’.  The output argument VN has the same size as VERT and can be used to set the "VertexNormals" property of the corresponding patch.

     If called with additional input arguments X, Y, and Z, which are 3-dimensional arrays with the same size as VAL, then the volume data is taken at these points.  Instead of the vertex data VERT, a patch handle HP can be passed to the function.

     If the last input argument is the string "negate", compute the reverse vector normals of an isosurface geometry (i.e., pointed towards larger values in VAL).

     If no output argument is given, the property "VertexNormals" of the patch associated with the patch handle HP is changed directly.

     See also: isosurface, isocolors, smooth3.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Calculate normals to an isosurface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isosurface


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4539
 -- : FV = isosurface (V, ISOVAL)
 -- : FV = isosurface (V)
 -- : FV = isosurface (X, Y, Z, V, ISOVAL)
 -- : FV = isosurface (X, Y, Z, V)
 -- : FVC = isosurface (..., COL)
 -- : FV = isosurface (..., "noshare")
 -- : FV = isosurface (..., "verbose")
 -- : [F, V] = isosurface (...)
 -- : [F, V, C] = isosurface (...)
 -- : isosurface (...)

     Calculate isosurface of 3-D volume data.

     An isosurface connects points with the same value and is analogous to a contour plot, but in three dimensions.

     The input argument V is a three-dimensional array that contains data sampled over a volume.

     The input ISOVAL is a scalar that specifies the value for the isosurface.  If ISOVAL is omitted or empty, a "good" value for an isosurface is determined from V.

     When called with a single output argument ‘isosurface’ returns a structure array FV that contains the fields FACES and VERTICES computed at the points ‘[X, Y, Z] = meshgrid (1:l, 1:m, 1:n)’ where ‘[l, m, n] = size (V)’.  The output FV can be used directly as input to the ‘patch’ function.

     If called with additional input arguments X, Y, and Z that are three-dimensional arrays with the same size as V or vectors with lengths corresponding to the dimensions of V, then the volume data is taken at the specified points.  If X, Y, or Z are empty, the grid corresponds to the indices (‘1:n’) in the respective direction (*note meshgrid: XREFmeshgrid.).

     The optional input argument COL, which is a three-dimensional array of the same size as V, specifies coloring of the isosurface.  The color data is interpolated, as necessary, to match ISOVAL.  The output structure array, in this case, has the additional field FACEVERTEXCDATA.

     If given the string input argument "noshare", vertices may be returned multiple times for different faces.  The default behavior is to eliminate vertices shared by adjacent faces with ‘unique’ which may be time consuming.

     The string input argument "verbose" is supported for MATLAB compatibility, but has no effect.

     Any string arguments must be passed after the other arguments.

     If called with two or three output arguments, return the information about the faces F, vertices V, and color data C as separate arrays instead of a single structure array.

     If called with no output argument, the isosurface geometry is directly plotted with the ‘patch’ command and a light object is added to the axes if not yet present.

     For example,

          [x, y, z] = meshgrid (1:5, 1:5, 1:5);
          v = rand (5, 5, 5);
          isosurface (x, y, z, v, .5);

     will directly draw a random isosurface geometry in a graphics window.

     An example of an isosurface geometry with different additional coloring:

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          v = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure ();

          subplot (2,2,1); view (-38, 20);
          [f, vert] = isosurface (x, y, z, v, iso);
          p = patch ("Faces", f, "Vertices", vert, "EdgeColor", "none");
          pbaspect ([1 1 1]);
          isonormals (x, y, z, v, p)
          set (p, "FaceColor", "green", "FaceLighting", "gouraud");
          light ("Position", [1 1 5]);

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", vert, "EdgeColor", "blue");
          pbaspect ([1 1 1]);
          isonormals (x, y, z, v, p)
          set (p, "FaceColor", "none", "EdgeLighting", "gouraud");
          light ("Position", [1 1 5]);

          subplot (2,2,3); view (-38, 20);
          [f, vert, c] = isosurface (x, y, z, v, iso, y);
          p = patch ("Faces", f, "Vertices", vert, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          pbaspect ([1 1 1]);
          isonormals (x, y, z, v, p)
          set (p, "FaceLighting", "gouraud");
          light ("Position", [1 1 5]);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", vert, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "blue");
          pbaspect ([1 1 1]);
          isonormals (x, y, z, v, p)
          set (p, "FaceLighting", "gouraud");
          light ("Position", [1 1 5]);

     See also: isonormals, isocolors, isocaps, smooth3, reducevolume, reducepatch, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Calculate isosurface of 3-D volume data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
light


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1825
 -- : light ()
 -- : light (..., "PROP", VAL, ...)
 -- : light (HAX, ...)
 -- : H = light (...)
     Create a light object in the current axes or for axes HAX.

     When a light object is present in an axes object, and the properties "EdgeLighting" or "FaceLighting" of a ‘patch’ or ‘surface’ object are set to a value other than "none", these objects are drawn with light and shadow effects.  Supported values for Lighting properties are "none" (no lighting effects), "flat" (faceted look of the objects), and "gouraud" (linear interpolation of the lighting effects between the vertices).  For ‘patch’ objects, the normals must be set manually (property "VertexNormals").

     Up to eight light objects are supported per axes.

     Lighting is only supported for OpenGL graphic toolkits (i.e., "fltk" and "qt").

     A light object has the following properties which alter the appearance of the plot.

     "Color": The color of the light can be passed as an
          RGB-vector (e.g., ‘[1 0 0]’ for red) or as a string (e.g., "r" for red).  The default color is white (‘[1 1 1]’).

     "Position": The direction from which the light emanates as a
          1x3-vector.  The default direction is ‘[1 0 1]’.

     "Style": This string defines whether the light emanates from a
          light source at infinite distance ("infinite") or from a local point source ("local").  The default is "infinite".

     If the first argument HAX is an axes handle, then add the light object to this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created light object.

     Programming Note: The full list of properties is documented at *note Light Properties: Light Properties.

     See also: lighting, material, patch, surface.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Create a light object in the current axes or for axes HAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
line


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808
 -- : line ()
 -- : line (X, Y)
 -- : line (X, Y, PROPERTY, VALUE, ...)
 -- : line (X, Y, Z)
 -- : line (X, Y, Z, PROPERTY, VALUE, ...)
 -- : line (PROPERTY, VALUE, ...)
 -- : line (HAX, ...)
 -- : H = line (...)
     Create line object from X and Y (and possibly Z) and insert in the current axes.

     Multiple property-value pairs may be specified for the line object, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle (or vector of handles) to the line objects created.

     Programming Note: The full list of properties is documented at *note Line Properties: Line Properties.

     See also: image, patch, rectangle, surface, text.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create line object from X and Y (and possibly Z) and insert in the current axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
loglog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 569
 -- : loglog (Y)
 -- : loglog (X, Y)
 -- : loglog (X, Y, PROP, VALUE, ...)
 -- : loglog (X, Y, FMT)
 -- : loglog (HAX, ...)
 -- : H = loglog (...)
     Produce a 2-D plot using logarithmic scales for both axes.

     See the documentation of ‘plot’ for a description of the arguments that ‘loglog’ will accept.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     See also: plot, semilogx, semilogy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Produce a 2-D plot using logarithmic scales for both axes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
loglogerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925
 -- : loglogerr (Y, EY)
 -- : loglogerr (Y, ..., FMT)
 -- : loglogerr (X, Y, EY)
 -- : loglogerr (X, Y, ERR, FMT)
 -- : loglogerr (X, Y, LERR, UERR, FMT)
 -- : loglogerr (X, Y, EX, EY, FMT)
 -- : loglogerr (X, Y, LX, UX, LY, UY, FMT)
 -- : loglogerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- : loglogerr (HAX, ...)
 -- : H = loglogerr (...)
     Produce 2-D plots on a double logarithm axis with errorbars.

     Many different combinations of arguments are possible.  The most common form is

          loglogerr (X, Y, EY, FMT)

     which produces a double logarithm plot of Y versus X with errors in the Y-scale defined by EY and the plot format defined by FMT.  *Note errorbar: XREFerrorbar, for available formats and additional information.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: errorbar, semilogxerr, semilogyerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce 2-D plots on a double logarithm axis with errorbars.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1335
 -- : mesh (X, Y, Z)
 -- : mesh (Z)
 -- : mesh (..., C)
 -- : mesh (..., PROP, VAL, ...)
 -- : mesh (HAX, ...)
 -- : H = mesh (...)
     Plot a 3-D wireframe mesh.

     The wireframe mesh is plotted using rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     See also: ezmesh, meshc, meshz, trimesh, contour, surf, surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot a 3-D wireframe mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
meshc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1418
 -- : meshc (X, Y, Z)
 -- : meshc (Z)
 -- : meshc (..., C)
 -- : meshc (..., PROP, VAL, ...)
 -- : meshc (HAX, ...)
 -- : H = meshc (...)
     Plot a 3-D wireframe mesh with underlying contour lines.

     The wireframe mesh is plotted using rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a 2-element vector with a graphics handle to the created surface object and to the created contour plot.

     See also: ezmeshc, mesh, meshz, contour, surfc, surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Plot a 3-D wireframe mesh with underlying contour lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
meshz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1360
 -- : meshz (X, Y, Z)
 -- : meshz (Z)
 -- : meshz (..., C)
 -- : meshz (..., PROP, VAL, ...)
 -- : meshz (HAX, ...)
 -- : H = meshz (...)
     Plot a 3-D wireframe mesh with a surrounding curtain.

     The wireframe mesh is plotted using rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     See also: mesh, meshc, contour, surf, surface, waterfall, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Plot a 3-D wireframe mesh with a surrounding curtain.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pareto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1666
 -- : pareto (Y)
 -- : pareto (Y, X)
 -- : pareto (HAX, ...)
 -- : H = pareto (...)
     Draw a Pareto chart.

     A Pareto chart is a bar graph that arranges information in such a way that priorities for process improvement can be established; It organizes and displays information to show the relative importance of data.  The chart is similar to the histogram or bar chart, except that the bars are arranged in decreasing magnitude from left to right along the x-axis.

     The fundamental idea (Pareto principle) behind the use of Pareto diagrams is that the majority of an effect is due to a small subset of the causes.  For quality improvement, the first few contributing causes (leftmost bars as presented on the diagram) to a problem usually account for the majority of the result.  Thus, targeting these "major causes" for elimination results in the most cost-effective improvement scheme.

     Typically only the magnitude data Y is present in which case X is taken to be the range ‘1 : length (Y)’.  If X is given it may be a string array, a cell array of strings, or a numerical vector.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a 2-element vector with a graphics handle for the created bar plot and a second handle for the created line plot.

     An example of the use of ‘pareto’ is

          Cheese = {"Cheddar", "Swiss", "Camembert", ...
                    "Munster", "Stilton", "Blue"};
          Sold = [105, 30, 70, 10, 15, 20];
          pareto (Sold, Cheese);

     See also: bar, barh, hist, pie, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Draw a Pareto chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
patch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2296
 -- : patch ()
 -- : patch (X, Y, C)
 -- : patch (X, Y, Z, C)
 -- : patch ("Faces", FACES, "Vertices", VERTS, ...)
 -- : patch (..., PROP, VAL, ...)
 -- : patch (..., PROPSTRUCT, ...)
 -- : patch (HAX, ...)
 -- : H = patch (...)
     Create patch object in the current axes with vertices at locations (X, Y) and of color C.

     If the vertices are matrices of size MxN then each polygon patch has M vertices and a total of N polygons will be created.  If some polygons do not have M vertices use NaN to represent "no vertex".  If the Z input is present then 3-D patches will be created.

     The color argument C can take many forms.  To create polygons which all share a single color use a string value (e.g., "r" for red), a scalar value which is scaled by ‘caxis’ and indexed into the current colormap, or a 3-element RGB vector with the precise TrueColor.

     If C is a vector of length N then the ith polygon will have a color determined by scaling entry C(i) according to ‘caxis’ and then indexing into the current colormap.  More complicated coloring situations require directly manipulating patch property/value pairs.

     Instead of specifying polygons by matrices X and Y, it is possible to present a unique list of vertices and then a list of polygon faces created from those vertices.  In this case the "Vertices" matrix will be an Nx2 (2-D patch) or Nx3 (3-D patch).  The MxN "Faces" matrix describes M polygons having N vertices—each row describes a single polygon and each column entry is an index into the "Vertices" matrix to identify a vertex.  The patch object can be created by directly passing the property/value pairs "Vertices"/VERTS, "Faces"/FACES as inputs.

     Instead of using property/value pairs, any property can be set by passing a structure PROPSTRUCT with the respective field names.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created patch object.

     Programming Note: The full list of properties is documented at *note Patch Properties: Patch Properties.  Useful patch properties include: "cdata", "edgecolor", "facecolor", "faces", and "facevertexcdata".

     See also: fill, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Create patch object in the current axes with vertices at locations (X, Y) and of color C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pcolor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1521
 -- : pcolor (X, Y, C)
 -- : pcolor (C)
 -- : pcolor (HAX, ...)
 -- : H = pcolor (...)
     Produce a 2-D density plot.

     A ‘pcolor’ plot draws rectangles with colors from the matrix C over the two-dimensional region represented by the matrices X and Y.  X and Y are the coordinates of the mesh’s vertices and are typically the output of ‘meshgrid’.  If X and Y are vectors, then a typical vertex is (X(j), Y(i), C(i,j)).  Thus, columns of C correspond to different X values and rows of C correspond to different Y values.

     The values in C are scaled to span the range of the current colormap.  Limits may be placed on the color axis by the command ‘caxis’, or by setting the ‘clim’ property of the parent axis.

     The face color of each cell of the mesh is determined by interpolating the values of C for each of the cell’s vertices; Contrast this with ‘imagesc’ which renders one cell for each element of C.

     ‘shading’ modifies an attribute determining the manner by which the face color of each cell is interpolated from the values of C, and the visibility of the cells’ edges.  By default the attribute is "faceted", which renders a single color for each cell’s face with the edge visible.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     See also: caxis, shading, meshgrid, contour, imagesc.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Produce a 2-D density plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
peaks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1007
 -- : peaks ()
 -- : peaks (N)
 -- : peaks (X, Y)
 -- : Z = peaks (...)
 -- : [X, Y, Z] = peaks (...)
     Plot a function with lots of local maxima and minima.

     The function has the form

     f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
              - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
              - 1/3*exp(-(x+1)^2 - y^2)

     Called without a return argument, ‘peaks’ plots the surface of the above function using ‘surf’.

     If N is a scalar, ‘peaks’ plots the value of the above function on an N-by-N mesh over the range [-3,3].  The default value for N is 49.

     If N is a vector, then it represents the grid values over which to calculate the function.  If X and Y are specified then the function value is calculated over the specified grid of vertices.

     When called with output arguments, return the data for the function evaluated over the meshgrid.  This can subsequently be plotted with ‘surf (X, Y, Z)’.

     See also: sombrero, meshgrid, mesh, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Plot a function with lots of local maxima and minima.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pie


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1156
 -- : pie (X)
 -- : pie (..., EXPLODE)
 -- : pie (..., LABELS)
 -- : pie (HAX, ...);
 -- : H = pie (...);
     Plot a 2-D pie chart.

     When called with a single vector argument, produce a pie chart of the elements in X.  The size of the ith slice is the percentage that the element Xi represents of the total sum of X: ‘pct = X(i) / sum (X)’.

     The optional input EXPLODE is a vector of the same length as X that, if nonzero, "explodes" the slice from the pie chart.

     The optional input LABELS is a cell array of strings of the same length as X specifying the label for each slice.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a list of handles to the patch and text objects generating the plot.

     Note: If ‘sum (X) ≤ 1’ then the elements of X are interpreted as percentages directly and are not normalized by ‘sum (x)’.  Furthermore, if the sum is less than 1 then there will be a missing slice in the pie plot to represent the missing, unspecified percentage.

     See also: pie3, bar, hist, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 2-D pie chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pie3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1179
 -- : pie3 (X)
 -- : pie3 (..., EXPLODE)
 -- : pie3 (..., LABELS)
 -- : pie3 (HAX, ...);
 -- : H = pie3 (...);
     Plot a 3-D pie chart.

     Called with a single vector argument, produces a 3-D pie chart of the elements in X.  The size of the ith slice is the percentage that the element Xi represents of the total sum of X: ‘pct = X(i) / sum (X)’.

     The optional input EXPLODE is a vector of the same length as X that, if nonzero, "explodes" the slice from the pie chart.

     The optional input LABELS is a cell array of strings of the same length as X specifying the label for each slice.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a list of graphics handles to the patch, surface, and text objects generating the plot.

     Note: If ‘sum (X) ≤ 1’ then the elements of X are interpreted as percentages directly and are not normalized by ‘sum (x)’.  Furthermore, if the sum is less than 1 then there will be a missing slice in the pie plot to represent the missing, unspecified percentage.

     See also: pie, bar, hist, rose.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Plot a 3-D pie chart.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
plot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6431
 -- : plot (Y)
 -- : plot (X, Y)
 -- : plot (X, Y, FMT)
 -- : plot (..., PROPERTY, VALUE, ...)
 -- : plot (X1, Y1, ..., XN, YN)
 -- : plot (HAX, ...)
 -- : H = plot (...)
     Produce 2-D plots.

     Many different combinations of arguments are possible.  The simplest form is

          plot (Y)

     where the argument is taken as the set of Y coordinates and the X coordinates are taken to be the range ‘1:numel (Y)’.

     If more than one argument is given, they are interpreted as

          plot (Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, FMT, ...)

     and so on.  Any number of argument sets may appear.  The X and Y values are interpreted as follows:

        • If a single data argument is supplied, it is taken as the set of Y coordinates and the X coordinates are taken to be the indices of the elements, starting with 1.

        • If X and Y are scalars, a single point is plotted.

        • ‘squeeze()’ is applied to arguments with more than two dimensions, but no more than two singleton dimensions.

        • If both arguments are vectors, the elements of Y are plotted versus the elements of X.

        • If X is a vector and Y is a matrix, then the columns (or rows) of Y are plotted versus X.  (using whichever combination matches, with columns tried first.)

        • If the X is a matrix and Y is a vector, Y is plotted versus the columns (or rows) of X.  (using whichever combination matches, with columns tried first.)

        • If both arguments are matrices, the columns of Y are plotted versus the columns of X.  In this case, both matrices must have the same number of rows and columns and no attempt is made to transpose the arguments to make the number of rows match.

     Multiple property-value pairs may be specified, but they must appear in pairs.  These arguments are applied to the line objects drawn by ‘plot’.  Useful properties to modify are "linestyle", "linewidth", "color", "marker", "markersize", "markeredgecolor", "markerfacecolor".  *Note Line Properties::.

     The FMT format argument can also be used to control the plot style.  It is a string composed of four optional parts: "<linestyle><marker><color><;displayname;>".  When a marker is specified, but no linestyle, only the markers are plotted.  Similarly, if a linestyle is specified, but no marker, then only lines are drawn.  If both are specified then lines and markers will be plotted.  If no FMT and no PROPERTY/VALUE pairs are given, then the default plot style is solid lines with no markers and the color determined by the "colororder" property of the current axes.

     Format arguments:

     linestyle

          ‘-’                                                           Use solid lines (default).
          ‘--’                                                          Use dashed lines.
          ‘:’                                                           Use dotted lines.
          ‘-.’                                                          Use dash-dotted lines.

     marker

          ‘+’                                                           crosshair
          ‘o’                                                           circle
          ‘*’                                                           star
          ‘.’                                                           point
          ‘x’                                                           cross
          ‘s’                                                           square
          ‘d’                                                           diamond
          ‘^’                                                           upward-facing triangle
          ‘v’                                                           downward-facing triangle
          ‘>’                                                           right-facing triangle
          ‘<’                                                           left-facing triangle
          ‘p’                                                           pentagram
          ‘h’                                                           hexagram

     color

          ‘k’                                                           blacK
          ‘r’                                                           Red
          ‘g’                                                           Green
          ‘b’                                                           Blue
          ‘y’                                                           Yellow
          ‘m’                                                           Magenta
          ‘c’                                                           Cyan
          ‘w’                                                           White

     ";displayname;"
          Here "displayname" is the label to use for the plot legend.

     The FMT argument may also be used to assign legend labels.  To do so, include the desired label between semicolons after the formatting sequence described above, e.g., "+b;Key Title;".  Note that the last semicolon is required and Octave will generate an error if it is left out.

     Here are some plot examples:

          plot (x, y, "or", x, y2, x, y3, "m", x, y4, "+")

     This command will plot ‘y’ with red circles, ‘y2’ with solid lines, ‘y3’ with solid magenta lines, and ‘y4’ with points displayed as ‘+’.

          plot (b, "*", "markersize", 10)

     This command will plot the data in the variable ‘b’, with points displayed as ‘*’ and a marker size of 10.

          t = 0:0.1:6.3;
          plot (t, cos(t), "-;cos(t);", t, sin(t), "-b;sin(t);");

     This will plot the cosine and sine functions and label them accordingly in the legend.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the created line objects.

     To save a plot, in one of several image formats such as PostScript or PNG, use the ‘print’ command.

     See also: axis, box, grid, hold, legend, title, xlabel, ylabel, xlim, ylim, ezplot, errorbar, fplot, line, plot3, polar, loglog, semilogx, semilogy, subplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Produce 2-D plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
plot3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2004
 -- : plot3 (X, Y, Z)
 -- : plot3 (X, Y, Z, PROP, VALUE, ...)
 -- : plot3 (X, Y, Z, FMT)
 -- : plot3 (X, CPLX)
 -- : plot3 (CPLX)
 -- : plot3 (HAX, ...)
 -- : H = plot3 (...)
     Produce 3-D plots.

     Many different combinations of arguments are possible.  The simplest form is

          plot3 (X, Y, Z)

     in which the arguments are taken to be the vertices of the points to be plotted in three dimensions.  If all arguments are vectors of the same length, then a single continuous line is drawn.  If all arguments are matrices, then each column of is treated as a separate line.  No attempt is made to transpose the arguments to make the number of rows match.

     If only two arguments are given, as

          plot3 (X, CPLX)

     the real and imaginary parts of the second argument are used as the Y and Z coordinates, respectively.

     If only one argument is given, as

          plot3 (CPLX)

     the real and imaginary parts of the argument are used as the Y and Z values, and they are plotted versus their index.

     Arguments may also be given in groups of three as

          plot3 (X1, Y1, Z1, X2, Y2, Z2, ...)

     in which each set of three arguments is treated as a separate line or set of lines in three dimensions.

     To plot multiple one- or two-argument groups, separate each group with an empty format string, as

          plot3 (X1, C1, "", C2, "", ...)

     Multiple property-value pairs may be specified which will affect the line objects drawn by ‘plot3’.  If the FMT argument is supplied it will format the line objects in the same manner as ‘plot’.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     Example:

          z = [0:0.05:5];
          plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
          plot3 (z, exp (2i*pi*z), ";complex sinusoid;");

     See also: ezplot3, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Produce 3-D plots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
plotmatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1399
 -- : plotmatrix (X, Y)
 -- : plotmatrix (X)
 -- : plotmatrix (..., STYLE)
 -- : plotmatrix (HAX, ...)
 -- : [H, AX, BIGAX, P, PAX] = plotmatrix (...)
     Scatter plot of the columns of one matrix against another.

     Given the arguments X and Y that have a matching number of rows, ‘plotmatrix’ plots a set of axes corresponding to

          plot (X(:, i), Y(:, j))

     When called with a single argument X this is equivalent to

          plotmatrix (X, X)

     except that the diagonal of the set of axes will be replaced with the histogram ‘hist (X(:, i))’.

     The marker to use can be changed with the STYLE argument, that is a string defining a marker in the same manner as the ‘plot’ command.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H provides handles to the individual graphics objects in the scatter plots, whereas AX returns the handles to the scatter plot axes objects.

     BIGAX is a hidden axes object that surrounds the other axes, such that the commands ‘xlabel’, ‘title’, etc., will be associated with this hidden axes.

     Finally, P returns the graphics objects associated with the histogram and PAX the corresponding axes objects.

     Example:

          plotmatrix (randn (100, 3), "g+")

     See also: scatter, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Scatter plot of the columns of one matrix against another.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
plotyy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1235
 -- : plotyy (X1, Y1, X2, Y2)
 -- : plotyy (..., FUN)
 -- : plotyy (..., FUN1, FUN2)
 -- : plotyy (HAX, ...)
 -- : [AX, H1, H2] = plotyy (...)
     Plot two sets of data with independent y-axes and a common x-axis.

     The arguments X1 and Y1 define the arguments for the first plot and X1 and Y2 for the second.

     By default the arguments are evaluated with ‘feval (@plot, X, Y)’.  However the type of plot can be modified with the FUN argument, in which case the plots are generated by ‘feval (FUN, X, Y)’.  FUN can be a function handle, an inline function, or a string of a function name.

     The function to use for each of the plots can be independently defined with FUN1 and FUN2.

     If the first argument HAX is an axes handle, then it defines the principal axes in which to plot the X1 and Y1 data.

     The return value AX is a vector with the axes handles of the two y-axes.  H1 and H2 are handles to the objects generated by the plot commands.

          x = 0:0.1:2*pi;
          y1 = sin (x);
          y2 = exp (x - 1);
          ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
          xlabel ("X");
          ylabel (ax(1), "Axis 1");
          ylabel (ax(2), "Axis 2");

     See also: plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Plot two sets of data with independent y-axes and a common x-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
polar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1242
 -- : polar (THETA, RHO)
 -- : polar (THETA, RHO, FMT)
 -- : polar (CPLX)
 -- : polar (CPLX, FMT)
 -- : polar (HAX, ...)
 -- : H = polar (...)
     Create a 2-D plot from polar coordinates THETA and RHO.

     If a single complex input CPLX is given then the real part is used for THETA and the imaginary part is used for RHO.

     The optional argument FMT specifies the line format in the same way as ‘plot’.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     Implementation Note: The polar axis is drawn using line and text objects encapsulated in an hggroup.  The hggroup properties are linked to the original axes object such that altering an appearance property, for example ‘fontname’, will update the polar axis.  Two new properties are added to the original axes–‘rtick’, ‘ttick’–which replace ‘xtick’, ‘ytick’.  The first is a list of tick locations in the radial (rho) direction; The second is a list of tick locations in the angular (theta) direction specified in degrees, i.e., in the range 0–359.

     See also: rose, compass, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Create a 2-D plot from polar coordinates THETA and RHO.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quiver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1708
 -- : quiver (U, V)
 -- : quiver (X, Y, U, V)
 -- : quiver (..., S)
 -- : quiver (..., STYLE)
 -- : quiver (..., "filled")
 -- : quiver (HAX, ...)
 -- : H = quiver (...)

     Plot a 2-D vector field with arrows.

     Plot the (U, V) components of a vector field at the grid points defined by (X, Y).  If the grid is uniform then X and Y can be specified as vectors and ‘meshgrid’ is used to create the 2-D grid.

     If X and Y are not given they are assumed to be ‘(1:M, 1:N)’ where ‘[M, N] = size (U)’.

     The optional input S is a scalar defining a scaling factor to use for the arrows of the field relative to the mesh spacing.  A value of 1.0 will result in the longest vector exactly filling one grid square.  A value of 0 disables all scaling.  The default value is 0.9.

     The style to use for the plot can be defined with a line style STYLE of the same format as the ‘plot’ command.  If a marker is specified then the markers are drawn at the origin of the vectors (which are the grid points defined by X and Y).  When a marker is specified, the arrowhead is not drawn.  If the argument "filled" is given then the markers are filled.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to a quiver object.  A quiver object regroups the components of the quiver plot (body, arrow, and marker), and allows them to be changed together.

     Example:

          [x, y] = meshgrid (1:2:20);
          h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
          set (h, "maxheadsize", 0.33);

     See also: quiver3, compass, feather, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Plot a 2-D vector field with arrows.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quiver3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1821
 -- : quiver3 (U, V, W)
 -- : quiver3 (X, Y, Z, U, V, W)
 -- : quiver3 (..., S)
 -- : quiver3 (..., STYLE)
 -- : quiver3 (..., "filled")
 -- : quiver3 (HAX, ...)
 -- : H = quiver3 (...)

     Plot a 3-D vector field with arrows.

     Plot the (U, V, W) components of a vector field at the grid points defined by (X, Y, Z).  If the grid is uniform then X, Y, and Z can be specified as vectors and ‘meshgrid’ is used to create the 3-D grid.

     If X, Y, and Z are not given they are assumed to be ‘(1:M, 1:N, 1:P)’ where ‘[M, N] = size (U)’ and ‘P = max (size (W))’.

     The optional input S is a scalar defining a scaling factor to use for the arrows of the field relative to the mesh spacing.  A value of 1.0 will result in the longest vector exactly filling one grid cube.  A value of 0 disables all scaling.  The default value is 0.9.

     The style to use for the plot can be defined with a line style STYLE of the same format as the ‘plot’ command.  If a marker is specified then the markers are drawn at the origin of the vectors (which are the grid points defined by X, Y, Z).  When a marker is specified, the arrowhead is not drawn.  If the argument "filled" is given then the markers are filled.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to a quiver object.  A quiver object regroups the components of the quiver plot (body, arrow, and marker), and allows them to be changed together.

          [x, y, z] = peaks (25);
          surf (x, y, z);
          hold on;
          [u, v, w] = surfnorm (x, y, z / 10);
          h = quiver3 (x, y, z, u, v, w);
          set (h, "maxheadsize", 0.33);

     See also: quiver, compass, feather, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Plot a 3-D vector field with arrows.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rectangle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1450
 -- : rectangle ()
 -- : rectangle (..., "Position", POS)
 -- : rectangle (..., "Curvature", CURV)
 -- : rectangle (..., "EdgeColor", EC)
 -- : rectangle (..., "FaceColor", FC)
 -- : rectangle (HAX, ...)
 -- : H = rectangle (...)
     Draw a rectangular patch defined by POS and CURV.

     The variable ‘POS(1:2)’ defines the lower left-hand corner of the patch and ‘POS(3:4)’ defines its width and height.  By default, the value of POS is ‘[0, 0, 1, 1]’.

     The variable CURV defines the curvature of the sides of the rectangle and may be a scalar or two-element vector with values between 0 and 1.  A value of 0 represents no curvature of the side, whereas a value of 1 means that the side is entirely curved into the arc of a circle.  If CURV is a two-element vector, then the first element is the curvature along the x-axis of the patch and the second along y-axis.

     If CURV is a scalar, it represents the curvature of the shorter of the two sides of the rectangle and the curvature of the other side is defined by

          min (pos(1:2)) / max (pos(1:2)) * curv

     Additional property/value pairs are passed to the underlying patch command.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created rectangle object.

     See also: patch, line, cylinder, ellipsoid, sphere.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Draw a rectangular patch defined by POS and CURV.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
reducepatch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2689
 -- : REDUCED_FV = reducepatch (FV)
 -- : REDUCED_FV = reducepatch (FACES, VERTICES)
 -- : REDUCED_FV = reducepatch (PATCH_HANDLE)
 -- : reducepatch (PATCH_HANDLE)
 -- : REDUCED_FV = reducepatch (..., REDUCTION_FACTOR)
 -- : REDUCED_FV = reducepatch (..., "fast")
 -- : REDUCED_FV = reducepatch (..., "verbose")
 -- : [REDUCED_FACES, REDUCES_VERTICES] = reducepatch (...)

     Reduce the number of faces and vertices in a patch object while retaining the overall shape of the patch.

     The input patch can be represented by a structure FV with the fields ‘faces’ and ‘vertices’, by two matrices FACES and VERTICES (see, e.g., the result of ‘isosurface’), or by a handle to a patch object PATCH_HANDLE (*note patch: XREFpatch.).

     The number of faces and vertices in the patch is reduced by iteratively collapsing the shortest edge of the patch to its midpoint (as discussed, e.g., here: <https://libigl.github.io/libigl/tutorial/tutorial.html#meshdecimation>).

     Currently, only patches consisting of triangles are supported.  The resulting patch also consists only of triangles.

     If ‘reducepatch’ is called with a handle to a valid patch PATCH_HANDLE, and without any output arguments, then the given patch is updated immediately.

     If the REDUCTION_FACTOR is omitted, the resulting structure REDUCED_FV includes approximately 50% of the faces of the original patch.  If REDUCTION_FACTOR is a fraction between 0 (excluded) and 1 (excluded), a patch with approximately the corresponding fraction of faces is determined.  If REDUCTION_FACTOR is an integer greater than or equal to 1, the resulting patch has approximately REDUCTION_FACTOR faces.  Depending on the geometry of the patch, the resulting number of faces can differ from the given value of REDUCTION_FACTOR.  This is especially true when many shared vertices are detected.

     For the reduction, it is necessary that vertices of touching faces are shared.  Shared vertices are detected automatically.  This detection can be skipped by passing the optional string argument "fast".

     With the optional string arguments "verbose", additional status messages are printed to the command window.

     Any string input arguments must be passed after all other arguments.

     If called with one output argument, the reduced faces and vertices are returned in a structure REDUCED_FV with the fields ‘faces’ and ‘vertices’ (see the one output option of ‘isosurface’).

     If called with two output arguments, the reduced faces and vertices are returned in two separate matrices REDUCED_FACES and REDUCED_VERTICES.

     See also: isosurface, isonormals, reducevolume, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Reduce the number of faces and vertices in a patch object while retaining the overall shape of the patch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
reducevolume


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1445
 -- : [NX, NY, NZ, NV] = reducevolume (V, R)
 -- : [NX, NY, NZ, NV] = reducevolume (X, Y, Z, V, R)
 -- : NV = reducevolume (...)

     Reduce the volume of the dataset in V according to the values in R.

     V is a matrix that is non-singleton in the first 3 dimensions.

     R can either be a vector of 3 elements representing the reduction factors in the x-, y-, and z-directions or a scalar, in which case the same reduction factor is used in all three dimensions.

     ‘reducevolume’ reduces the number of elements of V by taking only every R-th element in the respective dimension.

     Optionally, X, Y, and Z can be supplied to represent the set of coordinates of V.  They can either be matrices of the same size as V or vectors with sizes according to the dimensions of V, in which case they are expanded to matrices (*note meshgrid: XREFmeshgrid.).

     If ‘reducevolume’ is called with two arguments then X, Y, and Z are assumed to match the respective indices of V.

     The reduced matrix is returned in NV.

     Optionally, the reduced set of coordinates are returned in NX, NY, and NZ, respectively.

     Examples:

          V = reshape (1:6*8*4, [6 8 4]);
          NV = reducevolume (V, [4 3 2]);

          V = reshape (1:6*8*4, [6 8 4]);
          X = 1:3:24;  Y = -14:5:11;  Z = linspace (16, 18, 4);
          [NX, NY, NZ, NV] = reducevolume (X, Y, Z, V, [4 3 2]);

     See also: isosurface, isonormals.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Reduce the volume of the dataset in V according to the values in R.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ribbon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 766
 -- : ribbon (Y)
 -- : ribbon (X, Y)
 -- : ribbon (X, Y, WIDTH)
 -- : ribbon (HAX, ...)
 -- : H = ribbon (...)
     Draw a ribbon plot for the columns of Y vs.  X.

     If X is omitted, a vector containing the row numbers is assumed (‘1:rows (Y)’).  Alternatively, X can also be a vector with same number of elements as rows of Y in which case the same X is used for each column of Y.

     The optional parameter WIDTH specifies the width of a single ribbon (default is 0.75).

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the surface objects representing each ribbon.

     See also: surface, waterfall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Draw a ribbon plot for the columns of Y vs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1482
 -- : rose (TH)
 -- : rose (TH, NBINS)
 -- : rose (TH, BINS)
 -- : rose (HAX, ...)
 -- : H = rose (...)
 -- : [THOUT ROUT] = rose (...)
     Plot an angular histogram.

     With one vector argument, TH, plot the histogram with 20 angular bins.  If TH is a matrix then each column of TH produces a separate histogram.

     If NBINS is given and is a scalar, then the histogram is produced with NBIN bins.  If BINS is a vector, then the center of each bin is defined by the values in BINS and the number of bins is given by the number of elements in BINS.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a vector of graphics handles to the line objects representing each histogram.

     If two output arguments are requested then no plot is made and the polar vectors necessary to plot the histogram are returned instead.

     Example

          [th, r] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
          polar (th, r);

     Programming Note: When specifying bin centers with the BINS input, the edges for bins 2 to N-1 are spaced so that ‘BINS(i)’ is centered between the edges.  The final edge is drawn halfway between bin N and bin 1.  This guarantees that all input TH will be placed into one of the bins, but also means that for some combinations bin 1 and bin N may not be centered on the user’s given values.

     See also: hist, polar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot an angular histogram.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
scatter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1652
 -- : scatter (X, Y)
 -- : scatter (X, Y, S)
 -- : scatter (X, Y, S, C)
 -- : scatter (..., STYLE)
 -- : scatter (..., "filled")
 -- : scatter (..., PROP, VAL, ...)
 -- : scatter (HAX, ...)
 -- : H = scatter (...)
     Draw a 2-D scatter plot.

     A marker is plotted at each point defined by the coordinates in the vectors X and Y.

     The size of the markers is determined by S, which can be a scalar or a vector of the same length as X and Y.  If S is not given, or is an empty matrix, then a default value of 36 square points is used (The marker size itself is ‘sqrt (s)’).

     The color of the markers is determined by C, which can be a string defining a fixed color; a 3-element vector giving the red, green, and blue components of the color; a vector of the same length as X that gives a scaled index into the current colormap; or an Nx3 matrix defining the RGB color of each marker individually.

     The marker to use can be changed with the STYLE argument; it is a string defining a marker in the same manner as the ‘plot’ command.  If no marker is specified it defaults to "o" or circles.  If the argument "filled" is given then the markers are filled.

     Additional property/value pairs are passed directly to the underlying patch object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created scatter object.

     Example:

          x = randn (100, 1);
          y = randn (100, 1);
          scatter (x, y, [], sqrt (x.^2 + y.^2));

     See also: scatter3, patch, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Draw a 2-D scatter plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
scatter3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1596
 -- : scatter3 (X, Y, Z)
 -- : scatter3 (X, Y, Z, S)
 -- : scatter3 (X, Y, Z, S, C)
 -- : scatter3 (..., STYLE)
 -- : scatter3 (..., "filled")
 -- : scatter3 (..., PROP, VAL)
 -- : scatter3 (HAX, ...)
 -- : H = scatter3 (...)
     Draw a 3-D scatter plot.

     A marker is plotted at each point defined by the coordinates in the vectors X, Y, and Z.

     The size of the markers is determined by S, which can be a scalar or a vector of the same length as X, Y, and Z.  If S is not given, or is an empty matrix, then a default value of 8 points is used.

     The color of the markers is determined by C, which can be a string defining a fixed color; a 3-element vector giving the red, green, and blue components of the color; a vector of the same length as X that gives a scaled index into the current colormap; or an Nx3 matrix defining the RGB color of each marker individually.

     The marker to use can be changed with the STYLE argument, that is a string defining a marker in the same manner as the ‘plot’ command.  If no marker is specified it defaults to "o" or circles.  If the argument "filled" is given then the markers are filled.

     Additional property/value pairs are passed directly to the underlying patch object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the hggroup object representing the points.

          [x, y, z] = peaks (20);
          scatter3 (x(:), y(:), z(:), [], z(:));

     See also: scatter, patch, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Draw a 3-D scatter plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
semilogx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- : semilogx (Y)
 -- : semilogx (X, Y)
 -- : semilogx (X, Y, PROPERTY, VALUE, ...)
 -- : semilogx (X, Y, FMT)
 -- : semilogx (HAX, ...)
 -- : H = semilogx (...)
     Produce a 2-D plot using a logarithmic scale for the x-axis.

     See the documentation of ‘plot’ for a description of the arguments that ‘semilogx’ will accept.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     See also: plot, semilogy, loglog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a 2-D plot using a logarithmic scale for the x-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
semilogxerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 977
 -- : semilogxerr (Y, EY)
 -- : semilogxerr (Y, ..., FMT)
 -- : semilogxerr (X, Y, EY)
 -- : semilogxerr (X, Y, ERR, FMT)
 -- : semilogxerr (X, Y, LERR, UERR, FMT)
 -- : semilogxerr (X, Y, EX, EY, FMT)
 -- : semilogxerr (X, Y, LX, UX, LY, UY, FMT)
 -- : semilogxerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- : semilogxerr (HAX, ...)
 -- : H = semilogxerr (...)
     Produce 2-D plots using a logarithmic scale for the x-axis and errorbars at each data point.

     Many different combinations of arguments are possible.  The most common form is

          semilogxerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors in the Y-scale defined by EY and the plot format defined by FMT.  *Note errorbar: XREFerrorbar, for available formats and additional information.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: errorbar, semilogyerr, loglogerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Produce 2-D plots using a logarithmic scale for the x-axis and errorbars at each data point.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
semilogy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 585
 -- : semilogy (Y)
 -- : semilogy (X, Y)
 -- : semilogy (X, Y, PROPERTY, VALUE, ...)
 -- : semilogy (X, Y, FMT)
 -- : semilogy (H, ...)
 -- : H = semilogy (...)
     Produce a 2-D plot using a logarithmic scale for the y-axis.

     See the documentation of ‘plot’ for a description of the arguments that ‘semilogy’ will accept.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created plot.

     See also: plot, semilogx, loglog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Produce a 2-D plot using a logarithmic scale for the y-axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
semilogyerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 977
 -- : semilogyerr (Y, EY)
 -- : semilogyerr (Y, ..., FMT)
 -- : semilogyerr (X, Y, EY)
 -- : semilogyerr (X, Y, ERR, FMT)
 -- : semilogyerr (X, Y, LERR, UERR, FMT)
 -- : semilogyerr (X, Y, EX, EY, FMT)
 -- : semilogyerr (X, Y, LX, UX, LY, UY, FMT)
 -- : semilogyerr (X1, Y1, ..., FMT, XN, YN, ...)
 -- : semilogyerr (HAX, ...)
 -- : H = semilogyerr (...)
     Produce 2-D plots using a logarithmic scale for the y-axis and errorbars at each data point.

     Many different combinations of arguments are possible.  The most common form is

          semilogyerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors in the Y-scale defined by EY and the plot format defined by FMT.  *Note errorbar: XREFerrorbar, for available formats and additional information.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     See also: errorbar, semilogxerr, loglogerr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Produce 2-D plots using a logarithmic scale for the y-axis and errorbars at each data point.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
shrinkfaces


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1653
 -- : shrinkfaces (P, SF)
 -- : NFV = shrinkfaces (P, SF)
 -- : NFV = shrinkfaces (FV, SF)
 -- : NFV = shrinkfaces (F, V, SF)
 -- : [NF, NV] = shrinkfaces (...)

     Reduce the size of faces in a patch by the shrink factor SF.

     The patch object can be specified by a graphics handle (P), a patch structure (FV) with the fields "faces" and "vertices", or as two separate matrices (F, V) of faces and vertices.

     The shrink factor SF is a positive number specifying the percentage of the original area the new face will occupy.  If no factor is given the default is 0.3 (a reduction to 30% of the original size).  A factor greater than 1.0 will result in the expansion of faces.

     Given a patch handle as the first input argument and no output parameters, perform the shrinking of the patch faces in place and redraw the patch.

     If called with one output argument, return a structure with fields "faces", "vertices", and "facevertexcdata" containing the data after shrinking.  This structure can be used directly as an input argument to the ‘patch’ function.

     *Caution:*: Performing the shrink operation on faces which are not convex can lead to undesirable results.

     Example: a triangulated 3/4 circle and the corresponding shrunken version.

          [phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
          tri = delaunay (phi(:), r(:));
          v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
          clf ()
          p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
          fv = shrinkfaces (p);
          patch (fv)
          axis equal
          grid on

     See also: patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Reduce the size of faces in a patch by the shrink factor SF.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
slice


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1825
 -- : slice (X, Y, Z, V, SX, SY, SZ)
 -- : slice (X, Y, Z, V, XI, YI, ZI)
 -- : slice (V, SX, SY, SZ)
 -- : slice (V, XI, YI, ZI)
 -- : slice (..., METHOD)
 -- : slice (HAX, ...)
 -- : H = slice (...)
     Plot slices of 3-D data/scalar fields.

     Each element of the 3-dimensional array V represents a scalar value at a location given by the parameters X, Y, and Z.  The parameters X, X, and Z are either 3-dimensional arrays of the same size as the array V in the "meshgrid" format or vectors.  The parameters XI, etc. respect a similar format to X, etc., and they represent the points at which the array VI is interpolated using interp3.  The vectors SX, SY, and SZ contain points of orthogonal slices of the respective axes.

     If X, Y, Z are omitted, they are assumed to be ‘x = 1:size (V, 2)’, ‘y = 1:size (V, 1)’ and ‘z = 1:size (V, 3)’.

     METHOD is one of:

     "nearest"
          Return the nearest neighbor.

     "linear"
          Linear interpolation from nearest neighbors.

     "cubic"
          Cubic interpolation from four nearest neighbors (not implemented yet).

     "spline"
          Cubic spline interpolation—smooth first and second derivatives throughout the curve.

     The default method is "linear".

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Examples:

          [x, y, z] = meshgrid (linspace (-8, 8, 32));
          v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
          slice (x, y, z, v, [], 0, []);

          [xi, yi] = meshgrid (linspace (-7, 7));
          zi = xi + yi;
          slice (x, y, z, v, xi, yi, zi);

     See also: interp3, surface, pcolor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Plot slices of 3-D data/scalar fields.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
smooth3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1483
 -- : SMOOTHED_DATA = smooth3 (DATA)
 -- : SMOOTHED_DATA = smooth3 (DATA, METHOD)
 -- : SMOOTHED_DATA = smooth3 (DATA, METHOD, SZ)
 -- : SMOOTHED_DATA = smooth3 (DATA, METHOD, SZ, STD_DEV)
     Smooth values of 3-dimensional matrix DATA.

     This function can be used, for example, to reduce the impact of noise in DATA before calculating isosurfaces.

     DATA must be a non-singleton 3-dimensional matrix.  The smoothed data from this matrix is returned in SMOOTHED_DATA which is of the same size as DATA.

     The option input METHOD determines which convolution kernel is used for the smoothing process.  Possible choices:

     "box", "b" (default)
          to use a convolution kernel with sharp edges.

     "gaussian", "g"
          to use a convolution kernel that is represented by a non-correlated trivariate normal distribution function.

     SZ is either a vector of 3 elements representing the size of the convolution kernel in x-, y- and z-direction or a scalar, in which case the same size is used in all three dimensions.  The default value is 3.

     When METHOD is "gaussian", STD_DEV defines the standard deviation of the trivariate normal distribution function.  STD_DEV is either a vector of 3 elements representing the standard deviation of the Gaussian convolution kernel in x-, y- and z-directions or a scalar, in which case the same value is used in all three dimensions.  The default value is 0.65.

     See also: isosurface, isonormals, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Smooth values of 3-dimensional matrix DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sombrero


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 671
 -- : sombrero ()
 -- : sombrero (N)
 -- : Z = sombrero (...)
 -- : [X, Y, Z] = sombrero (...)
     Plot the familiar 3-D sombrero function.

     The function plotted is

          z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))

     Called without a return argument, ‘sombrero’ plots the surface of the above function over the meshgrid [-8,8] using ‘surf’.

     If N is a scalar the plot is made with N grid lines.  The default value for N is 41.

     When called with output arguments, return the data for the function evaluated over the meshgrid.  This can subsequently be plotted with ‘surf (X, Y, Z)’.

     See also: peaks, meshgrid, mesh, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Plot the familiar 3-D sombrero function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sphere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 714
 -- : sphere ()
 -- : sphere (N)
 -- : sphere (HAX, ...)
 -- : [X, Y, Z] = sphere (...)
     Plot a 3-D unit sphere.

     The optional input N determines the number of faces around the circumference of the sphere.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If outputs are requested ‘sphere’ returns three matrices in ‘meshgrid’ format such that ‘surf (X, Y, Z)’ generates a unit sphere.

     Example:

          [x, y, z] = sphere (40);
          surf (3*x, 3*y, 3*z);
          axis equal;
          title ("sphere of radius 3");

     See also: cylinder, ellipsoid, rectangle.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Plot a 3-D unit sphere.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stairs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1107
 -- : stairs (Y)
 -- : stairs (X, Y)
 -- : stairs (..., STYLE)
 -- : stairs (..., PROP, VAL, ...)
 -- : stairs (HAX, ...)
 -- : H = stairs (...)
 -- : [XSTEP, YSTEP] = stairs (...)
     Produce a stairstep plot.

     The arguments X and Y may be vectors or matrices.  If only one argument is given, it is taken as a vector of Y values and the X coordinates are taken to be the indices of the elements (‘X = 1:numel (Y)’).

     The style to use for the plot can be defined with a line style STYLE of the same format as the ‘plot’ command.

     Multiple property/value pairs may be specified, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If one output argument is requested, return a graphics handle to the created plot.  If two output arguments are specified, the data are generated but not plotted.  For example,

          stairs (x, y);

     and

          [xs, ys] = stairs (x, y);
          plot (xs, ys);

     are equivalent.

     See also: bar, hist, plot, stem.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Produce a stairstep plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2699
 -- : stem (Y)
 -- : stem (X, Y)
 -- : stem (..., LINESPEC)
 -- : stem (..., "filled")
 -- : stem (..., PROP, VAL, ...)
 -- : stem (HAX, ...)
 -- : H = stem (...)
     Plot a 2-D stem graph.

     If only one argument is given, it is taken as the y-values and the x-coordinates are taken from the indices of the elements.

     If Y is a matrix, then each column of the matrix is plotted as a separate stem graph.  In this case X can either be a vector, the same length as the number of rows in Y, or it can be a matrix of the same size as Y.

     The default color is "b" (blue), the default line style is "-", and the default marker is "o".  The line style can be altered by the LINESPEC argument in the same manner as the ‘plot’ command.  If the "filled" argument is present the markers at the top of the stems will be filled in.  For example,

          x = 1:10;
          y = 2*x;
          stem (x, y, "r");

     plots 10 stems with heights from 2 to 20 in red;

     Optional property/value pairs may be specified to control the appearance of the plot.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a handle to a "stem series" hggroup.  The single hggroup handle has all of the graphical elements comprising the plot as its children; This allows the properties of multiple graphics objects to be changed by modifying just a single property of the "stem series" hggroup.

     For example,

          x = [0:10]';
          y = [sin(x), cos(x)]
          h = stem (x, y);
          set (h(2), "color", "g");
          set (h(1), "basevalue", -1)

     changes the color of the second "stem series" and moves the base line of the first.

     Stem Series Properties

     linestyle
          The linestyle of the stem.  (Default: "-")

     linewidth
          The width of the stem.  (Default: 0.5)

     color
          The color of the stem, and if not separately specified, the marker.  (Default: "b" [blue])

     marker
          The marker symbol to use at the top of each stem.  (Default: "o")

     markeredgecolor
          The edge color of the marker.  (Default: "color" property)

     markerfacecolor
          The color to use for "filling" the marker.  (Default: "none" [unfilled])

     markersize
          The size of the marker.  (Default: 6)

     baseline
          The handle of the line object which implements the baseline.  Use ‘set’ with the returned handle to change graphic properties of the baseline.

     basevalue
          The y-value where the baseline is drawn.  (Default: 0)

     See also: stem3, bar, hist, plot, stairs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Plot a 2-D stem graph.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
stem3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1278
 -- : stem3 (X, Y, Z)
 -- : stem3 (..., LINESPEC)
 -- : stem3 (..., "filled")
 -- : stem3 (..., PROP, VAL, ...)
 -- : stem3 (HAX, ...)
 -- : H = stem3 (...)
     Plot a 3-D stem graph.

     Stems are drawn from the height Z to the location in the x-y plane determined by X and Y.  The default color is "b" (blue), the default line style is "-", and the default marker is "o".

     The line style can be altered by the LINESPEC argument in the same manner as the ‘plot’ command.  If the "filled" argument is present the markers at the top of the stems will be filled in.

     Optional property/value pairs may be specified to control the appearance of the plot.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a handle to the "stem series" hggroup containing the line and marker objects used for the plot.  *Note stem: XREFstem, for a description of the "stem series" object.

     Example:

          theta = 0:0.2:6;
          stem3 (cos (theta), sin (theta), theta);

     plots 31 stems with heights from 0 to 6 lying on a circle.

     Implementation Note: Color definitions with RGB-triples are not valid.

     See also: stem, bar, hist, plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Plot a 3-D stem graph.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
stemleaf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2454
 -- : stemleaf (X, CAPTION)
 -- : stemleaf (X, CAPTION, STEM_SZ)
 -- : PLOTSTR = stemleaf (...)
     Compute and display a stem and leaf plot of the vector X.

     The input X should be a vector of integers.  Any non-integer values will be converted to integer by ‘X = fix (X)’.  By default each element of X will be plotted with the last digit of the element as a leaf value and the remaining digits as the stem.  For example, 123 will be plotted with the stem ‘12’ and the leaf ‘3’.  The second argument, CAPTION, should be a character array which provides a description of the data.  It is included as a heading for the output.

     The optional input STEM_SZ sets the width of each stem.  The stem width is determined by ‘10^(STEM_SZ + 1)’.  The default stem width is 10.

     The output of ‘stemleaf’ is composed of two parts: a "Fenced Letter Display," followed by the stem-and-leaf plot itself.  The Fenced Letter Display is described in ‘Exploratory Data Analysis’.  Briefly, the entries are as shown:


                  Fenced Letter Display
          #% nx|___________________     nx = numel (x)
          M% mi|       md         |     mi median index, md median
          H% hi|hl              hu| hs  hi lower hinge index, hl,hu hinges,
          1    |x(1)         x(nx)|     hs h_spreadx(1), x(nx) first
                     _______            and last data value.
               ______|step |_______     step 1.5*h_spread
              f|ifl            ifh|     inner fence, lower and higher
               |nfl            nfh|     no.\ of data points within fences
              F|ofl            ofh|     outer fence, lower and higher
               |nFl            nFh|     no.\ of data points outside outer
                                        fences

     The stem-and-leaf plot shows on each line the stem value followed by the string made up of the leaf digits.  If the STEM_SZ is not 1 the successive leaf values are separated by ",".

     With no return argument, the plot is immediately displayed.  If an output argument is provided, the plot is returned as an array of strings.

     The leaf digits are not sorted.  If sorted leaf values are desired, use ‘XS = sort (X)’ before calling ‘stemleaf (XS)’.

     The stem and leaf plot and associated displays are described in: Chapter 3, ‘Exploratory Data Analysis’ by J. W. Tukey, Addison-Wesley, 1977.

     See also: hist, printd.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute and display a stem and leaf plot of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1511
 -- : surf (X, Y, Z)
 -- : surf (Z)
 -- : surf (..., C)
 -- : surf (..., PROP, VAL, ...)
 -- : surf (HAX, ...)
 -- : H = surf (...)
     Plot a 3-D surface mesh.

     The surface mesh is plotted using shaded rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Note: The exact appearance of the surface can be controlled with the ‘shading’ command or by using ‘set’ to control surface object properties.

     See also: ezsurf, surfc, surfl, surfnorm, trisurf, contour, mesh, surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Plot a 3-D surface mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
surface


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1066
 -- : surface (X, Y, Z, C)
 -- : surface (X, Y, Z)
 -- : surface (Z, C)
 -- : surface (Z)
 -- : surface (..., PROP, VAL, ...)
 -- : surface (HAX, ...)
 -- : H = surface (...)
     Create a surface graphic object given matrices X and Y from ‘meshgrid’ and a matrix of values Z corresponding to the X and Y coordinates of the surface.

     If X and Y are vectors, then a typical vertex is (X(j), Y(i), Z(i,j)).  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.  If only a single input Z is given then X is taken to be ‘1:columns (Z)’ and Y is ‘1:rows (Z)’.

     Any property/value input pairs are assigned to the surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Programming Note: The full list of properties is documented at *note Surface Properties: Surface Properties.

     See also: surf, mesh, patch, line.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
Create a surface graphic object given matrices X and Y from ‘meshgrid’ and a matrix of values Z corresponding to the X and Y coordinates of the surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
surfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1547
 -- : surfc (X, Y, Z)
 -- : surfc (Z)
 -- : surfc (..., C)
 -- : surfc (..., PROP, VAL, ...)
 -- : surfc (HAX, ...)
 -- : H = surfc (...)
     Plot a 3-D surface mesh with underlying contour lines.

     The surface mesh is plotted using shaded rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Note: The exact appearance of the surface can be controlled with the ‘shading’ command or by using ‘set’ to control surface object properties.

     See also: ezsurfc, surf, surfl, surfnorm, trisurf, contour, mesh, surface, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Plot a 3-D surface mesh with underlying contour lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
surfl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1919
 -- : surfl (Z)
 -- : surfl (X, Y, Z)
 -- : surfl (..., LSRC)
 -- : surfl (X, Y, Z, LSRC, P)
 -- : surfl (..., "cdata")
 -- : surfl (..., "light")
 -- : surfl (HAX, ...)
 -- : H = surfl (...)
     Plot a 3-D surface using shading based on various lighting models.

     The surface mesh is plotted using shaded rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The default lighting mode "cdata", changes the cdata property of the surface object to give the impression of a lighted surface.  *Warning:* The alternative mode "light" mode which creates a light object to illuminate the surface is not implemented (yet).

     The light source location can be specified using LSRC.  It can be given as a 2-element vector [azimuth, elevation] in degrees, or as a 3-element vector [lx, ly, lz].  The default value is rotated 45 degrees counterclockwise to the current view.

     The material properties of the surface can specified using a 4-element vector P = [AM D SP EXP] which defaults to P = [0.55 0.6 0.4 10].

     "AM" strength of ambient light

     "D" strength of diffuse reflection

     "SP" strength of specular reflection

     "EXP" specular exponent

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     Example:

          colormap (bone (64));
          surfl (peaks);
          shading interp;

     See also: diffuse, specular, surf, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Plot a 3-D surface using shading based on various lighting models.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
surfnorm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1790
 -- : surfnorm (X, Y, Z)
 -- : surfnorm (Z)
 -- : surfnorm (..., PROP, VAL, ...)
 -- : surfnorm (HAX, ...)
 -- : [NX, NY, NZ] = surfnorm (...)
     Find the vectors normal to a meshgridded surface.

     If X and Y are vectors, then a typical vertex is (X(j), Y(i), Z(i,j)).  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.  If only a single input Z is given then X is taken to be ‘1:columns (Z)’ and Y is ‘1:rows (Z)’.

     If no return arguments are requested, a surface plot with the normal vectors to the surface is plotted.

     Any property/value input pairs are assigned to the surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     If output arguments are requested then the components of the normal vectors are returned in NX, NY, and NZ and no plot is made.  The normal vectors are unnormalized (magnitude != 1).  To normalize, use

          len = sqrt (nx.^2 + ny.^2 + nz.^2);
          nx ./= len;  ny ./= len;  nz ./= len;

     An example of the use of ‘surfnorm’ is

          surfnorm (peaks (25));

     Algorithm: The normal vectors are calculated by taking the cross product of the diagonals of each of the quadrilateral faces in the meshgrid to find the normal vectors at the center of each face.  Next, for each meshgrid point the four nearest normal vectors are averaged to obtain the final normal to the surface at the meshgrid point.

     For surface objects, the "VertexNormals" property contains equivalent information, except possibly near the boundary of the surface where different interpolation schemes may yield slightly different values.

     See also: isonormals, quiver3, surf, meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Find the vectors normal to a meshgridded surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
tetramesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1265
 -- : tetramesh (T, X)
 -- : tetramesh (T, X, C)
 -- : tetramesh (..., PROPERTY, VAL, ...)
 -- : H = tetramesh (...)
     Display the tetrahedrons defined in the m-by-4 matrix T as 3-D patches.

     T is typically the output of a Delaunay triangulation of a 3-D set of points.  Every row of T contains four indices into the n-by-3 matrix X of the vertices of a tetrahedron.  Every row in X represents one point in 3-D space.

     The vector C specifies the color of each tetrahedron as an index into the current colormap.  The default value is 1:m where m is the number of tetrahedrons; the indices are scaled to map to the full range of the colormap.  If there are more tetrahedrons than colors in the colormap then the values in C are cyclically repeated.

     Calling ‘tetramesh (..., "property", "value", ...)’ passes all property/value pairs directly to the patch function as additional arguments.

     The optional return value H is a vector of patch handles where each handle represents one tetrahedron in the order given by T.  A typical use case for H is to turn the respective patch "visible" property "on" or "off".

     Type ‘demo tetramesh’ to see examples on using ‘tetramesh’.

     See also: trimesh, delaunay, delaunayn, patch.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Display the tetrahedrons defined in the m-by-4 matrix T as 3-D patches.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
trimesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1386
 -- : trimesh (TRI, X, Y, Z, C)
 -- : trimesh (TRI, X, Y, Z)
 -- : trimesh (TRI, X, Y)
 -- : trimesh (..., PROP, VAL, ...)
 -- : H = trimesh (...)
     Plot a 3-D triangular wireframe mesh.

     In contrast to ‘mesh’, which plots a mesh using rectangles, ‘trimesh’ plots the mesh using triangles.

     TRI is typically the output of a Delaunay triangulation over the grid of X, Y.  Every row of TRI represents one triangle and contains three indices into [X, Y] which are the vertices of the triangles in the x-y plane.  Z determines the height above the plane of each vertex.  If no Z input is given then the triangles are plotted as a 2-D figure.

     The color of the trimesh is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of Z by supplying C, which is a vector for colormap data, or a matrix with three columns for RGB data.  The number of colors specified in C must either equal the number of vertices in Z or the number of triangles in TRI.

     Any property/value pairs are passed directly to the underlying patch object.

     The optional return value H is a graphics handle to the created patch object.

     See also: mesh, tetramesh, triplot, trisurf, delaunay, patch, hidden.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Plot a 3-D triangular wireframe mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
triplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 608
 -- : triplot (TRI, X, Y)
 -- : triplot (TRI, X, Y, LINESPEC)
 -- : H = triplot (...)
     Plot a 2-D triangular mesh.

     TRI is typically the output of a Delaunay triangulation over the grid of X, Y.  Every row of TRI represents one triangle and contains three indices into [X, Y] which are the vertices of the triangles in the x-y plane.

     The linestyle to use for the plot can be defined with the argument LINESPEC of the same format as the ‘plot’ command.

     The optional return value H is a graphics handle to the created patch object.

     See also: plot, trimesh, trisurf, delaunay.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Plot a 2-D triangular mesh.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
trisurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1473
 -- : trisurf (TRI, X, Y, Z, C)
 -- : trisurf (TRI, X, Y, Z)
 -- : trisurf (..., PROP, VAL, ...)
 -- : H = trisurf (...)
     Plot a 3-D triangular surface.

     In contrast to ‘surf’, which plots a surface mesh using rectangles, ‘trisurf’ plots the mesh using triangles.

     TRI is typically the output of a Delaunay triangulation over the grid of X, Y.  Every row of TRI represents one triangle and contains three indices into [X, Y] which are the vertices of the triangles in the x-y plane.  Z determines the height above the plane of each vertex.

     The color of the trisurf is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently of Z by supplying C, which is a vector for colormap data, or a matrix with three columns for RGB data.  The number of colors specified in C must either equal the number of vertices in Z or the number of triangles in TRI.  When specifying the color at each vertex the triangle will be colored according to the color of the first vertex only (see patch documentation and the "FaceColor" property when set to "flat").

     Any property/value pairs are passed directly to the underlying patch object.

     The optional return value H is a graphics handle to the created patch object.

     See also: surf, triplot, trimesh, delaunay, patch, shading.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Plot a 3-D triangular surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
waterfall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1480
 -- : waterfall (X, Y, Z)
 -- : waterfall (Z)
 -- : waterfall (..., C)
 -- : waterfall (..., PROP, VAL, ...)
 -- : waterfall (HAX, ...)
 -- : H = waterfall (...)
     Plot a 3-D waterfall plot.

     A waterfall plot is similar to a ‘meshz’ plot except only mesh lines for the rows of Z (x-values) are shown.

     The wireframe mesh is plotted using rectangles.  The vertices of the rectangles [X, Y] are typically the output of ‘meshgrid’.  over a 2-D rectangular region in the x-y plane.  Z determines the height above the plane of each vertex.  If only a single Z matrix is given, then it is plotted over the meshgrid ‘X = 1:columns (Z), Y = 1:rows (Z)’.  Thus, columns of Z correspond to different X values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values to fit the range of the current colormap.  Use ‘caxis’ and/or change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying surface object.

     If the first argument HAX is an axes handle, then plot into this axes, rather than the current axes returned by ‘gca’.

     The optional return value H is a graphics handle to the created surface object.

     See also: meshz, mesh, meshc, contour, surf, surface, ribbon, meshgrid, hidden, shading, colormap, caxis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Plot a 3-D waterfall plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
allchild


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 432
 -- : H = allchild (HANDLES)
     Find all children, including hidden children, of a graphics object.

     This function is similar to ‘get (h, "children")’, but also returns hidden objects (HandleVisibility = "off").

     If HANDLES is a scalar, H will be a vector.  Otherwise, H will be a cell matrix of the same size as HANDLES and each cell will contain a vector of handles.

     See also: findall, findobj, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Find all children, including hidden children, of a graphics object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ancestor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 579
 -- : PARENT = ancestor (H, TYPE)
 -- : PARENT = ancestor (H, TYPE, "toplevel")
     Return the first ancestor of handle object H whose type matches TYPE, where TYPE is a character string.

     If TYPE is a cell array of strings, return the first parent whose type matches any of the given type strings.

     If the handle object H itself is of type TYPE, return H.

     If "toplevel" is given as a third argument, return the highest parent in the object hierarchy that matches the condition, instead of the first (nearest) one.

     See also: findobj, findall, allchild.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Return the first ancestor of handle object H whose type matches TYPE, where TYPE is a character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
axes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 958
 -- : axes ()
 -- : axes (PROPERTY, VALUE, ...)
 -- : axes (HAX)
 -- : H = axes (...)
     Create a Cartesian axes object and return a handle to it, or set the current axes to HAX.

     Called without any arguments, or with PROPERTY/VALUE pairs, construct a new axes.

     Called with a single axes handle argument HAX, the function makes HAX the current axes (as returned by ‘gca’).  It also makes the figure which contains HAX the current figure (as returned by ‘gcf’).  Finally, it restacks the parent object’s ‘children’ property so that the axes HAX appears before all other axes handles in the list.  This causes HAX to be displayed on top of any other axes objects (Z-order stacking).  In addition it restacks any legend or colorbar objects associated with HAX so that they are also visible.

     Programming Note: The full list of properties is documented at *note Axes Properties: Axes Properties.

     See also: gca, set, get.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Create a Cartesian axes object and return a handle to it, or set the current axes to HAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cla


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 930
 -- : cla
 -- : cla reset
 -- : cla (HAX)
 -- : cla (HAX, "reset")
     Clear the current or specified (HAX) axes object.

     ‘cla’ operates by deleting child graphic objects with visible handles (‘HandleVisibility’ = "on").  This typically clears the axes of any visual objects, but leaves in place axes limits, tick marks and labels, camera view, etc.  In addition, the automatic coloring and styling of lines is reset by changing the axes properties ‘ColorOrderIndex’, ‘LinestyleOrderIndex’ to 1.

     If the optional argument "reset" is specified, delete all child objects, including those with hidden handles, and reset all axes properties to their defaults.  However, the following properties are not reset: ‘Position’, ‘Units’.

     If the first argument HAX is an axes handle, then operate on this axes rather than the current axes returned by ‘gca’.

     See also: clf, delete, reset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Clear the current or specified (HAX) axes object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
clf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 771
 -- : clf
 -- : clf reset
 -- : clf (HFIG)
 -- : clf (HFIG, "reset")
 -- : H = clf (...)
     Clear the current figure window.

     ‘clf’ operates by deleting child graphics objects with visible handles (HandleVisibility = "on").

     If the optional argument "reset" is specified, delete all child objects including those with hidden handles and reset all figure properties to their defaults.  However, the following properties are not reset: Position, Units, PaperPosition, PaperUnits.

     If the first argument HFIG is a figure handle, then operate on this figure rather than the current figure returned by ‘gcf’.

     The optional return value H is the graphics handle of the figure window that was cleared.

     See also: cla, close, delete, reset.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Clear the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
close


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1351
 -- : close
 -- : close (H)
 -- : close FIGNAME
 -- : close all
 -- : close all hidden
 -- : close all force
     Close figure window(s).

     When called with no arguments, close the current figure.  This is equivalent to ‘close (gcf)’.  If the input H is a graphic handle, or vector of graphics handles, then close each figure in H.  The figure to close may also be specified by name FIGNAME which is matched against the "Name" property of all figures.

     If the argument "all" is given then all figures with visible handles (HandleVisibility = "on") are closed.

     If the additional argument "hidden" is given then all figures, including hidden ones, are closed.

     If the additional argument "force" is given then figures are closed even when "closerequestfcn" has been altered to prevent closing the window.

     Implementation Note: ‘close’ operates by making the handle H the current figure, and then calling the function specified by the "closerequestfcn" property of the figure.  By default, the function ‘closereq’ is used.  It is possible that the function invoked will delay or abort removing the figure.  To remove a figure without executing any callback functions use ‘delete’.  When writing a callback function to close a window do not use ‘close’ to avoid recursion.

     See also: closereq, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Close figure window(s).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
closereq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 229
 -- : closereq ()
     Close the current figure and delete all graphics objects associated with it.

     By default, the "closerequestfcn" property of a new plot figure points to this function.

     See also: close, delete.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Close the current figure and delete all graphics objects associated with it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
colstyle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- : [STYLE, COLOR, MARKER, MSG] = colstyle (STYLE)
     Parse the line specification STYLE and return the line style, color, and markers given.

     In the case of an error, the string MSG will return the text of the error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Parse the line specification STYLE and return the line style, color, and markers given.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
copyobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 761
 -- : HNEW = copyobj (HORIG)
 -- : HNEW = copyobj (HORIG, HPARENT)
     Construct a copy of the graphic objects associated with the handles HORIG and return new handles HNEW to the new objects.

     If a parent handle HPARENT (root, figure, axes, or hggroup) is specified, the copied object will be created as a child of HPARENT.

     If HORIG is a vector of handles, and HPARENT is a scalar, then each handle in the vector HNEW has its "Parent" property set to HPARENT.  Conversely, if HORIG is a scalar and HPARENT a vector, then each parent object will receive a copy of HORIG.  If HORIG and HPARENT are both vectors with the same number of elements then ‘HNEW(i)’ will have parent ‘HPARENT(i)’.

     See also: struct2hdl, hdl2struct, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Construct a copy of the graphic objects associated with the handles HORIG and return new handles HNEW to the new objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
figure


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 823
 -- : figure
 -- : figure N
 -- : figure (N)
 -- : figure (..., "PROPERTY", VALUE, ...)
 -- : H = figure (...)
     Create a new figure window for plotting.

     If no arguments are specified, a new figure with the next available number is created.

     If called with an integer N, and no such numbered figure exists, then a new figure with the specified number is created.  If the figure already exists then it is made visible and becomes the current figure for plotting.

     Multiple property-value pairs may be specified for the figure object, but they must appear in pairs.

     The optional return value H is a graphics handle to the created figure object.

     Programming Note: The full list of properties is documented at *note Figure Properties: Figure Properties.

     See also: axes, gcf, clf, close.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create a new figure window for plotting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 731
 -- : H = findall ()
 -- : H = findall (PROP_NAME, PROP_VALUE, ...)
 -- : H = findall (PROP_NAME, PROP_VALUE, "-LOGICAL_OP", PROP_NAME, PROP_VALUE)
 -- : H = findall ("-property", PROP_NAME)
 -- : H = findall ("-regexp", PROP_NAME, PATTERN)
 -- : H = findall (HLIST, ...)
 -- : H = findall (HLIST, "flat", ...)
 -- : H = findall (HLIST, "-depth", D, ...)
     Find graphics object, including hidden ones, with specified properties.

     The return value H is a list of handles to the found graphic objects.

     ‘findall’ performs the same search as ‘findobj’, but it includes hidden objects (HandleVisibility = "off").  For full documentation, *note findobj: XREFfindobj.

     See also: findobj, allchild, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Find graphics object, including hidden ones, with specified properties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
findfigs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- : findfigs ()
     Find all visible figures that are currently off the screen and move them onto the screen.

     See also: allchild, figure, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Find all visible figures that are currently off the screen and move them onto the screen.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findobj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2375
 -- : H = findobj ()
 -- : H = findobj (PROP_NAME, PROP_VALUE, ...)
 -- : H = findobj (PROP_NAME, PROP_VALUE, "-LOGICAL_OP", PROP_NAME, PROP_VALUE)
 -- : H = findobj ("-property", PROP_NAME)
 -- : H = findobj ("-regexp", PROP_NAME, PATTERN)
 -- : H = findobj (HLIST, ...)
 -- : H = findobj (HLIST, "flat", ...)
 -- : H = findobj (HLIST, "-depth", D, ...)
     Find graphics objects with specified properties.

     When called without arguments, return all graphic objects beginning with the root object (0) and including all of its descendants.

     The simplest form for narrowing the results is

          findobj (PROP_NAME, PROP_VALUE)

     which returns the handles of all objects which have a property named PROP_NAME that has the value PROP_VALUE.  If multiple property/value pairs are specified then only objects meeting all of the conditions (equivalent to ‘-and’) are returned.

     The search can be limited to a particular set of objects and their descendants, by passing a handle or set of handles HLIST as the first argument.

     The depth of the object hierarchy to search can be limited with the "-depth" argument.  An example of searching through only three generations of children is:

          findobj (HLIST, "-depth", 3, PROP_NAME, PROP_VALUE)

     Specifying a depth D of 0 limits the search to the set of objects passed in HLIST.  A depth of 0 is also equivalent to the "flat" argument.  The default depth value is ‘Inf’ which includes all descendants.

     A specified logical operator may be used between PROP_NAME, PROP_VALUE pairs.  The supported logical operators are: "-and", "-or", "-xor", "-not".  Example code to locate all figure and axes objects is

          findobj ("type", "figure", "-or", "type", "axes")

     Objects may also be matched by comparing a regular expression to the property values, where property values that match ‘regexp (PROP_VALUE, PATTERN)’ are returned.

     Finally, objects which have a property name can be found with the "-property" option.  For example, code to locate objects with a "meshstyle" property is

          findobj ("-property", "meshstyle")

     Implementation Note: The search only includes objects with visible handles (HandleVisibility = "on").  *Note findall: XREFfindall, to search for all objects including hidden ones.

     See also: findall, allchild, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Find graphics objects with specified properties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gca


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 831
 -- : H = gca ()
     Return a handle to the current axes object.

     The current axes is the default target for graphics output.  In the case of a figure with multiple axes, ‘gca’ returns the last created axes or the last axes that was clicked on with the mouse.

     If no current axes object exists, create one and return its handle.  The handle may then be used to examine or set properties of the axes.  For example,

          ax = gca ();
          set (ax, "position", [0.5, 0.5, 0.5, 0.5]);

     creates an empty axes object and then changes its location and size in the figure window.

     Note: To find the current axes without creating a new axes object if it does not exist, query the "CurrentAxes" property of a figure.

          get (gcf, "currentaxes");

     See also: gcf, gco, gcbf, gcbo, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return a handle to the current axes object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gcbf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 336
 -- : FIG = gcbf ()
     Return a handle to the figure containing the object whose callback is currently executing.

     If no callback is executing, this function returns the empty matrix.  The handle returned by this function is the same as the second output argument of ‘gcbo’.

     See also: gcbo, gcf, gco, gca, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return a handle to the figure containing the object whose callback is currently executing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gcbo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 537
 -- : H = gcbo ()
 -- : [H, FIG] = gcbo ()
     Return a handle to the object whose callback is currently executing.

     If no callback is executing, this function returns the empty matrix.  This handle is obtained from the root object property "CallbackObject".

     When called with a second output argument, return the handle of the figure containing the object whose callback is currently executing.  If no callback is executing the second output is also set to the empty matrix.

     See also: gcbf, gco, gca, gcf, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return a handle to the object whose callback is currently executing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gcf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 909
 -- : H = gcf ()
     Return a handle to the current figure.

     The current figure is the default target for graphics output.  If multiple figures exist, ‘gcf’ returns the last created figure or the last figure that was clicked on with the mouse.

     If a current figure does not exist, create one and return its handle.  The handle may then be used to examine or set properties of the figure.  For example,

          fplot (@sin, [-10, 10]);
          fig = gcf ();
          set (fig, "numbertitle", "off", "name", "sin plot")

     plots a sine wave, finds the handle of the current figure, and then renames the figure window to describe the contents.

     Note: To find the current figure without creating a new one if it does not exist, query the "CurrentFigure" property of the root graphics object.

          get (groot, "currentfigure");

     See also: gca, gco, gcbf, gcbo, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return a handle to the current figure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 833
 -- : H = gco ()
 -- : H = gco (FIG)
     Return a handle to the current object of the current figure, or a handle to the current object of the figure with handle FIG.

     The current object of a figure is the object that was last clicked on.  It is stored in the "CurrentObject" property of the target figure.

     If the last mouse click did not occur on any child object of the figure, then the current object is the figure itself.

     If no mouse click occurred in the target figure, this function returns an empty matrix.

     Programming Note: The value returned by this function is not necessarily the same as the one returned by ‘gcbo’ during callback execution.  An executing callback can be interrupted by another callback and the current object may be changed.

     See also: gcbo, gca, gcf, gcbf, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
Return a handle to the current object of the current figure, or a handle to the current object of the figure with handle FIG.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ginput


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 835
 -- : [X, Y, BUTTONS] = ginput (N)
 -- : [X, Y, BUTTONS] = ginput ()
     Return the position and type of mouse button clicks and/or key strokes in the current figure window.

     If N is defined, then capture N events before returning.  When N is not defined ‘ginput’ will loop until the return key <RET> is pressed.

     The return values X, Y are the coordinates where the mouse was clicked in the units of the current axes.  The return value BUTTON is 1, 2, or 3 for the left, middle, or right button.  If a key is pressed the ASCII value is returned in BUTTON.

     Implementation Note: ‘ginput’ is intenteded for 2-D plots.  For 3-D plots see the CURRENTPOINT property of the current axes which can be transformed with knowledge of the current ‘view’ into data units.

     See also: gtext, waitforbuttonpress.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
Return the position and type of mouse button clicks and/or key strokes in the current figure window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
graphics_toolkit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 769
 -- : NAME = graphics_toolkit ()
 -- : NAME = graphics_toolkit (HLIST)
 -- : graphics_toolkit (NAME)
 -- : graphics_toolkit (HLIST, NAME)
     Query or set the default graphics toolkit which is assigned to new figures.

     With no inputs, return the current default graphics toolkit.  If the input is a list of figure graphic handles, HLIST, then return the name of the graphics toolkit in use for each figure.

     When called with a single input NAME set the default graphics toolkit to NAME.  If the toolkit is not already loaded, it is initialized by calling the function ‘__init_NAME__’.  If the first input is a list of figure handles, HLIST, then the graphics toolkit is set to NAME for these figures only.

     See also: available_graphics_toolkits.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Query or set the default graphics toolkit which is assigned to new figures.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
groot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1131
 -- : H = groot ()
     Return a handle to the root graphics object.

     The root graphics object is the ultimate parent of all graphics objects.

     In addition, the root object contains information about the graphics system as a whole such as the ‘ScreenSize’.  Use ‘get (groot)’ to find out what information is available.

     Defaults for the graphic system as a whole are specified by setting properties of the root graphics object that begin with "Default".  For example, to set the default font for all text objects to FreeSans use

          set (groot, "DefaultTextFontName", "FreeSans")

     Default properties can be deleted by using ‘set’ with the special property value of "remove".  To undo the default font assignment above use

          set (groot, "DefaultTextFontName", "remove")

     Programming Note: The root graphics object is identified by the special handle value of 0.  At some point this unique value may change, but code can be made resistant to future changes by using ‘groot’ which is guaranteed to always return the root graphics object.

     See also: gcf, gca, get, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return a handle to the root graphics object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
hdl2struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 301
 -- : S = hdl2struct (H)
     Return a structure, S, whose fields describe the properties of the object, and its children, associated with the handle, H.

     The fields of the structure S are "type", "handle", "properties", "children", and "special".

     See also: struct2hdl, hgsave, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
Return a structure, S, whose fields describe the properties of the object, and its children, associated with the handle, H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hggroup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 832
 -- : hggroup ()
 -- : hggroup (HAX)
 -- : hggroup (..., PROPERTY, VALUE, ...)
 -- : H = hggroup (...)
     Create handle graphics group object with axes parent HAX.

     If no parent is specified, the group is created in the current axes.

     Multiple property/value pairs may be specified for the hggroup, but they must appear in pairs.

     The optional return value H is a graphics handle to the created hggroup object.

     Programming Note: An hggroup is a way to group base graphics objects such as line objects or patch objects into a single unit which can react appropriately.  For example, the individual lines of a contour plot are collected into a single hggroup so that they can be made visible/invisible with a single command, ‘set (hg_handle, "visible", "off")’.

     See also: addproperty, addlistener.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create handle graphics group object with axes parent HAX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hgload


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 262
 -- : H = hgload (FILENAME)
     Load the graphics object in FILENAME into the graphics handle H.

     If FILENAME has no extension, Octave will try to find the file with and without the standard extension of ‘.ofig’.

     See also: hgsave, struct2hdl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Load the graphics object in FILENAME into the graphics handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hgsave


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 921
 -- : hgsave (FILENAME)
 -- : hgsave (H, FILENAME)
 -- : hgsave (H, FILENAME, FMT)
     Save the graphics handle H to the file FILENAME in the format FMT.

     If unspecified, H is the current figure as returned by ‘gcf’.

     When FILENAME does not have an extension the default filename extension ‘.ofig’ will be appended.

     If present, FMT should be one of the following:

        • ‘-binary’, ‘-float-binary’

        • ‘-hdf5’, ‘-float-hdf5’

        • ‘-V7’, ‘-v7’, ‘-7’, ‘-mat7-binary’

        • ‘-V6’, ‘-v6’, ‘-6’, ‘-mat6-binary’

        • ‘-text’

        • ‘-zip’, ‘-z’

     When producing graphics for final publication use ‘print’ or ‘saveas’.  When it is important to be able to continue to edit a figure as an Octave object, use ‘hgsave’/‘hgload’.

     See also: hgload, hdl2struct, saveas, print.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Save the graphics handle H to the file FILENAME in the format FMT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
hgtransform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 285
 -- : H = hgtransform ()
 -- : H = hgtransform (PROPERTY, VALUE, ...)
 -- : H = hgtransform (HAX, ...)

     Create a graphics transform object.

     FIXME: Need to write documentation.  FIXME: Add ’makehgtform’ to seealso list when it is implemented.

     See also: hggroup.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Create a graphics transform object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hold


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 952
 -- : hold
 -- : hold on
 -- : hold off
 -- : hold (HAX, ...)
     Toggle or set the "hold" state of the plotting engine which determines whether new graphic objects are added to the plot or replace the existing objects.

     ‘hold on’
          Retain plot data and settings so that subsequent plot commands are displayed on a single graph.  Line color and line style are advanced for each new plot added.

     ‘hold all (deprecated)’
          Equivalent to ‘hold on’.

     ‘hold off’
          Restore default graphics settings which clear the graph and reset axes properties before each new plot command.  (default).

     ‘hold’
          Toggle the current hold state.

     When given the additional argument HAX, the hold state is modified for this axes rather than the current axes returned by ‘gca’.

     To query the current hold state use the ‘ishold’ function.

     See also: ishold, cla, clf, newplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
Toggle or set the "hold" state of the plotting engine which determines whether new graphic objects are added to the plot or replace the existing objects.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isaxes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 285
 -- : isaxes (H)
     Return true if H is an axes graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where the elements of H are axes graphics handles and false where they are not.

     See also: isfigure, ishghandle, isgraphics.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return true if H is an axes graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isfigure


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 -- : isfigure (H)
     Return true if H is a figure graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where the elements of H are figure graphics handles and false where they are not.

     See also: isaxes, ishghandle, isgraphics.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if H is a figure graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isgraphics


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- : isgraphics (H)
 -- : isgraphics (H, TYPE)
     Return true if H is a graphics handle (of type TYPE) and false otherwise.

     When no TYPE is specified the function is equivalent to ‘ishghandle’.

     See also: ishghandle, ishandle, isaxes, isfigure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return true if H is a graphics handle (of type TYPE) and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ishandle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 593
 -- : ishandle (H)
     Return true if H is a handle to a graphics or Java object and false otherwise.

     H may also be a matrix of handles in which case a logical array is returned that is true where the elements of H are handles to graphics or Java objects and false where they are not.

     Programming Note: It is often more useful to test for a specific object type.  To determine if a handle belongs to a graphics object use ‘ishghandle’ or ‘isgraphics’.  To determine if a handle belongs to a Java object use ‘isjava’.

     See also: ishghandle, isgraphics, isjava.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return true if H is a handle to a graphics or Java object and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ishold


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 356
 -- : ishold
 -- : ishold (HAX)
 -- : ishold (HFIG)
     Return true if the next plot will be added to the current plot, or false if the plot device will be cleared before drawing the next plot.

     If the first argument is an axes handle HAX or figure handle HFIG then operate on this plot rather than the current one.

     See also: hold, newplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
Return true if the next plot will be added to the current plot, or false if the plot device will be cleared before drawing the next plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 386
 -- : RES = isprop (OBJ, "PROP")
     Return true if PROP is a property of the object OBJ.

     OBJ may also be an array of objects in which case RES will be a logical array indicating whether each handle has the property PROP.

     For plotting, OBJ is a handle to a graphics object.  Otherwise, OBJ should be an instance of a class.

     See also: get, set, ismethod, isobject.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if PROP is a property of the object OBJ.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linkaxes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 782
 -- : linkaxes (HAX)
 -- : linkaxes (HAX, OPTSTR)
     Link the axis limits of 2-D plots such that a change in one is propagated to the others.

     The axes handles to be linked are passed as the first argument HAX.

     The optional second argument is a string which defines which axis limits will be linked.  The possible values for OPTSTR are:

     "x"
          Link x-axes

     "y"
          Link y-axes

     "xy" (default)
          Link both axes

     "off"
          Turn off linking

     If unspecified the default is to link both X and Y axes.

     When linking, the limits from the first axes in HAX are applied to the other axes in the list.  Subsequent changes to any one of the axes will be propagated to the others.

     See also: linkprop, addproperty.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
Link the axis limits of 2-D plots such that a change in one is propagated to the others.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linkprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1242
 -- : HLINK = linkprop (H, "PROP")
 -- : HLINK = linkprop (H, {"PROP1", "PROP2", ...})
     Link graphic object properties, such that a change in one is propagated to the others.

     The input H is a vector of graphic handles to link.

     PROP may be a string when linking a single property, or a cell array of strings for multiple properties.  During the linking process all properties in PROP will initially be set to the values that exist on the first object in the list H.

     The function returns HLINK which is a special object describing the link.  As long as the reference HLINK exists, the link between graphic objects will be active.  This means that HLINK must be preserved in a workspace variable, a global variable, or otherwise stored using a function such as ‘setappdata’ or ‘guidata’.  To unlink properties, execute ‘clear HLINK’.

     An example of the use of ‘linkprop’ is

          x = 0:0.1:10;
          subplot (1,2,1);
          h1 = plot (x, sin (x));
          subplot (1,2,2);
          h2 = plot (x, cos (x));
          hlink = linkprop ([h1, h2], {"color","linestyle"});
          set (h1, "color", "green");
          set (h2, "linestyle", "--");

     See also: linkaxes, addlistener.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Link graphic object properties, such that a change in one is propagated to the others.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
meshgrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1576
 -- : [XX, YY] = meshgrid (X, Y)
 -- : [XX, YY, ZZ] = meshgrid (X, Y, Z)
 -- : [XX, YY] = meshgrid (X)
 -- : [XX, YY, ZZ] = meshgrid (X)
     Given vectors of X and Y coordinates, return matrices XX and YY corresponding to a full 2-D grid.

     The rows of XX are copies of X, and the columns of YY are copies of Y.  If Y is omitted, then it is assumed to be the same as X.

     If the optional Z input is given, or ZZ is requested, then the output will be a full 3-D grid.  If Z is omitted and ZZ is requested, it is assumed to be the same as Y.

     ‘meshgrid’ is most frequently used to produce input for a 2-D or 3-D function that will be plotted.  The following example creates a surface plot of the “sombrero” function.

          f = @(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
          range = linspace (-8, 8, 41);
          [X, Y] = meshgrid (range, range);
          Z = f (X, Y);
          surf (X, Y, Z);

     Programming Note: ‘meshgrid’ is restricted to 2-D or 3-D grid generation.  The ‘ndgrid’ function will generate 1-D through N-D grids.  However, the functions are not completely equivalent.  If X is a vector of length M and Y is a vector of length N, then ‘meshgrid’ will produce an output grid which is NxM.  ‘ndgrid’ will produce an output which is MxN (transpose) for the same input.  Some core functions expect ‘meshgrid’ input and others expect ‘ndgrid’ input.  Check the documentation for the function in question to determine the proper input format.

     See also: ndgrid, mesh, contour, surf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Given vectors of X and Y coordinates, return matrices XX and YY corresponding to a full 2-D grid.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ndgrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 858
 -- : [Y1, Y2, ..., Yn] = ndgrid (X1, X2, ..., Xn)
 -- : [Y1, Y2, ..., Yn] = ndgrid (X)
     Given n vectors X1, ..., Xn, ‘ndgrid’ returns n arrays of dimension n.

     The elements of the i-th output argument contains the elements of the vector Xi repeated over all dimensions different from the i-th dimension.  Calling ndgrid with only one input argument X is equivalent to calling ndgrid with all n input arguments equal to X:

     [Y1, Y2, ..., Yn] = ndgrid (X, ..., X)

     Programming Note: ‘ndgrid’ is very similar to the function ‘meshgrid’ except that the first two dimensions are transposed in comparison to ‘meshgrid’.  Some core functions expect ‘meshgrid’ input and others expect ‘ndgrid’ input.  Check the documentation for the function in question to determine the proper input format.

     See also: meshgrid.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Given n vectors X1, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
newplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7482
 -- : newplot ()
 -- : newplot (HFIG)
 -- : newplot (HAX)
 -- : HAX = newplot (...)
     Prepare graphics engine to produce a new plot.

     This function is called at the beginning of all high-level plotting functions.  It is not normally required in user programs.  ‘newplot’ queries the "NextPlot" field of the current figure and axes to determine what to do.

     Figure NextPlot                                                                                                                                                                                                                                                  Action
     ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     "new"                                                                                                                                                                                                                                                            Create a new figure and make it the current figure.
                                                                                                                                                                                                                                                                      
     "add" (default)                                                                                                                                                                                                                                                  Add new graphic objects to the current figure.
                                                                                                                                                                                                                                                                      
     "replacechildren"                                                                                                                                                                                                                                                Delete child objects whose HandleVisibility is set to "on".  Set NextPlot property to "add".  This typically clears a figure, but leaves in place hidden objects such as menubars.  This is equivalent to ‘clf’.
                                                                                                                                                                                                                                                                      
     "replace"                                                                                                                                                                                                                                                        Delete all child objects of the figure and reset all figure properties to their defaults.  However, the following four properties are not reset: Position, Units, PaperPosition, PaperUnits.  This is equivalent to ‘clf reset’.

     Axes NextPlot                                                                                                                                                                                                                                                    Action
     ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     "add"                                                                                                                                                                                                                                                            Add new graphic objects to the current axes.  This is equivalent to ‘hold on’.
                                                                                                                                                                                                                                                                      
     "replacechildren"                                                                                                                                                                                                                                                Delete child objects whose HandleVisibility is set to "on", but leave axes properties unmodified.  This typically clears a plot, but preserves special settings such as log scaling for axes.  This is equivalent to ‘cla’.
                                                                                                                                                                                                                                                                      
     "replace" (default)                                                                                                                                                                                                                                              Delete all child objects of the axes and reset all axes properties to their defaults.  However, the following properties are not reset: Position, Units.  This is equivalent to ‘cla reset’.

     If the optional input HFIG or HAX is given then prepare the specified figure or axes rather than the current figure and axes.

     The optional return value HAX is a graphics handle to the created axes object (not figure).

     *Caution:* Calling ‘newplot’ may change the current figure and current axes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Prepare graphics engine to produce a new plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- : pan
 -- : pan on
 -- : pan off
 -- : pan xon
 -- : pan yon
 -- : pan (HFIG, OPTION)
     Control the interactive panning mode of a figure in the GUI.

     Given the option "on" or "off", set the interactive pan mode on or off.

     With no arguments, toggle the current pan mode on or off.

     Given the option "xon" or "yon", enable pan mode for the x or y axis only.

     If the first argument HFIG is a figure, then operate on the given figure rather than the current figure as returned by ‘gcf’.

     See also: rotate3d, zoom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Control the interactive panning mode of a figure in the GUI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
print


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9550
 -- : print ()
 -- : print (OPTIONS)
 -- : print (FILENAME, OPTIONS)
 -- : print (H, FILENAME, OPTIONS)
     Print a plot, or save it to a file.

     Both output formatted for printing (PDF and PostScript), and many bitmapped and vector image formats are supported.

     FILENAME defines the name of the output file.  If the filename has no suffix, one is inferred from the specified device and appended to the filename.  If no filename is specified, the output is sent to the printer.

     H specifies the handle of the figure to print.  If no handle is specified the current figure is used.

     For output to a printer, PostScript file, or PDF file, the paper size is specified by the figure’s ‘papersize’ property.  The location and size of the image on the page are specified by the figure’s ‘paperposition’ property.  The orientation of the page is specified by the figure’s ‘paperorientation’ property.

     The width and height of images are specified by the figure’s ‘paperposition(3:4)’ property values.

     The ‘print’ command supports many OPTIONS:

     ‘-fH’
          Specify the handle, H, of the figure to be printed.  The default is the current figure.

     ‘-PPRINTER’
          Set the PRINTER name to which the plot is sent if no FILENAME is specified.

     ‘-GGHOSTSCRIPT_COMMAND’
          Specify the command for calling Ghostscript.  For Unix and Windows the defaults are "gs" and "gswin32c", respectively.

     ‘-color’
     ‘-mono’
          Color or monochrome output.

     ‘-solid’
     ‘-dashed’
          Force all lines to be solid or dashed, respectively.

     ‘-portrait’
     ‘-landscape’
          Specify the orientation of the plot for printed output.  For non-printed output the aspect ratio of the output corresponds to the plot area defined by the "paperposition" property in the orientation specified.  This option is equivalent to changing the figure’s "paperorientation" property.

     ‘-TextAlphaBits=N’
     ‘-GraphicsAlphaBits=N’
          Octave is able to produce output for various printers, bitmaps, and vector formats by using Ghostscript.  For bitmap and printer output anti-aliasing is applied using Ghostscript’s TextAlphaBits and GraphicsAlphaBits options.  The default number of bits are 4 and 1 respectively.  Allowed values for N are 1, 2, or 4.

     ‘-dDEVICE’
          The available output format is specified by the option DEVICE, and is one of:

          ‘ps’
          ‘ps2’
          ‘psc’
          ‘psc2’
               PostScript (level 1 and 2, mono and color).  The OpenGL-based toolkits always generate PostScript level 3.0.

          ‘eps’
          ‘eps2’
          ‘epsc’
          ‘epsc2’
               Encapsulated PostScript (level 1 and 2, mono and color).  The OpenGL-based toolkits always generate PostScript level 3.0.

          ‘pslatex’
          ‘epslatex’
          ‘pdflatex’
          ‘pslatexstandalone’
          ‘epslatexstandalone’
          ‘pdflatexstandalone’
               Generate a LaTeX file ‘FILENAME.tex’ for the text portions of a plot and a file ‘FILENAME.(ps|eps|pdf)’ for the remaining graphics.  The graphics file suffix .ps|eps|pdf is determined by the specified device type.  The LaTeX file produced by the ‘standalone’ option can be processed directly by LaTeX.  The file generated without the ‘standalone’ option is intended to be included from another LaTeX document.  In either case, the LaTeX file contains an ‘\includegraphics’ command so that the generated graphics file is automatically included when the LaTeX file is processed.  The text that is written to the LaTeX file contains the strings *exactly* as they were specified in the plot.  If any special characters of the TeX mode interpreter were used, the file must be edited before LaTeX processing.  Specifically, the special characters must be enclosed with dollar signs (‘$ ... $’), and other characters that are recognized by LaTeX may also need editing (.e.g., braces).  The ‘pdflatex’ device, and any
               of the ‘standalone’ formats, are not available with the Gnuplot toolkit.

          ‘epscairo’
          ‘pdfcairo’
          ‘epscairolatex’
          ‘pdfcairolatex’
          ‘epscairolatexstandalone’
          ‘pdfcairolatexstandalone’
               Generate Cairo based output when using the Gnuplot graphics toolkit.  The ‘epscairo’ and ‘pdfcairo’ devices are synonymous with the ‘epsc’ device.  The LaTeX variants generate a LaTeX file, ‘FILENAME.tex’, for the text portions of a plot, and an image file, ‘FILENAME.(eps|pdf)’, for the graph portion of the plot.  The ‘standalone’ variants behave as described for ‘epslatexstandalone’ above.

          ‘ill’
          ‘aifm’
               Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)

          ‘canvas’
               Javascript-based drawing on HTML5 canvas viewable in a web browser (only available for the Gnuplot graphics toolkit).

          ‘cdr’
          ‘corel’
               CorelDraw

          ‘cgm’
               Computer Graphics Metafile, Version 1, ANSI X3.122-1986 (only available for the Gnuplot graphics toolkit).

          ‘dxf’
               AutoCAD

          ‘emf’
          ‘meta’
               Microsoft Enhanced Metafile

          ‘fig’
               XFig.  For the Gnuplot graphics toolkit, the additional options ‘-textspecial’ or ‘-textnormal’ can be used to control whether the special flag should be set for the text in the figure.  (default is ‘-textnormal’)

          ‘gif’
               GIF image (only available for the Gnuplot graphics toolkit).

          ‘hpgl’
               HP plotter language

          ‘jpg’
          ‘jpeg’
               JPEG image

          ‘latex’
          ‘eepic’
               LaTeX picture environment and extended picture environment (only available for the Gnuplot graphics toolkit).

          ‘mf’
               Metafont

          ‘png’
               Portable network graphics

          ‘pbm’
               PBMplus

          ‘pdf’
               Portable document format

          ‘svg’
               Scalable vector graphics

          ‘tikz’
          ‘tikzstandalone’
               Generate a LaTeX file using PGF/TikZ format.  The OpenGL-based toolkits create a PGF file while Gnuplot creates a TikZ file.  The ‘tikzstandalone’ device produces a LaTeX document which includes the TikZ file (‘tikzstandalone’ and is only available for the Gnuplot graphics toolkit).

          If the device is omitted, it is inferred from the file extension, or if there is no filename it is sent to the printer as PostScript.

     ‘-dGHOSTSCRIPT_DEVICE’
          Additional devices are supported by Ghostscript.  Some examples are;

          ‘pdfwrite’
               Produces pdf output from eps

          ‘ljet2p’
               HP LaserJet IIP

          ‘pcx24b’
               24-bit color PCX file format

          ‘ppm’
               Portable Pixel Map file format

          For a complete list, type ‘system ("gs -h")’ to see what formats and devices are available.

          When Ghostscript output is sent to a printer the size is determined by the figure’s "papersize" property.  When the output is sent to a file the size is determined by the plot box defined by the figure’s "paperposition" property.

     ‘-append’
          Append PostScript or PDF output to a pre-existing file of the same type.

     ‘-rNUM’
          Resolution of bitmaps in pixels per inch.  For both metafiles and SVG the default is the screen resolution; for other formats it is 150 dpi.  To specify screen resolution, use "-r0".

     ‘-loose’
     ‘-tight’
          Force a tight or loose bounding box for eps files.  The default is loose.

     ‘-PREVIEW’
          Add a preview to eps files.  Supported formats are:

          ‘-interchange’
               Provide an interchange preview.

          ‘-metafile’
               Provide a metafile preview.

          ‘-pict’
               Provide pict preview.

          ‘-tiff’
               Provide a tiff preview.

     ‘-SXSIZE,YSIZE’
          Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG.  For PS, EPS, PDF, and other vector formats the plot size is in points.  This option is equivalent to changing the size of the plot box associated with the "paperposition" property.  When using the command form of the print function you must quote the XSIZE,YSIZE option.  For example, by writing "-S640,480".

     ‘-FFONTNAME’
     ‘-FFONTNAME:SIZE’
     ‘-F:SIZE’
          Use FONTNAME and/or FONTSIZE for all text.  FONTNAME is ignored for some devices: dxf, fig, hpgl, etc.

     The filename and options can be given in any order.

     Example: Print to a file using the pdf device.

          figure (1);
          clf ();
          surf (peaks);
          print figure1.pdf

     Example: Print to a file using jpg device.

          clf ();
          surf (peaks);
          print -djpg figure2.jpg

     Example: Print to printer named PS_printer using ps format.

          clf ();
          surf (peaks);
          print -dpswrite -PPS_printer

     See also: saveas, hgsave, orient, figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Print a plot, or save it to a file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
printd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 390
 -- : printd (OBJ, FILENAME)
 -- : OUT_FILE = printd (...)

     Convert any object acceptable to ‘disp’ into the format selected by the suffix of FILENAME.

     If the return argument OUT_FILE is given, the name of the created file is returned.

     This function is intended to facilitate manipulation of the output of functions such as ‘stemleaf’.

     See also: stemleaf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Convert any object acceptable to ‘disp’ into the format selected by the suffix of FILENAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
refresh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- : refresh ()
 -- : refresh (H)
     Refresh a figure, forcing it to be redrawn.

     When called without an argument the current figure is redrawn.  Otherwise, the figure with graphic handle H is redrawn.

     See also: drawnow.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Refresh a figure, forcing it to be redrawn.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
refreshdata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 916
 -- : refreshdata ()
 -- : refreshdata (H)
 -- : refreshdata (H, WORKSPACE)
     Evaluate any ‘datasource’ properties of the current figure and update the plot if the corresponding data has changed.

     If the first argument H is a list of graphic handles, then operate on these objects rather than the current figure returned by ‘gcf’.

     The optional second argument WORKSPACE can take the following values:

     "base"
          Evaluate the datasource properties in the base workspace.  (default).

     "caller"
          Evaluate the datasource properties in the workspace of the function that called ‘refreshdata’.

     An example of the use of ‘refreshdata’ is:

          x = 0:0.1:10;
          y = sin (x);
          plot (x, y, "ydatasource", "y");
          for i = 1 : 100
            pause (0.1);
            y = sin (x + 0.1*i);
            refreshdata ();
          endfor
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Evaluate any ‘datasource’ properties of the current figure and update the plot if the corresponding data has changed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rotate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 437
 -- : rotate (H, DIRECTION, ALPHA)
 -- : rotate (..., ORIGIN)
     Rotate the plot object H through ALPHA degrees around the line with direction DIRECTION and origin ORIGIN.

     The default value of ORIGIN is the center of the axes object that is the parent of H.

     If H is a vector of handles, they must all have the same parent axes object.

     Graphics objects that may be rotated are lines, surfaces, patches, and images.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 106
Rotate the plot object H through ALPHA degrees around the line with direction DIRECTION and origin ORIGIN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rotate3d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 467
 -- : rotate3d
 -- : rotate3d on
 -- : rotate3d off
 -- : rotate3d (HFIG, OPTION)
     Control the interactive 3-D rotation mode of a figure in the GUI.

     Given the option "on" or "off", set the interactive rotate mode on or off.

     With no arguments, toggle the current rotate mode on or off.

     If the first argument HFIG is a figure, then operate on the given figure rather than the current figure as returned by ‘gcf’.

     See also: pan, zoom.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Control the interactive 3-D rotation mode of a figure in the GUI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
saveas


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 719
 -- : saveas (H, FILENAME)
 -- : saveas (H, FILENAME, FMT)
     Save graphic object H to the file FILENAME in graphic format FMT.

     All device formats accepted by ‘print’ may be used.  Common formats are:

     ‘ps’
          PostScript

     ‘eps’
          Encapsulated PostScript

     ‘pdf’
          Portable Document Format

     ‘jpg’
          JPEG Image

     ‘png’
          PNG Image

     ‘emf’
          Enhanced Meta File

     If FMT is omitted it is extracted from the extension of FILENAME.  The default format when there is no extension is "pdf".

          clf ();
          surf (peaks);
          saveas (1, "figure1.png");

     See also: print, hgsave, orient.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Save graphic object H to the file FILENAME in graphic format FMT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
shg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 136
 -- : shg
     Show the graph window.

     Currently, this is the same as executing ‘drawnow’.

     See also: drawnow, figure.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Show the graph window.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
struct2hdl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 747
 -- : H = struct2hdl (S)
 -- : H = struct2hdl (S, P)
 -- : H = struct2hdl (S, P, HILEV)
     Construct a graphics handle object H from the structure S.

     The structure must contain the fields "handle", "type", "children", "properties", and "special".

     If the handle of an existing figure or axes is specified, P, the new object will be created as a child of that object.  If no parent handle is provided then a new figure and the necessary children will be constructed using the default values from the root figure.

     A third boolean argument HILEV can be passed to specify whether the function should preserve listeners/callbacks, e.g., for legends or hggroups.  The default is false.

     See also: hdl2struct, hgload, findobj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Construct a graphics handle object H from the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
subplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2243
 -- : subplot (ROWS, COLS, INDEX)
 -- : subplot (ROWS, COLS, INDEX, HAX)
 -- : subplot (RCN)
 -- : subplot (HAX)
 -- : subplot (..., "align")
 -- : subplot (..., "replace")
 -- : subplot (..., "position", POS)
 -- : subplot (..., PROP, VAL, ...)
 -- : HAX = subplot (...)
     Set up a plot grid with ROWS by COLS subwindows and set the current axes for plotting (‘gca’) to the location given by INDEX.

     If an axes handle HAX is provided after the (ROWS, COLS, INDEX) arguments, the corresponding axes is turned into a subplot.

     If only one numeric argument is supplied, then it must be a three digit value specifying the number of rows in digit 1, the number of columns in digit 2, and the plot index in digit 3.

     The plot index runs row-wise; First, all columns in a row are numbered and then the next row is filled.

     For example, a plot with 2x3 grid will have plot indices running as follows:

          +-----+-----+-----+
          |  1  |  2  |  3  |
          +-----+-----+-----+
          |  4  |  5  |  6  |
          +-----+-----+-----+

     INDEX may also be a vector.  In this case, the new axes will enclose the grid locations specified.  The first demo illustrates this:

          demo ("subplot", 1)

     The index of the subplot to make active may also be specified by its axes handle, HAX, returned from a previous ‘subplot’ command.

     If the option "align" is given then the plot boxes of the subwindows will align, but this may leave no room for axes tick marks or labels.

     If the option "replace" is given then the subplot axes will be reset, rather than just switching the current axes for plotting to the requested subplot.

     The "position" property can be used to exactly position the subplot axes within the current figure.  The option POS is a 4-element vector [x, y, width, height] that determines the location and size of the axes.  The values in POS are normalized in the range [0,1].

     Any property/value pairs are passed directly to the underlying axes object.

     If the output HAX is requested, subplot returns the axes handle for the subplot.  This is useful for modifying the properties of a subplot using ‘set’.

     See also: axes, plot, gca, set.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Set up a plot grid with ROWS by COLS subwindows and set the current axes for plotting (‘gca’) to the location given by INDEX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
zoom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1139
 -- : zoom
 -- : zoom (FACTOR)
 -- : zoom on
 -- : zoom off
 -- : zoom xon
 -- : zoom yon
 -- : zoom out
 -- : zoom reset
 -- : zoom (HFIG, OPTION)
     Zoom the current axes object or control the interactive zoom mode of a figure in the GUI.

     Given a numeric argument greater than zero, zoom by the given factor.  If the zoom factor is greater than one, zoom in on the plot.  If the factor is less than one, zoom out.  If the zoom factor is a two- or three-element vector, then the elements specify the zoom factors for the x, y, and z axes respectively.

     Given the option "on" or "off", set the interactive zoom mode on or off.

     With no arguments, toggle the current zoom mode on or off.

     Given the option "xon" or "yon", enable zoom mode for the x or y-axis only.

     Given the option "out", zoom to the initial zoom setting.

     Given the option "reset", store the current zoom setting so that ‘zoom out’ will return to this zoom level.

     If the first argument HFIG is a figure, then operate on the given figure rather than the current figure as returned by ‘gcf’.

     See also: pan, rotate3d.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Zoom the current axes object or control the interactive zoom mode of a figure in the GUI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
compan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 856
 -- : compan (C)
     Compute the companion matrix corresponding to polynomial coefficient vector C.

     The companion matrix is

               _                                                        _
              |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
              |       1            0      ...       0             0      |
              |       0            1      ...       0             0      |
          A = |       .            .      .         .             .      |
              |       .            .       .        .             .      |
              |       .            .        .       .             .      |
              |_      0            0      ...       1             0     _|

     The eigenvalues of the companion matrix are equal to the roots of the polynomial.

     See also: roots, poly, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Compute the companion matrix corresponding to polynomial coefficient vector C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
conv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 789
 -- : conv (A, B)
 -- : conv (A, B, SHAPE)
     Convolve two vectors A and B.

     When A and B are the coefficient vectors of two polynomials, the convolution represents the coefficient vector of the product polynomial.

     The size of the result is determined by the optional SHAPE argument which takes the following values

     SHAPE = "full"
          Return the full convolution.  (default) The result is a vector with length equal to ‘length (A) + length (B) - 1’.

     SHAPE = "same"
          Return the central part of the convolution with the same size as A.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.  The size of the result is ‘max (size (A) - size (B) + 1, 0)’.

     See also: deconv, conv2, convn, fftconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Convolve two vectors A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
deconv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- : B = deconv (Y, A)
 -- : [B, R] = deconv (Y, A)
     Deconvolve two vectors (polynomial division).

     ‘[B, R] = deconv (Y, A)’ solves for B and R such that ‘Y = conv (A, B) + R’.

     If Y and A are polynomial coefficient vectors, B will contain the coefficients of the polynomial quotient and R will be a remainder polynomial of lowest order.

     See also: conv, residue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Deconvolve two vectors (polynomial division).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mkpp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 992
 -- : PP = mkpp (BREAKS, COEFS)
 -- : PP = mkpp (BREAKS, COEFS, D)

     Construct a piecewise polynomial (pp) structure from sample points BREAKS and coefficients COEFS.

     BREAKS must be a vector of strictly increasing values.  The number of intervals is given by ‘NI = length (BREAKS) - 1’.

     When M is the polynomial order COEFS must be of size: NI-by-(M + 1).

     The i-th row of COEFS, ‘COEFS (I,:)’, contains the coefficients for the polynomial over the I-th interval, ordered from highest (M) to lowest (0).

     COEFS may also be a multi-dimensional array, specifying a vector-valued or array-valued polynomial.  In that case the polynomial order M is defined by the length of the last dimension of COEFS.  The size of first dimension(s) are given by the scalar or vector D.  If D is not given it is set to ‘1’.  In any case COEFS is reshaped to a 2-D matrix of size ‘[NI*prod(D) M]’.

     See also: unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Construct a piecewise polynomial (pp) structure from sample points BREAKS and coefficients COEFS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mpoles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- : [MULTP, IDXP] = mpoles (P)
 -- : [MULTP, IDXP] = mpoles (P, TOL)
 -- : [MULTP, IDXP] = mpoles (P, TOL, REORDER)
     Identify unique poles in P and their associated multiplicity.

     The output is ordered from largest pole to smallest pole.

     If the relative difference of two poles is less than TOL then they are considered to be multiples.  The default value for TOL is 0.001.

     If the optional parameter REORDER is zero, poles are not sorted.

     The output MULTP is a vector specifying the multiplicity of the poles.  ‘MULTP(n)’ refers to the multiplicity of the Nth pole ‘P(IDXP(n))’.

     For example:

          p = [2 3 1 1 2];
          [m, n] = mpoles (p)
             ⇒ m = [1; 1; 2; 1; 2]
             ⇒ n = [2; 5; 1; 4; 3]
             ⇒ p(n) = [3, 2, 2, 1, 1]

     See also: residue, poly, roots, conv, deconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Identify unique poles in P and their associated multiplicity.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
padecoef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1153
 -- : [NUM, DEN] = padecoef (T)
 -- : [NUM, DEN] = padecoef (T, N)
     Compute the Nth-order Padé approximant of the continuous-time delay T in transfer function form.

     The Padé approximant of ‘exp (-sT)’ is defined by the following equation

                       Pn(s)
          exp (-sT) ~ -------
                       Qn(s)

     Where both Pn(s) and Qn(s) are Nth-order rational functions defined by the following expressions

                   N    (2N - k)!N!        k
          Pn(s) = SUM --------------- (-sT)
                  k=0 (2N)!k!(N - k)!

          Qn(s) = Pn(-s)

     The inputs T and N must be non-negative numeric scalars.  If N is unspecified it defaults to 1.

     The output row vectors NUM and DEN contain the numerator and denominator coefficients in descending powers of s.  Both are Nth-order polynomials.

     For example:

          t = 0.1;
          n = 4;
          [num, den] = padecoef (t, n)
          ⇒ num =

                1.0000e-04  -2.0000e-02   1.8000e+00  -8.4000e+01   1.6800e+03

          ⇒ den =

                1.0000e-04   2.0000e-02   1.8000e+00   8.4000e+01   1.6800e+03
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Compute the Nth-order Padé approximant of the continuous-time delay T in transfer function form.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pchip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1068
 -- : PP = pchip (X, Y)
 -- : YI = pchip (X, Y, XI)
     Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of points X and Y.

     If called with two arguments, return the piecewise polynomial PP that may be used with ‘ppval’ to evaluate the polynomial at specific points.

     When called with a third input argument, ‘pchip’ evaluates the pchip polynomial at the points XI.  The third calling form is equivalent to ‘ppval (pchip (X, Y), XI)’.

     The variable X must be a strictly monotonic vector (either increasing or decreasing) of length N.

     Y can be either a vector or array.  If Y is a vector then it must be the same length N as X.  If Y is an array then the size of Y must have the form ‘[S1, S2, ..., SK, N]’ The array is reshaped internally to a matrix where the leading dimension is given by ‘S1 * S2 * ... * SK’ and each row of this matrix is then treated separately.  Note that this is exactly opposite to ‘interp1’ but is done for MATLAB compatibility.

     See also: spline, ppval, mkpp, unmkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of points X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 937
 -- : poly (A)
 -- : poly (X)
     If A is a square N-by-N matrix, ‘poly (A)’ is the row vector of the coefficients of ‘det (z * eye (N) - A)’, the characteristic polynomial of A.

     For example, the following code finds the eigenvalues of A which are the roots of ‘poly (A)’.

          roots (poly (eye (3)))
              ⇒ 1.00001 + 0.00001i
                 1.00001 - 0.00001i
                 0.99999 + 0.00000i

     In fact, all three eigenvalues are exactly 1 which emphasizes that for numerical performance the ‘eig’ function should be used to compute eigenvalues.

     If X is a vector, ‘poly (X)’ is a vector of the coefficients of the polynomial whose roots are the elements of X.  That is, if C is a polynomial, then the elements of ‘D = roots (poly (C))’ are contained in C.  The vectors C and D are not identical, however, due to sorting and numerical errors.

     See also: roots, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
If A is a square N-by-N matrix, ‘poly (A)’ is the row vector of the coefficients of ‘det (z * eye (N) - A)’, the characteristic polynomial of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
polyaffine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- : polyaffine (F, MU)
     Return the coefficients of the polynomial vector F after an affine transformation.

     If F is the vector representing the polynomial f(x), then ‘G = polyaffine (F, MU)’ is the vector representing:

          g(x) = f( (x - MU(1)) / MU(2) )

     See also: polyval, polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Return the coefficients of the polynomial vector F after an affine transformation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 477
 -- : polyder (P)
 -- : [K] = polyder (A, B)
 -- : [Q, D] = polyder (B, A)
     Return the coefficients of the derivative of the polynomial whose coefficients are given by the vector P.

     If a pair of polynomials is given, return the derivative of the product A*B.

     If two inputs and two outputs are given, return the derivative of the polynomial quotient B/A.  The quotient numerator is in Q and the denominator in D.

     See also: polyint, polyval, polyreduce.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
Return the coefficients of the derivative of the polynomial whose coefficients are given by the vector P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyeig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 531
 -- : Z = polyeig (C0, C1, ..., CL)
 -- : [V, Z] = polyeig (C0, C1, ..., CL)

     Solve the polynomial eigenvalue problem of degree L.

     Given an N*N matrix polynomial

     ‘C(s) = C0 + C1 s + ... + CL s^l’

     ‘polyeig’ solves the eigenvalue problem

     ‘(C0 + C1 + ... + CL)v = 0’.

     Note that the eigenvalues Z are the zeros of the matrix polynomial.  Z is a row vector with N*L elements.  V is a matrix (N x N*L) with columns that correspond to the eigenvectors.

     See also: eig, eigs, compan.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Solve the polynomial eigenvalue problem of degree L.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyfit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1586
 -- : P = polyfit (X, Y, N)
 -- : [P, S] = polyfit (X, Y, N)
 -- : [P, S, MU] = polyfit (X, Y, N)
     Return the coefficients of a polynomial P(X) of degree N that minimizes the least-squares-error of the fit to the points ‘[X, Y]’.

     If N is a logical vector, it is used as a mask to selectively force the corresponding polynomial coefficients to be used or ignored.

     The polynomial coefficients are returned in a row vector.

     The optional output S is a structure containing the following fields:

     ‘R’
          Triangular factor R from the QR decomposition.

     ‘X’
          The Vandermonde matrix used to compute the polynomial coefficients.

     ‘C’
          The unscaled covariance matrix, formally equal to the inverse of X’*X, but computed in a way minimizing roundoff error propagation.

     ‘df’
          The degrees of freedom.

     ‘normr’
          The norm of the residuals.

     ‘yf’
          The values of the polynomial for each value of X.

     The second output may be used by ‘polyval’ to calculate the statistical error limits of the predicted values.  In particular, the standard deviation of P coefficients is given by

     ‘sqrt (diag (s.C)/s.df)*s.normr’.

     When the third output, MU, is present the coefficients, P, are associated with a polynomial in

     ‘XHAT = (X - MU(1)) / MU(2)’
     where MU(1) = mean (X), and MU(2) = std (X).

     This linear transformation of X improves the numerical stability of the fit.

     See also: polyval, polyaffine, roots, vander, zscore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Return the coefficients of a polynomial P(X) of degree N that minimizes the least-squares-error of the fit to the points ‘[X, Y]’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polygcd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 707
 -- : Q = polygcd (B, A)
 -- : Q = polygcd (B, A, TOL)

     Find the greatest common divisor of two polynomials.

     This is equivalent to the polynomial found by multiplying together all the common roots.  Together with deconv, you can reduce a ratio of two polynomials.

     The tolerance TOL defaults to ‘sqrt (eps)’.

     *Caution:* This is a numerically unstable algorithm and should not be used on large polynomials.

     Example code:

          polygcd (poly (1:8), poly (3:12)) - poly (3:8)
          ⇒ [ 0, 0, 0, 0, 0, 0, 0 ]
          deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
          ⇒ [ 0, 0, 0 ]

     See also: poly, roots, conv, deconv, residue.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Find the greatest common divisor of two polynomials.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 277
 -- : polyint (P)
 -- : polyint (P, K)
     Return the coefficients of the integral of the polynomial whose coefficients are represented by the vector P.

     The variable K is the constant of integration, which by default is set to zero.

     See also: polyder, polyval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return the coefficients of the integral of the polynomial whose coefficients are represented by the vector P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 424
 -- : polyout (C)
 -- : polyout (C, X)
 -- : STR = polyout (...)
     Display a formatted version of the polynomial C.

     The formatted polynomial

          c(x) = c(1) * x^n + ... + c(n) x + c(n+1)

     is returned as a string or written to the screen if ‘nargout’ is zero.

     The second argument X specifies the variable name to use for each term and defaults to the string "s".

     See also: polyreduce.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Display a formatted version of the polynomial C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
polyreduce


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- : polyreduce (C)
     Reduce a polynomial coefficient vector to a minimum number of terms by stripping off any leading zeros.

     See also: polyout.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Reduce a polynomial coefficient vector to a minimum number of terms by stripping off any leading zeros.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
polyval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 702
 -- : Y = polyval (P, X)
 -- : Y = polyval (P, X, [], MU)
 -- : [Y, DY] = polyval (P, X, S)
 -- : [Y, DY] = polyval (P, X, S, MU)

     Evaluate the polynomial P at the specified values of X.

     If X is a vector or matrix, the polynomial is evaluated for each of the elements of X.

     When MU is present, evaluate the polynomial for (X-MU(1))/MU(2).

     In addition to evaluating the polynomial, the second output represents the prediction interval, Y +/- DY, which contains at least 50% of the future predictions.  To calculate the prediction interval, the structured variable S, originating from ‘polyfit’, must be supplied.

     See also: polyvalm, polyaffine, polyfit, roots, poly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Evaluate the polynomial P at the specified values of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
polyvalm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 342
 -- : polyvalm (C, X)
     Evaluate a polynomial in the matrix sense.

     ‘polyvalm (C, X)’ will evaluate the polynomial in the matrix sense, i.e., matrix multiplication is used instead of element by element multiplication as used in ‘polyval’.

     The argument X must be a square matrix.

     See also: polyval, roots, poly.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Evaluate a polynomial in the matrix sense.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- : ppd = ppder (pp)
 -- : ppd = ppder (pp, m)
     Compute the piecewise M-th derivative of a piecewise polynomial struct PP.

     If M is omitted the first derivative is calculated.

     See also: mkpp, ppval, ppint.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Compute the piecewise M-th derivative of a piecewise polynomial struct PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
 -- : PPI = ppint (PP)
 -- : PPI = ppint (PP, C)
     Compute the integral of the piecewise polynomial struct PP.

     C, if given, is the constant of integration.

     See also: mkpp, ppval, ppder.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the integral of the piecewise polynomial struct PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ppjumps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 230
 -- : JUMPS = ppjumps (PP)
     Evaluate the boundary jumps of a piecewise polynomial.

     If there are n intervals, and the dimensionality of PP is d, the resulting array has dimensions ‘[d, n-1]’.

     See also: mkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Evaluate the boundary jumps of a piecewise polynomial.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ppval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 392
 -- : YI = ppval (PP, XI)
     Evaluate the piecewise polynomial structure PP at the points XI.

     If PP describes a scalar polynomial function, the result is an array of the same shape as XI.  Otherwise, the size of the result is ‘[pp.dim, length(XI)]’ if XI is a vector, or ‘[pp.dim, size(XI)]’ if it is a multi-dimensional array.

     See also: mkpp, unmkpp, spline, pchip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Evaluate the piecewise polynomial structure PP at the points XI.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
residue


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2359
 -- : [R, P, K, E] = residue (B, A)
 -- : [B, A] = residue (R, P, K)
 -- : [B, A] = residue (R, P, K, E)
     The first calling form computes the partial fraction expansion for the quotient of the polynomials, B and A.

     The quotient is defined as

          B(s)    M       r(m)        N
          ---- = SUM ------------- + SUM k(i)*s^(N-i)
          A(s)   m=1 (s-p(m))^e(m)   i=1

     where M is the number of poles (the length of the R, P, and E), the K vector is a polynomial of order N-1 representing the direct contribution, and the E vector specifies the multiplicity of the m-th residue’s pole.

     For example,

          b = [1, 1, 1];
          a = [1, -5, 8, -4];
          [r, p, k, e] = residue (b, a)
             ⇒ r = [-2; 7; 3]
             ⇒ p = [2; 2; 1]
             ⇒ k = [](0x0)
             ⇒ e = [1; 2; 1]

     which represents the following partial fraction expansion

                  s^2 + s + 1       -2        7        3
             ------------------- = ----- + ------- + -----
             s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)

     The second calling form performs the inverse operation and computes the reconstituted quotient of polynomials, B(s)/A(s), from the partial fraction expansion; represented by the residues, poles, and a direct polynomial specified by R, P and K, and the pole multiplicity E.

     If the multiplicity, E, is not explicitly specified the multiplicity is determined by the function ‘mpoles’.

     For example:

          r = [-2; 7; 3];
          p = [2; 2; 1];
          k = [1, 0];
          [b, a] = residue (r, p, k)
             ⇒ b = [1, -5, 9, -3, 1]
             ⇒ a = [1, -5, 8, -4]

          where mpoles is used to determine e = [1; 2; 1]

     Alternatively the multiplicity may be defined explicitly, for example,

          r = [7; 3; -2];
          p = [2; 1; 2];
          k = [1, 0];
          e = [2; 1; 1];
          [b, a] = residue (r, p, k, e)
             ⇒ b = [1, -5, 9, -3, 1]
             ⇒ a = [1, -5, 8, -4]

     which represents the following partial fraction expansion

           -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
          ----- + ------- + ----- + s = --------------------------
          (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4

     See also: mpoles, poly, roots, conv, deconv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
The first calling form computes the partial fraction expansion for the quotient of the polynomials, B and A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
roots


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 506
 -- : roots (C)

     Compute the roots of the polynomial C.

     For a vector C with N components, return the roots of the polynomial

          c(1) * x^(N-1) + ... + c(N-1) * x + c(N)

     As an example, the following code finds the roots of the quadratic polynomial

          p(x) = x^2 - 5.

          c = [1, 0, -5];
          roots (c)
          ⇒  2.2361
          ⇒ -2.2361

     Note that the true result is +/- sqrt(5) which is roughly +/- 2.2361.

     See also: poly, compan, fzero.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Compute the roots of the polynomial C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1289
 -- : PP = spline (X, Y)
 -- : YI = spline (X, Y, XI)
     Return the cubic spline interpolant of points X and Y.

     When called with two arguments, return the piecewise polynomial PP that may be used with ‘ppval’ to evaluate the polynomial at specific points.

     When called with a third input argument, ‘spline’ evaluates the spline at the points XI.  The third calling form ‘spline (X, Y, XI)’ is equivalent to ‘ppval (spline (X, Y), XI)’.

     The variable X must be a vector of length N.

     Y can be either a vector or array.  If Y is a vector it must have a length of either N or ‘N + 2’.  If the length of Y is N, then the "not-a-knot" end condition is used.  If the length of Y is ‘N + 2’, then the first and last values of the vector Y are the values of the first derivative of the cubic spline at the endpoints.

     If Y is an array, then the size of Y must have the form ‘[S1, S2, ..., SK, N]’ or ‘[S1, S2, ..., SK, N + 2]’.  The array is reshaped internally to a matrix where the leading dimension is given by ‘S1 * S2 * ... * SK’ and each row of this matrix is then treated separately.  Note that this is exactly the opposite of ‘interp1’ but is done for MATLAB compatibility.

     See also: pchip, ppval, mkpp, unmkpp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the cubic spline interpolant of points X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
splinefit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2589
 -- : PP = splinefit (X, Y, BREAKS)
 -- : PP = splinefit (X, Y, P)
 -- : PP = splinefit (..., "periodic", PERIODIC)
 -- : PP = splinefit (..., "robust", ROBUST)
 -- : PP = splinefit (..., "beta", BETA)
 -- : PP = splinefit (..., "order", ORDER)
 -- : PP = splinefit (..., "constraints", CONSTRAINTS)

     Fit a piecewise cubic spline with breaks (knots) BREAKS to the noisy data, X and Y.

     X is a vector, and Y is a vector or N-D array.  If Y is an N-D array, then X(j) is matched to Y(:,...,:,j).

     P is a positive integer defining the number of intervals along X, and P+1 is the number of breaks.  The number of points in each interval differ by no more than 1.

     The optional property PERIODIC is a logical value which specifies whether a periodic boundary condition is applied to the spline.  The length of the period is ‘max (BREAKS) - min (BREAKS)’.  The default value is ‘false’.

     The optional property ROBUST is a logical value which specifies if robust fitting is to be applied to reduce the influence of outlying data points.  Three iterations of weighted least squares are performed.  Weights are computed from previous residuals.  The sensitivity of outlier identification is controlled by the property BETA.  The value of BETA is restricted to the range, 0 < BETA < 1.  The default value is BETA = 1/2.  Values close to 0 give all data equal weighting.  Increasing values of BETA reduce the influence of outlying data.  Values close to unity may cause instability or rank deficiency.

     The fitted spline is returned as a piecewise polynomial, PP, and may be evaluated using ‘ppval’.

     The splines are constructed of polynomials with degree ORDER.  The default is a cubic, ORDER=3.  A spline with P pieces has P+ORDER degrees of freedom.  With periodic boundary conditions the degrees of freedom are reduced to P.

     The optional property, CONSTAINTS, is a structure specifying linear constraints on the fit.  The structure has three fields, "xc", "yc", and "cc".

     "xc"
          Vector of the x-locations of the constraints.

     "yc"
          Constraining values at the locations XC.  The default is an array of zeros.

     "cc"
          Coefficients (matrix).  The default is an array of ones.  The number of rows is limited to the order of the piecewise polynomials, ORDER.

     Constraints are linear combinations of derivatives of order 0 to ORDER-1 according to

          cc(1,j) * y(xc(j)) + cc(2,j) * y'(xc(j)) + ... = yc(:,...,:,j).

     See also: interp1, unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Fit a piecewise cubic spline with breaks (knots) BREAKS to the noisy data, X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unmkpp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 665
 -- : [X, P, N, K, D] = unmkpp (PP)

     Extract the components of a piecewise polynomial structure PP.

     The components are:

     X
          Sample points.

     P
          Polynomial coefficients for points in sample interval.  ‘P (I, :)’ contains the coefficients for the polynomial over interval I ordered from highest to lowest.  If ‘D > 1’, ‘P (R, I, :)’ contains the coefficients for the r-th polynomial defined on interval I.

     N
          Number of polynomial pieces.

     K
          Order of the polynomial plus 1.

     D
          Number of polynomials defined for each interval.

     See also: mkpp, ppval, spline, pchip.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Extract the components of a piecewise polynomial structure PP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 644
 -- : addpref ("GROUP", "PREF", VAL)
 -- : addpref ("GROUP", {"PREF1", "PREF2", ...}, {VAL1, VAL2, ...})
     Add the preference PREF and associated value VAL to the named preference group GROUP.

     The named preference group must be a string.

     The preference PREF may be a string or a cell array of strings.  An error will be issued if the preference already exists.

     The corresponding value VAL may be any Octave value, .e.g., double, struct, cell array, object, etc.  Or, if PREF is a cell array of strings then VAL must be a cell array of values with the same size as PREF.

     See also: setpref, getpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Add the preference PREF and associated value VAL to the named preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1162
 -- : VAL = getpref ("GROUP", "PREF")
 -- : VAL = getpref ("GROUP", "PREF", DEFAULT)
 -- : {VAL1, VAL2, ...} = getpref ("GROUP", {"PREF1", "PREF2", ...})
 -- : PREFSTRUCT = getpref ("GROUP")
 -- : PREFSTRUCT = getpref ()
     Return the preference value corresponding to the named preference PREF in the preference group GROUP.

     The named preference group must be a string.

     If PREF does not exist in GROUP and DEFAULT is specified, create the preference with value DEFAULT and return DEFAULT.

     The preference PREF may be a string or cell array of strings.  If it is a cell array of strings then a cell array of preferences is returned.

     The corresponding default value DEFAULT may be any Octave value, .e.g., double, struct, cell array, object, etc.  Or, if PREF is a cell array of strings then DEFAULT must be a cell array of values with the same size as PREF.

     If neither PREF nor DEFAULT are specified, return a structure of preferences for the preference group GROUP.

     If no arguments are specified, return a structure containing all groups of preferences and their values.

     See also: addpref, setpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
Return the preference value corresponding to the named preference PREF in the preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ispref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 443
 -- : ispref ("GROUP", "PREF")
 -- : ispref ("GROUP", {"PREF1", "PREF2", ...})
 -- : ispref ("GROUP")
     Return true if the named preference PREF exists in the preference group GROUP.

     The named preference group must be a string.

     The preference PREF may be a string or a cell array of strings.

     If PREF is not specified, return true if the preference group GROUP exists.

     See also: getpref, addpref, setpref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return true if the named preference PREF exists in the preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
prefdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 419
 -- : prefdir
 -- : prefdir (1)
 -- : DIR = prefdir
     Return the directory that holds the preferences for Octave.

     Examples:

     Display the preferences directory

          prefdir

     Change to the preferences folder

          cd (prefdir)

     If called with an argument, the preferences directory is created if it doesn’t already exist.

     See also: getpref, setpref, addpref, rmpref, ispref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the directory that holds the preferences for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
preferences


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- : preferences
     Display the GUI preferences dialog window for Octave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Display the GUI preferences dialog window for Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rmpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 479
 -- : rmpref ("GROUP", "PREF")
 -- : rmpref ("GROUP", {"PREF1", "PREF2", ...})
 -- : rmpref ("GROUP")
     Remove the named preference PREF from the preference group GROUP.

     The named preference group must be a string.

     The preference PREF may be a string or cell array of strings.

     If PREF is not specified, remove the preference group GROUP.

     It is an error to remove a nonexistent preference or group.

     See also: addpref, ispref, setpref, getpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Remove the named preference PREF from the preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
setpref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 645
 -- : setpref ("GROUP", "PREF", VAL)
 -- : setpref ("GROUP", {"PREF1", "PREF2", ...}, {VAL1, VAL2, ...})
     Set the preference PREF to the given VAL in the named preference group GROUP.

     The named preference group must be a string.

     The preference PREF may be a string or a cell array of strings.

     The corresponding value VAL may be any Octave value, .e.g., double, struct, cell array, object, etc.  Or, if PREF is a cell array of strings then VAL must be a cell array of values with the same size as PREF.

     If the named preference or group does not exist, it is added.

     See also: addpref, getpref, ispref, rmpref.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Set the preference PREF to the given VAL in the named preference group GROUP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
profexplore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 446
 -- : profexplore ()
 -- : profexplore (DATA)
     Interactively explore hierarchical profiler output.

     Assuming DATA is the structure with profile data returned by ‘profile ("info")’, this command opens an interactive prompt that can be used to explore the call-tree.  Type ‘help’ to get a list of possible commands.  If DATA is omitted, ‘profile ("info")’ is called and used in its place.

     See also: profile, profshow.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Interactively explore hierarchical profiler output.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
profexport


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 628
 -- : profexport (DIR)
 -- : profexport (DIR, DATA)
 -- : profexport (DIR, NAME)
 -- : profexport (DIR, NAME, DATA)

     Export profiler data as HTML.

     Export the profiling data in DATA into a series of HTML files in the folder DIR.  The initial file will be ‘DATA/index.html’.

     If NAME is specified, it must be a string that contains a “name” for the profile being exported.  This name is included in the HTML.

     The input DATA is the structure returned by ‘profile ("info")’.  If unspecified, ‘profexport’ will use the current profile dataset.

     See also: profshow, profexplore, profile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Export profiler data as HTML.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
profile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1464
 -- : profile on
 -- : profile off
 -- : profile resume
 -- : profile clear
 -- : S = profile ("status")
 -- : T = profile ("info")
     Control the built-in profiler.

     ‘profile on’
          Start the profiler, clearing all previously collected data if there is any.

     ‘profile off’
          Stop profiling.  The collected data can later be retrieved and examined with ‘T = profile ("info")’.

     ‘profile clear’
          Clear all collected profiler data.

     ‘profile resume’
          Restart profiling without clearing the old data.  All newly collected statistics are added to the existing ones.

     ‘S = profile ("status")’
          Return a structure with information about the current status of the profiler.  At the moment, the only field is ‘ProfilerStatus’ which is either "on" or "off".

     ‘T = profile ("info")’
          Return the collected profiling statistics in the structure T.  The flat profile is returned in the field ‘FunctionTable’ which is an array of structures, each entry corresponding to a function which was called and for which profiling statistics are present.  In addition, the field ‘Hierarchical’ contains the hierarchical call tree.  Each node has an index into the ‘FunctionTable’ identifying the function it corresponds to as well as data fields for number of calls and time spent at this level in the call tree.

          See also: profshow, profexplore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Control the built-in profiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
profshow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- : profshow (DATA)
 -- : profshow (DATA, N)
 -- : profshow ()
 -- : profshow (N)
     Display flat per-function profiler results.

     Print out profiler data (execution time, number of calls) for the most critical N functions.  The results are sorted in descending order by the total time spent in each function.  If N is unspecified it defaults to 20.

     The input DATA is the structure returned by ‘profile ("info")’.  If unspecified, ‘profshow’ will use the current profile dataset.

     The attribute column displays ‘R’ for recursive functions, and is blank for all other function types.

     See also: profexplore, profile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Display flat per-function profiler results.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
intersect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 624
 -- : C = intersect (A, B)
 -- : C = intersect (A, B, "rows")
 -- : [C, IA, IB] = intersect (...)

     Return the unique elements common to both A and B sorted in ascending order.

     If A and B are both row vectors then return a row vector; Otherwise, return a column vector.  The inputs may also be cell arrays of strings.

     If the optional input "rows" is given then return the common rows of A and B.  The inputs must be 2-D matrices to use this option.

     If requested, return index vectors IA and IB such that ‘C = A(IA)’ and ‘C = B(IB)’.

     See also: unique, union, setdiff, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the unique elements common to both A and B sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismember


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- : TF = ismember (A, S)
 -- : TF = ismember (A, S, "rows")
 -- : [TF, S_IDX] = ismember (...)

     Return a logical matrix TF with the same shape as A which is true (1) if the element in A is found in S and false (0) if it is not.

     If a second output argument is requested then the index into S of each matching element is also returned.

          a = [3, 10, 1];
          s = [0:9];
          [tf, s_idx] = ismember (a, s)
               ⇒ tf = [1, 0, 1]
               ⇒ s_idx = [4, 0, 2]

     The inputs A and S may also be cell arrays.

          a = {"abc"};
          s = {"abc", "def"};
          [tf, s_idx] = ismember (a, s)
               ⇒ tf = [1, 0]
               ⇒ s_idx = [1, 0]

     If the optional third argument "rows" is given then compare rows in A with rows in S.  The inputs must be 2-D matrices with the same number of columns to use this option.

          a = [1:3; 5:7; 4:6];
          s = [0:2; 1:3; 2:4; 3:5; 4:6];
          [tf, s_idx] = ismember (a, s, "rows")
               ⇒ tf = logical ([1; 0; 1])
               ⇒ s_idx = [2; 0; 5];

     See also: lookup, unique, union, intersect, setdiff, setxor.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
Return a logical matrix TF with the same shape as A which is true (1) if the element in A is found in S and false (0) if it is not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
powerset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- : powerset (A)
 -- : powerset (A, "rows")
     Compute the powerset (all subsets) of the set A.

     The set A must be a numerical matrix or a cell array of strings.  The output will always be a cell array of either vectors or strings.

     With the optional argument "rows", each row of the set A is considered one element of the set.  The input must be a 2-D numeric matrix to use this argument.

     See also: unique, union, intersect, setdiff, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the powerset (all subsets) of the set A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
setdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 580
 -- : C = setdiff (A, B)
 -- : C = setdiff (A, B, "rows")
 -- : [C, IA] = setdiff (...)
     Return the unique elements in A that are not in B sorted in ascending order.

     If A is a row vector return a row vector; Otherwise, return a column vector.  The inputs may also be cell arrays of strings.

     If the optional input "rows" is given then return the rows in A that are not in B.  The inputs must be 2-D matrices to use this option.

     If requested, return the index vector IA such that ‘C = A(IA)’.

     See also: unique, union, intersect, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the unique elements in A that are not in B sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setxor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- : C = setxor (A, B)
 -- : C = setxor (A, B, "rows")
 -- : [C, IA, IB] = setxor (...)

     Return the unique elements exclusive to sets A or B sorted in ascending order.

     If A and B are both row vectors then return a row vector; Otherwise, return a column vector.  The inputs may also be cell arrays of strings.

     If the optional input "rows" is given then return the rows exclusive to sets A and B.  The inputs must be 2-D matrices to use this option.

     If requested, return index vectors IA and IB such that ‘A(IA)’ and ‘B(IB)’ are disjoint sets whose union is C.

     See also: unique, union, intersect, setdiff, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return the unique elements exclusive to sets A or B sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
union


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 654
 -- : C = union (A, B)
 -- : C = union (A, B, "rows")
 -- : [C, IA, IB] = union (...)

     Return the unique elements that are in either A or B sorted in ascending order.

     If A and B are both row vectors then return a row vector; Otherwise, return a column vector.  The inputs may also be cell arrays of strings.

     If the optional input "rows" is given then return rows that are in either A or B.  The inputs must be 2-D matrices to use this option.

     The optional outputs IA and IB are index vectors such that ‘A(IA)’ and ‘B(IB)’ are disjoint sets whose union is C.

     See also: unique, intersect, setdiff, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return the unique elements that are in either A or B sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unique


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 923
 -- : unique (X)
 -- : unique (X, "rows")
 -- : [Y, I, J] = unique (...)
 -- : [Y, I, J] = unique (..., "first")
 -- : [Y, I, J] = unique (..., "last")
     Return the unique elements of X sorted in ascending order.

     If the input X is a column vector then return a column vector; Otherwise, return a row vector.  X may also be a cell array of strings.

     If the optional argument "rows" is given then return the unique rows of X sorted in ascending order.  The input must be a 2-D matrix to use this option.

     If requested, return index vectors I and J such that ‘Y = X(I)’ and ‘X = Y(J)’.

     Additionally, if I is a requested output then one of "first" or "last" may be given as an input.  If "last" is specified, return the highest possible indices in I, otherwise, if "first" is specified, return the lowest.  The default is "last".

     See also: union, intersect, setdiff, setxor, ismember.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the unique elements of X sorted in ascending order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arch_fit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 857
 -- : [A, B] = arch_fit (Y, X, P, ITER, GAMMA, A0, B0)
     Fit an ARCH regression model to the time series Y using the scoring algorithm in Engle’s original ARCH paper.

     The model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2

     in which e(t) is N(0, h(t)), given a time-series vector Y up to time t-1 and a matrix of (ordinary) regressors X up to t.  The order of the regression of the residual variance is specified by P.

     If invoked as ‘arch_fit (Y, K, P)’ with a positive integer K, fit an ARCH(K, P) process, i.e., do the above with the t-th row of X given by

          [1, y(t-1), ..., y(t-k)]

     Optionally, one can specify the number of iterations ITER, the updating factor GAMMA, and initial values a0 and b0 for the scoring algorithm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Fit an ARCH regression model to the time series Y using the scoring algorithm in Engle’s original ARCH paper.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arch_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 361
 -- : arch_rnd (A, B, T)
     Simulate an ARCH sequence of length T with AR coefficients B and CH coefficients A.

     The result y(t) follows the model

          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),

     where e(t), given Y up to time t-1, is N(0, h(t)), with

          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Simulate an ARCH sequence of length T with AR coefficients B and CH coefficients A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
arch_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 936
 -- : [PVAL, LM] = arch_test (Y, X, P)
     For a linear regression model

          y = x * b + e

     perform a Lagrange Multiplier (LM) test of the null hypothesis of no conditional heteroscedascity against the alternative of CH(P).

     I.e., the model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),

     given Y up to t-1 and X up to t, e(t) is N(0, h(t)) with

          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,

     and the null is a(1) == ... == a(p) == 0.

     If the second argument is a scalar integer, k, perform the same test in a linear autoregression model of order k, i.e., with

          [1, y(t-1), ..., y(t-K)]

     as the t-th row of X.

     Under the null, LM approximately has a chisquare distribution with P degrees of freedom and PVAL is the p-value (1 minus the CDF of this distribution at LM) of the test.

     If no output argument is given, the p-value is displayed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
For a linear regression model 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arma_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 584
 -- : arma_rnd (A, B, V, T, N)
     Return a simulation of the ARMA model.

     The ARMA model is defined by

          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)

     in which K is the length of vector A, L is the length of vector B and E is Gaussian white noise with variance V.  The function returns a vector of length T.

     The optional parameter N gives the number of dummy X(I) used for initialization, i.e., a sequence of length T+N is generated and X(N+1:T+N) is returned.  If N is omitted, N = 100 is used.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return a simulation of the ARMA model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
autoreg_matrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- : autoreg_matrix (Y, K)
     Given a time series (vector) Y, return a matrix with ones in the first column and the first K lagged values of Y in the other columns.

     In other words, for T > K, ‘[1, Y(T-1), ..., Y(T-K)]’ is the t-th row of the result.

     The resulting matrix may be used as a regressor matrix in autoregressions.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
Given a time series (vector) Y, return a matrix with ones in the first column and the first K lagged values of Y in the other columns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bartlett


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 233
 -- : bartlett (M)
     Return the filter coefficients of a Bartlett (triangular) window of length M.

     For a definition of the Bartlett window see, e.g., A.V. Oppenheim & R. W. Schafer, ‘Discrete-Time Signal Processing’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return the filter coefficients of a Bartlett (triangular) window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
blackman


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- : blackman (M)
 -- : blackman (M, "periodic")
 -- : blackman (M, "symmetric")
     Return the filter coefficients of a Blackman window of length M.

     If the optional argument "periodic" is given, the periodic form of the window is returned.  This is equivalent to the window of length M+1 with the last coefficient removed.  The optional argument "symmetric" is equivalent to not specifying a second argument.

     For a definition of the Blackman window, see, e.g., A.V. Oppenheim & R. W. Schafer, ‘Discrete-Time Signal Processing’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return the filter coefficients of a Blackman window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
detrend


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- : detrend (X, P)
     If X is a vector, ‘detrend (X, P)’ removes the best fit of a polynomial of order P from the data X.

     If X is a matrix, ‘detrend (X, P)’ does the same for each column in X.

     The second argument P is optional.  If it is not specified, a value of 1 is assumed.  This corresponds to removing a linear trend.

     The order of the polynomial can also be given as a string, in which case P must be either "constant" (corresponds to ‘P=0’) or "linear" (corresponds to ‘P=1’).

     See also: polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
If X is a vector, ‘detrend (X, P)’ removes the best fit of a polynomial of order P from the data X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
diffpara


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 693
 -- : [D, DD] = diffpara (X, A, B)
     Return the estimator D for the differencing parameter of an integrated time series.

     The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the estimation.  If B is omitted, the interval [2*pi/T, 2*pi*a/T] is used.  If both B and A are omitted then a = 0.5 * sqrt (T) and b = 1.5 * sqrt (T) is used, where T is the sample size.  If X is a matrix, the differencing parameter of each column is estimated.

     The estimators for all frequencies in the intervals described above is returned in DD.

     The value of D is simply the mean of DD.

     Reference: P.J. Brockwell & R.A. Davis.  ‘Time Series: Theory and Methods’.  Springer 1987.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 83
Return the estimator D for the differencing parameter of an integrated time series.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
durbinlevinson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 380
 -- : durbinlevinson (C, OLDPHI, OLDV)
     Perform one step of the Durbin-Levinson algorithm.

     The vector C specifies the autocovariances ‘[gamma_0, ..., gamma_t]’ from lag 0 to T, OLDPHI specifies the coefficients based on C(T-1) and OLDV specifies the corresponding error.

     If OLDPHI and OLDV are omitted, all steps from 1 to T of the algorithm are performed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Perform one step of the Durbin-Levinson algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fftconv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- : fftconv (X, Y)
 -- : fftconv (X, Y, N)
     Convolve two vectors using the FFT for computation.

     ‘c = fftconv (X, Y)’ returns a vector of length equal to ‘length (X) + length (Y) - 1’.  If X and Y are the coefficient vectors of two polynomials, the returned value is the coefficient vector of the product polynomial.

     The computation uses the FFT by calling the function ‘fftfilt’.  If the optional argument N is specified, an N-point FFT is used.

     See also: deconv, conv, conv2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Convolve two vectors using the FFT for computation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fftfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- : fftfilt (B, X)
 -- : fftfilt (B, X, N)
     Filter X with the FIR filter B using the FFT.

     If X is a matrix, filter each column of the matrix.

     Given the optional third argument, N, ‘fftfilt’ uses the overlap-add method to filter X with B using an N-point FFT.  The FFT size must be an even power of 2 and must be greater than or equal to the length of B.  If the specified N does not meet these criteria, it is automatically adjusted to the nearest value that does.

     See also: filter, filter2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Filter X with the FIR filter B using the FFT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fftshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 701
 -- : fftshift (X)
 -- : fftshift (X, DIM)
     Perform a shift of the vector X, for use with the ‘fft’ and ‘ifft’ functions, in order to move the frequency 0 to the center of the vector or matrix.

     If X is a vector of N elements corresponding to N time samples spaced by dt, then ‘fftshift (fft (X))’ corresponds to frequencies

          f = [ -(ceil((N-1)/2):-1:1), 0, (1:floor((N-1)/2)) ] * df

     where df = 1 / (N * dt).

     If X is a matrix, the same holds for rows and columns.  If X is an array, then the same holds along each dimension.

     The optional DIM argument can be used to limit the dimension along which the permutation occurs.

     See also: ifftshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
Perform a shift of the vector X, for use with the ‘fft’ and ‘ifft’ functions, in order to move the frequency 0 to the center of the vector or matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
filter2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- : Y = filter2 (B, X)
 -- : Y = filter2 (B, X, SHAPE)
     Apply the 2-D FIR filter B to X.

     If the argument SHAPE is specified, return an array of the desired shape.  Possible values are:

     "full"
          pad X with zeros on all sides before filtering.

     "same"
          unpadded X (default)

     "valid"
          trim X after filtering so edge effects are no included.

     Note this is just a variation on convolution, with the parameters reversed and B rotated 180 degrees.

     See also: conv2.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Apply the 2-D FIR filter B to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
fractdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- : fractdiff (X, D)
     Compute the fractional differences (1-L)^d x where L denotes the lag-operator and d is greater than -1.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Compute the fractional differences (1-L)^d x where L denotes the lag-operator and d is greater than -1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
freqz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1336
 -- : [H, W] = freqz (B, A, N, "whole")
 -- : [H, W] = freqz (B)
 -- : [H, W] = freqz (B, A)
 -- : [H, W] = freqz (B, A, N)
 -- : H = freqz (B, A, W)
 -- : [H, W] = freqz (..., FS)
 -- : freqz (...)

     Return the complex frequency response H of the rational IIR filter whose numerator and denominator coefficients are B and A, respectively.

     The response is evaluated at N angular frequencies between 0 and 2*pi.

     The output value W is a vector of the frequencies.

     If A is omitted, the denominator is assumed to be 1 (this corresponds to a simple FIR filter).

     If N is omitted, a value of 512 is assumed.  For fastest computation, N should factor into a small number of small primes.

     If the fourth argument, "whole", is omitted the response is evaluated at frequencies between 0 and pi.

     ‘freqz (B, A, W)’

     Evaluate the response at the specific frequencies in the vector W.  The values for W are measured in radians.

     ‘[...] = freqz (..., FS)’

     Return frequencies in Hz instead of radians assuming a sampling rate FS.  If you are evaluating the response at specific frequencies W, those frequencies should be requested in Hz rather than radians.

     ‘freqz (...)’

     Plot the magnitude and phase response of H rather than returning them.

     See also: freqz_plot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
Return the complex frequency response H of the rational IIR filter whose numerator and denominator coefficients are B and A, respectively.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
freqz_plot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- : freqz_plot (W, H)
 -- : freqz_plot (W, H, FREQ_NORM)
     Plot the magnitude and phase response of H.

     If the optional FREQ_NORM argument is true, the frequency vector W is in units of normalized radians.  If FREQ_NORM is false, or not given, then W is measured in Hertz.

     See also: freqz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Plot the magnitude and phase response of H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hamming


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 544
 -- : hamming (M)
 -- : hamming (M, "periodic")
 -- : hamming (M, "symmetric")
     Return the filter coefficients of a Hamming window of length M.

     If the optional argument "periodic" is given, the periodic form of the window is returned.  This is equivalent to the window of length M+1 with the last coefficient removed.  The optional argument "symmetric" is equivalent to not specifying a second argument.

     For a definition of the Hamming window see, e.g., A.V. Oppenheim & R. W. Schafer, ‘Discrete-Time Signal Processing’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the filter coefficients of a Hamming window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hanning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 544
 -- : hanning (M)
 -- : hanning (M, "periodic")
 -- : hanning (M, "symmetric")
     Return the filter coefficients of a Hanning window of length M.

     If the optional argument "periodic" is given, the periodic form of the window is returned.  This is equivalent to the window of length M+1 with the last coefficient removed.  The optional argument "symmetric" is equivalent to not specifying a second argument.

     For a definition of the Hanning window see, e.g., A.V. Oppenheim & R. W. Schafer, ‘Discrete-Time Signal Processing’.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the filter coefficients of a Hanning window of length M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hurst


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- : hurst (X)
     Estimate the Hurst parameter of sample X via the rescaled range statistic.

     If X is a matrix, the parameter is estimated for every column.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Estimate the Hurst parameter of sample X via the rescaled range statistic.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ifftshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 220
 -- : ifftshift (X)
 -- : ifftshift (X, DIM)
     Undo the action of the ‘fftshift’ function.

     For even length X, ‘fftshift’ is its own inverse, but odd lengths differ slightly.

     See also: fftshift.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Undo the action of the ‘fftshift’ function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
periodogram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1836
 -- : [PXX, W] = periodogram (X)
 -- : [PXX, W] = periodogram (X, WIN)
 -- : [PXX, W] = periodogram (X, WIN, NFFT)
 -- : [PXX, F] = periodogram (X, WIN, NFFT, FS)
 -- : [PXX, F] = periodogram (..., "RANGE")
 -- : periodogram (...)
     Return the periodogram (Power Spectral Density) of X.

     The possible inputs are:

     X

          data vector.  If X is real-valued a one-sided spectrum is estimated.  If X is complex-valued, or "RANGE" specifies "twosided", the full spectrum is estimated.

     WIN
          window weight data.  If window is empty or unspecified a default rectangular window is used.  Otherwise, the window is applied to the signal (‘X .* WIN’) before computing the periodogram.  The window data must be a vector of the same length as X.

     NFFT
          number of frequency bins.  The default is 256 or the next higher power of 2 greater than the length of X (‘max (256, 2.^nextpow2 (length (x)))’).  If NFFT is greater than the length of the input then X will be zero-padded to the length of NFFT.

     FS
          sampling rate.  The default is 1.

     RANGE
          range of spectrum.  "onesided" computes spectrum from [0:nfft/2+1].  "twosided" computes spectrum from [0:nfft-1].

     The optional second output W are the normalized angular frequencies.  For a one-sided calculation W is in the range [0, pi] if NFFT is even and [0, pi) if NFFT is odd.  Similarly, for a two-sided calculation W is in the range [0, 2*pi] or [0, 2*pi) depending on NFFT.

     If a sampling frequency is specified, FS, then the output frequencies F will be in the range [0, FS/2] or [0, FS/2) for one-sided calculations.  For two-sided calculations the range will be [0, FS).

     When called with no outputs the periodogram is immediately plotted in the current figure window.

     See also: fft.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return the periodogram (Power Spectral Density) of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sinc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
 -- : sinc (X)
     Compute the sinc function.

     Return sin (pi*x) / (pi*x).
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Compute the sinc function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sinetone


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- : sinetone (FREQ, RATE, SEC, AMPL)
     Return a sinetone of frequency FREQ with a length of SEC seconds at sampling rate RATE and with amplitude AMPL.

     The arguments FREQ and AMPL may be vectors of common size.

     The defaults are RATE = 8000, SEC = 1, and AMPL = 64.

     See also: sinewave.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Return a sinetone of frequency FREQ with a length of SEC seconds at sampling rate RATE and with amplitude AMPL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sinewave


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 216
 -- : sinewave (M, N, D)
     Return an M-element vector with I-th element given by ‘sin (2 * pi * (I+D-1) / N)’.

     The default value for D is 0 and the default value for N is M.

     See also: sinetone.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return an M-element vector with I-th element given by ‘sin (2 * pi * (I+D-1) / N)’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
spectral_adf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 453
 -- : spectral_adf (C)
 -- : spectral_adf (C, WIN)
 -- : spectral_adf (C, WIN, B)
     Return the spectral density estimator given a vector of autocovariances C, window name WIN, and bandwidth, B.

     The window name, e.g., "triangle" or "rectangle" is used to search for a function called ‘WIN_lw’.

     If WIN is omitted, the triangle window is used.

     If B is omitted, ‘1 / sqrt (length (X))’ is used.

     See also: spectral_xdf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
Return the spectral density estimator given a vector of autocovariances C, window name WIN, and bandwidth, B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
spectral_xdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 439
 -- : spectral_xdf (X)
 -- : spectral_xdf (X, WIN)
 -- : spectral_xdf (X, WIN, B)
     Return the spectral density estimator given a data vector X, window name WIN, and bandwidth, B.

     The window name, e.g., "triangle" or "rectangle" is used to search for a function called ‘WIN_sw’.

     If WIN is omitted, the triangle window is used.

     If B is omitted, ‘1 / sqrt (length (X))’ is used.

     See also: spectral_adf.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return the spectral density estimator given a data vector X, window name WIN, and bandwidth, B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spencer


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- : spencer (X)
     Return Spencer’s 15 point moving average of each column of X.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return Spencer’s 15 point moving average of each column of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1138
 -- : Y = stft (X)
 -- : Y = stft (X, WIN_SIZE)
 -- : Y = stft (X, WIN_SIZE, INC)
 -- : Y = stft (X, WIN_SIZE, INC, NUM_COEF)
 -- : Y = stft (X, WIN_SIZE, INC, NUM_COEF, WIN_TYPE)
 -- : [Y, C] = stft (...)
     Compute the short-time Fourier transform of the vector X with NUM_COEF coefficients by applying a window of WIN_SIZE data points and an increment of INC points.

     Before computing the Fourier transform, one of the following windows is applied:

     "hanning"
          win_type = 1

     "hamming"
          win_type = 2

     "rectangle"
          win_type = 3

     The window names can be passed as strings or by the WIN_TYPE number.

     The following defaults are used for unspecified arguments: WIN_SIZE = 80, INC = 24, NUM_COEF = 64, and WIN_TYPE = 1.

     ‘Y = stft (X, ...)’ returns the absolute values of the Fourier coefficients according to the NUM_COEF positive frequencies.

     ‘[Y, C] = stft (X, ...)’ returns the entire STFT-matrix Y and a 3-element vector C containing the window size, increment, and window type, which is needed by the ‘synthesis’ function.

     See also: synthesis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
Compute the short-time Fourier transform of the vector X with NUM_COEF coefficients by applying a window of WIN_SIZE data points and an increment of INC points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
synthesis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 269
 -- : X = synthesis (Y, C)
     Compute a signal from its short-time Fourier transform Y and a 3-element vector C specifying window size, increment, and window type.

     The values Y and C can be derived by

          [Y, C] = stft (X , ...)

     See also: stft.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
Compute a signal from its short-time Fourier transform Y and a 3-element vector C specifying window size, increment, and window type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unwrap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- : B = unwrap (X)
 -- : B = unwrap (X, TOL)
 -- : B = unwrap (X, TOL, DIM)

     Unwrap radian phases by adding or subtracting multiples of 2*pi as appropriate to remove jumps greater than TOL.

     TOL defaults to pi.

     Unwrap will work along the dimension DIM.  If DIM is unspecified it defaults to the first non-singleton dimension.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Unwrap radian phases by adding or subtracting multiples of 2*pi as appropriate to remove jumps greater than TOL.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
yulewalker


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- : [A, V] = yulewalker (C)
     Fit an AR (p)-model with Yule-Walker estimates given a vector C of autocovariances ‘[gamma_0, ..., gamma_p]’.

     Returns the AR coefficients, A, and the variance of white noise, V.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
Fit an AR (p)-model with Yule-Walker estimates given a vector C of autocovariances ‘[gamma_0, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
bicg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5781
 -- : X = bicg (A, B)
 -- : X = bicg (A, B, TOL)
 -- : X = bicg (A, B, TOL, MAXIT)
 -- : X = bicg (A, B, TOL, MAXIT, M)
 -- : X = bicg (A, B, TOL, MAXIT, M1, M2)
 -- : X = bicg (A, B, TOL, MAXIT, M, [], X0)
 -- : X = bicg (A, B, TOL, MAXIT, M1, M2, X0)
 -- : X = bicg (A, B, TOL, MAXIT, M, [], X0, ...)
 -- : X = bicg (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = bicg (A, B, ...)
     Solve the linear system of equations ‘A * X = B’ by means of the Bi-Conjugate Gradient iterative method.

     The input arguments are:

        • A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun (x, "notransp") = A * x’ and ‘Afun (x, "transp") = A' * x’.  Additional parameters to ‘Afun’ may be passed after X0.

        • B is the right-hand side vector.  It must be a column vector with the same number of rows as A.

        • TOL is the required relative tolerance for the residual error, ‘B - A * X’.  The iteration stops if ‘norm (B - A * X)’ ≤ ‘TOL * norm (B)’.  If TOL is omitted or empty, then a tolerance of 1e-6 is used.

        • MAXIT is the maximum allowed number of iterations; if MAXIT is omitted or empty then a value of 20 is used.

        • M1, M2 are the preconditioners.  The preconditioner M is given as ‘M = M1 * M2’.  Both M1 and M2 can be passed as a matrix or as a function handle or inline function ‘g’ such that ‘g (X, "notransp") = M1 \ X’ or ‘g (X, "notransp") = M2 \ X’ and ‘g (X, "transp") = M1' \ X’ or ‘g (X, "transp") = M2' \ X’.  If M1 is omitted or empty, then preconditioning is not applied.  The preconditioned system is theoretically equivalent to applying the ‘bicg’ method to the linear system ‘inv (M1) * A * inv (M2) * Y = inv (M1) * B’ and ‘inv (M2') * A' * inv (M1') * Z = inv (M2') * B’ and then setting ‘X = inv (M2) * Y’.

        • X0 is the initial guess.  If X0 is omitted or empty then the function sets X0 to a zero vector by default.

     Any arguments which follow X0 are treated as parameters, and passed in an appropriate manner to any of the functions (AFUN or MFUN) or that have been given to ‘bicg’.

     The output parameters are:

        • X is the computed approximation to the solution of ‘A * X = B’.  If the algorithm did not converge, then X is the iteration which has the minimum residual.

        • FLAG indicates the exit status:

             • 0: The algorithm converged to within the prescribed tolerance.

             • 1: The algorithm did not converge and it reached the maximum number of iterations.

             • 2: The preconditioner matrix is singular.

             • 3: The algorithm stagnated, i.e., the absolute value of the difference between the current iteration X and the previous is less than ‘eps * norm (X,2)’.

             • 4: The algorithm could not continue because intermediate values became too small or too large for reliable computation.

        • RELRES is the ratio of the final residual to its initial value, measured in the Euclidean norm.

        • ITER is the iteration which X is computed.

        • RESVEC is a vector containing the residual at each iteration.  The total number of iterations performed is given by ‘length (RESVEC) - 1’.

     Consider a trivial problem with a tridiagonal matrix

          n = 20;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
              toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
                        sparse (1, 2, 1, 1, n) * n / 2);
          b = A * ones (n, 1);
          restart = 5;
          [M1, M2] = ilu (A);  # in this tridiag case, it corresponds to lu (A)
          M = M1 * M2;
          Afun = @(x, string) strcmp (string, "notransp") * (A * x) + ...
                               strcmp (string, "transp") * (A' * x);
          Mfun = @(x, string) strcmp (string, "notransp") * (M \ x) + ...
                               strcmp (string, "transp") * (M' \ x);
          M1fun = @(x, string) strcmp (string, "notransp") * (M1 \ x) + ...
                               strcmp (string, "transp") * (M1' \ x);
          M2fun = @(x, string) strcmp (string, "notransp") * (M2 \ x) + ...
                               strcmp (string, "transp") * (M2' \ x);

     EXAMPLE 1: simplest usage of ‘bicg’

          x = bicg (A, b)

     EXAMPLE 2: ‘bicg’ with a function that computes ‘A*X’ and ‘A'*X’

          x = bicg (Afun, b, [], n)

     EXAMPLE 3: ‘bicg’ with a preconditioner matrix M

          x = bicg (A, b, 1e-6, n, M)

     EXAMPLE 4: ‘bicg’ with a function as preconditioner

          x = bicg (Afun, b, 1e-6, n, Mfun)

     EXAMPLE 5: ‘bicg’ with preconditioner matrices M1 and M2

          x = bicg (A, b, 1e-6, n, M1, M2)

     EXAMPLE 6: ‘bicg’ with functions as preconditioners

          x = bicg (Afun, b, 1e-6, n, M1fun, M2fun)

     EXAMPLE 7: ‘bicg’ with as input a function requiring an argument

          function y = Ap (A, x, string, z)
            ## compute A^z * x or (A^z)' * x
            y = x;
            if (strcmp (string, "notransp"))
              for i = 1:z
                y = A * y;
              endfor
            elseif (strcmp (string, "transp"))
              for i = 1:z
                y = A' * y;
              endfor
            endif
          endfunction

          Apfun = @(x, string, p) Ap (A, x, string, p);
          x = bicg (Apfun, b, [], [], [], [], [], 2);

     References:

       1. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, Second edition, 2003, SIAM.

     See also: bicgstab, cgs, gmres, pcg, qmr, tfqmr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Solve the linear system of equations ‘A * X = B’ by means of the Bi-Conjugate Gradient iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bicgstab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4906
 -- : X = bicgstab (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- : X = bicgstab (A, B, TOL, MAXIT, M, [], X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = bicgstab (A, B, ...)
     Solve ‘A x = b’ using the stabilizied Bi-conjugate gradient iterative method.

     The input parameters are:

        − A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun(x) = A * x’.  Additional parameters to ‘Afun’ are passed after X0.

        − B is the right hand side vector.  It must be a column vector with the same number of rows as A.

        − TOL is the required relative tolerance for the residual error, ‘B - A * X’.  The iteration stops if ‘norm (B - A * X)’ ≤ ‘TOL * norm (B)’.  If TOL is omitted or empty, then a tolerance of 1e-6 is used.

        − MAXIT the maximum number of outer iterations, if not given or set to [] the default value ‘min (20, numel (b))’ is used.

        − M1, M2 are the preconditioners.  The preconditioner M is given as ‘M = M1 * M2’.  Both M1 and M2 can be passed as a matrix or as a function handle or inline function ‘g’ such that ‘g(X) = M1 \ X’ or ‘g(X) = M2 \ X’.  The technique used is the right preconditioning, i.e., it is solved ‘A * inv (M) * Y = B’ and then ‘X = inv (M) * Y’.

        − X0 the initial guess, if not given or set to [] the default value ‘zeros (size (B))’ is used.

     The arguments which follow X0 are treated as parameters, and passed in a proper way to any of the functions (A or M) which are passed to ‘bicstab’.

     The output parameters are:

        − X is the approximation computed.  If the method doesn’t converge then it is the iterated with the minimum residual.

        − FLAG indicates the exit status:

             − 0: iteration converged to the within the chosen tolerance

             − 1: the maximum number of iterations was reached before convergence

             − 2: the preconditioner matrix is singular

             − 3: the algorithm reached stagnation

             − 4: the algorithm can’t continue due to a division by zero

        − RELRES is the relative residual obtained with as ‘(A*X-B) / norm(B)’.

        − ITER is the (possibily half) iteration which X is computed.  If it is an half iteration then it is ‘ITER + 0.5’

        − RESVEC is a vector containing the residual of each half and total iteration (There are also the half iterations since X is computed in two steps at each iteration).  Doing ‘(length(RESVEC) - 1) / 2’ is possible to see the total number of (total) iterations performed.

     Let us consider a trivial problem with a tridiagonal matrix

          n = 20;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
              toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
          b = A * ones (n, 1);
          restart = 5;
          [M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
          M = M1 * M2;
          Afun = @(x) A * x;
          Mfun = @(x) M \ x;
          M1fun = @(x) M1 \ x;
          M2fun = @(x) M2 \ x;

     EXAMPLE 1: simplest usage of ‘bicgstab’

          x = bicgstab (A, b, [], n)

     EXAMPLE 2: ‘bicgstab’ with a function which computes ‘A * X’

          x = bicgstab (Afun, b, [], n)

     EXAMPLE 3: ‘bicgstab’ with a preconditioner matrix M

          x = bicgstab (A, b, [], 1e-06, n, M)

     EXAMPLE 4: ‘bicgstab’ with a function as preconditioner

          x = bicgstab (Afun, b, 1e-6, n, Mfun)

     EXAMPLE 5: ‘bicgstab’ with preconditioner matrices M1 and M2

          x = bicgstab (A, b, [], 1e-6, n, M1, M2)

     EXAMPLE 6: ‘bicgstab’ with functions as preconditioners

          x = bicgstab (Afun, b, 1e-6, n, M1fun, M2fun)

     EXAMPLE 7: ‘bicgstab’ with as input a function requiring an argument

          function y = Ap (A, x, z) # compute A^z * x
             y = x;
             for i = 1:z
               y = A * y;
             endfor
           endfunction
          Apfun = @(x, string, p) Ap (A, x, string, p);
          x = bicgstab (Apfun, b, [], [], [], [], [], 2);

     EXAMPLE 8: explicit example to show that ‘bicgstab’ uses a right preconditioner

          [M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
          M = M1 * M2;

          ## reference solution computed by bicgstab after one iteration
          [x_ref, fl] = bicgstab (A, b, [], 1, M)

          ## right preconditioning
          [y, fl] = bicgstab (A / M, b, [], 1)
          x = M \ y # compare x and x_ref


     References:

       1. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, Second edition, 2003, SIAM

     See also: bicg, cgs, gmres, pcg, qmr, tfqmr.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
Solve ‘A x = b’ using the stabilizied Bi-conjugate gradient iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cgs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4558
 -- : X = cgs (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- : X = cgs (A, B, TOL, MAXIT, M, [], X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = cgs (A, B, ...)
     Solve ‘A x = b’, where A is a square matrix, using the Conjugate Gradients Squared method.

     The input arguments are:

        − A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun(x) = A * x’.  Additional parameters to ‘Afun’ are passed after X0.

        − B is the right hand side vector.  It must be a column vector with same number of rows of A.

        − TOL is the relative tolerance, if not given or set to [] the default value 1e-6 is used.

        − MAXIT the maximum number of outer iterations, if not given or set to [] the default value ‘min (20, numel (b))’ is used.

        − M1, M2 are the preconditioners.  The preconditioner matrix is given as ‘M = M1 * M2’.  Both M1 and M2 can be passed as a matrix or as a function handle or inline function ‘g’ such that ‘g(x) = M1 \ x’ or ‘g(x) = M2 \ x’.  If M1 is empty or not passed then no preconditioners are applied.  The technique used is the right preconditioning, i.e., it is solved ‘A*inv(M)*y = b’ and then ‘X = inv(M)*y’.

        − X0 the initial guess, if not given or set to [] the default value ‘zeros (size (b))’ is used.

     The arguments which follow X0 are treated as parameters, and passed in a proper way to any of the functions (A or P) which are passed to ‘cgs’.

     The output parameters are:

        − X is the approximation computed.  If the method doesn’t converge then it is the iterated with the minimum residual.

        − FLAG indicates the exit status:

             − 0: iteration converged to the within the chosen tolerance

             − 1: the maximum number of iterations was reached before convergence

             − 2: the preconditioner matrix is singular

             − 3: the algorithm reached stagnation

             − 4: the algorithm can’t continue due to a division by zero

        − RELRES is the relative residual obtained with as ‘(A*X-B) / norm(B)’.

        − ITER is the iteration which X is computed.

        − RESVEC is a vector containing the residual at each iteration.  Doing ‘length(RESVEC) - 1’ is possible to see the total number of iterations performed.

     Let us consider a trivial problem with a tridiagonal matrix

          n = 20;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
              toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
          b = A * ones (n, 1);
          restart = 5;
          [M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
          M = M1 * M2;
          Afun = @(x) A * x;
          Mfun = @(x) M \ x;
          M1fun = @(x) M1 \ x;
          M2fun = @(x) M2 \ x;

     EXAMPLE 1: simplest usage of ‘cgs’

          x = cgs (A, b, [], n)

     EXAMPLE 2: ‘cgs’ with a function which computes ‘A * X’

          x = cgs (Afun, b, [], n)

     EXAMPLE 3: ‘cgs’ with a preconditioner matrix M

          x = cgs (A, b, [], 1e-06, n, M)

     EXAMPLE 4: ‘cgs’ with a function as preconditioner

          x = cgs (Afun, b, 1e-6, n, Mfun)

     EXAMPLE 5: ‘cgs’ with preconditioner matrices M1 and M2

          x = cgs (A, b, [], 1e-6, n, M1, M2)

     EXAMPLE 6: ‘cgs’ with functions as preconditioners

          x = cgs (Afun, b, 1e-6, n, M1fun, M2fun)

     EXAMPLE 7: ‘cgs’ with as input a function requiring an argument

          function y = Ap (A, x, z) # compute A^z * x
             y = x;
             for i = 1:z
               y = A * y;
             endfor
           endfunction
          Apfun = @(x, string, p) Ap (A, x, string, p);
          x = cgs (Apfun, b, [], [], [], [], [], 2);

     EXAMPLE 8: explicit example to show that ‘cgs’ uses a right preconditioner

          [M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
          M = M1 * M2;

          ## reference solution computed by cgs after one iteration
          [x_ref, fl] = cgs (A, b, [], 1, M)

          ## right preconditioning
          [y, fl] = cgs (A / M, b, [], 1)
          x = M \ y # compare x and x_ref


     References:

       1. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, Second edition, 2003, SIAM

     See also: pcg, bicgstab, bicg, gmres, qmr, tfqmr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Solve ‘A x = b’, where A is a square matrix, using the Conjugate Gradients Squared method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
colperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 304
 -- : P = colperm (S)
     Return the column permutations such that the columns of ‘S (:, P)’ are ordered in terms of increasing number of nonzero elements.

     If S is symmetric, then P is chosen such that ‘S (P, P)’ orders the rows and columns with increasing number of nonzeros elements.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
Return the column permutations such that the columns of ‘S (:, P)’ are ordered in terms of increasing number of nonzero elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
eigs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5461
 -- : D = eigs (A)
 -- : D = eigs (A, K)
 -- : D = eigs (A, K, SIGMA)
 -- : D = eigs (A, K, SIGMA, OPTS)
 -- : D = eigs (A, B)
 -- : D = eigs (A, B, K)
 -- : D = eigs (A, B, K, SIGMA)
 -- : D = eigs (A, B, K, SIGMA, OPTS)
 -- : D = eigs (AF, N)
 -- : D = eigs (AF, N, B)
 -- : D = eigs (AF, N, K)
 -- : D = eigs (AF, N, B, K)
 -- : D = eigs (AF, N, K, SIGMA)
 -- : D = eigs (AF, N, B, K, SIGMA)
 -- : D = eigs (AF, N, K, SIGMA, OPTS)
 -- : D = eigs (AF, N, B, K, SIGMA, OPTS)
 -- : [V, D] = eigs (A, ...)
 -- : [V, D] = eigs (AF, N, ...)
 -- : [V, D, FLAG] = eigs (A, ...)
 -- : [V, D, FLAG] = eigs (AF, N, ...)
     Calculate a limited number of eigenvalues and eigenvectors of A, based on a selection criteria.

     The number of eigenvalues and eigenvectors to calculate is given by K and defaults to 6.

     By default, ‘eigs’ solve the equation ‘A * v = lambda * v’, where ‘lambda’ is a scalar representing one of the eigenvalues, and ‘v’ is the corresponding eigenvector.  If given the positive definite matrix B then ‘eigs’ solves the general eigenvalue equation ‘A * v = lambda * B * v’.

     The argument SIGMA determines which eigenvalues are returned.  SIGMA can be either a scalar or a string.  When SIGMA is a scalar, the K eigenvalues closest to SIGMA are returned.  If SIGMA is a string, it must have one of the following values.

     "lm"
          Largest Magnitude (default).

     "sm"
          Smallest Magnitude.

     "la"
          Largest Algebraic (valid only for real symmetric problems).

     "sa"
          Smallest Algebraic (valid only for real symmetric problems).

     "be"
          Both Ends, with one more from the high-end if K is odd (valid only for real symmetric problems).

     "lr"
          Largest Real part (valid only for complex or unsymmetric problems).

     "sr"
          Smallest Real part (valid only for complex or unsymmetric problems).

     "li"
          Largest Imaginary part (valid only for complex or unsymmetric problems).

     "si"
          Smallest Imaginary part (valid only for complex or unsymmetric problems).

     If OPTS is given, it is a structure defining possible options that ‘eigs’ should use.  The fields of the OPTS structure are:

     ‘issym’
          If AF is given, then flags whether the function AF defines a symmetric problem.  It is ignored if A is given.  The default is false.

     ‘isreal’
          If AF is given, then flags whether the function AF defines a real problem.  It is ignored if A is given.  The default is true.

     ‘tol’
          Defines the required convergence tolerance, calculated as ‘tol * norm (A)’.  The default is ‘eps’.

     ‘maxit’
          The maximum number of iterations.  The default is 300.

     ‘p’
          The number of Lanzcos basis vectors to use.  More vectors will result in faster convergence, but a greater use of memory.  The optimal value of ‘p’ is problem dependent and should be in the range ‘K + 1’ to N.  The default value is ‘2 * K’.

     ‘v0’
          The starting vector for the algorithm.  An initial vector close to the final vector will speed up convergence.  The default is for ARPACK to randomly generate a starting vector.  If specified, ‘v0’ must be an N-by-1 vector where ‘N = rows (A)’

     ‘disp’
          The level of diagnostic printout (0|1|2).  If ‘disp’ is 0 then diagnostics are disabled.  The default value is 0.

     ‘cholB’
          Flag if ‘chol (B)’ is passed rather than B.  The default is false.

     ‘permB’
          The permutation vector of the Cholesky factorization of B if ‘cholB’ is true.  It is obtained by ‘[R, ~, permB] = chol (B, "vector")’.  The default is ‘1:N’.

     It is also possible to represent A by a function denoted AF.  AF must be followed by a scalar argument N defining the length of the vector argument accepted by AF.  AF can be a function handle, an inline function, or a string.  When AF is a string it holds the name of the function to use.

     AF is a function of the form ‘y = af (x)’ where the required return value of AF is determined by the value of SIGMA.  The four possible forms are

     ‘A * x’
          if SIGMA is not given or is a string other than "sm".

     ‘A \ x’
          if SIGMA is 0 or "sm".

     ‘(A - sigma * I) \ x’
          for the standard eigenvalue problem, where ‘I’ is the identity matrix of the same size as A.

     ‘(A - sigma * B) \ x’
          for the general eigenvalue problem.

     The return arguments of ‘eigs’ depend on the number of return arguments requested.  With a single return argument, a vector D of length K is returned containing the K eigenvalues that have been found.  With two return arguments, V is a N-by-K matrix whose columns are the K eigenvectors corresponding to the returned eigenvalues.  The eigenvalues themselves are returned in D in the form of a N-by-K matrix, where the elements on the diagonal are the eigenvalues.

     Given a third return argument FLAG, ‘eigs’ returns the status of the convergence.  If FLAG is 0 then all eigenvalues have converged.  Any other value indicates a failure to converge.

     This function is based on the ARPACK package, written by R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang.  For more information see <http://www.caam.rice.edu/software/ARPACK/>.

     See also: eig, svds.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Calculate a limited number of eigenvalues and eigenvectors of A, based on a selection criteria.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
etreeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- : etreeplot (A)
 -- : etreeplot (A, NODE_STYLE, EDGE_STYLE)
     Plot the elimination tree of the matrix A or A+A’ if A in not symmetric.

     The optional parameters NODE_STYLE and EDGE_STYLE define the output style.

     See also: treeplot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Plot the elimination tree of the matrix A or A+A’ if A in not symmetric.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gmres


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6127
 -- : X = gmres (A, B, RESTART, TOL, MAXIT, M1, M2, X0, ...)
 -- : X = gmres (A, B, RESTART, TOL, MAXIT, M, [], X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = gmres (A, B, ...)
     Solve ‘A x = b’ using the Preconditioned GMRES iterative method with restart, a.k.a.  PGMRES(restart).

     The input arguments are:

        − A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun(x) = A * x’.  Additional parameters to ‘Afun’ are passed after X0.

        − B is the right hand side vector.  It must be a column vector with the same numbers of rows as A.

        − RESTART is the number of iterations before that the method restarts.  If it is [] or N = numel (b), then the restart is not applied.

        − TOL is the required relative tolerance for the preconditioned residual error, ‘inv (M) * (B - A * X)’.  The iteration stops if ‘norm (inv (M) * (B - A * X)) ≤ TOL * norm (inv (M) * B)’.  If TOL is omitted or empty, then a tolerance of 1e-6 is used.

        − MAXIT is the maximum number of outer iterations, if not given or set to [], then the default value ‘min (10, N / RESTART)’ is used.  Note that, if RESTART is empty, then MAXIT is the maximum number of iterations.  If RESTART and MAXIT are not empty, then the maximum number of iterations is ‘RESTART * MAXIT’.  If both RESTART and MAXIT are empty, then the maximum number of iterations is set to ‘min (10, N)’.

        − M1, M2 are the preconditioners.  The preconditioner M is given as ‘M = M1 * M2’.  Both M1 and M2 can be passed as a matrix, function handle, or inline function ‘g’ such that ‘g(x) = M1 \ x’ or ‘g(x) = M2 \ x’.  If M1 is [] or not given, then the preconditioner is not applied.  The technique used is the left-preconditioning, i.e., it is solved ‘inv(M) * A * X = inv(M) * B’ instead of ‘A * X = B’.

        − X0 is the initial guess, if not given or set to [], then the default value ‘zeros (size (B))’ is used.

     The arguments which follow X0 are treated as parameters, and passed in a proper way to any of the functions (A or M or M1 or M2) which are passed to ‘gmres’.

     The outputs are:

        − X the computed approximation.  If the method does not converge, then it is the iterated with minimum residual.

        − FLAG indicates the exit status:

          0 : iteration converged to within the specified tolerance

          1 : maximum number of iterations exceeded

          2 : the preconditioner matrix is singular

          3 : algorithm reached stagnation (the relative difference between two
               consecutive iterations is less than eps)

        − RELRES is the value of the relative preconditioned residual of the approximation X.

        − ITER is a vector containing the number of outer iterations and inner iterations performed to compute X.  That is:

             • ITER(1): number of outer iterations, i.e., how many times the method restarted.  (if RESTART is empty or N, then it is 1, if not 1 ≤ ITER(1) ≤ MAXIT).

             • ITER(2): the number of iterations performed before the restart, i.e., the method restarts when ‘ITER(2) = RESTART’.  If RESTART is empty or N, then 1 ≤ ITER(2) ≤ MAXIT.

          To be more clear, the approximation X is computed at the iteration ‘(ITER(1) - 1) * RESTART + ITER(2)’.  Since the output X corresponds to the minimal preconditioned residual solution, the total number of iterations that the method performed is given by ‘length (resvec) - 1’.

        − RESVEC is a vector containing the preconditioned relative residual at each iteration, including the 0-th iteration ‘norm (A * X0 - B)’.

     Let us consider a trivial problem with a tridiagonal matrix

          n = 20;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
              toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
          b = A * ones (n, 1);
          restart = 5;
          [M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
          M = M1 * M2;
          Afun = @(x) A * x;
          Mfun = @(x) M \ x;
          M1fun = @(x) M1 \ x;
          M2fun = @(x) M2 \ x;

     EXAMPLE 1: simplest usage of ‘gmres’

          x = gmres (A, b, [], [], n)

     EXAMPLE 2: ‘gmres’ with a function which computes ‘A * X’

          x = gmres (Afun, b, [], [], n)

     EXAMPLE 3: usage of ‘gmres’ with the restart

          x = gmres (A, b, restart);

     EXAMPLE 4: ‘gmres’ with a preconditioner matrix M with and without restart

          x = gmres (A, b, [], 1e-06, n, M)
          x = gmres (A, b, restart, 1e-06, n, M)

     EXAMPLE 5: ‘gmres’ with a function as preconditioner

          x = gmres (Afun, b, [], 1e-6, n, Mfun)

     EXAMPLE 6: ‘gmres’ with preconditioner matrices M1 and M2

          x = gmres (A, b, [], 1e-6, n, M1, M2)

     EXAMPLE 7: ‘gmres’ with functions as preconditioners

          x = gmres (Afun, b, 1e-6, n, M1fun, M2fun)

     EXAMPLE 8: ‘gmres’ with as input a function requiring an argument

            function y = Ap (A, x, p) # compute A^p * x
               y = x;
               for i = 1:p
                 y = A * y;
               endfor
            endfunction
          Apfun = @(x, p) Ap (A, x, p);
          x = gmres (Apfun, b, [], [], [], [], [], [], 2);

     EXAMPLE 9: explicit example to show that ‘gmres’ uses a left preconditioner

          [M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
          M = M1 * M2;

          ## reference solution computed by gmres after two iterations
          [x_ref, fl] = gmres (A, b, [], [], 1, M)

          ## left preconditioning
          [x, fl] = gmres (M \ A, M \ b, [], [], 1)
          x # compare x and x_ref


     References:

       1. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, Second edition, 2003, SIAM

     See also: bicg, bicgstab, cgs, pcg, pcr, qmr, tfqmr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Solve ‘A x = b’ using the Preconditioned GMRES iterative method with restart, a.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- : gplot (A, XY)
 -- : gplot (A, XY, LINE_STYLE)
 -- : [X, Y] = gplot (A, XY)
     Plot a graph defined by A and XY in the graph theory sense.

     A is the adjacency matrix of the array to be plotted and XY is an N-by-2 matrix containing the coordinates of the nodes of the graph.

     The optional parameter LINE_STYLE defines the output style for the plot.  Called with no output arguments the graph is plotted directly.  Otherwise, return the coordinates of the plot in X and Y.

     See also: treeplot, etreeplot, spy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Plot a graph defined by A and XY in the graph theory sense.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ichol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3993
 -- : L = ichol (A)
 -- : L = ichol (A, OPTS)

     Compute the incomplete Cholesky factorization of the sparse square matrix A.

     By default, ‘ichol’ uses only the lower triangle of A and produces a lower triangular factor L such that L*L’ approximates A.

     The factor given by this routine may be useful as a preconditioner for a system of linear equations being solved by iterative methods such as PCG (Preconditioned Conjugate Gradient).

     The factorization may be modified by passing options in a structure OPTS.  The option name is a field of the structure and the setting is the value of field.  Names and specifiers are case sensitive.

     type
          Type of factorization.

          "nofill" (default)
               Incomplete Cholesky factorization with no fill-in (IC(0)).

          "ict"
               Incomplete Cholesky factorization with threshold dropping (ICT).

     diagcomp
          A non-negative scalar ALPHA for incomplete Cholesky factorization of ‘A + ALPHA * diag (diag (A))’ instead of A.  This can be useful when A is not positive definite.  The default value is 0.

     droptol
          A non-negative scalar specifying the drop tolerance for factorization if performing ICT.  The default value is 0 which produces the complete Cholesky factorization.

          Non-diagonal entries of L are set to 0 unless

          ‘abs (L(i,j)) >= droptol * norm (A(j:end, j), 1)’.

     michol
          Modified incomplete Cholesky factorization:

          "off" (default)
               Row and column sums are not necessarily preserved.

          "on"
               The diagonal of L is modified so that row (and column) sums are preserved even when elements have been dropped during the factorization.  The relationship preserved is: ‘A * e = L * L' * e’, where e is a vector of ones.

     shape

          "lower" (default)
               Use only the lower triangle of A and return a lower triangular factor L such that L*L’ approximates A.

          "upper"
               Use only the upper triangle of A and return an upper triangular factor U such that ‘U'*U’ approximates A.

     EXAMPLES

     The following problem demonstrates how to factorize a sample symmetric positive definite matrix with the full Cholesky decomposition and with the incomplete one.

          A = [ 0.37, -0.05,  -0.05,  -0.07;
               -0.05,  0.116,  0.0,   -0.05;
               -0.05,  0.0,    0.116, -0.05;
               -0.07, -0.05,  -0.05,   0.202];
          A = sparse (A);
          nnz (tril (A))
          ans =  9
          L = chol (A, "lower");
          nnz (L)
          ans =  10
          norm (A - L * L', "fro") / norm (A, "fro")
          ans =  1.1993e-16
          opts.type = "nofill";
          L = ichol (A, opts);
          nnz (L)
          ans =  9
          norm (A - L * L', "fro") / norm (A, "fro")
          ans =  0.019736

     Another example for decomposition is a finite difference matrix used to solve a boundary value problem on the unit square.

          nx = 400; ny = 200;
          hx = 1 / (nx + 1); hy = 1 / (ny + 1);
          Dxx = spdiags ([ones(nx, 1), -2*ones(nx, 1), ones(nx, 1)],
                         [-1 0 1 ], nx, nx) / (hx ^ 2);
          Dyy = spdiags ([ones(ny, 1), -2*ones(ny, 1), ones(ny, 1)],
                         [-1 0 1 ], ny, ny) / (hy ^ 2);
          A = -kron (Dxx, speye (ny)) - kron (speye (nx), Dyy);
          nnz (tril (A))
          ans =  239400
          opts.type = "nofill";
          L = ichol (A, opts);
          nnz (tril (A))
          ans =  239400
          norm (A - L * L', "fro") / norm (A, "fro")
          ans =  0.062327

     References for implemented algorithms:

     [1] Y. Saad.  "Preconditioning Techniques."  ‘Iterative Methods for Sparse Linear Systems’, PWS Publishing Company, 1996.

     [2] M. Jones, P. Plassmann: ‘An Improved Incomplete Cholesky Factorization’, 1992.

     See also: chol, ilu, pcg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Compute the incomplete Cholesky factorization of the sparse square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ilu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4291
 -- : ilu (A)
 -- : ilu (A, OPTS)
 -- : [L, U] = ilu (...)
 -- : [L, U, P] = ilu (...)

     Compute the incomplete LU factorization of the sparse square matrix A.

     ‘ilu’ returns a unit lower triangular matrix L, an upper triangular matrix U, and optionally a permutation matrix P, such that ‘L*U’ approximates ‘P*A’.

     The factors given by this routine may be useful as preconditioners for a system of linear equations being solved by iterative methods such as BICG (BiConjugate Gradients) or GMRES (Generalized Minimum Residual Method).

     The factorization may be modified by passing options in a structure OPTS.  The option name is a field of the structure and the setting is the value of field.  Names and specifiers are case sensitive.

     ‘type’
          Type of factorization.

          "nofill" (default)
               ILU factorization with no fill-in (ILU(0)).

               Additional supported options: ‘milu’.

          "crout"
               Crout version of ILU factorization (ILUC).

               Additional supported options: ‘milu’, ‘droptol’.

          "ilutp"
               ILU factorization with threshold and pivoting.

               Additional supported options: ‘milu’, ‘droptol’, ‘udiag’, ‘thresh’.

     ‘droptol’
          A non-negative scalar specifying the drop tolerance for factorization.  The default value is 0 which produces the complete LU factorization.

          Non-diagonal entries of U are set to 0 unless

          ‘abs (U(i,j)) >= droptol * norm (A(:,j))’.

          Non-diagonal entries of L are set to 0 unless

          ‘abs (L(i,j)) >= droptol * norm (A(:,j))/U(j,j)’.

     ‘milu’
          Modified incomplete LU factorization:

          "row"
               Row-sum modified incomplete LU factorization.  The factorization preserves row sums: ‘A * e = L * U * e’, where e is a vector of ones.

          "col"
               Column-sum modified incomplete LU factorization.  The factorization preserves column sums: ‘e' * A = e' * L * U’.

          "off" (default)
               Row and column sums are not necessarily preserved.

     ‘udiag’
          If true, any zeros on the diagonal of the upper triangular factor are replaced by the local drop tolerance ‘droptol * norm (A(:,j))/U(j,j)’.  The default is false.

     ‘thresh’
          Pivot threshold for factorization.  It can range between 0 (diagonal pivoting) and 1 (default), where the maximum magnitude entry in the column is chosen to be the pivot.

     If ‘ilu’ is called with just one output, the returned matrix is ‘L + U - speye (size (A))’, where L is unit lower triangular and U is upper triangular.

     With two outputs, ‘ilu’ returns a unit lower triangular matrix L and an upper triangular matrix U.  For OPTS.type == "ilutp", one of the factors is permuted based on the value of OPTS.milu.  When OPTS.milu == "row", U is a column permuted upper triangular factor.  Otherwise, L is a row-permuted unit lower triangular factor.

     If there are three named outputs and OPTS.milu != "row", P is returned such that L and U are incomplete factors of ‘P*A’.  When OPTS.milu == "row", P is returned such that L and U are incomplete factors of ‘A*P’.

     EXAMPLES

          A = gallery ("neumann", 1600) + speye (1600);
          opts.type = "nofill";
          nnz (A)
          ans = 7840

          nnz (lu (A))
          ans = 126478

          nnz (ilu (A, opts))
          ans = 7840

     This shows that A has 7,840 nonzeros, the complete LU factorization has 126,478 nonzeros, and the incomplete LU factorization, with 0 level of fill-in, has 7,840 nonzeros, the same amount as A.  Taken from: <http://www.mathworks.com/help/matlab/ref/ilu.html>

          A = gallery ("wathen", 10, 10);
          b = sum (A, 2);
          tol = 1e-8;
          maxit = 50;
          opts.type = "crout";
          opts.droptol = 1e-4;
          [L, U] = ilu (A, opts);
          x = bicg (A, b, tol, maxit, L, U);
          norm (A * x - b, inf)

     This example uses ILU as preconditioner for a random FEM-Matrix, which has a large condition number.  Without L and U BICG would not converge.

     See also: lu, ichol, bicg, gmres.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the incomplete LU factorization of the sparse square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nonzeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- : nonzeros (S)
     Return a vector of the nonzero values of the sparse matrix S.

     See also: find, nnz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return a vector of the nonzero values of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pcg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6925
 -- : X = pcg (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- : X = pcg (A, B, TOL, MAXIT, M, [], X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC, EIGEST] = pcg (A, B, ...)

     Solve the linear system of equations ‘A * X = B’ by means of the Preconditioned Conjugate Gradient iterative method.

     The input arguments are:

        • A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun(x) = A * x’.  Additional parameters to ‘Afun’ may be passed after X0.

          A has to be Hermitian and Positive Definite (HPD).  If ‘pcg’ detects A not to be positive definite, a warning is printed and the FLAG output is set.

        • B is the right-hand side vector.

        • TOL is the required relative tolerance for the residual error, ‘B - A * X’.  The iteration stops if ‘norm (B - A * X)’ ≤ ‘TOL * norm (B)’.  If TOL is omitted or empty, then a tolerance of 1e-6 is used.

        • MAXIT is the maximum allowed number of iterations; if MAXIT is omitted or empty then a value of 20 is used.

        • M is a HPD preconditioning matrix.  For any decomposition ‘M = P1 * P2’ such that ‘inv (P1) * A * inv (P2)’ is HPD, the conjugate gradient method is formally applied to the linear system ‘inv (P1) * A * inv (P2) * Y = inv (P1) * B’, with ‘X = inv (P2) * Y’ (split preconditioning).  In practice, at each iteration of the conjugate gradient method a linear system with matrix M is solved with ‘mldivide’.  If a particular factorization ‘M = M1 * M2’ is available (for instance, an incomplete Cholesky factorization of A), the two matrices M1 and M2 can be passed and the relative linear systems are solved with the ‘mldivide’ operator.  Note that a proper choice of the preconditioner may dramatically improve the overall performance of the method.  Instead of matrices M1 and M2, the user may pass two functions which return the results of applying the inverse of M1 and M2 to a vector.  If M1 is omitted or empty ‘[]’, then no preconditioning is applied.  If no factorization of M is available, M2 can be omitted
          or left [], and the input variable M1 can be used to pass the preconditioner M.

        • X0 is the initial guess.  If X0 is omitted or empty then the function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and passed in an appropriate manner to any of the functions (A or M1 or M2) that have been given to ‘pcg’.  See the examples below for further details.

     The output arguments are:

        • X is the computed approximation to the solution of ‘A * X = B’.  If the algorithm did not converge, then X is the iteration which has the minimum residual.

        • FLAG reports on the convergence:

             • 0: The algorithm converged to within the prescribed tolerance.

             • 1: The algorithm did not converge and it reached the maximum number of iterations.

             • 2: The preconditioner matrix is singular.

             • 3: The algorithm stagnated, i.e., the absolute value of the difference between the current iteration X and the previous is less than ‘EPS * norm (X,2)’.

             • 4: The algorithm detects that the input (preconditioned) matrix is not HPD.

        • RELRES is the ratio of the final residual to its initial value, measured in the Euclidean norm.

        • ITER indicates the iteration of X which it was computed.  Since the output X corresponds to the minimal residual solution, the total number of iterations that the method performed is given by ‘length(resvec) - 1’.

        • RESVEC describes the convergence history of the method.  ‘RESVEC (I, 1)’ is the Euclidean norm of the residual, and ‘RESVEC (I, 2)’ is the preconditioned residual norm, after the (I-1)-th iteration, ‘I = 1, 2, ..., ITER+1’.  The preconditioned residual norm is defined as ‘R' * (M \ R)’ where ‘R = B - A * X’, see also the description of M.  If EIGEST is not required, only ‘RESVEC (:, 1)’ is returned.

        • EIGEST returns the estimate for the smallest ‘EIGEST(1)’ and largest ‘EIGEST(2)’ eigenvalues of the preconditioned matrix ‘P = M \ A’.  In particular, if no preconditioning is used, the estimates for the extreme eigenvalues of A are returned.  ‘EIGEST(1)’ is an overestimate and ‘EIGEST(2)’ is an underestimate, so that ‘EIGEST(2) / EIGEST(1)’ is a lower bound for ‘cond (P, 2)’, which nevertheless in the limit should theoretically be equal to the actual value of the condition number.

     Let us consider a trivial problem with a tridiagonal matrix

          n = 10;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1], 1, n));
          b = A * ones (n, 1);
          M1 = ichol (A); # in this tridiagonal case it corresponds to chol (A)'
          M2 = M1';
          M = M1 * M2;
          Afun = @(x) A * x;
          Mfun = @(x) M \ x;
          M1fun = @(x) M1 \ x;
          M2fun = @(x) M2 \ x;

     EXAMPLE 1: Simplest use of ‘pcg’

          x = pcg (A, b)

     EXAMPLE 2: ‘pcg’ with a function which computes ‘A * X’

          x = pcg (Afun, b)

     EXAMPLE 3: ‘pcg’ with a preconditioner matrix M

          x = pcg (A, b, 1e-06, 100, M)

     EXAMPLE 4: ‘pcg’ with a function as preconditioner

          x = pcg (Afun, b, 1e-6, 100, Mfun)

     EXAMPLE 5: ‘pcg’ with preconditioner matrices M1 and M2

          x = pcg (A, b, 1e-6, 100, M1, M2)

     EXAMPLE 6: ‘pcg’ with functions as preconditioners

          x = pcg (Afun, b, 1e-6, 100, M1fun, M2fun)

     EXAMPLE 7: ‘pcg’ with as input a function requiring an argument

            function y = Ap (A, x, p) # compute A^p * x
               y = x;
               for i = 1:p
                 y = A * y;
               endfor
            endfunction
          Apfun = @(x, p) Ap (A, x, p);
          x = pcg (Apfun, b, [], [], [], [], [], 2);

     EXAMPLE 8: explicit example to show that ‘pcg’ uses a split preconditioner

          M1 = ichol (A + 0.1 * eye (n)); # factorization of A perturbed
          M2 = M1';
          M = M1 * M2;

          ## reference solution computed by pcg after two iterations
          [x_ref, fl] = pcg (A, b, [], 2, M)

          ## split preconditioning
          [y, fl] = pcg ((M1 \ A) / M2, M1 \ b, [], 2)
          x = M2 \ y # compare x and x_ref


     References:

       1. C.T. Kelley, ‘Iterative Methods for Linear and Nonlinear Equations’, SIAM, 1995.  (the base PCG algorithm)

       2. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, PWS 1996.  (condition number estimate from PCG) Revised version of this book is available online at <https://www-users.cs.umn.edu/~saad/books.html>

     See also: sparse, pcr, gmres, bicg, bicgstab, cgs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 120
Solve the linear system of equations ‘A * X = B’ by means of the Preconditioned Conjugate Gradient iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pcr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4137
 -- : X = pcr (A, B, TOL, MAXIT, M, X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = pcr (...)

     Solve the linear system of equations ‘A * X = B’ by means of the Preconditioned Conjugate Residuals iterative method.

     The input arguments are

        • A can be either a square (preferably sparse) matrix or a function handle, inline function or string containing the name of a function which computes ‘A * X’.  In principle A should be symmetric and non-singular; if ‘pcr’ finds A to be numerically singular, you will get a warning message and the FLAG output parameter will be set.

        • B is the right hand side vector.

        • TOL is the required relative tolerance for the residual error, ‘B - A * X’.  The iteration stops if ‘norm (B - A * X) <= TOL * norm (B - A * X0)’.  If TOL is empty or is omitted, the function sets ‘TOL = 1e-6’ by default.

        • MAXIT is the maximum allowable number of iterations; if ‘[]’ is supplied for MAXIT, or ‘pcr’ has less arguments, a default value equal to 20 is used.

        • M is the (left) preconditioning matrix, so that the iteration is (theoretically) equivalent to solving by ‘pcr’ ‘P * X = M \ B’, with ‘P = M \ A’.  Note that a proper choice of the preconditioner may dramatically improve the overall performance of the method.  Instead of matrix M, the user may pass a function which returns the results of applying the inverse of M to a vector (usually this is the preferred way of using the preconditioner).  If ‘[]’ is supplied for M, or M is omitted, no preconditioning is applied.

        • X0 is the initial guess.  If X0 is empty or omitted, the function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and passed in a proper way to any of the functions (A or M) which are passed to ‘pcr’.  See the examples below for further details.

     The output arguments are

        • X is the computed approximation to the solution of ‘A * X = B’.

        • FLAG reports on the convergence.  ‘FLAG = 0’ means the solution converged and the tolerance criterion given by TOL is satisfied.  ‘FLAG = 1’ means that the MAXIT limit for the iteration count was reached.  ‘FLAG = 3’ reports a ‘pcr’ breakdown, see [1] for details.

        • RELRES is the ratio of the final residual to its initial value, measured in the Euclidean norm.

        • ITER is the actual number of iterations performed.

        • RESVEC describes the convergence history of the method, so that ‘RESVEC (i)’ contains the Euclidean norms of the residual after the (I-1)-th iteration, ‘I = 1,2, ..., ITER+1’.

     Let us consider a trivial problem with a diagonal matrix (we exploit the sparsity of A)

          n = 10;
          A = sparse (diag (1:n));
          b = rand (N, 1);

     EXAMPLE 1: Simplest use of ‘pcr’

          x = pcr (A, b)

     EXAMPLE 2: ‘pcr’ with a function which computes ‘A * X’.

          function y = apply_a (x)
            y = [1:10]' .* x;
          endfunction

          x = pcr ("apply_a", b)

     EXAMPLE 3: Preconditioned iteration, with full diagnostics.  The preconditioner (quite strange, because even the original matrix A is trivial) is defined as a function

          function y = apply_m (x)
            k = floor (length (x) - 2);
            y = x;
            y(1:k) = x(1:k) ./ [1:k]';
          endfunction

          [x, flag, relres, iter, resvec] = ...
                             pcr (A, b, [], [], "apply_m")
          semilogy ([1:iter+1], resvec);

     EXAMPLE 4: Finally, a preconditioner which depends on a parameter K.

          function y = apply_m (x, varargin)
            k = varargin{1};
            y = x;
            y(1:k) = x(1:k) ./ [1:k]';
          endfunction

          [x, flag, relres, iter, resvec] = ...
                             pcr (A, b, [], [], "apply_m"', [], 3)

     References:

     [1] W. Hackbusch, ‘Iterative Solution of Large Sparse Systems of Equations’, section 9.5.4; Springer, 1994

     See also: sparse, pcg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
Solve the linear system of equations ‘A * X = B’ by means of the Preconditioned Conjugate Residuals iterative method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
qmr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2101
 -- : X = qmr (A, B, RTOL, MAXIT, M1, M2, X0)
 -- : X = qmr (A, B, RTOL, MAXIT, P)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = qmr (A, B, ...)
     Solve ‘A x = b’ using the Quasi-Minimal Residual iterative method (without look-ahead).

        − RTOL is the relative tolerance, if not given or set to [] the default value 1e-6 is used.

        − MAXIT the maximum number of outer iterations, if not given or set to [] the default value ‘min (20, numel (b))’ is used.

        − X0 the initial guess, if not given or set to [] the default value ‘zeros (size (b))’ is used.

     A can be passed as a matrix or as a function handle or inline function ‘f’ such that ‘f(x, "notransp") = A*x’ and ‘f(x, "transp") = A'*x’.

     The preconditioner P is given as ‘P = M1 * M2’.  Both M1 and M2 can be passed as a matrix or as a function handle or inline function ‘g’ such that ‘g(x, "notransp") = M1 \ x’ or ‘g(x, "notransp") = M2 \ x’ and ‘g(x, "transp") = M1' \ x’ or ‘g(x, "transp") = M2' \ x’.

     If called with more than one output parameter

        − FLAG indicates the exit status:

             − 0: iteration converged to the within the chosen tolerance

             − 1: the maximum number of iterations was reached before convergence

             − 3: the algorithm reached stagnation

          (the value 2 is unused but skipped for compatibility).

        − RELRES is the final value of the relative residual.

        − ITER is the number of iterations performed.

        − RESVEC is a vector containing the residual norms at each iteration.

     References:

       1. R. Freund and N. Nachtigal, ‘QMR: a quasi-minimal residual method for non-Hermitian linear systems’, Numerische Mathematik, 1991, 60, pp.  315-339.

       2. R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhour, R. Pozo, C. Romine, and H. van der Vorst, ‘Templates for the solution of linear systems: Building blocks for iterative methods’, SIAM, 2nd ed., 1994.

     See also: bicg, bicgstab, cgs, gmres, pcg.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
Solve ‘A x = b’ using the Quasi-Minimal Residual iterative method (without look-ahead).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spaugment


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1310
 -- : S = spaugment (A, C)
     Create the augmented matrix of A.

     This is given by

          [C * eye(M, M), A;
                      A', zeros(N, N)]

     This is related to the least squares solution of ‘A \ B’, by

          S * [ R / C; x] = [ B, zeros(N, columns(B)) ]

     where R is the residual error

          R = B - A * X

     As the matrix S is symmetric indefinite it can be factorized with ‘lu’, and the minimum norm solution can therefore be found without the need for a ‘qr’ factorization.  As the residual error will be ‘zeros (M, M)’ for underdetermined problems, and example can be

          m = 11; n = 10; mn = max (m, n);
          A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
                       [-1, 0, 1], m, n);
          x0 = A \ ones (m,1);
          s = spaugment (A);
          [L, U, P, Q] = lu (s);
          x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
          x1 = x1(end - n + 1 : end);

     To find the solution of an overdetermined problem needs an estimate of the residual error R and so it is more complex to formulate a minimum norm solution using the ‘spaugment’ function.

     In general the left division operator is more stable and faster than using the ‘spaugment’ function.

     See also: mldivide.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Create the augmented matrix of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spconvert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 413
 -- : X = spconvert (M)
     Convert a simple sparse matrix format easily generated by other programs into Octave’s internal sparse format.

     The input M is either a 3 or 4 column real matrix, containing the row, column, real, and imaginary parts of the elements of the sparse matrix.  An element with a zero real and imaginary part can be used to force a particular matrix size.

     See also: sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
Convert a simple sparse matrix format easily generated by other programs into Octave’s internal sparse format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spdiags


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1063
 -- : B = spdiags (A)
 -- : [B, D] = spdiags (A)
 -- : B = spdiags (A, D)
 -- : A = spdiags (V, D, A)
 -- : A = spdiags (V, D, M, N)
     A generalization of the function ‘diag’.

     Called with a single input argument, the nonzero diagonals D of A are extracted.

     With two arguments the diagonals to extract are given by the vector D.

     The other two forms of ‘spdiags’ modify the input matrix by replacing the diagonals.  They use the columns of V to replace the diagonals represented by the vector D.  If the sparse matrix A is defined then the diagonals of this matrix are replaced.  Otherwise a matrix of M by N is created with the diagonals given by the columns of V.

     Negative values of D represent diagonals below the main diagonal, and positive values of D diagonals above the main diagonal.

     For example:

          spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
             ⇒ 5 10  0  0
                1  6 11  0
                0  2  7 12
                0  0  3  8
                0  0  0  4

     See also: diag.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
A generalization of the function ‘diag’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
speye


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 466
 -- : S = speye (M, N)
 -- : S = speye (M)
 -- : S = speye (SZ)
     Return a sparse identity matrix of size MxN.

     The implementation is significantly more efficient than ‘sparse (eye (M))’ as the full matrix is not constructed.

     Called with a single argument a square matrix of size M-by-M is created.  If called with a single vector argument SZ, this argument is taken to be the size of the matrix to create.

     See also: sparse, spdiags, eye.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return a sparse identity matrix of size MxN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
spfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- : Y = spfun (F, S)
     Compute ‘f(S)’ for the nonzero values of S.

     This results in a sparse matrix with the same structure as S.  The function F can be passed as a string, a function handle, or an inline function.

     See also: arrayfun, cellfun, structfun.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Compute ‘f(S)’ for the nonzero values of S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
spones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- : R = spones (S)
     Replace the nonzero entries of S with ones.

     This creates a sparse matrix with the same structure as S.

     See also: sparse, sprand, sprandn, sprandsym, spfun, spy.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Replace the nonzero entries of S with ones.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sprand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 713
 -- : sprand (M, N, D)
 -- : sprand (M, N, D, RC)
 -- : sprand (S)
     Generate a sparse matrix with uniformly distributed random values.

     The size of the matrix is MxN with a density of values D.  D must be between 0 and 1.  Values will be uniformly distributed on the interval (0, 1).

     If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix S is nonzero.

     If called with a scalar fourth argument RC, a random sparse matrix with reciprocal condition number RC is generated.  If RC is a vector, then it specifies the first singular values of the generated matrix (‘length (RC) <= min (M, N)’).

     See also: sprandn, sprandsym, rand.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Generate a sparse matrix with uniformly distributed random values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sprandn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 728
 -- : sprandn (M, N, D)
 -- : sprandn (M, N, D, RC)
 -- : sprandn (S)
     Generate a sparse matrix with normally distributed random values.

     The size of the matrix is MxN with a density of values D.  D must be between 0 and 1.  Values will be normally distributed with a mean of 0 and a variance of 1.

     If called with a single matrix argument, a sparse matrix is generated with random values wherever the matrix S is nonzero.

     If called with a scalar fourth argument RC, a random sparse matrix with reciprocal condition number RC is generated.  If RC is a vector, then it specifies the first singular values of the generated matrix (‘length (RC) <= min (M, N)’).

     See also: sprand, sprandsym, randn.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Generate a sparse matrix with normally distributed random values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
sprandsym


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 484
 -- : sprandsym (N, D)
 -- : sprandsym (S)
     Generate a symmetric random sparse matrix.

     The size of the matrix will be NxN, with a density of values given by D.  D must be between 0 and 1 inclusive.  Values will be normally distributed with a mean of zero and a variance of 1.

     If called with a single matrix argument, a random sparse matrix is generated wherever the matrix S is nonzero in its lower triangular part.

     See also: sprand, sprandn, spones, sparse.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Generate a symmetric random sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spstats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 549
 -- : [COUNT, MEAN, VAR] = spstats (S)
 -- : [COUNT, MEAN, VAR] = spstats (S, J)
     Return the stats for the nonzero elements of the sparse matrix S.

     COUNT is the number of nonzeros in each column, MEAN is the mean of the nonzeros in each column, and VAR is the variance of the nonzeros in each column.

     Called with two input arguments, if S is the data and J is the bin number for the data, compute the stats for each bin.  In this case, bins can contain data values of zero, whereas with ‘spstats (S)’ the zeros may disappear.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the stats for the nonzero elements of the sparse matrix S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
spy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 378
 -- : spy (X)
 -- : spy (..., MARKERSIZE)
 -- : spy (..., LINE_SPEC)
     Plot the sparsity pattern of the sparse matrix X.

     If the argument MARKERSIZE is given as a scalar value, it is used to determine the point size in the plot.

     If the string LINE_SPEC is given it is passed to ‘plot’ and determines the appearance of the plot.

     See also: plot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Plot the sparsity pattern of the sparse matrix X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
svds


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2200
 -- : S = svds (A)
 -- : S = svds (A, K)
 -- : S = svds (A, K, SIGMA)
 -- : S = svds (A, K, SIGMA, OPTS)
 -- : [U, S, V] = svds (...)
 -- : [U, S, V, FLAG] = svds (...)

     Find a few singular values of the matrix A.

     The singular values are calculated using

          [M, N] = size (A);
          S = eigs ([sparse(M, M), A;
                               A', sparse(N, N)])

     The eigenvalues returned by ‘eigs’ correspond to the singular values of A.  The number of singular values to calculate is given by K and defaults to 6.

     The argument SIGMA specifies which singular values to find.  When SIGMA is the string ’L’, the default, the largest singular values of A are found.  Otherwise, SIGMA must be a real scalar and the singular values closest to SIGMA are found.  As a corollary, ‘SIGMA = 0’ finds the smallest singular values.  Note that for relatively small values of SIGMA, there is a chance that the requested number of singular values will not be found.  In that case SIGMA should be increased.

     OPTS is a structure defining options that ‘svds’ will pass to ‘eigs’.  The possible fields of this structure are documented in ‘eigs’.  By default, ‘svds’ sets the following three fields:

     ‘tol’
          The required convergence tolerance for the singular values.  The default value is 1e-10.  ‘eigs’ is passed ‘TOL / sqrt(2)’.

     ‘maxit’
          The maximum number of iterations.  The default is 300.

     ‘disp’
          The level of diagnostic printout (0|1|2).  If ‘disp’ is 0 then diagnostics are disabled.  The default value is 0.

     If more than one output is requested then ‘svds’ will return an approximation of the singular value decomposition of A

          A_approx = U*S*V'

     where A_approx is a matrix of size A but only rank K.

     FLAG returns 0 if the algorithm has succesfully converged, and 1 otherwise.  The test for convergence is

          norm (A*V - U*S, 1) <= TOL * norm (A, 1)

     ‘svds’ is best for finding only a few singular values from a large sparse matrix.  Otherwise, ‘svd (full (A))’ will likely be more efficient.

     See also: svd, eigs.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Find a few singular values of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
tfqmr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4856
 -- : X = tfqmr (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- : X = tfqmr (A, B, TOL, MAXIT, M, [], X0, ...)
 -- : [X, FLAG, RELRES, ITER, RESVEC] = tfqmr (A, B, ...)
     Solve ‘A x = b’ using the Transpose-Tree qmr method, based on the cgs.

     The input parameters are:

        − A is the matrix of the linear system and it must be square.  A can be passed as a matrix, function handle, or inline function ‘Afun’ such that ‘Afun(x) = A * x’.  Additional parameters to ‘Afun’ are passed after X0.

        − B is the right hand side vector.  It must be a column vector with the same number of rows as A.

        − TOL is the relative tolerance, if not given or set to [] the default value 1e-6 is used.

        − MAXIT the maximum number of outer iterations, if not given or set to [] the default value ‘min (20, numel (b))’ is used.  To be compatible, since the method as different behaviors in the iteration number is odd or even, is considered as iteration in ‘tfqmr’ the entire odd-even cycle.  That is, to make an entire iteration, the algorithm performs two sub-iterations: the odd one and the even one.

        − M1, M2 are the preconditioners.  The preconditioner M is given as ‘M = M1 * M2’.  Both M1 and M2 can be passed as a matrix or as a function handle or inline function ‘g’ such that ‘g(x) = M1 \ x’ or ‘g(x) = M2 \ x’.  The technique used is the right-preconditioning, i.e., it is solved ‘A*inv(M)*y = b’ and then ‘x = inv(M)*y’, instead of ‘A x = b’.

        − X0 the initial guess, if not given or set to [] the default value ‘zeros (size (b))’ is used.

     The arguments which follow X0 are treated as parameters, and passed in a proper way to any of the functions (A or M) which are passed to ‘tfqmr’.

     The output parameters are:

        − X is the approximation computed.  If the method doesn’t converge then it is the iterated with the minimum residual.

        − FLAG indicates the exit status:

             − 0: iteration converged to the within the chosen tolerance

             − 1: the maximum number of iterations was reached before convergence

             − 2: the preconditioner matrix is singular

             − 3: the algorithm reached stagnation

             − 4: the algorithm can’t continue due to a division by zero

        − RELRES is the relative residual obtained as ‘(A*X-B) / norm (B)’.

        − ITER is the iteration which X is computed.

        − RESVEC is a vector containing the residual at each iteration (including ‘norm (b - A x0)’).  Doing ‘length (RESVEC) - 1’ is possible to see the total number of iterations performed.

     Let us consider a trivial problem with a tridiagonal matrix

          n = 20;
          A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
              toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
          b = A * ones (n, 1);
          restart = 5;
          [M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
          M = M1 * M2;
          Afun = @(x) A * x;
          Mfun = @(x) M \ x;
          M1fun = @(x) M1 \ x;
          M2fun = @(x) M2 \ x;

     EXAMPLE 1: simplest usage of ‘tfqmr’

          x = tfqmr (A, b, [], n)

     EXAMPLE 2: ‘tfqmr’ with a function which computes ‘A * X’

          x = tfqmr (Afun, b, [], n)

     EXAMPLE 3: ‘tfqmr’ with a preconditioner matrix M

          x = tfqmr (A, b, [], 1e-06, n, M)

     EXAMPLE 4: ‘tfqmr’ with a function as preconditioner

          x = tfqmr (Afun, b, 1e-6, n, Mfun)

     EXAMPLE 5: ‘tfqmr’ with preconditioner matrices M1 and M2

          x = tfqmr (A, b, [], 1e-6, n, M1, M2)

     EXAMPLE 6: ‘tfmqr’ with functions as preconditioners

          x = tfqmr (Afun, b, 1e-6, n, M1fun, M2fun)

     EXAMPLE 7: ‘tfqmr’ with as input a function requiring an argument

          function y = Ap (A, x, z) # compute A^z * x
             y = x;
             for i = 1:z
               y = A * y;
             endfor
           endfunction
          Apfun = @(x, string, p) Ap (A, x, string, p);
          x = tfqmr (Apfun, b, [], [], [], [], [], 2);

     EXAMPLE 8: explicit example to show that ‘tfqmr’ uses a right preconditioner

          [M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
          M = M1 * M2;

          ## reference solution computed by tfqmr after one iteration
          [x_ref, fl] = tfqmr (A, b, [], 1, M)

          ## right preconditioning
          [y, fl] = tfqmr (A / M, b, [], 1)
          x = M \ y # compare x and x_ref


     References:

       1. Y. Saad, ‘Iterative Methods for Sparse Linear Systems’, Second edition, 2003, SIAM

     See also: bicg, bicgstab, cgs, gmres, pcg, qmr, pcr.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Solve ‘A x = b’ using the Transpose-Tree qmr method, based on the cgs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
treelayout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 370
 -- : treelayout (TREE)
 -- : treelayout (TREE, PERMUTATION)
     treelayout lays out a tree or a forest.

     The first argument TREE is a vector of predecessors.

     The parameter PERMUTATION is an optional postorder permutation.

     The complexity of the algorithm is O(n) in terms of time and memory requirements.

     See also: etreeplot, gplot, treeplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
treelayout lays out a tree or a forest.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
treeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 374
 -- : treeplot (TREE)
 -- : treeplot (TREE, NODE_STYLE, EDGE_STYLE)
     Produce a graph of tree or forest.

     The first argument is vector of predecessors.

     The optional parameters NODE_STYLE and EDGE_STYLE define the output plot style.

     The complexity of the algorithm is O(n) in terms of is time and memory requirements.

     See also: etreeplot, gplot.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Produce a graph of tree or forest.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
beta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- : beta (A, B)
     Compute the Beta function for real inputs A and B.

     The Beta function definition is

          beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).

     The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly.  *Note betaln: XREFbetaln, for computing the logarithm of the Beta function in an efficient manner.

     See also: betaln, betainc, betaincinv.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the Beta function for real inputs A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1159
 -- : betainc (X, A, B)
 -- : betainc (X, A, B, TAIL)
     Compute the incomplete beta function.

     This is defined as

                         x
                        /
                       |
          I_x (a, b) = | t^(a-1) (1-t)^(b-1) dt
                       |
                       /
                      0

     with real X in the range [0,1].  The inputs A and B must be real and strictly positive (> 0).  If one of the inputs is not a scalar then the other inputs must be scalar or of compatible dimensions.

     By default, TAIL is "lower" and the incomplete beta function integrated from 0 to X is computed.  If TAIL is "upper" then the complementary function integrated from X to 1 is calculated.  The two choices are related by

     betainc (X, A, B, "upper") = 1 - betainc (X, A, B, "lower").

     ‘betainc’ uses a more sophisticated algorithm than subtraction to get numerically accurate results when the "lower" value is small.

     Reference: A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland, W.B. Jones, ‘Handbook of Continued Fractions for Special Functions’, ch. 18.

     See also: beta, betaincinv, betaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the incomplete beta function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
betaincinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1121
 -- : betaincinv (Y, A, B)
 -- : betaincinv (Y, A, B, "lower")
 -- : betaincinv (Y, A, B, "upper")
     Compute the inverse of the normalized incomplete beta function.

     The normalized incomplete beta function is defined as

                         x
                        /
                       |
          I_x (a, b) = | t^(a-1) (1-t)^(b-1) dt
                       |
                       /
                      0

     If two inputs are scalar, then ‘betaincinv (Y, A, B)’ is returned for each of the other inputs.

     If two or more inputs are not scalar, the sizes of them must agree, and ‘betaincinv’ is applied element-by-element.

     The variable Y must be in the interval [0,1], while A and B must be real and strictly positive.

     By default, TAIL is "lower" and the inverse of the incomplete beta function integrated from 0 to X is computed.  If TAIL is "upper" then the complementary function integrated from X to 1 is inverted.

     The function is computed by standard Newton’s method, by solving

          Y - betainc (X, A, B) = 0

     See also: betainc, beta, betaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the inverse of the normalized incomplete beta function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
betaln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 455
 -- : betaln (A, B)
     Compute the natural logarithm of the Beta function for real inputs A and B.

     ‘betaln’ is defined as

          betaln (a, b) = log (beta (a, b))

     and is calculated in a way to reduce the occurrence of underflow.

     The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly.

     See also: beta, betainc, betaincinv, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute the natural logarithm of the Beta function for real inputs A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cosint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 692
 -- : cosint (X)
     Compute the cosine integral function:

                      +oo
                     /
          Ci (x) = - | (cos (t)) / t dt
                     /
                    x

     An equivalent definition is

                                       x
                                      /
                                      |  cos (t) - 1
          Ci (x) = gamma + log (x) +  | -------------  dt
                                      |        t
                                      /
                                     0

     Reference:

     M. Abramowitz and I.A. Stegun, ‘Handbook of Mathematical Functions’ 1964.

     See also: sinint, expint, cos.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Compute the cosine integral function: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ellipke


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1138
 -- : K = ellipke (M)
 -- : K = ellipke (M, TOL)
 -- : [K, E] = ellipke (...)
     Compute complete elliptic integrals of the first K(M) and second E(M) kind.

     M must be a scalar or real array with -Inf ≤ M ≤ 1.

     The optional input TOL controls the stopping tolerance of the algorithm and defaults to ‘eps (class (M))’.  The tolerance can be increased to compute a faster, less accurate approximation.

     When called with one output only elliptic integrals of the first kind are returned.

     Mathematical Note:

     Elliptic integrals of the first kind are defined as

                   1
                  /               dt
          K (m) = | ------------------------------
                  / sqrt ((1 - t^2)*(1 - m*t^2))
                 0

     Elliptic integrals of the second kind are defined as

                   1
                  /  sqrt (1 - m*t^2)
          E (m) = |  ------------------ dt
                  /  sqrt (1 - t^2)
                 0

     Reference: Milton Abramowitz and Irene A. Stegun, ‘Handbook of Mathematical Functions’, Chapter 17, Dover, 1965.

     See also: ellipj.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute complete elliptic integrals of the first K(M) and second E(M) kind.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
expint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1008
 -- : expint (X)
     Compute the exponential integral.

     The exponential integral is defined as:

                     +oo
                    /
                    | exp (-t)
          E_1 (x) = | -------- dt
                    |    t
                    /
                   x

     Note: For compatibility, this function uses the MATLAB definition of the exponential integral.  Most other sources refer to this particular value as E_1 (x), and the exponential integral as

                      +oo
                     /
                     | exp (-t)
          Ei (x) = - | -------- dt
                     |    t
                     /
                   -x

     The two definitions are related, for positive real values of X, by ‘E_1 (-x) = -Ei (x) - i*pi’.

     References:

     M. Abramowitz and I.A. Stegun, ‘Handbook of Mathematical Functions’, 1964.

     N. Bleistein and R.A. Handelsman, ‘Asymptotic expansions of integrals’, 1986.

     See also: cosint, sinint, exp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Compute the exponential integral.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
factor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 521
 -- : PF = factor (Q)
 -- : [PF, N] = factor (Q)
     Return the prime factorization of Q.

     The prime factorization is defined as ‘prod (PF) == Q’ where every element of PF is a prime number.  If ‘Q == 1’, return 1.

     With two output arguments, return the unique prime factors PF and their multiplicities.  That is, ‘prod (PF .^ N) == Q’.

     Implementation Note: The input Q must be less than ‘flintmax’ (9.0072e+15) in order to factor correctly.

     See also: gcd, lcm, isprime, primes.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return the prime factorization of Q.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
factorial


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- : factorial (N)
     Return the factorial of N where N is a real non-negative integer.

     If N is a scalar, this is equivalent to ‘prod (1:N)’.  For vector or matrix arguments, return the factorial of each element in the array.

     For non-integers see the generalized factorial function ‘gamma’.  Note that the factorial function grows large quite quickly, and even with double precision values overflow will occur if N > 171.  For such cases consider ‘gammaln’.

     See also: prod, gamma, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the factorial of N where N is a real non-negative integer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gammainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1640
 -- : gammainc (X, A)
 -- : gammainc (X, A, TAIL)
     Compute the normalized incomplete gamma function.

     This is defined as

                                          x
                                 1       /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     with the limiting value of 1 as X approaches infinity.  The standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then ‘gammainc (X, A)’ is returned for each element of X and vice versa.

     If neither X nor A is scalar then the sizes of X and A must agree, and ‘gammainc’ is applied element-by-element.  The elements of A must be non-negative.

     By default, TAIL is "lower" and the incomplete gamma function integrated from 0 to X is computed.  If TAIL is "upper" then the complementary function integrated from X to infinity is calculated.

     If TAIL is "scaledlower", then the lower incomplete gamma function is multiplied by gamma(a+1)*exp(x)/(x^a).  If TAIL is "scaledupper", then the upper incomplete gamma function is multiplied by the same quantity.

     References:

     M. Abramowitz and I.A. Stegun, ‘Handbook of mathematical functions’, Dover publications, Inc., 1972.

     W. Gautschi, ‘A computational procedure for incomplete gamma functions’, ACM Trans.  Math Software, pp.  466–481, Vol 5, No.  4, 2012.

     W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery, ‘Numerical Recipes in Fortran 77’, ch. 6.2, Vol 1, 1992.

     See also: gamma, gammaincinv, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the normalized incomplete gamma function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gammaincinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1400
 -- : gammaincinv (Y, A)
 -- : gammaincinv (Y, A, TAIL)
     Compute the inverse of the normalized incomplete gamma function.

     The normalized incomplete gamma function is defined as

                                          x
                                 1       /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     and ‘gammaincinv (gammainc (X, A), A) = X’ for each non-negative value of X.  If A is scalar then ‘gammaincinv (Y, A)’ is returned for each element of Y and vice versa.

     If neither Y nor A is scalar then the sizes of Y and A must agree, and ‘gammaincinv’ is applied element-by-element.  The variable Y must be in the interval [0,1] while A must be real and positive.

     By default, TAIL is "lower" and the inverse of the incomplete gamma function integrated from 0 to X is computed.  If TAIL is "upper", then the complementary function integrated from X to infinity is inverted.

     The function is computed with Newton’s method by solving

          Y - gammainc (X, A) = 0

     Reference: A. Gil, J. Segura, and N. M. Temme, ‘Efficient and accurate algorithms for the computation and inversion of the incomplete gamma function ratios’, SIAM J. Sci.  Computing, pp.  A2965–A2981, Vol 34, 2012.

     See also: gammainc, gamma, gammaln.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the inverse of the normalized incomplete gamma function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isprime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1428
 -- : isprime (X)
     Return a logical array which is true where the elements of X are prime numbers and false where they are not.

     A prime number is conventionally defined as a positive integer greater than 1 (e.g., 2, 3, ...) which is divisible only by itself and 1.  Octave extends this definition to include both negative integers and complex values.  A negative integer is prime if its positive counterpart is prime.  This is equivalent to ‘isprime (abs (x))’.

     If ‘class (X)’ is complex, then primality is tested in the domain of Gaussian integers (<https://en.wikipedia.org/wiki/Gaussian_integer>).  Some non-complex integers are prime in the ordinary sense, but not in the domain of Gaussian integers.  For example, 5 = (1+2i)*(1-2i) shows that 5 is not prime because it has a factor other than itself and 1.  Exercise caution when testing complex and real values together in the same matrix.

     Examples:

          isprime (1:6)
              ⇒ [0, 1, 1, 0, 1, 0]

          isprime ([i, 2, 3, 5])
              ⇒ [0, 0, 1, 0]

     Programming Note: ‘isprime’ is appropriate if the maximum value in X is not too large (< 1e15).  For larger values special purpose factorization code should be used.

     Compatibility Note: MATLAB does not extend the definition of prime numbers and will produce an error if given negative or complex inputs.

     See also: primes, factor, gcd, lcm.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return a logical array which is true where the elements of X are prime numbers and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
lcm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 231
 -- : lcm (X, Y)
 -- : lcm (X, Y, ...)
     Compute the least common multiple of X and Y, or of the list of all arguments.

     All elements must be numeric and of the same size or scalar.

     See also: factor, gcd, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Compute the least common multiple of X and Y, or of the list of all arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
legendre


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2326
 -- : L = legendre (N, X)
 -- : L = legendre (N, X, NORMALIZATION)
     Compute the associated Legendre function of degree N and order M = 0 ... N.

     The value N must be a real non-negative integer.

     X is a vector with real-valued elements in the range [-1, 1].

     The optional argument NORMALIZATION may be one of "unnorm", "sch", or "norm".  The default if no normalization is given is "unnorm".

     When the optional argument NORMALIZATION is "unnorm", compute the associated Legendre function of degree N and order M and return all values for M = 0 ... N.  The return value has one dimension more than X.

     The associated Legendre function of degree N and order M:

           m         m      2  m/2   d^m
          P(x) = (-1) * (1-x  )    * ----  P(x)
           n                         dx^m   n

     with Legendre polynomial of degree N:

                    1    d^n   2    n
          P(x) = ------ [----(x - 1) ]
           n     2^n n!  dx^n

     ‘legendre (3, [-1.0, -0.9, -0.8])’ returns the matrix:

           x  |   -1.0   |   -0.9   |   -0.8
          ------------------------------------
          m=0 | -1.00000 | -0.47250 | -0.08000
          m=1 |  0.00000 | -1.99420 | -1.98000
          m=2 |  0.00000 | -2.56500 | -4.32000
          m=3 |  0.00000 | -1.24229 | -3.24000

     When the optional argument NORMALIZATION is "sch", compute the Schmidt semi-normalized associated Legendre function.  The Schmidt semi-normalized associated Legendre function is related to the unnormalized Legendre functions by the following:

     For Legendre functions of degree N and order 0:

            0      0
          SP(x) = P(x)
            n      n

     For Legendre functions of degree n and order m:

            m      m         m    2(n-m)! 0.5
          SP(x) = P(x) * (-1)  * [-------]
            n      n              (n+m)!

     When the optional argument NORMALIZATION is "norm", compute the fully normalized associated Legendre function.  The fully normalized associated Legendre function is related to the unnormalized associated Legendre functions by the following:

     For Legendre functions of degree N and order M

            m      m         m    (n+0.5)(n-m)! 0.5
          NP(x) = P(x) * (-1)  * [-------------]
            n      n                  (n+m)!

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the associated Legendre function of degree N and order M = 0 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nchoosek


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1326
 -- : C = nchoosek (N, K)
 -- : C = nchoosek (SET, K)

     Compute the binomial coefficient of N or list all possible combinations of a SET of items.

     If N is a scalar then calculate the binomial coefficient of N and K which is defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)       n!
           |   |  = ------------------------- =  ---------
           | k |               k!                k! (n-k)!
           \   /

     This is the number of combinations of N items taken in groups of size K.

     If the first argument is a vector, SET, then generate all combinations of the elements of SET, taken K at a time, with one row per combination.  The result C has K columns and ‘nchoosek (length (SET), K)’ rows.

     For example:

     How many ways can three items be grouped into pairs?

          nchoosek (3, 2)
             ⇒ 3

     What are the possible pairs?

          nchoosek (1:3, 2)
             ⇒  1   2
                 1   3
                 2   3

     Programming Note: When calculating the binomial coefficient ‘nchoosek’ works only for non-negative, integer arguments.  Use ‘bincoeff’ for non-integer and negative scalar arguments, or for computing many binomial coefficients at once with vector inputs for N or K.

     See also: bincoeff, perms.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Compute the binomial coefficient of N or list all possible combinations of a SET of items.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nthroot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 390
 -- : nthroot (X, N)

     Compute the real (non-complex) N-th root of X.

     X must have all real entries and N must be a scalar.  If N is an even integer and X has negative entries then ‘nthroot’ aborts and issues an error.

     Example:

          nthroot (-1, 3)
          ⇒ -1
          (-1) ^ (1 / 3)
          ⇒ 0.50000 - 0.86603i

     See also: realsqrt, sqrt, cbrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compute the real (non-complex) N-th root of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
perms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- : perms (V)
     Generate all permutations of vector V with one row per permutation.

     Results are returned in inverse lexicographic order.  The result has size ‘factorial (N) * N’, where N is the length of V.  Any repetitions are included in the output.  To generate just the unique permutations use ‘unique (perms (V), "rows")(end:-1:1,:)’.

     Example

          perms ([1, 2, 3])
          ⇒
            3   2   1
            3   1   2
            2   3   1
            2   1   3
            1   3   2
            1   2   3

     Programming Note: The maximum length of V should be less than or equal to 10 to limit memory consumption.

     See also: permute, randperm, nchoosek.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Generate all permutations of vector V with one row per permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pow2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- : pow2 (X)
 -- : pow2 (F, E)
     With one input argument, compute 2 .^ x for each element of X.

     With two input arguments, return f .* (2 .^ e).

     See also: log2, nextpow2, power.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
With one input argument, compute 2 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
primes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 571
 -- : P = primes (N)
     Return all primes up to N.

     The output data class (double, single, uint32, etc.) is the same as the input class of N.  The algorithm used is the Sieve of Eratosthenes.

     Note: If you need a specific number of primes you can use the fact that the distance from one prime to the next is, on average, proportional to the logarithm of the prime.  Integrating, one finds that there are about k primes less than k*log (5*k).

     See also ‘list_primes’ if you need a specific number N of primes.

     See also: list_primes, isprime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return all primes up to N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
reallog


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- : reallog (X)
     Return the real-valued natural logarithm of each element of X.

     If any element results in a complex return value ‘reallog’ aborts and issues an error.

     See also: log, realpow, realsqrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the real-valued natural logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realpow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 248
 -- : realpow (X, Y)
     Compute the real-valued, element-by-element power operator.

     This is equivalent to ‘X .^ Y’, except that ‘realpow’ reports an error if any return value is complex.

     See also: power, reallog, realsqrt.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute the real-valued, element-by-element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
realsqrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 222
 -- : realsqrt (X)
     Return the real-valued square root of each element of X.

     If any element results in a complex return value ‘realsqrt’ aborts and issues an error.

     See also: sqrt, realpow, reallog.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the real-valued square root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sinint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- : sinint (X)
     Compute the sine integral function:

                     x
                    /
          Si (x) =  | sin (t) / t dt
                    /
                   0

     Reference: M. Abramowitz and I.A. Stegun, ‘Handbook of Mathematical Functions’, 1964.

     See also: cosint, expint, sin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute the sine integral function: 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gallery


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9223
 -- : gallery (NAME)
 -- : gallery (NAME, ARGS)
     Create interesting matrices for testing.

 -- : C = gallery ("cauchy", X)
 -- : C = gallery ("cauchy", X, Y)
     Create a Cauchy matrix.

 -- : C = gallery ("chebspec", N)
 -- : C = gallery ("chebspec", N, K)
     Create a Chebyshev spectral differentiation matrix.

 -- : C = gallery ("chebvand", P)
 -- : C = gallery ("chebvand", M, P)
     Create a Vandermonde-like matrix for the Chebyshev polynomials.

 -- : A = gallery ("chow", N)
 -- : A = gallery ("chow", N, ALPHA)
 -- : A = gallery ("chow", N, ALPHA, DELTA)
     Create a Chow matrix – a singular Toeplitz lower Hessenberg matrix.

 -- : C = gallery ("circul", V)
     Create a circulant matrix.

 -- : A = gallery ("clement", N)
 -- : A = gallery ("clement", N, K)
     Create a tridiagonal matrix with zero diagonal entries.

 -- : C = gallery ("compar", A)
 -- : C = gallery ("compar", A, K)
     Create a comparison matrix.

 -- : A = gallery ("condex", N)
 -- : A = gallery ("condex", N, K)
 -- : A = gallery ("condex", N, K, THETA)
     Create a ‘counterexample’ matrix to a condition estimator.

 -- : A = gallery ("cycol", [M N])
 -- : A = gallery ("cycol", N)
 -- : A = gallery (..., K)
     Create a matrix whose columns repeat cyclically.

 -- : [C, D, E] = gallery ("dorr", N)
 -- : [C, D, E] = gallery ("dorr", N, THETA)
 -- : A = gallery ("dorr", ...)
     Create a diagonally dominant, ill-conditioned, tridiagonal matrix.

 -- : A = gallery ("dramadah", N)
 -- : A = gallery ("dramadah", N, K)
     Create a (0, 1) matrix whose inverse has large integer entries.

 -- : A = gallery ("fiedler", C)
     Create a symmetric Fiedler matrix.

 -- : A = gallery ("forsythe", N)
 -- : A = gallery ("forsythe", N, ALPHA)
 -- : A = gallery ("forsythe", N, ALPHA, LAMBDA)
     Create a Forsythe matrix (a perturbed Jordan block).

 -- : F = gallery ("frank", N)
 -- : F = gallery ("frank", N, K)
     Create a Frank matrix (ill-conditioned eigenvalues).

 -- : C = gallery ("gcdmat", N)
     Create a greatest common divisor matrix.

     C is an N-by-N matrix whose values correspond to the greatest common divisor of its coordinate values, i.e., C(i,j) correspond ‘gcd (i, j)’.

 -- : A = gallery ("gearmat", N)
 -- : A = gallery ("gearmat", N, I)
 -- : A = gallery ("gearmat", N, I, J)
     Create a Gear matrix.

 -- : G = gallery ("grcar", N)
 -- : G = gallery ("grcar", N, K)
     Create a Toeplitz matrix with sensitive eigenvalues.

 -- : A = gallery ("hanowa", N)
 -- : A = gallery ("hanowa", N, D)
     Create a matrix whose eigenvalues lie on a vertical line in the complex plane.

 -- : V = gallery ("house", X)
 -- : [V, BETA] = gallery ("house", X)
     Create a householder matrix.

 -- : A = gallery ("integerdata", IMAX, [M N ...], J)
 -- : A = gallery ("integerdata", IMAX, M, N, ..., J)
 -- : A = gallery ("integerdata", [IMIN, IMAX], [M N ...], J)
 -- : A = gallery ("integerdata", [IMIN, IMAX], M, N, ..., J)
 -- : A = gallery ("integerdata", ..., "CLASS")
     Create a matrix with random integers in the range [1, IMAX].  If IMIN is given then the integers are in the range [IMIN, IMAX].

     The second input is a matrix of dimensions describing the size of the output.  The dimensions can also be input as comma-separated arguments.

     The input J is an integer index in the range [0, 2^32-1].  The values of the output matrix are always exactly the same (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting matrix.  Possible values for CLASS: "uint8", "uint16", "uint32", "int8", "int16", int32", "single", "double".  The default is "double".

 -- : A = gallery ("invhess", X)
 -- : A = gallery ("invhess", X, Y)
     Create the inverse of an upper Hessenberg matrix.

 -- : A = gallery ("invol", N)
     Create an involutory matrix.

 -- : A = gallery ("ipjfact", N)
 -- : A = gallery ("ipjfact", N, K)
     Create a Hankel matrix with factorial elements.

 -- : A = gallery ("jordbloc", N)
 -- : A = gallery ("jordbloc", N, LAMBDA)
     Create a Jordan block.

 -- : U = gallery ("kahan", N)
 -- : U = gallery ("kahan", N, THETA)
 -- : U = gallery ("kahan", N, THETA, PERT)
     Create a Kahan matrix (upper trapezoidal).

 -- : A = gallery ("kms", N)
 -- : A = gallery ("kms", N, RHO)
     Create a Kac-Murdock-Szego Toeplitz matrix.

 -- : B = gallery ("krylov", A)
 -- : B = gallery ("krylov", A, X)
 -- : B = gallery ("krylov", A, X, J)
     Create a Krylov matrix.

 -- : A = gallery ("lauchli", N)
 -- : A = gallery ("lauchli", N, MU)
     Create a Lauchli matrix (rectangular).

 -- : A = gallery ("lehmer", N)
     Create a Lehmer matrix (symmetric positive definite).

 -- : T = gallery ("lesp", N)
     Create a tridiagonal matrix with real, sensitive eigenvalues.

 -- : A = gallery ("lotkin", N)
     Create a Lotkin matrix.

 -- : A = gallery ("minij", N)
     Create a symmetric positive definite matrix MIN(i,j).

 -- : A = gallery ("moler", N)
 -- : A = gallery ("moler", N, ALPHA)
     Create a Moler matrix (symmetric positive definite).

 -- : [A, T] = gallery ("neumann", N)
     Create a singular matrix from the discrete Neumann problem (sparse).

 -- : A = gallery ("normaldata", [M N ...], J)
 -- : A = gallery ("normaldata", M, N, ..., J)
 -- : A = gallery ("normaldata", ..., "CLASS")
     Create a matrix with random samples from the standard normal distribution (mean = 0, std = 1).

     The first input is a matrix of dimensions describing the size of the output.  The dimensions can also be input as comma-separated arguments.

     The input J is an integer index in the range [0, 2^32-1].  The values of the output matrix are always exactly the same (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting matrix.  Possible values for CLASS: "single", "double".  The default is "double".

 -- : Q = gallery ("orthog", N)
 -- : Q = gallery ("orthog", N, K)
     Create orthogonal and nearly orthogonal matrices.

 -- : A = gallery ("parter", N)
     Create a Parter matrix (a Toeplitz matrix with singular values near pi).

 -- : P = gallery ("pei", N)
 -- : P = gallery ("pei", N, ALPHA)
     Create a Pei matrix.

 -- : A = gallery ("Poisson", N)
     Create a block tridiagonal matrix from Poisson’s equation (sparse).

 -- : A = gallery ("prolate", N)
 -- : A = gallery ("prolate", N, W)
     Create a prolate matrix (symmetric, ill-conditioned Toeplitz matrix).

 -- : H = gallery ("randhess", X)
     Create a random, orthogonal upper Hessenberg matrix.

 -- : A = gallery ("rando", N)
 -- : A = gallery ("rando", N, K)
     Create a random matrix with elements -1, 0 or 1.

 -- : A = gallery ("randsvd", N)
 -- : A = gallery ("randsvd", N, KAPPA)
 -- : A = gallery ("randsvd", N, KAPPA, MODE)
 -- : A = gallery ("randsvd", N, KAPPA, MODE, KL)
 -- : A = gallery ("randsvd", N, KAPPA, MODE, KL, KU)
     Create a random matrix with pre-assigned singular values.

 -- : A = gallery ("redheff", N)
     Create a zero and ones matrix of Redheffer associated with the Riemann hypothesis.

 -- : A = gallery ("riemann", N)
     Create a matrix associated with the Riemann hypothesis.

 -- : A = gallery ("ris", N)
     Create a symmetric Hankel matrix.

 -- : A = gallery ("smoke", N)
 -- : A = gallery ("smoke", N, K)
     Create a complex matrix, with a ‘smoke ring’ pseudospectrum.

 -- : T = gallery ("toeppd", N)
 -- : T = gallery ("toeppd", N, M)
 -- : T = gallery ("toeppd", N, M, W)
 -- : T = gallery ("toeppd", N, M, W, THETA)
     Create a symmetric positive definite Toeplitz matrix.

 -- : P = gallery ("toeppen", N)
 -- : P = gallery ("toeppen", N, A)
 -- : P = gallery ("toeppen", N, A, B)
 -- : P = gallery ("toeppen", N, A, B, C)
 -- : P = gallery ("toeppen", N, A, B, C, D)
 -- : P = gallery ("toeppen", N, A, B, C, D, E)
     Create a pentadiagonal Toeplitz matrix (sparse).

 -- : A = gallery ("tridiag", X, Y, Z)
 -- : A = gallery ("tridiag", N)
 -- : A = gallery ("tridiag", N, C, D, E)
     Create a tridiagonal matrix (sparse).

 -- : T = gallery ("triw", N)
 -- : T = gallery ("triw", N, ALPHA)
 -- : T = gallery ("triw", N, ALPHA, K)
     Create an upper triangular matrix discussed by Kahan, Golub, and Wilkinson.

 -- : A = gallery ("uniformdata", [M N ...], J)
 -- : A = gallery ("uniformdata", M, N, ..., J)
 -- : A = gallery ("uniformdata", ..., "CLASS")
     Create a matrix with random samples from the standard uniform distribution (range [0,1]).

     The first input is a matrix of dimensions describing the size of the output.  The dimensions can also be input as comma-separated arguments.

     The input J is an integer index in the range [0, 2^32-1].  The values of the output matrix are always exactly the same (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting matrix.  Possible values for CLASS: "single", "double".  The default is "double".

 -- : A = gallery ("wathen", NX, NY)
 -- : A = gallery ("wathen", NX, NY, K)
     Create the Wathen matrix.

 -- : [A, B] = gallery ("wilk", N)
     Create various specific matrices devised/discussed by Wilkinson.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create interesting matrices for testing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
hadamard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 681
 -- : hadamard (N)
     Construct a Hadamard matrix (Hn) of size N-by-N.

     The size N must be of the form 2^k * p in which p is one of 1, 12, 20 or 28.  The returned matrix is normalized, meaning ‘Hn(:,1) == 1’ and ‘Hn(1,:) == 1’.

     Some of the properties of Hadamard matrices are:

        • ‘kron (Hm, Hn)’ is a Hadamard matrix of size M-by-N.

        • ‘Hn * Hn' = N * eye (N)’.

        • The rows of Hn are orthogonal.

        • ‘det (A) <= abs (det (Hn))’ for all A with ‘abs (A(i, j)) <= 1’.

        • Multiplying any row or column by -1 and the matrix will remain a Hadamard matrix.

     See also: compan, hankel, toeplitz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Construct a Hadamard matrix (Hn) of size N-by-N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
hankel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 548
 -- : hankel (C)
 -- : hankel (C, R)
     Return the Hankel matrix constructed from the first column C, and (optionally) the last row R.

     If the last element of C is not the same as the first element of R, the last element of C is used.  If the second argument is omitted, it is assumed to be a vector of zeros with the same size as C.

     A Hankel matrix formed from an m-vector C, and an n-vector R, has the elements

          H(i,j) = c(i+j-1),  i+j-1 <= m;
          H(i,j) = r(i+j-m),  otherwise

     See also: hadamard, toeplitz.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Return the Hankel matrix constructed from the first column C, and (optionally) the last row R.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hilb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 542
 -- : hilb (N)
     Return the Hilbert matrix of order N.

     The i,j element of a Hilbert matrix is defined as

          H(i, j) = 1 / (i + j - 1)

     Hilbert matrices are close to being singular which make them difficult to invert with numerical routines.  Comparing the condition number of a random matrix 5x5 matrix with that of a Hilbert matrix of order 5 reveals just how difficult the problem is.

          cond (rand (5))
             ⇒ 14.392
          cond (hilb (5))
             ⇒ 4.7661e+05

     See also: invhilb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the Hilbert matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
invhilb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 974
 -- : invhilb (N)
     Return the inverse of the Hilbert matrix of order N.

     This can be computed exactly using


                     (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
          A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                   \ n-j /  \ n-i /   \ i-2 /

                 = p(i) p(j) / (i+j-1)


     where

                   k  /k+n-1\   /n\
          p(k) = -1  (       ) (   )
                      \ k-1 /   \k/

     The validity of this formula can easily be checked by expanding the binomial coefficients in both formulas as factorials.  It can be derived more directly via the theory of Cauchy matrices.  See J. W. Demmel, ‘Applied Numerical Linear Algebra’, p.  92.

     Compare this with the numerical calculation of ‘inverse (hilb (n))’, which suffers from the ill-conditioning of the Hilbert matrix, and the finite precision of your computer’s floating point arithmetic.

     See also: hilb.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the inverse of the Hilbert matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
magic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 387
 -- : magic (N)

     Create an N-by-N magic square.

     A magic square is an arrangement of the integers ‘1:n^2’ such that the row sums, column sums, and diagonal sums are all equal to the same value.

     Note: N must be a scalar greater than or equal to 3.  If you supply N less than 3, magic returns either a nonmagic square, or else the degenerate magic squares 1 and [].
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Create an N-by-N magic square.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pascal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 653
 -- : pascal (N)
 -- : pascal (N, T)
     Return the Pascal matrix of order N if ‘T = 0’.

     The default value of T is 0.

     When ‘T = 1’, return the pseudo-lower triangular Cholesky factor of the Pascal matrix (The sign of some columns may be negative).  This matrix is its own inverse, that is ‘pascal (N, 1) ^ 2 == eye (N)’.

     If ‘T = -1’, return the true Cholesky factor with strictly positive values on the diagonal.

     If ‘T = 2’, return a transposed and permuted version of ‘pascal (N, 1)’, which is the cube root of the identity matrix.  That is, ‘pascal (N, 2) ^ 3 == eye (N)’.

     See also: chol.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the Pascal matrix of order N if ‘T = 0’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rosser


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- : rosser ()
     Return the Rosser matrix.

     This is a difficult test case used to evaluate eigenvalue algorithms.

     See also: wilkinson, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Return the Rosser matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
toeplitz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 815
 -- : toeplitz (C)
 -- : toeplitz (C, R)
     Return the Toeplitz matrix constructed from the first column C, and optionally the first row R.

     If the second argument is omitted, the first row is taken to be the same as the first column.  If the first element of R is not the same as the first element of C, the first element of C is used.

     A Toeplitz, or diagonal-constant, matrix has the same value along each diagonal.  Although it need not be square, it often is.  An MxN Toeplitz matrix has the form:

          c(1)  r(2)   r(3)  ...  r(n)
          c(2)  c(1)   r(2)  ... r(n-1)
          c(3)  c(2)   c(1)  ... r(n-2)
           .     .      .   .      .
           .     .      .     .    .
           .     .      .       .  .
          c(m) c(m-1) c(m-2) ... c(m-n+1)

     See also: hankel.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
Return the Toeplitz matrix constructed from the first column C, and optionally the first row R.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
vander


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- : vander (C)
 -- : vander (C, N)
     Return the Vandermonde matrix whose next to last column is C.

     If N is specified, it determines the number of columns; otherwise, N is taken to be equal to the length of C.

     A Vandermonde matrix has the form:

          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1

     See also: polyfit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the Vandermonde matrix whose next to last column is C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
wilkinson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 290
 -- : wilkinson (N)
     Return the Wilkinson matrix of order N.

     Wilkinson matrices are symmetric and tridiagonal with pairs of nearly, but not exactly, equal eigenvalues.  They are useful in testing the behavior and performance of eigenvalue solvers.

     See also: rosser, eig.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Return the Wilkinson matrix of order N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bounds


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 917
 -- : [S, L] = bounds (X)
 -- : [S, L] = bounds (X, DIM)
 -- : [S, L] = bounds (..., "nanflag")
     Return the smallest and largest values of the input data X.

     If X is a vector, the bounds are calculated over the elements of X.  If X is a matrix, the bounds are calculated for each column.  For a multi-dimensional array, the bounds are calculated over the first non-singleton dimension.

     If the optional argument DIM is given, operate along this dimension.

     The optional argument "nanflag" defaults to "omitnan" which does not include NaN values in the result.  If the argument "includenan" is given, and there is a NaN present, then the result for both smallest (S) and largest (L) elements will be NaN.

     The bounds are a quickly computed measure of the dispersion of a data set, but are less accurate than ‘iqr’ if there are outlying data points.

     See also: range, iqr, mad, std.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the smallest and largest values of the input data X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
center


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 641
 -- : center (X)
 -- : center (X, DIM)
     Center data by subtracting its mean.

     If X is a vector, subtract its mean.

     If X is a matrix, do the above for each column.

     If the optional argument DIM is given, operate along this dimension.

     Programming Note: ‘center’ has obvious application for normalizing statistical data.  It is also useful for improving the precision of general numerical calculations.  Whenever there is a large value that is common to a batch of data, the mean can be subtracted off, the calculation performed, and then the mean added back to obtain the final answer.

     See also: zscore.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Center data by subtracting its mean.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
corr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- : corr (X)
 -- : corr (X, Y)
     Compute matrix of correlation coefficients.

     If each row of X and Y is an observation and each column is a variable, then the (I, J)-th entry of ‘corr (X, Y)’ is the correlation between the I-th variable in X and the J-th variable in Y.

          corr (X,Y) = cov (X,Y) / (std (X) * std (Y))

     If called with one argument, compute ‘corr (X, X)’, the correlation between the columns of X.

     See also: cov.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute matrix of correlation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
corrcoef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1363
 -- : R = corrcoef (X)
 -- : R = corrcoef (X, Y)
 -- : [R, P] = corrcoef (...)
 -- : [R, P, LCI, HCI] = corrcoef (...)
 -- : [...] = corrcoef (..., PARAM, VALUE, ...)
     Compute a matrix of correlation coefficients.

     X is an array where each column contains a variable and each row is an observation.

     If a second input Y (of the same size as X) is given then calculate the correlation coefficients between X and Y.

     R is a matrix of Pearson’s product moment correlation coefficients for each pair of variables.

     P is a matrix of pair-wise p-values testing for the null hypothesis of a correlation coefficient of zero.

     LCI and HCI are matrices containing, respectively, the lower and higher bounds of the 95% confidence interval of each correlation coefficient.

     PARAM, VALUE are pairs of optional parameters and values.  Valid options are:

     "alpha"
          Confidence level used for the definition of the bounds of the confidence interval, LCI and HCI.  Default is 0.05, i.e., 95% confidence interval.

     "rows"
          Determine processing of NaN values.  Acceptable values are "all", "complete", and "pairwise".  Default is "all".  With "complete", only the rows without NaN values are considered.  With "pairwise", the selection of NaN-free rows is made for each pair of variables.

     See also: corr, cov.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Compute a matrix of correlation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1262
 -- : cov (X)
 -- : cov (X, OPT)
 -- : cov (X, Y)
 -- : cov (X, Y, OPT)
     Compute the covariance matrix.

     If each row of X and Y is an observation, and each column is a variable, then the (I, J)-th entry of ‘cov (X, Y)’ is the covariance between the I-th variable in X and the J-th variable in Y.

          cov (X) = 1/(N-1) * SUM_i (X(i) - mean(X)) * (Y(i) - mean(Y))

     where N is the length of the X and Y vectors.

     If called with one argument, compute ‘cov (X, X)’, the covariance between the columns of X.

     The argument OPT determines the type of normalization to use.  Valid values are

     0:
          normalize with N-1, provides the best unbiased estimator of the covariance [default]

     1:
          normalize with N, this provides the second moment around the mean

     Compatibility Note:: Octave always treats rows of X and Y as multivariate random variables.  For two inputs, however, MATLAB treats X and Y as two univariate distributions regardless of their shapes, and will calculate ‘cov ([X(:), Y(:)])’ whenever the number of elements in X and Y are equal.  This will result in a 2x2 matrix.  Code relying on MATLAB’s definition will need to be changed when running in Octave.

     See also: corr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Compute the covariance matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
 -- : discrete_cdf (X, V, P)
     For each element of X, compute the cumulative distribution function (CDF) at X of a univariate discrete distribution which assumes the values in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
For each element of X, compute the cumulative distribution function (CDF) at X of a univariate discrete distribution which assumes the values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- : discrete_inv (X, V, P)
     For each element of X, compute the quantile (the inverse of the CDF) at X of the univariate distribution which assumes the values in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
For each element of X, compute the quantile (the inverse of the CDF) at X of the univariate distribution which assumes the values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- : discrete_pdf (X, V, P)
     For each element of X, compute the probability density function (PDF) at X of a univariate discrete distribution which assumes the values in V with probabilities P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
For each element of X, compute the probability density function (PDF) at X of a univariate discrete distribution which assumes the values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
discrete_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- : discrete_rnd (V, P)
 -- : discrete_rnd (V, P, R)
 -- : discrete_rnd (V, P, R, C, ...)
 -- : discrete_rnd (V, P, [SZ])
     Return a matrix of random samples from the univariate distribution which assumes the values in V with probabilities P.

     When called with a single size argument, return a square matrix with the dimension specified.  When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.  The size may also be specified with a vector of dimensions SZ.

     If no size arguments are given then the result matrix is the common size of V and P.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 118
Return a matrix of random samples from the univariate distribution which assumes the values in V with probabilities P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- : empirical_cdf (X, DATA)
     For each element of X, compute the cumulative distribution function (CDF) at X of the empirical distribution obtained from the univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
For each element of X, compute the cumulative distribution function (CDF) at X of the empirical distribution obtained from the univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- : empirical_inv (X, DATA)
     For each element of X, compute the quantile (the inverse of the CDF) at X of the empirical distribution obtained from the univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
For each element of X, compute the quantile (the inverse of the CDF) at X of the empirical distribution obtained from the univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_pdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 -- : empirical_pdf (X, DATA)
     For each element of X, compute the probability density function (PDF) at X of the empirical distribution obtained from the univariate sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
For each element of X, compute the probability density function (PDF) at X of the empirical distribution obtained from the univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
empirical_rnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 689
 -- : empirical_rnd (DATA)
 -- : empirical_rnd (DATA, R)
 -- : empirical_rnd (DATA, R, C, ...)
 -- : empirical_rnd (DATA, [SZ])
     Return a matrix of random samples from the empirical distribution obtained from the univariate sample DATA.

     When called with a single size argument, return a square matrix with the dimension specified.  When called with more than one scalar argument the first two arguments are taken as the number of rows and columns and any further arguments specify additional matrix dimensions.  The size may also be specified with a vector of dimensions SZ.

     If no size arguments are given then the result matrix is a random ordering of the sample DATA.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Return a matrix of random samples from the empirical distribution obtained from the univariate sample DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
histc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 967
 -- : N = histc (X, EDGES)
 -- : N = histc (X, EDGES, DIM)
 -- : [N, IDX] = histc (...)
     Compute histogram counts.

     When X is a vector, the function counts the number of elements of X that fall in the histogram bins defined by EDGES.  This must be a vector of monotonically increasing values that define the edges of the histogram bins.  ‘N(k)’ contains the number of elements in X for which ‘EDGES(k) <= X < EDGES(k+1)’.  The final element of N contains the number of elements of X exactly equal to the last element of EDGES.

     When X is an N-dimensional array, the computation is carried out along dimension DIM.  If not specified DIM defaults to the first non-singleton dimension.

     When a second output argument is requested an index matrix is also returned.  The IDX matrix has the same size as X.  Each element of IDX contains the index of the histogram bin in which the corresponding element of X was counted.

     See also: hist.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Compute histogram counts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
iqr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- : iqr (X)
 -- : iqr (X, DIM)
     Return the interquartile range, i.e., the difference between the upper and lower quartile of the input data.

     If X is a matrix, do the above for first non-singleton dimension of X.

     If the optional argument DIM is given, operate along this dimension.

     As a measure of dispersion, the interquartile range is less affected by outliers than either ‘range’ or ‘std’.

     See also: bounds, mad, range, std.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the interquartile range, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
kendall


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 712
 -- : kendall (X)
 -- : kendall (X, Y)
     Compute Kendall’s TAU.

     For two data vectors X, Y of common length N, Kendall’s TAU is the correlation of the signs of all rank differences of X and Y; i.e., if both X and Y have distinct entries, then

                   1
          TAU = -------   SUM sign (Q(i) - Q(j)) * sign (R(i) - R(j))
                N (N-1)   i,j

     in which the Q(i) and R(i) are the ranks of X and Y, respectively.

     If X and Y are drawn from independent distributions, Kendall’s TAU is asymptotically normal with mean 0 and variance ‘(2 * (2N+5)) / (9 * N * (N-1))’.

     ‘kendall (X)’ is equivalent to ‘kendall (X, X)’.

     See also: ranks, spearman.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Compute Kendall’s TAU.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
kurtosis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1197
 -- : kurtosis (X)
 -- : kurtosis (X, FLAG)
 -- : kurtosis (X, FLAG, DIM)
     Compute the sample kurtosis of the elements of X.

     The sample kurtosis is defined as

               mean ((X - mean (X)).^4)
          k1 = ------------------------
                      std (X).^4

     The optional argument FLAG controls which normalization is used.  If FLAG is equal to 1 (default value, used when FLAG is omitted or empty), return the sample kurtosis as defined above.  If FLAG is equal to 0, return the "bias-corrected" kurtosis coefficient instead:

                        N - 1
          k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
                   (N - 2)(N - 3)

     where N is the length of the X vector.

     The bias-corrected kurtosis coefficient is obtained by replacing the sample second and fourth central moments by their unbiased versions.  It is an unbiased estimate of the population kurtosis for normal populations.

     If X is a matrix, or more generally a multi-dimensional array, return the kurtosis along the first non-singleton dimension.  If the optional DIM argument is given, operate along this dimension.

     See also: var, skewness, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the sample kurtosis of the elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 949
 -- : mad (X)
 -- : mad (X, OPT)
 -- : mad (X, OPT, DIM)
     Compute the mean or median absolute deviation of the elements of X.

     The mean absolute deviation is defined as

          MAD = mean (abs (X - mean (X)))

     The median absolute deviation is defined as

          MAD = median (abs (X - median (X)))

     If X is a matrix, compute ‘mad’ for each column and return results in a row vector.  For a multi-dimensional array, the calculation is done over the first non-singleton dimension.

     The optional argument OPT determines whether mean or median absolute deviation is calculated.  The default is 0 which corresponds to mean absolute deviation; A value of 1 corresponds to median absolute deviation.

     If the optional argument DIM is given, operate along this dimension.

     As a measure of dispersion, ‘mad’ is less affected by outliers than ‘std’.

     See also: bounds, range, iqr, std, mean, median.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Compute the mean or median absolute deviation of the elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1267
 -- : mean (X)
 -- : mean (X, DIM)
 -- : mean (X, OPT)
 -- : mean (X, DIM, OPT)
 -- : mean (..., OUTTYPE)
     Compute the mean of the elements of the vector X.

     The mean is defined as

          mean (X) = SUM_i X(i) / N

     where N is the length of the X vector.

     If X is a matrix, compute the mean for each column and return them in a row vector.

     If the optional argument DIM is given, operate along this dimension.

     The optional argument OPT selects the type of mean to compute.  The following options are recognized:

     "a"
          Compute the (ordinary) arithmetic mean.  [default]

     "g"
          Compute the geometric mean.

     "h"
          Compute the harmonic mean.

     The optional argument OUTTYPE selects the data type of the output value.  The following options are recognized:

     "default"
          Output will be of class double unless X is of class single, in which case the output will also be single.

     "double"
          Output will be of class double.

     "native"
          Output will be the same class as X unless X is of class logical in which case it returns of class double.

     Both DIM and OPT are optional.  If both are supplied, either may appear first.

     See also: median, mode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the mean of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
meansq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 422
 -- : meansq (X)
 -- : meansq (X, DIM)
     Compute the mean square of the elements of the vector X.

     The mean square is defined as

          meansq (X) = 1/N SUM_i X(i)^2

     where N is the length of the X vector.

     If X is a matrix, return a row vector containing the mean square of each column.

     If the optional argument DIM is given, operate along this dimension.

     See also: var, std, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute the mean square of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
median


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 652
 -- : median (X)
 -- : median (X, DIM)
     Compute the median value of the elements of the vector X.

     When the elements of X are sorted, say ‘S = sort (X)’, the median is defined as

                       |  S(ceil(N/2))           N odd
          median (X) = |
                       | (S(N/2) + S(N/2+1))/2   N even

     If X is of a discrete type such as integer or logical, then the case of even N rounds up (or toward ‘true’).

     If X is a matrix, compute the median value for each column and return them in a row vector.

     If the optional DIM argument is given, operate along this dimension.

     See also: mean, mode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute the median value of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 631
 -- : mode (X)
 -- : mode (X, DIM)
 -- : [M, F, C] = mode (...)
     Compute the most frequently occurring value in a dataset (mode).

     ‘mode’ determines the frequency of values along the first non-singleton dimension and returns the value with the highest frequency.  If two, or more, values have the same frequency ‘mode’ returns the smallest.

     If the optional argument DIM is given, operate along this dimension.

     The return variable F is the number of occurrences of the mode in the dataset.

     The cell array C contains all of the elements with the maximum frequency.

     See also: mean, median.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the most frequently occurring value in a dataset (mode).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
moment


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1150
 -- : moment (X, P)
 -- : moment (X, P, TYPE)
 -- : moment (X, P, DIM)
 -- : moment (X, P, TYPE, DIM)
 -- : moment (X, P, DIM, TYPE)
     Compute the P-th central moment of the vector X.

     The P-th central moment of X is defined as:

          1/N SUM_i (X(i) - mean(X))^P

     where N is the length of the X vector.

     If X is a matrix, return the row vector containing the P-th central moment of each column.

     If the optional argument DIM is given, operate along this dimension.

     The optional string TYPE specifies the type of moment to be computed.  Valid options are:

     "c"
          Central Moment (default).

     "a"
     "ac"
          Absolute Central Moment.  The moment about the mean ignoring sign defined as

               1/N SUM_i (abs (X(i) - mean(X)))^P

     "r"
          Raw Moment.  The moment about zero defined as

               moment (X) = 1/N SUM_i X(i)^P

     "ar"
          Absolute Raw Moment.  The moment about zero ignoring sign defined as

               1/N SUM_i ( abs (X(i)) )^P

     If both TYPE and DIM are given they may appear in any order.

     See also: var, skewness, kurtosis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the P-th central moment of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
prctile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 712
 -- : Q = prctile (X)
 -- : Q = prctile (X, P)
 -- : Q = prctile (X, P, DIM)
     For a sample X, compute the quantiles, Q, corresponding to the cumulative probability values, P, in percent.

     If X is a matrix, compute the percentiles for each column and return them in a matrix, such that the i-th row of Q contains the P(i)th percentiles of each column of X.

     If P is unspecified, return the quantiles for ‘[0 25 50 75 100]’.

     The optional argument DIM determines the dimension along which the percentiles are calculated.  If DIM is omitted it defaults to the first non-singleton dimension.

     Programming Note: All non-numeric values (NaNs) of X are ignored.

     See also: quantile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
For a sample X, compute the quantiles, Q, corresponding to the cumulative probability values, P, in percent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
quantile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2800
 -- : Q = quantile (X)
 -- : Q = quantile (X, P)
 -- : Q = quantile (X, P, DIM)
 -- : Q = quantile (X, P, DIM, METHOD)
     For a sample, X, calculate the quantiles, Q, corresponding to the cumulative probability values in P.  All non-numeric values (NaNs) of X are ignored.

     If X is a matrix, compute the quantiles for each column and return them in a matrix, such that the i-th row of Q contains the P(i)th quantiles of each column of X.

     If P is unspecified, return the quantiles for ‘[0.00 0.25 0.50 0.75 1.00]’.  The optional argument DIM determines the dimension along which the quantiles are calculated.  If DIM is omitted it defaults to the first non-singleton dimension.

     The methods available to calculate sample quantiles are the nine methods used by R (<https://www.r-project.org/>).  The default value is METHOD = 5.

     Discontinuous sample quantile methods 1, 2, and 3

       1. Method 1: Inverse of empirical distribution function.

       2. Method 2: Similar to method 1 but with averaging at discontinuities.

       3. Method 3: SAS definition: nearest even order statistic.

     Continuous sample quantile methods 4 through 9, where P(k) is the linear interpolation function respecting each method’s representative cdf.

       4. Method 4: P(k) = k / N. That is, linear interpolation of the empirical cdf, where N is the length of P.

       5. Method 5: P(k) = (k - 0.5) / N. That is, a piecewise linear function where the knots are the values midway through the steps of the empirical cdf.

       6. Method 6: P(k) = k / (N + 1).

       7. Method 7: P(k) = (k - 1) / (N - 1).

       8. Method 8: P(k) = (k - 1/3) / (N + 1/3).  The resulting quantile estimates are approximately median-unbiased regardless of the distribution of X.

       9. Method 9: P(k) = (k - 3/8) / (N + 1/4).  The resulting quantile estimates are approximately unbiased for the expected order statistics if X is normally distributed.

     Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS use method 6.  MATLAB uses method 5.

     References:

        • Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language.  Wadsworth & Brooks/Cole.

        • Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in statistical packages, American Statistician, 50, 361–365.

        • R: A Language and Environment for Statistical Computing; <https://cran.r-project.org/doc/manuals/fullrefman.pdf>.

     Examples:

          x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
          q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
          q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution

     See also: prctile.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
For a sample, X, calculate the quantiles, Q, corresponding to the cumulative probability values in P.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
range


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 541
 -- : range (X)
 -- : range (X, DIM)
     Return the range, i.e., the difference between the maximum and the minimum of the input data.

     If X is a vector, the range is calculated over the elements of X.  If X is a matrix, the range is calculated over each column of X.

     If the optional argument DIM is given, operate along this dimension.

     The range is a quickly computed measure of the dispersion of a data set, but is less accurate than ‘iqr’ if there are outlying data points.

     See also: bounds, iqr, mad, std.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Return the range, i.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ranks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 220
 -- : ranks (X, DIM)
     Return the ranks of X along the first non-singleton dimension adjusted for ties.

     If the optional argument DIM is given, operate along this dimension.

     See also: spearman, kendall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the ranks of X along the first non-singleton dimension adjusted for ties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
run_count


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- : run_count (X, N)
 -- : run_count (X, N, DIM)
     Count the upward runs along the first non-singleton dimension of X of length 1, 2, ..., N-1 and greater than or equal to N.

     If the optional argument DIM is given then operate along this dimension.

     See also: runlength.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Count the upward runs along the first non-singleton dimension of X of length 1, 2, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
runlength


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 391
 -- : count = runlength (X)
 -- : [count, value] = runlength (X)
     Find the lengths of all sequences of common values.

     COUNT is a vector with the lengths of each repeated value.

     The optional output VALUE contains the value that was repeated in the sequence.

          runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
          ⇒  [2, 1, 3, 1, 4]

     See also: run_count.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find the lengths of all sequences of common values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
skewness


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1215
 -- : skewness (X)
 -- : skewness (X, FLAG)
 -- : skewness (X, FLAG, DIM)
     Compute the sample skewness of the elements of X.

     The sample skewness is defined as

                         mean ((X - mean (X)).^3)
          skewness (X) = ------------------------.
                                std (X).^3

     The optional argument FLAG controls which normalization is used.  If FLAG is equal to 1 (default value, used when FLAG is omitted or empty), return the sample skewness as defined above.  If FLAG is equal to 0, return the adjusted skewness coefficient instead:

                            sqrt (N*(N-1))   mean ((X - mean (X)).^3)
          skewness (X, 0) = -------------- * ------------------------.
                                (N - 2)             std (X).^3

     where N is the length of the X vector.

     The adjusted skewness coefficient is obtained by replacing the sample second and third central moments by their bias-corrected versions.

     If X is a matrix, or more generally a multi-dimensional array, return the skewness along the first non-singleton dimension.  If the optional DIM argument is given, operate along this dimension.

     See also: var, kurtosis, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the sample skewness of the elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
spearman


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 509
 -- : spearman (X)
 -- : spearman (X, Y)
     Compute Spearman’s rank correlation coefficient RHO.

     For two data vectors X and Y, Spearman’s RHO is the correlation coefficient of the ranks of X and Y.

     If X and Y are drawn from independent distributions, RHO has zero mean and variance ‘1 / (N - 1)’, where N is the length of the X and Y vectors, and is asymptotically normally distributed.

     ‘spearman (X)’ is equivalent to ‘spearman (X, X)’.

     See also: ranks, kendall.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute Spearman’s rank correlation coefficient RHO.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
statistics


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- : statistics (X)
 -- : statistics (X, DIM)
     Return a vector with the minimum, first quartile, median, third quartile, maximum, mean, standard deviation, skewness, and kurtosis of the elements of the vector X.

     If X is a matrix, calculate statistics over the first non-singleton dimension.

     If the optional argument DIM is given, operate along this dimension.

     See also: min, max, median, mean, std, skewness, kurtosis.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
Return a vector with the minimum, first quartile, median, third quartile, maximum, mean, standard deviation, skewness, and kurtosis of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
std


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 842
 -- : std (X)
 -- : std (X, OPT)
 -- : std (X, OPT, DIM)
     Compute the standard deviation of the elements of the vector X.

     The standard deviation is defined as

          std (X) = sqrt ( 1/(N-1) SUM_i (X(i) - mean(X))^2 )

     where N is the number of elements of the X vector.

     If X is a matrix, compute the standard deviation for each column and return them in a row vector.

     The argument OPT determines the type of normalization to use.  Valid values are

     0:
          normalize with N-1, provides the square root of the best unbiased estimator of the variance [default]

     1:
          normalize with N, this provides the square root of the second moment around the mean

     If the optional argument DIM is given, operate along this dimension.

     See also: var, bounds, mad, range, iqr, mean, median.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the standard deviation of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
var


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 833
 -- : var (X)
 -- : var (X, OPT)
 -- : var (X, OPT, DIM)
     Compute the variance of the elements of the vector X.

     The variance is defined as

          var (X) = 1/(N-1) SUM_i (X(i) - mean(X))^2

     where N is the length of the X vector.

     If X is a matrix, compute the variance for each column and return them in a row vector.

     The argument OPT determines the type of normalization to use.  Valid values are

     0:
          normalize with N-1, provides the best unbiased estimator of the variance [default]

     1:
          normalizes with N, this provides the second moment around the mean

     If N is equal to 1 the value of OPT is ignored and normalization by N is used.

     If the optional argument DIM is given, operate along this dimension.

     See also: cov, std, skewness, kurtosis, moment.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the variance of the elements of the vector X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zscore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 733
 -- : Z = zscore (X)
 -- : Z = zscore (X, OPT)
 -- : Z = zscore (X, OPT, DIM)
 -- : [Z, MU, SIGMA] = zscore (...)
     Compute the Z score of X.

     If X is a vector, subtract its mean and divide by its standard deviation.  If the standard deviation is zero, divide by 1 instead.

     The optional parameter OPT determines the normalization to use when computing the standard deviation and has the same definition as the corresponding parameter for ‘std’.

     If X is a matrix, calculate along the first non-singleton dimension.  If the third optional argument DIM is given, operate along this dimension.

     The optional outputs MU and SIGMA contain the mean and standard deviation.

     See also: mean, std, center.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Compute the Z score of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
base2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 669
 -- : base2dec (S, BASE)
     Convert S from a string of digits in base BASE to a decimal integer (base 10).

          base2dec ("11120", 3)
             ⇒ 123

     If S is a string matrix, return a column vector with one value per row of S.  If a row contains invalid symbols then the corresponding value will be NaN.

     If S is a cell array of strings, return a column vector with one value per cell element in S.

     If BASE is a string, the characters of BASE are used as the symbols for the digits of S.  Space (’ ’) may not be used as a symbol.

          base2dec ("yyyzx", "xyz")
             ⇒ 123

     See also: dec2base, bin2dec, hex2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Convert S from a string of digits in base BASE to a decimal integer (base 10).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bin2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 620
 -- : bin2dec (S)
     Return the decimal number corresponding to the binary number represented by the string S.

     For example:

          bin2dec ("1110")
               ⇒ 14

     Spaces are ignored during conversion and may be used to make the binary number more readable.

          bin2dec ("1000 0001")
               ⇒ 129

     If S is a string matrix, return a column vector with one converted number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one converted number per cell element in S.

     See also: dec2bin, base2dec, hex2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 89
Return the decimal number corresponding to the binary number represented by the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
blanks


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 371
 -- : blanks (N)
     Return a string of N blanks.

     For example:

          blanks (10);
          whos ans
               ⇒
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x10                        10  char

     See also: repmat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return a string of N blanks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cstrcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 390
 -- : cstrcat (S1, S2, ...)
     Return a string containing all the arguments concatenated horizontally with trailing white space preserved.

     For example:

          cstrcat ("ab   ", "cd")
                ⇒ "ab   cd"

          s = [ "ab"; "cde" ];
          cstrcat (s, s, s)
                ⇒ "ab ab ab "
                   "cdecdecde"

     See also: strcat, char, strvcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
Return a string containing all the arguments concatenated horizontally with trailing white space preserved.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
deblank


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- : deblank (S)
     Remove trailing whitespace and nulls from S.

     If S is a matrix, DEBLANK trims each row to the length of longest string.  If S is a cell array of strings, operate recursively on each string element.

     Examples:

          deblank ("    abc  ")
               ⇒  "    abc"

          deblank ([" abc   "; "   def   "])
               ⇒  [" abc  " ; "   def"]

     See also: strtrim.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Remove trailing whitespace and nulls from S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dec2base


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 -- : dec2base (D, BASE)
 -- : dec2base (D, BASE, LEN)
     Return a string of symbols in base BASE corresponding to the non-negative integer D.

          dec2base (123, 3)
             ⇒ "11120"

     If D is a matrix or cell array, return a string matrix with one row per element in D, padded with leading zeros to the width of the largest value.

     If BASE is a string then the characters of BASE are used as the symbols for the digits of D.  Space (’ ’) may not be used as a symbol.

          dec2base (123, "aei")
             ⇒ "eeeia"

     The optional third argument, LEN, specifies the minimum number of digits in the result.

     See also: base2dec, dec2bin, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Return a string of symbols in base BASE corresponding to the non-negative integer D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dec2bin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 491
 -- : dec2bin (D, LEN)
     Return a binary number corresponding to the non-negative integer D, as a string of ones and zeros.

     For example:

          dec2bin (14)
               ⇒ "1110"

     If D is a matrix or cell array, return a string matrix with one row per element in D, padded with leading zeros to the width of the largest value.

     The optional second argument, LEN, specifies the minimum number of digits in the result.

     See also: bin2dec, dec2base, dec2hex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 98
Return a binary number corresponding to the non-negative integer D, as a string of ones and zeros.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dec2hex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- : dec2hex (D, LEN)
     Return the hexadecimal string corresponding to the non-negative integer D.

     For example:

          dec2hex (2748)
               ⇒ "ABC"

     If D is a matrix or cell array, return a string matrix with one row per element in D, padded with leading zeros to the width of the largest value.

     The optional second argument, LEN, specifies the minimum number of digits in the result.

     See also: hex2dec, dec2base, dec2bin.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return the hexadecimal string corresponding to the non-negative integer D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
erase


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1033
 -- : NEWSTR = erase (STR, PTN)
     Delete all occurrences of PTN within STR.

     STR and PTN can be ordinary strings, cell array of strings, or character arrays.

     Examples

          ## string, single pattern
          erase ("Hello World!", " World")
              ⇒ "Hello!"

          ## cellstr, single pattern
          erase ({"Hello", "World!"}, "World")
              ⇒ {"Hello", "!"}

          ## string, multiple patterns
          erase ("The Octave interpreter is fabulous", {"interpreter ", "The "})
              ⇒ "Octave is fabulous"

          ## cellstr, multiple patterns
          erase ({"The ", "Octave interpreter ", "is fabulous"}, {"interpreter ", "The "})
              ⇒ {"", "Octave ", "is fabulous"}

     Programming Note: ‘erase’ deletes the first instance of a pattern in a string when there are overlapping occurrences.  For example:

          erase ("abababa", "aba")
              ⇒ "b"

     See ‘strrep’ for processing overlaps.

     See also: strrep, regexprep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Delete all occurrences of PTN within STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
findstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- : findstr (S, T)
 -- : findstr (S, T, OVERLAP)
     Return the vector of all positions in the longer of the two strings S and T where an occurrence of the shorter of the two starts.

     If the optional argument OVERLAP is true (default), the returned vector can include overlapping positions.  For example:

          findstr ("ababab", "a")
               ⇒ [1, 3, 5];
          findstr ("abababa", "aba", 0)
               ⇒ [1, 5]

     *Caution:* ‘findstr’ is scheduled for deprecation.  Use ‘strfind’ in all new code.

     See also: strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129
Return the vector of all positions in the longer of the two strings S and T where an occurrence of the shorter of the two starts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hex2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 513
 -- : hex2dec (S)
     Return the integer corresponding to the hexadecimal number represented by the string S.

     For example:

          hex2dec ("12B")
                ⇒ 299
          hex2dec ("12b")
                ⇒ 299

     If S is a string matrix, return a column vector with one converted number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one converted number per cell element in S.

     See also: dec2hex, base2dec, bin2dec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Return the integer corresponding to the hexadecimal number represented by the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 452
 -- : index (S, T)
 -- : index (S, T, DIRECTION)
     Return the position of the first occurrence of the string T in the string S, or 0 if no occurrence is found.

     S may also be a string array or cell array of strings.

     For example:

          index ("Teststring", "t")
              ⇒ 4

     If DIRECTION is "first", return the first element found.  If DIRECTION is "last", return the last element found.

     See also: find, rindex.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
Return the position of the first occurrence of the string T in the string S, or 0 if no occurrence is found.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isletter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 255
 -- : isletter (S)
     Return a logical array which is true where the elements of S are letters and false where they are not.

     This is an alias for the ‘isalpha’ function.

     See also: isalpha, isdigit, ispunct, isspace, iscntrl, isalnum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
Return a logical array which is true where the elements of S are letters and false where they are not.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isstring


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 691
 -- : isstring (S)
     Return true if S is a string array.

     A string array is a data type that stores strings (row vectors of characters) at each element in the array.  It is distinct from character arrays which are N-dimensional arrays where each element is a single 1x1 character.  It is also distinct from cell arrays of strings which store strings at each element, but use cell indexing ‘{}’ to access elements rather than string arrays which use ordinary array indexing ‘()’.

     Programming Note: Octave does not yet implement string arrays so this function will always return false.

     See also: ischar, iscellstr, isfloat, isinteger, islogical, isnumeric, isa.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return true if S is a string array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isstrprop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1419
 -- : isstrprop (STR, PROP)
     Test character string properties.

     For example:

          isstrprop ("abc123", "alpha")
          ⇒ [1, 1, 1, 0, 0, 0]

     If STR is a cell array, ‘isstrpop’ is applied recursively to each element of the cell array.

     Numeric arrays are converted to character strings.

     The second argument PROP must be one of

     "alpha"
          True for characters that are alphabetic (letters).

     "alnum"
     "alphanum"
          True for characters that are alphabetic or digits.

     "lower"
          True for lowercase letters.

     "upper"
          True for uppercase letters.

     "digit"
          True for decimal digits (0-9).

     "xdigit"
          True for hexadecimal digits (a-fA-F0-9).

     "space"
     "wspace"
          True for whitespace characters (space, formfeed, newline, carriage return, tab, vertical tab).

     "punct"
          True for punctuation characters (printing characters except space or letter or digit).

     "cntrl"
          True for control characters.

     "graph"
     "graphic"
          True for printing characters except space.

     "print"
          True for printing characters including space.

     "ascii"
          True for characters that are in the range of ASCII encoding.

     See also: isalpha, isalnum, islower, isupper, isdigit, isxdigit, isspace, ispunct, iscntrl, isgraph, isprint, isascii.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Test character string properties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mat2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1193
 -- : S = mat2str (X, N)
 -- : S = mat2str (X, N, "class")
     Format real, complex, and logical matrices as strings.

     The returned string may be used to reconstruct the original matrix by using the ‘eval’ function.

     The precision of the values is given by N.  If N is a scalar then both real and imaginary parts of the matrix are printed to the same precision.  Otherwise ‘N(1)’ defines the precision of the real part and ‘N(2)’ defines the precision of the imaginary part.  The default for N is 15.

     If the argument "class" is given then the class of X is included in the string in such a way that ‘eval’ will result in the construction of a matrix of the same class.

          mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
               ⇒ "[-0.3333+0.14i;0.3333-0.14i]"

          mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
               ⇒ "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]"

          mat2str (int16 ([1 -1]), "class")
               ⇒ "int16([1 -1])"

          mat2str (logical (eye (2)))
               ⇒ "[true false;false true]"

          isequal (x, eval (mat2str (x)))
               ⇒ 1

     See also: sprintf, num2str, int2str.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Format real, complex, and logical matrices as strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
native2unicode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 822
 -- : UTF8_STR = native2unicode (NATIVE_BYTES, CODEPAGE)
 -- : UTF8_STR = native2unicode (NATIVE_BYTES)
     Convert byte stream NATIVE_BYTES to UTF-8 using CODEPAGE.

     The numbers in the vector NATIVE_BYTES are rounded and clipped to integers between 0 and 255.  This byte stream is then mapped into the code page given by the string CODEPAGE and returned in the string UTF8_STR.  Octave uses UTF-8 as its internal encoding.  The string CODEPAGE must be an identifier of a valid code page.  Examples for valid code pages are "ISO-8859-1", "Shift-JIS", or "UTF-16".  For a list of supported code pages, see <https://www.gnu.org/software/libiconv>.  If CODEPAGE is omitted or empty, the system default codepage is used.

     If NATIVE_BYTES is a string vector, it is returned as is.

     See also: unicode2native.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Convert byte stream NATIVE_BYTES to UTF-8 using CODEPAGE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ostrsplit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 873
 -- : [CSTR] = ostrsplit (S, SEP)
 -- : [CSTR] = ostrsplit (S, SEP, STRIP_EMPTY)
     Split the string S using one or more separators SEP and return a cell array of strings.

     Consecutive separators and separators at boundaries result in empty strings, unless STRIP_EMPTY is true.  The default value of STRIP_EMPTY is false.

     2-D character arrays are split at separators and at the original column boundaries.

     Example:

          ostrsplit ("a,b,c", ",")
                ⇒
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          ostrsplit (["a,b" ; "cde"], ",")
                ⇒
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = cde
                    }

     See also: strsplit, strtok.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
Split the string S using one or more separators SEP and return a cell array of strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
regexptranslate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 793
 -- : regexptranslate (OP, S)
     Translate a string for use in a regular expression.

     This may include either wildcard replacement or special character escaping.

     The behavior is controlled by OP which can take the following values

     "wildcard"
          The wildcard characters ‘.’, ‘*’, and ‘?’ are replaced with wildcards that are appropriate for a regular expression.  For example:

               regexptranslate ("wildcard", "*.m")
                    ⇒ '.*\.m'

     "escape"
          The characters ‘$.?[]’, that have special meaning for regular expressions are escaped so that they are treated literally.  For example:

               regexptranslate ("escape", "12.5")
                    ⇒ '12\.5'

     See also: regexp, regexpi, regexprep.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Translate a string for use in a regular expression.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 415
 -- : rindex (S, T)
     Return the position of the last occurrence of the character string T in the character string S, or 0 if no occurrence is found.

     S may also be a string array or cell array of strings.

     For example:

          rindex ("Teststring", "t")
               ⇒ 6

     The ‘rindex’ function is equivalent to ‘index’ with DIRECTION set to "last".

     See also: find, index.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
Return the position of the last occurrence of the character string T in the character string S, or 0 if no occurrence is found.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
str2num


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 770
 -- : X = str2num (S)
 -- : [X, STATE] = str2num (S)
     Convert the string (or character array) S to a number (or an array).

     Examples:

          str2num ("3.141596")
                ⇒ 3.141596

          str2num (["1, 2, 3"; "4, 5, 6"])
                ⇒ 1  2  3
                   4  5  6

     The optional second output, STATE, is logically true when the conversion is successful.  If the conversion fails the numeric output, X, is empty and STATE is false.

     *Caution:* As ‘str2num’ uses the ‘eval’ function to do the conversion, ‘str2num’ will execute any code contained in the string S.  Use ‘str2double’ for a safer and faster conversion.

     For cell array of strings use ‘str2double’.

     See also: str2double, eval.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Convert the string (or character array) S to a number (or an array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1211
 -- : strcat (S1, S2, ...)
     Return a string containing all the arguments concatenated horizontally.

     If the arguments are cell strings, ‘strcat’ returns a cell string with the individual cells concatenated.  For numerical input, each element is converted to the corresponding ASCII character.  Trailing white space for any character string input is eliminated before the strings are concatenated.  Note that cell string values do *not* have whitespace trimmed.

     For example:

          strcat ("|", " leading space is preserved", "|")
              ⇒ | leading space is preserved|

          strcat ("|", "trailing space is eliminated ", "|")
              ⇒ |trailing space is eliminated|

          strcat ("homogeneous space |", "  ", "| is also eliminated")
              ⇒ homogeneous space || is also eliminated

          s = [ "ab"; "cde" ];
          strcat (s, s, s)
              ⇒
                  "ababab   "
                  "cdecdecde"

          s = { "ab"; "cd " };
          strcat (s, s, s)
              ⇒
                  {
                    [1,1] = ababab
                    [2,1] = cd cd cd
                  }

     See also: cstrcat, char, strvcat.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return a string containing all the arguments concatenated horizontally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strchr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 411
 -- : IDX = strchr (STR, CHARS)
 -- : IDX = strchr (STR, CHARS, N)
 -- : IDX = strchr (STR, CHARS, N, DIRECTION)
 -- : [I, J] = strchr (...)
     Search for the string STR for occurrences of characters from the set CHARS.

     The return value(s), as well as the N and DIRECTION arguments behave identically as in ‘find’.

     This will be faster than using regexp in most cases.

     See also: find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Search for the string STR for occurrences of characters from the set CHARS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strjoin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 699
 -- : STR = strjoin (CSTR)
 -- : STR = strjoin (CSTR, DELIMITER)
     Join the elements of the cell string array, CSTR, into a single string.

     If no DELIMITER is specified, the elements of CSTR are separated by a space.

     If DELIMITER is specified as a string, the cell string array is joined using the string.  Escape sequences are supported.

     If DELIMITER is a cell string array whose length is one less than CSTR, then the elements of CSTR are joined by interleaving the cell string elements of DELIMITER.  Escape sequences are not supported.

          strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
                ⇒ 'Octave*Scilab*Lush*Yorick'

     See also: strsplit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Join the elements of the cell string array, CSTR, into a single string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strjust


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- : strjust (S)
 -- : strjust (S, POS)
     Return the text, S, justified according to POS, which may be "left", "center", or "right".

     If POS is omitted it defaults to "right".

     Null characters are replaced by spaces.  All other character data are treated as non-white space.

     Example:

          strjust (["a"; "ab"; "abc"; "abcd"])
               ⇒
                  "   a"
                  "  ab"
                  " abc"
                  "abcd"

     See also: deblank, strrep, strtrim, untabify.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Return the text, S, justified according to POS, which may be "left", "center", or "right".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strmatch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 902
 -- : strmatch (S, A)
 -- : strmatch (S, A, "exact")
     Return indices of entries of A which begin with the string S.

     The second argument A must be a string, character matrix, or a cell array of strings.

     If the third argument "exact" is not given, then S only needs to match A up to the length of S.  Trailing spaces and nulls in S and A are ignored when matching.

     For example:

          strmatch ("apple", "apple juice")
               ⇒ 1

          strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
               ⇒ [1; 2]

          strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
               ⇒ [1]

     *Caution:* ‘strmatch’ is scheduled for deprecation.  Use ‘strncmp’ (normal case), or ‘strcmp’ ("exact" case), or ‘regexp’ in all new code.

     See also: strfind, findstr, strcmp, strncmp, strcmpi, strncmpi, find.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return indices of entries of A which begin with the string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strsplit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3143
 -- : [CSTR] = strsplit (STR)
 -- : [CSTR] = strsplit (STR, DEL)
 -- : [CSTR] = strsplit (..., NAME, VALUE)
 -- : [CSTR, MATCHES] = strsplit (...)
     Split the string STR using the delimiters specified by DEL and return a cell string array of substrings.

     If a delimiter is not specified the string is split at whitespace ‘{" ", "\f", "\n", "\r", "\t", "\v"}’.  Otherwise, the delimiter, DEL must be a string or cell array of strings.  By default, consecutive delimiters in the input string S are collapsed into one resulting in a single split.

     Supported NAME/VALUE pair arguments are:

        • COLLAPSEDELIMITERS which may take the value of ‘true’ (default) or ‘false’.

        • DELIMITERTYPE which may take the value of "simple" (default) or "regularexpression".  A simple delimiter matches the text exactly as written.  Otherwise, the syntax for regular expressions outlined in ‘regexp’ is used.

     The optional second output, MATCHES, returns the delimiters which were matched in the original string.

     Examples with simple delimiters:

          strsplit ("a b c")
                ⇒
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,b,c", ",")
                ⇒
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a foo b,bar c", {" ", ",", "foo", "bar"})
                ⇒
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit ("a,,b, c", {",", " "}, "collapsedelimiters", false)
                ⇒
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
                    }


     Examples with regularexpression delimiters:

          strsplit ("a foo b,bar c", ',|\s|foo|bar', "delimitertype", "regularexpression")
          ⇒
          {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
          }

          strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, "delimitertype", "regularexpression")
          ⇒
          {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
          }

          strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
          ⇒
          {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
          }

          strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
          ⇒
          {
                      [1,1] = a
                      [1,2] =
                      [1,3] =
                      [1,4] = b
                      [1,5] =
                      [1,6] = c
          }

     See also: ostrsplit, strjoin, strtok, regexp.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
Split the string STR using the delimiters specified by DEL and return a cell string array of substrings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strtok


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 804
 -- : [TOK, REM] = strtok (STR)
 -- : [TOK, REM] = strtok (STR, DELIM)

     Find all characters in the string STR up to, but not including, the first character which is in the string DELIM.

     STR may also be a cell array of strings in which case the function executes on every individual string and returns a cell array of tokens and remainders.

     Leading delimiters are ignored.  If DELIM is not specified, whitespace is assumed.

     If REM is requested, it contains the remainder of the string, starting at the first delimiter.

     Examples:

          strtok ("this is the life")
               ⇒ "this"

          [tok, rem] = strtok ("14*27+31", "+-*/")
               ⇒
                  tok = 14
                  rem = *27+31

     See also: index, strsplit, strchr, isspace.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 113
Find all characters in the string STR up to, but not including, the first character which is in the string DELIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strtrim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- : strtrim (S)
     Remove leading and trailing whitespace from S.

     If S is a matrix, STRTRIM trims each row to the length of longest string.  If S is a cell array of strings, operate recursively on each string element.

     For example:

          strtrim ("    abc  ")
               ⇒  "abc"

          strtrim ([" abc   "; "   def   "])
               ⇒  ["abc  "  ; "  def"]

     See also: deblank.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Remove leading and trailing whitespace from S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strtrunc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 277
 -- : strtrunc (S, N)
     Truncate the character string S to length N.

     If S is a character matrix, then the number of columns is adjusted.

     If S is a cell array of strings, then the operation is performed on each cell element and the new cell array is returned.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Truncate the character string S to length N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
substr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
 -- : substr (S, OFFSET)
 -- : substr (S, OFFSET, LEN)
     Return the substring of S which starts at character number OFFSET and is LEN characters long.

     Position numbering for offsets begins with 1.  If OFFSET is negative, extraction starts that far from the end of the string.

     If LEN is omitted, the substring extends to the end of S.  A negative value for LEN extracts to within LEN characters of the end of the string

     Examples:

          substr ("This is a test string", 6, 9)
               ⇒ "is a test"
          substr ("This is a test string", -11)
               ⇒ "test string"
          substr ("This is a test string", -11, -7)
               ⇒ "test"

     This function is patterned after the equivalent function in Perl.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return the substring of S which starts at character number OFFSET and is LEN characters long.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
unicode2native


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 772
 -- : NATIVE_BYTES = unicode2native (UTF8_STR, CODEPAGE)
 -- : NATIVE_BYTES = unicode2native (UTF8_STR)
     Convert UTF-8 string UTF8_STR to byte stream using CODEPAGE.

     The character vector UTF8_STR is converted to a byte stream NATIVE_BYTES using the code page given by CODEPAGE.  The string CODEPAGE must be an identifier of a valid code page.  Examples for valid code pages are "ISO-8859-1", "Shift-JIS", or "UTF-16".  For a list of supported code pages, see <https://www.gnu.org/software/libiconv>.  If CODEPAGE is omitted or empty, the system default codepage is used.

     If any of the characters cannot be mapped into the codepage CODEPAGE, they are replaced with the appropriate substitution sequence for that codepage.

     See also: native2unicode.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Convert UTF-8 string UTF8_STR to byte stream using CODEPAGE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
untabify


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 900
 -- : untabify (T)
 -- : untabify (T, TW)
 -- : untabify (T, TW, DEBLANK)
     Replace TAB characters in T with spaces.

     The input, T, may be either a 2-D character array, or a cell array of character strings.  The output is the same class as the input.

     The tab width is specified by TW, and defaults to eight.

     If the optional argument DEBLANK is true, then the spaces will be removed from the end of the character data.

     The following example reads a file and writes an untabified version of the same file with trailing spaces stripped.

          fid = fopen ("tabbed_script.m");
          text = char (fread (fid, "uchar")');
          fclose (fid);
          fid = fopen ("untabified_script.m", "w");
          text = untabify (strsplit (text, "\n"), 8, true);
          fprintf (fid, "%s\n", text{:});
          fclose (fid);

     See also: strjust, strsplit, deblank.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Replace TAB characters in T with spaces.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
validatestring


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1375
 -- : VALIDSTR = validatestring (STR, STRARRAY)
 -- : VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME)
 -- : VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME, VARNAME)
 -- : VALIDSTR = validatestring (..., POSITION)
     Verify that STR is an element, or substring of an element, in STRARRAY.

     When STR is a character string to be tested, and STRARRAY is a cellstr of valid values, then VALIDSTR will be the validated form of STR where validation is defined as STR being a member or substring of VALIDSTR.  This is useful for both verifying and expanding short options, such as "r", to their longer forms, such as "red".  If STR is a substring of VALIDSTR, and there are multiple matches, the shortest match will be returned if all matches are substrings of each other.  Otherwise, an error will be raised because the expansion of STR is ambiguous.  All comparisons are case insensitive.

     The additional inputs FUNCNAME, VARNAME, and POSITION are optional and will make any generated validation error message more specific.

     Examples:

          validatestring ("r", {"red", "green", "blue"})
          ⇒ "red"

          validatestring ("b", {"red", "green", "blue", "black"})
          ⇒ error: validatestring: multiple unique matches were found for 'b':
             blue, black

     See also: strcmp, strcmpi, validateattributes, inputParser.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Verify that STR is an element, or substring of an element, in STRARRAY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
assert


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1630
 -- : assert (COND)
 -- : assert (COND, ERRMSG)
 -- : assert (COND, ERRMSG, ...)
 -- : assert (COND, MSG_ID, ERRMSG, ...)
 -- : assert (OBSERVED, EXPECTED)
 -- : assert (OBSERVED, EXPECTED, TOL)

     Produce an error if the specified condition is not met.

     ‘assert’ can be called in three different ways.

     ‘assert (COND)’
     ‘assert (COND, ERRMSG)’
     ‘assert (COND, ERRMSG, ...)’
     ‘assert (COND, MSG_ID, ERRMSG, ...)’
          Called with a single argument COND, ‘assert’ produces an error if COND is false (numeric zero).

          Any additional arguments are passed to the ‘error’ function for processing.

     ‘assert (OBSERVED, EXPECTED)’
          Produce an error if observed is not the same as expected.

          Note that OBSERVED and EXPECTED can be scalars, vectors, matrices, strings, cell arrays, or structures.

     ‘assert (OBSERVED, EXPECTED, TOL)’
          Produce an error if observed is not the same as expected but equality comparison for numeric data uses a tolerance TOL.

          If TOL is positive then it is an absolute tolerance which will produce an error if ‘abs (OBSERVED - EXPECTED) > abs (TOL)’.

          If TOL is negative then it is a relative tolerance which will produce an error if ‘abs (OBSERVED - EXPECTED) > abs (TOL * EXPECTED)’.

          If EXPECTED is zero TOL will always be interpreted as an absolute tolerance.

          If TOL is not scalar its dimensions must agree with those of OBSERVED and EXPECTED and tests are performed on an element-by-element basis.

     See also: fail, test, error, isequal.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Produce an error if the specified condition is not met.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2603
 -- : demo NAME
 -- : demo NAME N
 -- : demo ("NAME")
 -- : demo ("NAME", N)

     Run example code block N associated with the function NAME.

     If N is not specified, all examples are run.

     The preferred location for example code blocks is embedded within the script m-file immediately following the code that it exercises.  Alternatively, the examples may be stored in a file with the same name but no extension located on Octave’s load path.  To separate examples from regular script code all lines are prefixed by ‘%!’.  Each example must also be introduced by the keyword "demo" flush left to the prefix with no intervening spaces.  The remainder of the example can contain arbitrary Octave code.  For example:

          %!demo
          %! t = 0:0.01:2*pi;
          %! x = sin (t);
          %! plot (t, x);
          %! title ("one cycle of a sine wave");
          %! #-------------------------------------------------
          %! # the figure window shows one cycle of a sine wave

     Note that the code is displayed before it is executed so that a simple comment at the end suffices for labeling what is being shown.  For plots, labeling can also be done with ‘title’ or ‘text’.  It is generally *not* necessary to use ‘disp’ or ‘printf’ within the demo.

     Demos are run in a stand-alone function environment with no access to external variables.  This means that every demo must have separate initialization code.  Alternatively, all demos can be combined into a single large demo with the code

          %! input ("Press <enter> to continue: ", "s");

     between the sections, but this usage is discouraged.  Other techniques to avoid multiple initialization blocks include using multiple plots with a new ‘figure’ command between each plot, or using ‘subplot’ to put multiple plots in the same window.

     Finally, because ‘demo’ evaluates within a function context it is not possible to define new functions within the code.  Anonymous functions make a good substitute in most instances.  If function blocks *must* be used then the code ‘eval (example ("function", n))’ will allow Octave to see them.  This has its own problems, however, as ‘eval’ only evaluates one line or statement at a time.  In this case the function declaration must be wrapped with "if 1 <demo stuff> endif" where "if" is on the same line as "demo".  For example:

          %!demo if 1
          %!  function y = f(x)
          %!    y = x;
          %!  endfunction
          %!  f(3)
          %! endif

     See also: rundemos, example, test.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Run example code block N associated with the function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- : example NAME
 -- : example NAME N
 -- : example ("NAME")
 -- : example ("NAME", N)
 -- : [S, IDX] = example (...)

     Display the code for example N associated with the function NAME, but do not run it.

     If N is not specified, all examples are displayed.

     When called with output arguments, the examples are returned in the form of a string S, with IDX indicating the ending position of the various examples.

     See ‘demo’ for a complete explanation.

     See also: demo, test.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 84
Display the code for example N associated with the function NAME, but do not run it.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fail


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1069
 -- : fail (CODE)
 -- : fail (CODE, PATTERN)
 -- : fail (CODE, "warning")
 -- : fail (CODE, "warning", PATTERN)

     Return true if CODE fails with an error message matching PATTERN, otherwise produce an error.

     CODE must be in the form of a string that is passed to the Octave interpreter via the ‘evalin’ function, i.e., a (quoted) string constant or a string variable.

     Note that if CODE runs successfully, rather than failing, the error printed is:

                    expected error <.> but got none

     If called with two arguments, the return value will be true only if CODE fails with an error message containing PATTERN (case sensitive).  If the code fails with a different error than the one specified in PATTERN then the message produced is:

                    expected <PATTERN>
                    but got <text of actual error>

     The angle brackets are not part of the output.

     When called with the "warning" option ‘fail’ will produce an error if executing the code produces no warning.

     See also: assert, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return true if CODE fails with an error message matching PATTERN, otherwise produce an error.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rundemos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 391
 -- : rundemos ()
 -- : rundemos (DIRECTORY)
     Execute built-in demos for all m-files in the specified DIRECTORY.

     Demo blocks in any C++ source files (‘*.cc’) will also be executed for use with dynamically linked oct-file functions.

     If no directory is specified, operate on all directories in Octave’s search path for functions.

     See also: demo, runtests, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Execute built-in demos for all m-files in the specified DIRECTORY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
runtests


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 391
 -- : runtests ()
 -- : runtests (DIRECTORY)
     Execute built-in tests for all m-files in the specified DIRECTORY.

     Test blocks in any C++ source files (‘*.cc’) will also be executed for use with dynamically linked oct-file functions.

     If no directory is specified, operate on all directories in Octave’s search path for functions.

     See also: rundemos, test, path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Execute built-in tests for all m-files in the specified DIRECTORY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
speed


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4631
 -- : speed (F, INIT, MAX_N, F2, TOL)
 -- : [ORDER, N, T_F, T_F2] = speed (...)

     Determine the execution time of an expression (F) for various input values (N).

     The N are log-spaced from 1 to MAX_N.  For each N, an initialization expression (INIT) is computed to create any data needed for the test.  If a second expression (F2) is given then the execution times of the two expressions are compared.  When called without output arguments the results are printed to stdout and displayed graphically.

     ‘F’
          The code expression to evaluate.

     ‘MAX_N’
          The maximum test length to run.  The default value is 100.  Alternatively, use ‘[min_n, max_n]’ or specify the N exactly with ‘[n1, n2, ..., nk]’.

     ‘INIT’
          Initialization expression for function argument values.  Use K for the test number and N for the size of the test.  This should compute values for all variables used by F.  Note that INIT will be evaluated first for k = 0, so things which are constant throughout the test series can be computed once.  The default value is ‘X = randn (N, 1)’.

     ‘F2’
          An alternative expression to evaluate, so that the speed of two expressions can be directly compared.  The default is ‘[]’.

     ‘TOL’
          Tolerance used to compare the results of expression F and expression F2.  If TOL is positive, the tolerance is an absolute one.  If TOL is negative, the tolerance is a relative one.  The default is ‘eps’.  If TOL is ‘Inf’, then no comparison will be made.

     ‘ORDER’
          The time complexity of the expression O(a*n^p).  This is a structure with fields ‘a’ and ‘p’.

     ‘N’
          The values N for which the expression was calculated *AND* the execution time was greater than zero.

     ‘T_F’
          The nonzero execution times recorded for the expression F in seconds.

     ‘T_F2’
          The nonzero execution times recorded for the expression F2 in seconds.  If required, the mean time ratio is simply ‘mean (T_f ./ T_f2)’.

     The slope of the execution time graph shows the approximate power of the asymptotic running time O(n^p).  This power is plotted for the region over which it is approximated (the latter half of the graph).  The estimated power is not very accurate, but should be sufficient to determine the general order of an algorithm.  It should indicate if, for example, the implementation is unexpectedly O(n^2) rather than O(n) because it extends a vector each time through the loop rather than pre-allocating storage.  In the current version of Octave, the following is not the expected O(n).

          speed ("for i = 1:n, y{i} = x(i); endfor", "", [1000, 10000])

     But it is if you preallocate the cell array ‘y’:

          speed ("for i = 1:n, y{i} = x(i); endfor", ...
                 "x = rand (n, 1); y = cell (size (x));", [1000, 10000])

     An attempt is made to approximate the cost of individual operations, but it is wildly inaccurate.  You can improve the stability somewhat by doing more work for each ‘n’.  For example:

          speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])

     When comparing two different expressions (F, F2), the slope of the line on the speedup ratio graph should be larger than 1 if the new expression is faster.  Better algorithms have a shallow slope.  Generally, vectorizing an algorithm will not change the slope of the execution time graph, but will shift it relative to the original.  For example:

          speed ("sum (x)", "", [10000, 100000], ...
                 "v = 0; for i = 1:length (x), v += x(i); endfor")

     The following is a more complex example.  If there was an original version of ‘xcorr’ using for loops and a second version using an FFT, then one could compare the run speed for various lags as follows, or for a fixed lag with varying vector lengths as follows:

          speed ("xcorr (x, n)", "x = rand (128, 1);", 100,
                 "xcorr_orig (x, n)", -100*eps)
          speed ("xcorr (x, 15)", "x = rand (20+n, 1);", 100,
                 "xcorr_orig (x, n)", -100*eps)

     Assuming one of the two versions is in xcorr_orig, this would compare their speed and their output values.  Note that the FFT version is not exact, so one must specify an acceptable tolerance on the comparison ‘100*eps’.  In this case, the comparison should be computed relatively, as ‘abs ((X - Y) ./ Y)’ rather than absolutely as ‘abs (X - Y)’.

     Type ‘example ("speed")’ to see some real examples or ‘demo ("speed")’ to run them.

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Determine the execution time of an expression (F) for various input values (N).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3827
 -- : test NAME
 -- : test NAME quiet|normal|verbose
 -- : test ("NAME", "quiet|normal|verbose", FID)
 -- : test ("NAME", "quiet|normal|verbose", FNAME)
 -- : SUCCESS = test (...)
 -- : [N, NMAX, NXFAIL, NBUG, NSKIP, NRTSKIP, NREGRESSION] = test (...)
 -- : [CODE, IDX] = test ("NAME", "grabdemo")
 -- : test ([], "explain", FID)
 -- : test ([], "explain", FNAME)

     Perform built-in self-tests from the first file in the loadpath matching NAME.

     ‘test’ can be called in either command or functional form.  The exact operation of test is determined by a combination of mode (interactive or batch), reporting level ("quiet", "normal", "verbose"), and whether a logfile or summary output variable is used.

     The default mode when ‘test’ is called from the command line is interactive.  In this mode, tests will be run until the first error is encountered, or all tests complete successfully.  In batch mode, all tests are run regardless of any failures, and the results are collected for reporting.  Tests which require user interaction, i.e., demo blocks, are never run in batch mode.

     Batch mode is enabled by either 1) specifying a logfile using the third argument FNAME or FID, or 2) requesting an output argument such as SUCCESS, N, etc.

     The optional second argument determines the amount of output to generate and which types of tests to run.  The default value is "normal".  Requesting an output argument will suppress printing the final summary message and any intermediate warnings, unless verbose reporting is enabled.

     "quiet"
          Print a summary message when all tests pass, or print an error with the results of the first bad test when a failure occurs.  Don’t run tests which require user interaction.

     "normal"
          Display warning messages about skipped tests or failing xtests during test execution.  Print a summary message when all tests pass, or print an error with the results of the first bad test when a failure occurs.  Don’t run tests which require user interaction.

     "verbose"
          Display tests before execution.  Print all warning messages.  In interactive mode, run all tests including those which require user interaction.

     The optional third input argument specifies a logfile where results of the tests should be written.  The logfile may be a character string (FNAME) or an open file descriptor ID (FID).  To enable batch processing, but still print the results to the screen, use ‘stdout’ for FID.

     When called with just a single output argument SUCCESS, ‘test’ returns true if all of the tests were successful.  If called with more than one output argument then the number of successful tests (N), the total number of tests in the file (NMAX), the number of xtest failures (NXFAIL), the number of tests failed due known bugs (NBUG), the number of tests skipped due to missing features (NSKIP), the number of tests skipped due to run-time conditions (NRTSKIP), and the number of regressions (NREGRESSION) are returned.

     Example

          test sind
          ⇒
          PASSES 5 out of 5 tests

          [n, nmax] = test ("sind")
          ⇒
          n =  5
          nmax =  5

     Additional Calling Syntaxes

     If the second argument is the string "grabdemo", the contents of any built-in demo blocks are extracted but not executed.  The text for all code blocks is concatenated and returned as CODE with IDX being a vector of positions of the ends of each demo block.  For an easier way to extract demo blocks from files, *Note example: XREFexample.

     If the second argument is "explain" then NAME is ignored and an explanation of the line markers used in ‘test’ output reports is written to the file specified by FNAME or FID.

     See also: assert, fail, demo, example, error.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Perform built-in self-tests from the first file in the loadpath matching NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
addtodate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- : D = addtodate (D, Q, F)
     Add Q amount of time (with units F) to the serial datenum, D.

     F must be one of "year", "month", "day", "hour", "minute", "second", or "millisecond".

     See also: datenum, datevec, etime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Add Q amount of time (with units F) to the serial datenum, D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
asctime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- : asctime (TM_STRUCT)
     Convert a time structure to a string using the following format: "ddd mmm mm HH:MM:SS yyyy\n".

     For example:

          asctime (localtime (time ()))
               ⇒ "Mon Feb 17 01:15:06 1997\n"

     This is equivalent to ‘ctime (time ())’.

     See also: ctime, localtime, time.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
Convert a time structure to a string using the following format: "ddd mmm mm HH:MM:SS yyyy\n".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
calendar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 506
 -- : C = calendar ()
 -- : C = calendar (D)
 -- : C = calendar (Y, M)
 -- : calendar (...)
     Return the current monthly calendar in a 6x7 matrix.

     If D is specified, return the calendar for the month containing the date D, which must be a serial date number or a date string.

     If Y and M are specified, return the calendar for year Y and month M.

     If no output arguments are specified, print the calendar on the screen instead of returning a matrix.

     See also: datenum, datestr.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the current monthly calendar in a 6x7 matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
clock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- : clock ()
     Return the current local date and time as a date vector.

     The date vector contains the following fields: current year, month (1-12), day (1-31), hour (0-23), minute (0-59), and second (0-61).  The seconds field has a fractional part after the decimal point for extended accuracy.

     For example:

          fix (clock ())
               ⇒ [ 1993, 8, 20, 4, 56, 1 ]

     ‘clock’ is more accurate on systems that have the ‘gettimeofday’ function.

     See also: now, date, datevec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the current local date and time as a date vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ctime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- : ctime (T)
     Convert a value returned from ‘time’ (or any other non-negative integer), to the local time and return a string of the same form as ‘asctime’.

     The function ‘ctime (time)’ is equivalent to ‘asctime (localtime (time))’.  For example:

          ctime (time ())
             ⇒ "Mon Feb 17 01:15:06 1997\n"

     See also: asctime, time, localtime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
Convert a value returned from ‘time’ (or any other non-negative integer), to the local time and return a string of the same form as ‘asctime’.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
date


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 209
 -- : date ()
     Return the current date as a character string in the form DD-MMM-YYYY.

     For example:

          date ()
            ⇒ "20-Aug-1993"

     See also: now, clock, datestr, localtime.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the current date as a character string in the form DD-MMM-YYYY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datenum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2368
 -- : DAYS = datenum (DATEVEC)
 -- : DAYS = datenum (YEAR, MONTH, DAY)
 -- : DAYS = datenum (YEAR, MONTH, DAY, HOUR)
 -- : DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE)
 -- : DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)
 -- : DAYS = datenum ("datestr")
 -- : DAYS = datenum ("datestr", F)
 -- : DAYS = datenum ("datestr", P)
 -- : [DAYS, SECS] = datenum (...)
     Return the date/time input as a serial day number, with Jan 1, 0000 defined as day 1.

     The integer part, ‘floor (DAYS)’ counts the number of complete days in the date input.

     The fractional part, ‘rem (DAYS, 1)’ corresponds to the time on the given day.

     The input may be a date vector (see ‘datevec’), datestr (see ‘datestr’), or directly specified as input.

     When processing input datestrings, F is the format string used to interpret date strings (see ‘datestr’).  If no format F is specified, then a relatively slow search is performed through various formats.  It is always preferable to specify the format string F if it is known.  Formats which do not specify a particular time component will have the value set to zero.  Formats which do not specify a date will default to January 1st of the current year.

     P is the year at the start of the century to which two-digit years will be referenced.  If not specified, it defaults to the current year minus 50.

     The optional output SECS holds the time on the specified day with greater precision than DAYS.

     Notes:

        • Years can be negative and/or fractional.

        • Months below 1 are considered to be January.

        • Days of the month start at 1.

        • Days beyond the end of the month go into subsequent months.

        • Days before the beginning of the month go to the previous month.

        • Days can be fractional.

     *Caution:* this function does not attempt to handle Julian calendars so dates before October 15, 1582 are wrong by as much as eleven days.  Also, be aware that only Roman Catholic countries adopted the calendar in 1582.  It took until 1924 for it to be adopted everywhere.  See the Wikipedia entry on the Gregorian calendar for more details.

     *Warning:* leap seconds are ignored.  A table of leap seconds is available on the Wikipedia entry for leap seconds.

     See also: datestr, datevec, now, clock, date.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Return the date/time input as a serial day number, with Jan 1, 0000 defined as day 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datestr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37182
 -- : STR = datestr (DATE)
 -- : STR = datestr (DATE, F)
 -- : STR = datestr (DATE, F, P)
     Format the given date/time according to the format F and return the result in STR.

     DATE is a serial date number (see ‘datenum’) or a date vector (see ‘datevec’).  The value of DATE may also be a string or cell array of strings.

     F can be an integer which corresponds to one of the codes in the table below, or a date format string.

     P is the year at the start of the century in which two-digit years are to be interpreted in.  If not specified, it defaults to the current year minus 50.

     For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would be formatted as follows:

     Code                                                                                                   Format                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Example
     ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     0                                                                                                      dd-mmm-yyyy HH:MM:SS                                                                                                                                                                                                                                                                                                                                                                                                                                                          07-Sep-2000 15:38:09
     1                                                                                                      dd-mmm-yyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                   07-Sep-2000
     2                                                                                                      mm/dd/yy                                                                                                                                                                                                                                                                                                                                                                                                                                                                      09/07/00
     3                                                                                                      mmm                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Sep
     4                                                                                                      m                                                                                                                                                                                                                                                                                                                                                                                                                                                                             S
     5                                                                                                      mm                                                                                                                                                                                                                                                                                                                                                                                                                                                                            09
     6                                                                                                      mm/dd                                                                                                                                                                                                                                                                                                                                                                                                                                                                         09/07
     7                                                                                                      dd                                                                                                                                                                                                                                                                                                                                                                                                                                                                            07
     8                                                                                                      ddd                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Thu
     9                                                                                                      d                                                                                                                                                                                                                                                                                                                                                                                                                                                                             T
     10                                                                                                     yyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                          2000
     11                                                                                                     yy                                                                                                                                                                                                                                                                                                                                                                                                                                                                            00
     12                                                                                                     mmmyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Sep00
     13                                                                                                     HH:MM:SS                                                                                                                                                                                                                                                                                                                                                                                                                                                                      15:38:09
     14                                                                                                     HH:MM:SS PM                                                                                                                                                                                                                                                                                                                                                                                                                                                                   3:38:09 PM
     15                                                                                                     HH:MM                                                                                                                                                                                                                                                                                                                                                                                                                                                                         15:38
     16                                                                                                     HH:MM PM                                                                                                                                                                                                                                                                                                                                                                                                                                                                      3:38 PM
     17                                                                                                     QQ-YY                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Q3-00
     18                                                                                                     QQ                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Q3
     19                                                                                                     dd/mm                                                                                                                                                                                                                                                                                                                                                                                                                                                                         07/09
     20                                                                                                     dd/mm/yy                                                                                                                                                                                                                                                                                                                                                                                                                                                                      07/09/00
     21                                                                                                     mmm.dd,yyyy HH:MM:SS                                                                                                                                                                                                                                                                                                                                                                                                                                                          Sep.07,2000 15:38:08
     22                                                                                                     mmm.dd,yyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Sep.07,2000
     23                                                                                                     mm/dd/yyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                    09/07/2000
     24                                                                                                     dd/mm/yyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                    07/09/2000
     25                                                                                                     yy/mm/dd                                                                                                                                                                                                                                                                                                                                                                                                                                                                      00/09/07
     26                                                                                                     yyyy/mm/dd                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2000/09/07
     27                                                                                                     QQ-YYYY                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Q3-2000
     28                                                                                                     mmmyyyy                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Sep2000
     29                                                                                                     yyyy-mm-dd                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2000-09-07
     30                                                                                                     yyyymmddTHHMMSS                                                                                                                                                                                                                                                                                                                                                                                                                                                               20000907T153808
     31                                                                                                     yyyy-mm-dd HH:MM:SS                                                                                                                                                                                                                                                                                                                                                                                                                                                           2000-09-07 15:38:08

     If F is a format string, the following symbols are recognized:

     Symbol                                                                                                 Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Example
     -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     yyyy                                                                                                   Full year                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     2005
     yy                                                                                                     Two-digit year                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                05
     mmmm                                                                                                   Full month name                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               December
     mmm                                                                                                    Abbreviated month name                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Dec
     mm                                                                                                     Numeric month number (padded with zeros)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      01, 08, 12
     m                                                                                                      First letter of month name (capitalized)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      D
     dddd                                                                                                   Full weekday name                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Sunday
     ddd                                                                                                    Abbreviated weekday name                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Sun
     dd                                                                                                     Numeric day of month (padded with zeros)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      11
     d                                                                                                      First letter of weekday name (capitalized)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    S
     HH                                                                                                     Hour of day, padded with zeros,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               09:00
                                                                                                            or padded with spaces if PM is set                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            9:00 AM
     MM                                                                                                     Minute of hour (padded with zeros)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            10:05
     SS                                                                                                     Second of minute (padded with zeros)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10:05:03
     FFF                                                                                                    Milliseconds of second (padded with zeros)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    10:05:03.012
     AM                                                                                                     Use 12-hour time format                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       11:30 AM
     PM                                                                                                     Use 12-hour time format                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       11:30 PM

     If F is not specified or is ‘-1’, then use 0, 1 or 16, depending on whether the date portion or the time portion of DATE is empty.

     If P is nor specified, it defaults to the current year minus 50.

     If a matrix or cell array of dates is given, a column vector of date strings is returned.

     See also: datenum, datevec, date, now, clock.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
Format the given date/time according to the format F and return the result in STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
datevec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1049
 -- : V = datevec (DATE)
 -- : V = datevec (DATE, F)
 -- : V = datevec (DATE, P)
 -- : V = datevec (DATE, F, P)
 -- : [Y, M, D, H, MI, S] = datevec (...)
     Convert a serial date number (see ‘datenum’) or date string (see ‘datestr’) into a date vector.

     A date vector is a row vector with six members, representing the year, month, day, hour, minute, and seconds respectively.

     F is the format string used to interpret date strings (see ‘datestr’).  If DATE is a string, but no format is specified, then a relatively slow search is performed through various formats.  It is always preferable to specify the format string F if it is known.  Formats which do not specify a particular time component will have the value set to zero.  Formats which do not specify a date will default to January 1st of the current year.

     P is the year at the start of the century to which two-digit years will be referenced.  If not specified, it defaults to the current year minus 50.

     See also: datenum, datestr, clock, now, date.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
Convert a serial date number (see ‘datenum’) or date string (see ‘datestr’) into a date vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
eomday


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- : E = eomday (Y, M)
     Return the last day of the month M for the year Y.

     See also: weekday, datenum, datevec, is_leap_year, calendar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return the last day of the month M for the year Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
etime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- : etime (T2, T1)
     Return the difference in seconds between two time values returned from ‘clock’ (T2 - T1).

     For example:

          t0 = clock ();
          # many computations later...
          elapsed_time = etime (clock (), t0);

     will set the variable ‘elapsed_time’ to the number of seconds since the variable ‘t0’ was set.

     See also: tic, toc, clock, cputime, addtodate.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
Return the difference in seconds between two time values returned from ‘clock’ (T2 - T1).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_leap_year


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- : is_leap_year ()
 -- : is_leap_year (YEAR)
     Return true if YEAR is a leap year and false otherwise.

     If no year is specified, ‘is_leap_year’ uses the current year.

     For example:

          is_leap_year (2000)
             ⇒ 1

     See also: weekday, eomday, calendar.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return true if YEAR is a leap year and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
now


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 329
 -- : t = now ()
     Return the current local date/time as a serial day number (see ‘datenum’).

     The integral part, ‘floor (now)’ corresponds to the number of days between today and Jan 1, 0000.

     The fractional part, ‘rem (now, 1)’ corresponds to the current time.

     See also: clock, date, datenum.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return the current local date/time as a serial day number (see ‘datenum’).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
weekday


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2595
 -- : [N, S] = weekday (D)
 -- : [N, S] = weekday (D, FORMAT)
     Return the day of the week as a number in N and as a string in S.

     The days of the week are numbered 1–7 with the first day being Sunday.

     D is a serial date number or a date string.

     If the string FORMAT is not present or is equal to "short" then S will contain the abbreviated name of the weekday.  If FORMAT is "long" then S will contain the full name.

     Table of return values based on FORMAT:

     N                                                             "short"                                                                                                                               "long"
     -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1                                                             Sun                                                                                                                                   Sunday
     2                                                             Mon                                                                                                                                   Monday
     3                                                             Tue                                                                                                                                   Tuesday
     4                                                             Wed                                                                                                                                   Wednesday
     5                                                             Thu                                                                                                                                   Thursday
     6                                                             Fri                                                                                                                                   Friday
     7                                                             Sat                                                                                                                                   Saturday

     See also: eomday, is_leap_year, calendar, datenum, datevec.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the day of the week as a number in N and as a string in S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/ascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- : ascii (F)
     Set the FTP connection F to use ASCII mode for transfers.

     ASCII mode is only appropriate for text files as it will convert the remote host’s newline representation to the local host’s newline representation.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Set the FTP connection F to use ASCII mode for transfers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/binary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 261
 -- : binary (F)
     Set the FTP connection F to use binary mode for transfers.

     In binary mode there is no conversion of newlines from the remote representation to the local representation.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Set the FTP connection F to use binary mode for transfers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
@ftp/cd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 -- : cd (F)
 -- : cd (F, PATH)
     Get or set the remote directory on the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.

     If PATH is not specified, return the remote current working directory.  Otherwise, set the remote directory to PATH and return the new remote working directory.

     If the directory does not exist, an error message is printed and the working directory is not changed.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Get or set the remote directory on the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/close


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- : close (F)
     Close the FTP connection represented by the FTP object F.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Close the FTP connection represented by the FTP object F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/delete


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- : delete (F, FILE)
     Delete the remote file FILE over the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Delete the remote file FILE over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
@ftp/dir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- : LST = dir (F)
     List the current directory in verbose form for the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
List the current directory in verbose form for the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
@ftp/ftp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3607
 -- : F = ftp (HOST)
 -- : F = ftp (HOST, USERNAME, PASSWORD)
     Connect to the FTP server HOST with USERNAME and PASSWORD.

     If USERNAME and PASSWORD are not specified, user "anonymous" with no password is used.  The returned FTP object F represents the established FTP connection.

     The list of actions for an FTP object are shown below.  All functions require an FTP object as the first argument.

     Method                                                                                                                                                     Description
     ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     ascii                                                                                                                                                      Set transfer type to ascii
     binary                                                                                                                                                     Set transfer type to binary
     cd                                                                                                                                                         Change remote working directory
     close                                                                                                                                                      Close FTP connection
     delete                                                                                                                                                     Delete remote file
     dir                                                                                                                                                        List remote directory contents
     mget                                                                                                                                                       Download remote files
     mkdir                                                                                                                                                      Create remote directory
     mput                                                                                                                                                       Upload local files
     rename                                                                                                                                                     Rename remote file or directory
     rmdir                                                                                                                                                      Remove remote directory

   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Connect to the FTP server HOST with USERNAME and PASSWORD.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
@ftp/mget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- : mget (F, FILE)
 -- : mget (F, DIR)
 -- : mget (F, REMOTE_NAME, TARGET)
     Download a remote file FILE or directory DIR to the local directory on the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.

     The arguments FILE and DIR can include wildcards and any files or directories on the remote server that match will be downloaded.

     If a third string argument TARGET is given, then it must indicate the path to the local destination directory.  TARGET may be a relative or absolute path.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
Download a remote file FILE or directory DIR to the local directory on the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/mkdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- : mkdir (F, PATH)
     Create the remote directory PATH, over the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Create the remote directory PATH, over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
@ftp/mput


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 301
 -- : mput (F, FILE)
     Upload the local file FILE into the current remote directory on the FTP connection F.

     F is an FTP object returned by the ftp function.

     The argument FILE is passed through the ‘glob’ function and any files that match the wildcards in FILE will be uploaded.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
Upload the local file FILE into the current remote directory on the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
@ftp/rename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- : rename (F, OLDNAME, NEWNAME)
     Rename or move the remote file or directory OLDNAME to NEWNAME, over the FTP connection F.

     F is an FTP object returned by the ftp function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
Rename or move the remote file or directory OLDNAME to NEWNAME, over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
@ftp/rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- : rmdir (F, PATH)
     Remove the remote directory PATH, over the FTP connection F.

     F is an FTP object returned by the ‘ftp’ function.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Remove the remote directory PATH, over the FTP connection F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
gnuplot_binary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 486
 -- : [PROG, ARGS] = gnuplot_binary ()
 -- : [OLD_PROG, OLD_ARGS] = gnuplot_binary (NEW_PROG)
 -- : [OLD_PROG, OLD_ARGS] = gnuplot_binary (NEW_PROG, ARG1, ...)
     Query or set the name of the program invoked by the plot command when the graphics toolkit is set to "gnuplot".

     Additional arguments to pass to the external plotting program may also be given.  The default value is "gnuplot" with no additional arguments.  *Note Installation::.

     See also: graphics_toolkit.
   


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
Query or set the name of the program invoked by the plot command when the graphics toolkit is set to "gnuplot".



