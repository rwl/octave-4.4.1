<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Special Functions (GNU Octave (version 4.4.1))</title>

<meta name="description" content="Special Functions (GNU Octave (version 4.4.1))">
<meta name="keywords" content="Special Functions (GNU Octave (version 4.4.1))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Arithmetic.html#Arithmetic" rel="up" title="Arithmetic">
<link href="Rational-Approximations.html#Rational-Approximations" rel="next" title="Rational Approximations">
<link href="Utility-Functions.html#Utility-Functions" rel="prev" title="Utility Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<a name="Special-Functions"></a>
<div class="header">
<p>
Next: <a href="Rational-Approximations.html#Rational-Approximations" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="Utility-Functions.html#Utility-Functions" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="Arithmetic.html#Arithmetic" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Special-Functions-1"></a>
<h3 class="section">17.6 Special Functions</h3>

<a name="XREFairy"></a><dl>
<dt><a name="index-airy"></a><em>[<var>a</var>, <var>ierr</var>] =</em> <strong>airy</strong> <em>(<var>k</var>, <var>z</var>, <var>opt</var>)</em></dt>
<dd><p>Compute Airy functions of the first and second kind, and their derivatives.
</p>
<div class="example">
<pre class="example"> K   Function   Scale factor (if &quot;opt&quot; is supplied)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))
</pre></div>

<p>The function call <code>airy (<var>z</var>)</code> is equivalent to
<code>airy (0, <var>z</var>)</code>.
</p>
<p>The result is the same size as <var>z</var>.
</p>
<p>If requested, <var>ierr</var> contains the following status information and
is the same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half
 of machine accuracy.

</li><li> Loss of significance by argument reduction, output may be inaccurate.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code>NaN</code>.
</li></ol>
</dd></dl>


<a name="XREFbesselj"></a><dl>
<dt><a name="index-besselj"></a><em><var>J</var> =</em> <strong>besselj</strong> <em>(<var>alpha</var>, <var>x</var>)</em></dt>
<dt><a name="index-besselj-1"></a><em><var>J</var> =</em> <strong>besselj</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besselj-2"></a><em>[<var>J</var>, <var>ierr</var>] =</em> <strong>besselj</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute Bessel functions of the first kind.
</p>
<p>The order of the Bessel function <var>alpha</var> must be real.  The points for
evaluation <var>x</var> may be complex.
</p>
<p>If the optional argument <var>opt</var> is 1 or true, the result <var>J</var> is
multiplied by <code>exp&nbsp;<span class="nolinebreak">(-abs</span>&nbsp;(imag&nbsp;(<var>x</var>)))</code><!-- /@w -->.
</p>
<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.  If <var>x</var>
is a scalar, the result is the same size as <var>alpha</var>.  If <var>alpha</var> is a
row vector and <var>x</var> is a column vector, the result is a matrix with
<code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns.
Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var>ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Loss of significance by argument reduction, output may be inaccurate.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code>NaN</code>.
</li></ol>


<p><strong>See also:</strong> <a href="#XREFbessely">bessely</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a name="XREFbessely"></a><dl>
<dt><a name="index-bessely"></a><em><var>Y</var> =</em> <strong>bessely</strong> <em>(<var>alpha</var>, <var>x</var>)</em></dt>
<dt><a name="index-bessely-1"></a><em><var>Y</var> =</em> <strong>bessely</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-bessely-2"></a><em>[<var>Y</var>, <var>ierr</var>] =</em> <strong>bessely</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute Bessel functions of the second kind.
</p>
<p>The order of the Bessel function <var>alpha</var> must be real.  The points for
evaluation <var>x</var> may be complex.
</p>
<p>If the optional argument <var>opt</var> is 1 or true, the result <var>Y</var> is
multiplied by <code>exp&nbsp;<span class="nolinebreak">(-abs</span>&nbsp;(imag&nbsp;(<var>x</var>)))</code><!-- /@w -->.
</p>
<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.  If <var>x</var>
is a scalar, the result is the same size as <var>alpha</var>.  If <var>alpha</var> is a
row vector and <var>x</var> is a column vector, the result is a matrix with
<code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns.
Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var>ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code>NaN</code>.
</li></ol>


<p><strong>See also:</strong> <a href="#XREFbesselj">besselj</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a name="XREFbesseli"></a><dl>
<dt><a name="index-besseli"></a><em><var>I</var> =</em> <strong>besseli</strong> <em>(<var>alpha</var>, <var>x</var>)</em></dt>
<dt><a name="index-besseli-1"></a><em><var>I</var> =</em> <strong>besseli</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besseli-2"></a><em>[<var>I</var>, <var>ierr</var>] =</em> <strong>besseli</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute modified Bessel functions of the first kind.
</p>
<p>The order of the Bessel function <var>alpha</var> must be real.  The points for
evaluation <var>x</var> may be complex.
</p>
<p>If the optional argument <var>opt</var> is 1 or true, the result <var>I</var> is
multiplied by <code>exp&nbsp;<span class="nolinebreak">(-abs</span>&nbsp;(real&nbsp;(<var>x</var>)))</code><!-- /@w -->.
</p>
<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.  If <var>x</var>
is a scalar, the result is the same size as <var>alpha</var>.  If <var>alpha</var> is a
row vector and <var>x</var> is a column vector, the result is a matrix with
<code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns.
Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var>ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code>NaN</code>.
</li></ol>


<p><strong>See also:</strong> <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a name="XREFbesselk"></a><dl>
<dt><a name="index-besselk"></a><em><var>K</var> =</em> <strong>besselk</strong> <em>(<var>alpha</var>, <var>x</var>)</em></dt>
<dt><a name="index-besselk-1"></a><em><var>K</var> =</em> <strong>besselk</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besselk-2"></a><em>[<var>K</var>, <var>ierr</var>] =</em> <strong>besselk</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Compute modified Bessel functions of the second kind.
</p>
<p>The order of the Bessel function <var>alpha</var> must be real.  The points for
evaluation <var>x</var> may be complex.
</p>
<p>If the optional argument <var>opt</var> is 1 or true, the result <var>K</var> is
multiplied by <code>exp&nbsp;(<var>x</var>)</code><!-- /@w -->.
</p>
<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.  If <var>x</var>
is a scalar, the result is the same size as <var>alpha</var>.  If <var>alpha</var> is a
row vector and <var>x</var> is a column vector, the result is a matrix with
<code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns.
Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var>ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code>NaN</code>.
</li></ol>


<p><strong>See also:</strong> <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a name="XREFbesselh"></a><dl>
<dt><a name="index-besselh"></a><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>x</var>)</em></dt>
<dt><a name="index-besselh-1"></a><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>k</var>, <var>x</var>)</em></dt>
<dt><a name="index-besselh-2"></a><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>k</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besselh-3"></a><em>[<var>H</var>, <var>ierr</var>] =</em> <strong>besselh</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute Bessel functions of the third kind (Hankel functions).
</p>
<p>The order of the Bessel function <var>alpha</var> must be real.  The kind of Hankel
function is specified by <var>k</var> and may be either first (<var>k</var> = 1) or
second (<var>k</var> = 2).  The default is Hankel functions of the first kind.  The
points for evaluation <var>x</var> may be complex.
</p>
<p>If the optional argument <var>opt</var> is 1 or true, the result is multiplied
by <code>exp (-I*<var>x</var>)</code> for <var>k</var> = 1 or <code>exp (I*<var>x</var>)</code> for
<var>k</var> = 2.
</p>
<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.  If <var>x</var>
is a scalar, the result is the same size as <var>alpha</var>.  If <var>alpha</var> is a
row vector and <var>x</var> is a column vector, the result is a matrix with
<code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns.
Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var>ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code>NaN</code>.
</li></ol>


<p><strong>See also:</strong> <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>.
</p></dd></dl>


<a name="XREFbeta"></a><dl>
<dt><a name="index-beta"></a><em></em> <strong>beta</strong> <em>(<var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the Beta function for real inputs <var>a</var> and <var>b</var>.
</p>
<p>The Beta function definition is
</p>
<div class="example">
<pre class="example">beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
</pre></div>


<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
See <a href="#XREFbetaln">betaln</a>, for computing the logarithm of the Beta function
in an efficient manner.
</p>
<p><strong>See also:</strong> <a href="#XREFbetaln">betaln</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>.
</p></dd></dl>


<a name="XREFbetainc"></a><dl>
<dt><a name="index-betainc"></a><em></em> <strong>betainc</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>)</em></dt>
<dt><a name="index-betainc-1"></a><em></em> <strong>betainc</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>, <var>tail</var>)</em></dt>
<dd><p>Compute the incomplete beta function.
</p>
<p>This is defined as
</p>
<div class="example">
<pre class="example">               x
              /
             |
I_x (a, b) = | t^(a-1) (1-t)^(b-1) dt
             |
             /
            0
</pre></div>


<p>with real <var>x</var> in the range [0,1].  The inputs <var>a</var> and <var>b</var> must
be real and strictly positive (&gt; 0).  If one of the inputs is not a scalar
then the other inputs must be scalar or of compatible dimensions.
</p>
<p>By default, <var>tail</var> is <code>&quot;lower&quot;</code> and the incomplete beta function
integrated from 0 to <var>x</var> is computed.  If <var>tail</var> is <code>&quot;upper&quot;</code>
then the complementary function integrated from <var>x</var> to 1 is calculated.
The two choices are related by
</p>
<p>betainc (<var>x</var>, <var>a</var>, <var>b</var>, <code>&quot;upper&quot;</code>) =
1 - betainc (<var>x</var>, <var>a</var>, <var>b</var>, <code>&quot;lower&quot;</code>).
</p>
<p><code>betainc</code> uses a more sophisticated algorithm than subtraction to
get numerically accurate results when the <code>&quot;lower&quot;</code> value is small.
</p>
<p>Reference: A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland,
W.B. Jones, <cite>Handbook of Continued Fractions for Special Functions</cite>,
ch. 18.
</p>

<p><strong>See also:</strong> <a href="#XREFbeta">beta</a>, <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a name="XREFbetaincinv"></a><dl>
<dt><a name="index-betaincinv"></a><em></em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>)</em></dt>
<dt><a name="index-betaincinv-1"></a><em></em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>, &quot;lower&quot;)</em></dt>
<dt><a name="index-betaincinv-2"></a><em></em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>, &quot;upper&quot;)</em></dt>
<dd><p>Compute the inverse of the normalized incomplete beta function.
</p>
<p>The normalized incomplete beta function is defined as
</p>
<div class="example">
<pre class="example">               x
              /
             |
I_x (a, b) = | t^(a-1) (1-t)^(b-1) dt
             |
             /
            0
</pre></div>


<p>If two inputs are scalar, then <code>betaincinv (<var>y</var>, <var>a</var>, <var>b</var>)</code>
is returned for each of the other inputs.
</p>
<p>If two or more inputs are not scalar, the sizes of them must agree, and
<code>betaincinv</code> is applied element-by-element.
</p>
<p>The variable <var>y</var> must be in the interval [0,1], while <var>a</var> and
<var>b</var> must be real and strictly positive.
</p>
<p>By default, <var>tail</var> is <code>&quot;lower&quot;</code> and the inverse of the incomplete
beta function integrated from 0 to <var>x</var> is computed.  If <var>tail</var> is
<code>&quot;upper&quot;</code> then the complementary function integrated from <var>x</var> to 1
is inverted.
</p>
<p>The function is computed by standard Newton&rsquo;s method, by solving
</p>
<div class="example">
<pre class="example"><var>y</var> - betainc (<var>x</var>, <var>a</var>, <var>b</var>) = 0
</pre></div>



<p><strong>See also:</strong> <a href="#XREFbetainc">betainc</a>, <a href="#XREFbeta">beta</a>, <a href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a name="XREFbetaln"></a><dl>
<dt><a name="index-betaln"></a><em></em> <strong>betaln</strong> <em>(<var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the natural logarithm of the Beta function for real inputs <var>a</var>
and <var>b</var>.
</p>
<p><code>betaln</code> is defined as
</p>
<div class="example">
<pre class="example">betaln (a, b) = log (beta (a, b))
</pre></div>

<p>and is calculated in a way to reduce the occurrence of underflow.
</p>
<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
</p>
<p><strong>See also:</strong> <a href="#XREFbeta">beta</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFbincoeff"></a><dl>
<dt><a name="index-bincoeff"></a><em></em> <strong>bincoeff</strong> <em>(<var>n</var>, <var>k</var>)</em></dt>
<dd><p>Return the binomial coefficient of <var>n</var> and <var>k</var>.
</p>
<p>The binomial coefficient is defined as
</p>
<div class="example">
<pre class="example"> /   \
 | n |    n (n-1) (n-2) &hellip; (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /
</pre></div>

<p>For example:
</p>
<div class="example">
<pre class="example">bincoeff (5, 2)
   &rArr; 10
</pre></div>

<p>In most cases, the <code>nchoosek</code> function is faster for small
scalar integer arguments.  It also warns about loss of precision for
big arguments.
</p>

<p><strong>See also:</strong> <a href="Basic-Statistical-Functions.html#XREFnchoosek">nchoosek</a>.
</p></dd></dl>


<a name="XREFcommutation_005fmatrix"></a><dl>
<dt><a name="index-commutation_005fmatrix"></a><em></em> <strong>commutation_matrix</strong> <em>(<var>m</var>, <var>n</var>)</em></dt>
<dd><p>Return the commutation matrix
K(m,n)
which is the unique
<var>m</var>*<var>n</var> by <var>m</var>*<var>n</var>
matrix such that
<em>K(m,n) * vec(A) = vec(A')</em>
for all
<em>m</em> by <em>n</em>
matrices
<em>A</em>.
</p>
<p>If only one argument <var>m</var> is given,
<em>K(m,m)</em>
is returned.
</p>
<p>See Magnus and Neudecker (1988), <cite>Matrix Differential
Calculus with Applications in Statistics and Econometrics.</cite>
</p></dd></dl>


<a name="XREFcosint"></a><dl>
<dt><a name="index-cosint"></a><em></em> <strong>cosint</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the cosine integral function:
</p>
<div class="example">
<pre class="example">            +oo
           /
Ci (x) = - | (cos (t)) / t dt
           /
          x
</pre></div>

<p>An equivalent definition is
</p>
<div class="example">
<pre class="example">                             x
                            /
                            |  cos (t) - 1
Ci (x) = gamma + log (x) +  | -------------  dt
                            |        t
                            /
                           0
</pre></div>

<p>Reference:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite>Handbook of Mathematical Functions</cite>
1964.
</p>

<p><strong>See also:</strong> <a href="#XREFsinint">sinint</a>, <a href="#XREFexpint">expint</a>, <a href="Trigonometry.html#XREFcos">cos</a>.
</p>
</dd></dl>


<a name="XREFduplication_005fmatrix"></a><dl>
<dt><a name="index-duplication_005fmatrix"></a><em></em> <strong>duplication_matrix</strong> <em>(<var>n</var>)</em></dt>
<dd><p>Return the duplication matrix
<em>Dn</em>
which is the unique
<em>n^2</em> by <em>n*(n+1)/2</em>
matrix such that
<em>Dn vech (A) = vec (A)</em>
for all symmetric
<em>n</em> by <em>n</em>
matrices
<em>A</em>.
</p>
<p>See Magnus and Neudecker (1988), <cite>Matrix Differential
Calculus with Applications in Statistics and Econometrics.</cite>
</p></dd></dl>


<a name="XREFdawson"></a><dl>
<dt><a name="index-dawson"></a><em></em> <strong>dawson</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the Dawson (scaled imaginary error) function.
</p>
<p>The Dawson function is defined as
</p>
<div class="example">
<pre class="example">(sqrt (pi) / 2) * exp (-z^2) * erfi (z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFellipj"></a><dl>
<dt><a name="index-ellipj"></a><em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>)</em></dt>
<dt><a name="index-ellipj-1"></a><em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>, <var>tol</var>)</em></dt>
<dd><p>Compute the Jacobi elliptic functions <var>sn</var>, <var>cn</var>, and <var>dn</var>
of complex argument <var>u</var> and real parameter <var>m</var>.
</p>
<p>If <var>m</var> is a scalar, the results are the same size as <var>u</var>.
If <var>u</var> is a scalar, the results are the same size as <var>m</var>.
If <var>u</var> is a column vector and <var>m</var> is a row vector, the
results are matrices with <code>length (<var>u</var>)</code> rows and
<code>length (<var>m</var>)</code> columns.  Otherwise, <var>u</var> and
<var>m</var> must conform in size and the results will be the same size as the
inputs.
</p>
<p>The value of <var>u</var> may be complex.
The value of <var>m</var> must be 0 &le; <var>m</var> &le; 1.
</p>
<p>The optional input <var>tol</var> is currently ignored (<small>MATLAB</small> uses this to
allow faster, less accurate approximation).
</p>
<p>If requested, <var>err</var> contains the following status information
and is the same size as the result.
</p>
<ol start="0">
<li> Normal return.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code>NaN</code>.
</li></ol>

<p>Reference: Milton Abramowitz and Irene A Stegun,
<cite>Handbook of Mathematical Functions</cite>, Chapter 16 (Sections 16.4, 16.13,
and 16.15), Dover, 1965.
</p>

<p><strong>See also:</strong> <a href="#XREFellipke">ellipke</a>.
</p></dd></dl>


<a name="XREFellipke"></a><dl>
<dt><a name="index-ellipke"></a><em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>)</em></dt>
<dt><a name="index-ellipke-1"></a><em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>, <var>tol</var>)</em></dt>
<dt><a name="index-ellipke-2"></a><em>[<var>k</var>, <var>e</var>] =</em> <strong>ellipke</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute complete elliptic integrals of the first K(<var>m</var>) and second
E(<var>m</var>) kind.
</p>
<p><var>m</var> must be a scalar or real array with -Inf &le; <var>m</var> &le; 1.
</p>
<p>The optional input <var>tol</var> controls the stopping tolerance of the
algorithm and defaults to <code>eps (class (<var>m</var>))</code>.  The tolerance can
be increased to compute a faster, less accurate approximation.
</p>
<p>When called with one output only elliptic integrals of the first kind are
returned.
</p>
<p>Mathematical Note:
</p>
<p>Elliptic integrals of the first kind are defined as
</p>

<div class="example">
<pre class="example">         1
        /               dt
K (m) = | ------------------------------
        / sqrt ((1 - t^2)*(1 - m*t^2))
       0
</pre></div>


<p>Elliptic integrals of the second kind are defined as
</p>

<div class="example">
<pre class="example">         1
        /  sqrt (1 - m*t^2)
E (m) = |  ------------------ dt
        /  sqrt (1 - t^2)
       0
</pre></div>


<p>Reference: Milton Abramowitz and Irene A. Stegun,
<cite>Handbook of Mathematical Functions</cite>, Chapter 17, Dover, 1965.
</p>
<p><strong>See also:</strong> <a href="#XREFellipj">ellipj</a>.
</p></dd></dl>


<a name="XREFerf"></a><dl>
<dt><a name="index-erf"></a><em></em> <strong>erf</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the error function.
</p>
<p>The error function is defined as
</p>
<div class="example">
<pre class="example">                        z
              2        /
erf (z) = --------- *  | e^(-t^2) dt
          sqrt (pi)    /
                    t=0
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfc"></a><dl>
<dt><a name="index-erfc"></a><em></em> <strong>erfc</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the complementary error function.
</p>
<p>The complementary error function is defined as
<code>1&nbsp;<span class="nolinebreak">-</span>&nbsp;erf&nbsp;(<var>z</var>)</code><!-- /@w -->.
</p>
<p><strong>See also:</strong> <a href="#XREFerfcinv">erfcinv</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a name="XREFerfcx"></a><dl>
<dt><a name="index-erfcx"></a><em></em> <strong>erfcx</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the scaled complementary error function.
</p>
<p>The scaled complementary error function is defined as
</p>
<div class="example">
<pre class="example">exp (z^2) * erfc (z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfi"></a><dl>
<dt><a name="index-erfi"></a><em></em> <strong>erfi</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the imaginary error function.
</p>
<p>The imaginary error function is defined as
</p>
<div class="example">
<pre class="example">-i * erf (i*z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfinv"></a><dl>
<dt><a name="index-erfinv"></a><em></em> <strong>erfinv</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the inverse error function.
</p>
<p>The inverse error function is defined such that
</p>
<div class="example">
<pre class="example">erf (<var>y</var>) == <var>x</var>
</pre></div>

<p><strong>See also:</strong> <a href="#XREFerf">erf</a>, <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfcinv"></a><dl>
<dt><a name="index-erfcinv"></a><em></em> <strong>erfcinv</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the inverse complementary error function.
</p>
<p>The inverse complementary error function is defined such that
</p>
<div class="example">
<pre class="example">erfc (<var>y</var>) == <var>x</var>
</pre></div>

<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a name="XREFexpint"></a><dl>
<dt><a name="index-expint"></a><em></em> <strong>expint</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the exponential integral.
</p>
<p>The exponential integral is defined as:
</p>

<div class="example">
<pre class="example">           +oo
          /
          | exp (-t)
E_1 (x) = | -------- dt
          |    t
          /
         x
</pre></div>


<p>Note: For compatibility, this function uses the <small>MATLAB</small> definition
of the exponential integral.  Most other sources refer to this particular
value as <em>E_1 (x)</em>, and the exponential integral as
</p>
<div class="example">
<pre class="example">            +oo
           /
           | exp (-t)
Ei (x) = - | -------- dt
           |    t
           /
         -x
</pre></div>

<p>The two definitions are related, for positive real values of <var>x</var>, by
<code><span class="nolinebreak">E_1</span>&nbsp;<span class="nolinebreak">(-x)</span>&nbsp;=&nbsp;<span class="nolinebreak">-Ei</span>&nbsp;(x)&nbsp;<span class="nolinebreak">-</span>&nbsp;i*pi</code><!-- /@w -->.
</p>
<p>References:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite>Handbook of Mathematical Functions</cite>, 1964.
</p>
<p>N. Bleistein and R.A. Handelsman,
<cite>Asymptotic expansions of integrals</cite>, 1986.
</p>

<p><strong>See also:</strong> <a href="#XREFcosint">cosint</a>, <a href="#XREFsinint">sinint</a>, <a href="Exponents-and-Logarithms.html#XREFexp">exp</a>.
</p></dd></dl>


<a name="XREFgamma"></a><dl>
<dt><a name="index-gamma"></a><em></em> <strong>gamma</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the Gamma function.
</p>
<p>The Gamma function is defined as
</p>
<div class="example">
<pre class="example">             infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0
</pre></div>


<p>Programming Note: The gamma function can grow quite large even for small
input values.  In many cases it may be preferable to use the natural
logarithm of the gamma function (<code>gammaln</code>) in calculations to minimize
loss of precision.  The final result is then
<code>exp (<var>result_using_gammaln</var>).</code>
</p>
<p><strong>See also:</strong> <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgammaln">gammaln</a>, <a href="Utility-Functions.html#XREFfactorial">factorial</a>.
</p></dd></dl>


<a name="XREFgammainc"></a><dl>
<dt><a name="index-gammainc"></a><em></em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>)</em></dt>
<dt><a name="index-gammainc-1"></a><em></em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>, <var>tail</var>)</em></dt>
<dd><p>Compute the normalized incomplete gamma function.
</p>
<p>This is defined as
</p>
<div class="example">
<pre class="example">                                x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
</pre></div>

<p>with the limiting value of 1 as <var>x</var> approaches infinity.
The standard notation is <em>P(a,x)</em>, e.g., Abramowitz and
Stegun (6.5.1).
</p>
<p>If <var>a</var> is scalar, then <code>gammainc (<var>x</var>, <var>a</var>)</code> is returned
for each element of <var>x</var> and vice versa.
</p>
<p>If neither <var>x</var> nor <var>a</var> is scalar then the sizes of <var>x</var> and
<var>a</var> must agree, and <code>gammainc</code> is applied element-by-element.
The elements of <var>a</var> must be non-negative.
</p>
<p>By default, <var>tail</var> is <code>&quot;lower&quot;</code> and the incomplete gamma function
integrated from 0 to <var>x</var> is computed.  If <var>tail</var> is <code>&quot;upper&quot;</code>
then the complementary function integrated from <var>x</var> to infinity is
calculated.
</p>
<p>If <var>tail</var> is <code>&quot;scaledlower&quot;</code>, then the lower incomplete gamma
function is multiplied by
<em>gamma(a+1)*exp(x)/(x^a)</em>.
If <var>tail</var> is <code>&quot;scaledupper&quot;</code>, then the upper incomplete gamma
function is multiplied by the same quantity.
</p>
<p>References:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite>Handbook of mathematical functions</cite>,
Dover publications, Inc., 1972.
</p>
<p>W. Gautschi,
<cite>A computational procedure for incomplete gamma functions</cite>,
ACM Trans. Math Software, pp. 466&ndash;481, Vol 5, No. 4, 2012.
</p>
<p>W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery,
<cite>Numerical Recipes in Fortran 77</cite>, ch. 6.2, Vol 1, 1992.
</p>

<p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammaincinv">gammaincinv</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFgammaincinv"></a><dl>
<dt><a name="index-gammaincinv"></a><em></em> <strong>gammaincinv</strong> <em>(<var>y</var>, <var>a</var>)</em></dt>
<dt><a name="index-gammaincinv-1"></a><em></em> <strong>gammaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>tail</var>)</em></dt>
<dd><p>Compute the inverse of the normalized incomplete gamma function.
</p>
<p>The normalized incomplete gamma function is defined as
</p>
<div class="example">
<pre class="example">                                x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
</pre></div>


<p>and <code>gammaincinv (gammainc (<var>x</var>, <var>a</var>), <var>a</var>) = <var>x</var></code>
for each non-negative value of <var>x</var>.  If <var>a</var> is scalar then
<code>gammaincinv (<var>y</var>, <var>a</var>)</code> is returned for each element of
<var>y</var> and vice versa.
</p>
<p>If neither <var>y</var> nor <var>a</var> is scalar then the sizes of <var>y</var> and
<var>a</var> must agree, and <code>gammaincinv</code> is applied element-by-element.
The variable <var>y</var> must be in the interval <em>[0,1]</em> while <var>a</var> must
be real and positive.
</p>
<p>By default, <var>tail</var> is <code>&quot;lower&quot;</code> and the inverse of the incomplete
gamma function integrated from 0 to <var>x</var> is computed.  If <var>tail</var> is
<code>&quot;upper&quot;</code>, then the complementary function integrated from <var>x</var> to
infinity is inverted.
</p>
<p>The function is computed with Newton&rsquo;s method by solving
</p>
<div class="example">
<pre class="example"><var>y</var> - gammainc (<var>x</var>, <var>a</var>) = 0
</pre></div>


<p>Reference: A. Gil, J. Segura, and N. M. Temme, <cite>Efficient and
accurate algorithms for the computation and inversion of the incomplete
gamma function ratios</cite>, SIAM J. Sci. Computing, pp. A2965&ndash;A2981,
Vol 34, 2012.
</p>

<p><strong>See also:</strong> <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgamma">gamma</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFlegendre"></a><dl>
<dt><a name="index-legendre"></a><em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>)</em></dt>
<dt><a name="index-legendre-1"></a><em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>, <var>normalization</var>)</em></dt>
<dd><p>Compute the associated Legendre function of degree <var>n</var> and order
<var>m</var> = 0 &hellip; <var>n</var>.
</p>
<p>The value <var>n</var> must be a real non-negative integer.
</p>
<p><var>x</var> is a vector with real-valued elements in the range [-1, 1].
</p>
<p>The optional argument <var>normalization</var> may be one of <code>&quot;unnorm&quot;</code>,
<code>&quot;sch&quot;</code>, or <code>&quot;norm&quot;</code>.  The default if no normalization is given
is <code>&quot;unnorm&quot;</code>.
</p>
<p>When the optional argument <var>normalization</var> is <code>&quot;unnorm&quot;</code>, compute
the associated Legendre function of degree <var>n</var> and order <var>m</var> and
return all values for <var>m</var> = 0 &hellip; <var>n</var>.  The return value has one
dimension more than <var>x</var>.
</p>
<p>The associated Legendre function of degree <var>n</var> and order <var>m</var>:
</p>

<div class="example">
<pre class="example"> m         m      2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P(x)
 n                         dx^m   n
</pre></div>


<p>with Legendre polynomial of degree <var>n</var>:
</p>

<div class="example">
<pre class="example">          1    d^n   2    n
P(x) = ------ [----(x - 1) ]
 n     2^n n!  dx^n
</pre></div>


<p><code>legendre (3, [-1.0, -0.9, -0.8])</code> returns the matrix:
</p>
<div class="example">
<pre class="example"> x  |   -1.0   |   -0.9   |   -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000
</pre></div>

<p>When the optional argument <var>normalization</var> is <code>&quot;sch&quot;</code>, compute
the Schmidt semi-normalized associated Legendre function.  The Schmidt
semi-normalized associated Legendre function is related to the unnormalized
Legendre functions by the following:
</p>
<p>For Legendre functions of degree <var>n</var> and order 0:
</p>

<div class="example">
<pre class="example">  0      0
SP(x) = P(x)
  n      n
</pre></div>


<p>For Legendre functions of degree n and order m:
</p>

<div class="example">
<pre class="example">  m      m         m    2(n-m)! 0.5
SP(x) = P(x) * (-1)  * [-------]
  n      n              (n+m)!
</pre></div>


<p>When the optional argument <var>normalization</var> is <code>&quot;norm&quot;</code>, compute
the fully normalized associated Legendre function.  The fully normalized
associated Legendre function is related to the unnormalized associated
Legendre functions by the following:
</p>
<p>For Legendre functions of degree <var>n</var> and order <var>m</var>
</p>

<div class="example">
<pre class="example">  m      m         m    (n+0.5)(n-m)! 0.5
NP(x) = P(x) * (-1)  * [-------------]
  n      n                  (n+m)!
</pre></div>

</dd></dl>


<a name="XREFgammaln"></a><a name="XREFlgamma"></a><dl>
<dt><a name="index-gammaln"></a><em></em> <strong>gammaln</strong> <em>(<var>x</var>)</em></dt>
<dt><a name="index-lgamma"></a><em></em> <strong>lgamma</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Return the natural logarithm of the gamma function of <var>x</var>.
</p>
<p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammainc">gammainc</a>.
</p></dd></dl>


<a name="XREFpsi"></a><dl>
<dt><a name="index-psi"></a><em></em> <strong>psi</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-psi-1"></a><em></em> <strong>psi</strong> <em>(<var>k</var>, <var>z</var>)</em></dt>
<dd><p>Compute the psi (polygamma) function.
</p>
<p>The polygamma functions are the <var>k</var>th derivative of the logarithm
of the gamma function.  If unspecified, <var>k</var> defaults to zero.  A value
of zero computes the digamma function, a value of 1, the trigamma function,
and so on.
</p>
<p>The digamma function is defined:
</p>

<div class="example">
<pre class="example">psi (z) = d (log (gamma (z))) / dx
</pre></div>


<p>When computing the digamma function (when <var>k</var> equals zero), <var>z</var>
can have any value real or complex value.  However, for polygamma functions
(<var>k</var> higher than 0), <var>z</var> must be real and non-negative.
</p>

<p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFsinint"></a><dl>
<dt><a name="index-sinint"></a><em></em> <strong>sinint</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the sine integral function:
</p>
<div class="example">
<pre class="example">           x
          /
Si (x) =  | sin (t) / t dt
          /
         0
</pre></div>


<p>Reference:
M. Abramowitz and I.A. Stegun,
<cite>Handbook of Mathematical Functions</cite>, 1964.
</p>

<p><strong>See also:</strong> <a href="#XREFcosint">cosint</a>, <a href="#XREFexpint">expint</a>, <a href="Trigonometry.html#XREFsin">sin</a>.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Rational-Approximations.html#Rational-Approximations" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="Utility-Functions.html#Utility-Functions" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="Arithmetic.html#Arithmetic" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
