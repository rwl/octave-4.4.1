<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Three-Dimensional Plots (GNU Octave (version 4.4.1))</title>

<meta name="description" content="Three-Dimensional Plots (GNU Octave (version 4.4.1))">
<meta name="keywords" content="Three-Dimensional Plots (GNU Octave (version 4.4.1))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" rel="up" title="High-Level Plotting">
<link href="Aspect-Ratio.html#Aspect-Ratio" rel="next" title="Aspect Ratio">
<link href="Two_002ddimensional-Geometric-Shapes.html#Two_002ddimensional-Geometric-Shapes" rel="prev" title="Two-dimensional Geometric Shapes">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<a name="Three_002dDimensional-Plots"></a>
<div class="header">
<p>
Next: <a href="Plot-Annotations.html#Plot-Annotations" accesskey="n" rel="next">Plot Annotations</a>, Previous: <a href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots" accesskey="p" rel="prev">Two-Dimensional Plots</a>, Up: <a href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" accesskey="u" rel="up">High-Level Plotting</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Three_002dDimensional-Plots-1"></a>
<h4 class="subsection">15.2.2 Three-Dimensional Plots</h4>
<a name="index-plotting_002c-three_002ddimensional"></a>

<p>The function <code>mesh</code> produces mesh surface plots.  For example,
</p>
<div class="example">
<pre class="example">tx = ty = linspace (-8, 8, 41)';
[xx, yy] = meshgrid (tx, ty);
r = sqrt (xx .^ 2 + yy .^ 2) + eps;
tz = sin (r) ./ r;
mesh (tx, ty, tz);
xlabel (&quot;tx&quot;);
ylabel (&quot;ty&quot;);
zlabel (&quot;tz&quot;);
title (&quot;3-D Sombrero plot&quot;);
</pre></div>

<p>produces the familiar &ldquo;sombrero&rdquo; plot shown in <a href="#fig_003amesh">Figure 15.5</a>.  Note
the use of the function <code>meshgrid</code> to create matrices of X and Y
coordinates to use for plotting the Z data.  The <code>ndgrid</code> function
is similar to <code>meshgrid</code>, but works for N-dimensional matrices.
</p>
<div class="float"><a name="fig_003amesh"></a>
<div align="center"><img src="mesh.png" alt="mesh">
</div>
<div class="float-caption"><p><strong>Figure 15.5: </strong>Mesh plot.</p></div></div>
<p>The <code>meshc</code> function is similar to <code>mesh</code>, but also produces a
plot of contours for the surface.
</p>
<p>The <code>plot3</code> function displays arbitrary three-dimensional data,
without requiring it to form a surface.  For example,
</p>
<div class="example">
<pre class="example">t = 0:0.1:10*pi;
r = linspace (0, 1, numel (t));
z = linspace (0, 1, numel (t));
plot3 (r.*sin (t), r.*cos (t), z);
xlabel (&quot;r.*sin (t)&quot;);
ylabel (&quot;r.*cos (t)&quot;);
zlabel (&quot;z&quot;);
title (&quot;plot3 display of 3-D helix&quot;);
</pre></div>

<p>displays the spiral in three dimensions shown in <a href="#fig_003aplot3">Figure 15.6</a>.
</p>
<div class="float"><a name="fig_003aplot3"></a>
<div align="center"><img src="plot3.png" alt="plot3">
</div>
<div class="float-caption"><p><strong>Figure 15.6: </strong>Three-dimensional spiral.</p></div></div>
<p>Finally, the <code>view</code> function changes the viewpoint for
three-dimensional plots.
</p>
<a name="XREFmesh"></a><dl>
<dt><a name="index-mesh"></a><em></em> <strong>mesh</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-mesh-1"></a><em></em> <strong>mesh</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-mesh-2"></a><em></em> <strong>mesh</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-mesh-3"></a><em></em> <strong>mesh</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-mesh-4"></a><em></em> <strong>mesh</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-mesh-5"></a><em><var>h</var> =</em> <strong>mesh</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezmesh">ezmesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="#XREFmeshz">meshz</a>, <a href="Plotting-the-Triangulation.html#XREFtrimesh">trimesh</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFmeshc"></a><dl>
<dt><a name="index-meshc"></a><em></em> <strong>meshc</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshc-1"></a><em></em> <strong>meshc</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-meshc-2"></a><em></em> <strong>meshc</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-meshc-3"></a><em></em> <strong>meshc</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-meshc-4"></a><em></em> <strong>meshc</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-meshc-5"></a><em><var>h</var> =</em> <strong>meshc</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh with underlying contour lines.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a 2-element vector with a graphics
handle to the created surface object and to the created contour plot.
</p>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezmeshc">ezmeshc</a>, <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshz">meshz</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurfc">surfc</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFmeshz"></a><dl>
<dt><a name="index-meshz"></a><em></em> <strong>meshz</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshz-1"></a><em></em> <strong>meshz</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-meshz-2"></a><em></em> <strong>meshz</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-meshz-3"></a><em></em> <strong>meshz</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-meshz-4"></a><em></em> <strong>meshz</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-meshz-5"></a><em><var>h</var> =</em> <strong>meshz</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh with a surrounding curtain.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFwaterfall">waterfall</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFhidden"></a><dl>
<dt><a name="index-hidden"></a><em></em> <strong>hidden</strong></dt>
<dt><a name="index-hidden-1"></a><em></em> <strong>hidden</strong> <em>on</em></dt>
<dt><a name="index-hidden-2"></a><em></em> <strong>hidden</strong> <em>off</em></dt>
<dt><a name="index-hidden-3"></a><em><var>mode</var> =</em> <strong>hidden</strong> <em>(&hellip;)</em></dt>
<dd><p>Control mesh hidden line removal.
</p>
<p>When called with no argument the hidden line removal state is toggled.
</p>
<p>When called with one of the modes <code>&quot;on&quot;</code> or <code>&quot;off&quot;</code> the state
is set accordingly.
</p>
<p>The optional output argument <var>mode</var> is the current state.
</p>
<p>Hidden Line Removal determines what graphic objects behind a mesh plot
are visible.  The default is for the mesh to be opaque and lines behind
the mesh are not visible.  If hidden line removal is turned off then
objects behind the mesh can be seen through the faces (openings) of the
mesh, although the mesh grid lines are still opaque.
</p>

<p><strong>See also:</strong> <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="#XREFmeshz">meshz</a>, <a href="Three_002ddimensional-Function-Plotting.html#XREFezmesh">ezmesh</a>, <a href="Three_002ddimensional-Function-Plotting.html#XREFezmeshc">ezmeshc</a>, <a href="Plotting-the-Triangulation.html#XREFtrimesh">trimesh</a>, <a href="#XREFwaterfall">waterfall</a>.
</p></dd></dl>


<a name="XREFsurf"></a><dl>
<dt><a name="index-surf"></a><em></em> <strong>surf</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surf-1"></a><em></em> <strong>surf</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surf-2"></a><em></em> <strong>surf</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-surf-3"></a><em></em> <strong>surf</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surf-4"></a><em></em> <strong>surf</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surf-5"></a><em><var>h</var> =</em> <strong>surf</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface mesh.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the surface is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the surface can be specified independently of
<var>z</var> by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Note: The exact appearance of the surface can be controlled with the
<code>shading</code> command or by using <code>set</code> to control surface object
properties.
</p>
<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezsurf">ezsurf</a>, <a href="#XREFsurfc">surfc</a>, <a href="#XREFsurfl">surfl</a>, <a href="#XREFsurfnorm">surfnorm</a>, <a href="Plotting-the-Triangulation.html#XREFtrisurf">trisurf</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfc"></a><dl>
<dt><a name="index-surfc"></a><em></em> <strong>surfc</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfc-1"></a><em></em> <strong>surfc</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfc-2"></a><em></em> <strong>surfc</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-surfc-3"></a><em></em> <strong>surfc</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surfc-4"></a><em></em> <strong>surfc</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfc-5"></a><em><var>h</var> =</em> <strong>surfc</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface mesh with underlying contour lines.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the surface is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the surface can be specified independently of
<var>z</var> by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Note: The exact appearance of the surface can be controlled with the
<code>shading</code> command or by using <code>set</code> to control surface object
properties.
</p>
<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezsurfc">ezsurfc</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFsurfl">surfl</a>, <a href="#XREFsurfnorm">surfnorm</a>, <a href="Plotting-the-Triangulation.html#XREFtrisurf">trisurf</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfl"></a><dl>
<dt><a name="index-surfl"></a><em></em> <strong>surfl</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfl-1"></a><em></em> <strong>surfl</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfl-2"></a><em></em> <strong>surfl</strong> <em>(&hellip;, <var>lsrc</var>)</em></dt>
<dt><a name="index-surfl-3"></a><em></em> <strong>surfl</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>lsrc</var>, <var>P</var>)</em></dt>
<dt><a name="index-surfl-4"></a><em></em> <strong>surfl</strong> <em>(&hellip;, &quot;cdata&quot;)</em></dt>
<dt><a name="index-surfl-5"></a><em></em> <strong>surfl</strong> <em>(&hellip;, &quot;light&quot;)</em></dt>
<dt><a name="index-surfl-6"></a><em></em> <strong>surfl</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfl-7"></a><em><var>h</var> =</em> <strong>surfl</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface using shading based on various lighting models.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The default lighting mode <code>&quot;cdata&quot;</code>, changes the cdata property of the
surface object to give the impression of a lighted surface.
<strong>Warning:</strong> The alternative mode <code>&quot;light&quot;</code> mode which creates a
light object to illuminate the surface is not implemented (yet).
</p>
<p>The light source location can be specified using <var>lsrc</var>.  It can be
given as a 2-element vector [azimuth, elevation] in degrees, or as a
3-element vector [lx, ly, lz].  The default value is rotated 45 degrees
counterclockwise to the current view.
</p>
<p>The material properties of the surface can specified using a 4-element
vector <var>P</var> = [<var>AM</var> <var>D</var> <var>SP</var> <var>exp</var>] which defaults to
<var>p</var> = [0.55 0.6 0.4 10].
</p>
<dl compact="compact">
<dt><code>&quot;AM&quot;</code> strength of ambient light</dt>
<dt><code>&quot;D&quot;</code> strength of diffuse reflection</dt>
<dt><code>&quot;SP&quot;</code> strength of specular reflection</dt>
<dt><code>&quot;EXP&quot;</code> specular exponent</dt>
</dl>

<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Example:
</p>
<div class="example">
<pre class="example">colormap (bone (64));
surfl (peaks);
shading interp;
</pre></div>

<p><strong>See also:</strong> <a href="#XREFdiffuse">diffuse</a>, <a href="#XREFspecular">specular</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfnorm"></a><dl>
<dt><a name="index-surfnorm"></a><em></em> <strong>surfnorm</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfnorm-1"></a><em></em> <strong>surfnorm</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfnorm-2"></a><em></em> <strong>surfnorm</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surfnorm-3"></a><em></em> <strong>surfnorm</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfnorm-4"></a><em>[<var>nx</var>, <var>ny</var>, <var>nz</var>] =</em> <strong>surfnorm</strong> <em>(&hellip;)</em></dt>
<dd><p>Find the vectors normal to a meshgridded surface.
</p>
<p>If <var>x</var> and <var>y</var> are vectors, then a typical vertex is
(<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus, columns of <var>z</var> correspond
to different <var>x</var> values and rows of <var>z</var> correspond to different
<var>y</var> values.  If only a single input <var>z</var> is given then <var>x</var> is
taken to be <code>1:columns (<var>z</var>)</code> and <var>y</var> is
<code>1:rows (<var>z</var>)</code>.
</p>
<p>If no return arguments are requested, a surface plot with the normal
vectors to the surface is plotted.
</p>
<p>Any property/value input pairs are assigned to the surface object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>If output arguments are requested then the components of the normal
vectors are returned in <var>nx</var>, <var>ny</var>, and <var>nz</var> and no plot is
made.  The normal vectors are unnormalized (magnitude != 1).  To normalize,
use
</p>
<div class="example">
<pre class="example">len = sqrt (nx.^2 + ny.^2 + nz.^2);
nx ./= len;  ny ./= len;  nz ./= len;
</pre></div>

<p>An example of the use of <code>surfnorm</code> is
</p>
<div class="example">
<pre class="example">surfnorm (peaks (25));
</pre></div>

<p>Algorithm: The normal vectors are calculated by taking the cross product
of the diagonals of each of the quadrilateral faces in the meshgrid to find
the normal vectors at the center of each face.  Next, for each meshgrid
point the four nearest normal vectors are averaged to obtain the final
normal to the surface at the meshgrid point.
</p>
<p>For surface objects, the <code>&quot;VertexNormals&quot;</code> property contains
equivalent information, except possibly near the boundary of the surface
where different interpolation schemes may yield slightly different values.
</p>

<p><strong>See also:</strong> <a href="#XREFisonormals">isonormals</a>, <a href="Two_002dDimensional-Plots.html#XREFquiver3">quiver3</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFmeshgrid">meshgrid</a>.
</p></dd></dl>


<a name="XREFisosurface"></a><dl>
<dt><a name="index-isosurface"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(<var>v</var>, <var>isoval</var>)</em></dt>
<dt><a name="index-isosurface-1"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(<var>v</var>)</em></dt>
<dt><a name="index-isosurface-2"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>isoval</var>)</em></dt>
<dt><a name="index-isosurface-3"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>)</em></dt>
<dt><a name="index-isosurface-4"></a><em><var>fvc</var> =</em> <strong>isosurface</strong> <em>(&hellip;, <var>col</var>)</em></dt>
<dt><a name="index-isosurface-5"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(&hellip;, &quot;noshare&quot;)</em></dt>
<dt><a name="index-isosurface-6"></a><em><var>fv</var> =</em> <strong>isosurface</strong> <em>(&hellip;, &quot;verbose&quot;)</em></dt>
<dt><a name="index-isosurface-7"></a><em>[<var>f</var>, <var>v</var>] =</em> <strong>isosurface</strong> <em>(&hellip;)</em></dt>
<dt><a name="index-isosurface-8"></a><em>[<var>f</var>, <var>v</var>, <var>c</var>] =</em> <strong>isosurface</strong> <em>(&hellip;)</em></dt>
<dt><a name="index-isosurface-9"></a><em></em> <strong>isosurface</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Calculate isosurface of 3-D volume data.
</p>
<p>An isosurface connects points with the same value and is analogous to a
contour plot, but in three dimensions.
</p>
<p>The input argument <var>v</var> is a three-dimensional array that contains data
sampled over a volume.
</p>
<p>The input <var>isoval</var> is a scalar that specifies the value for the
isosurface.  If <var>isoval</var> is omitted or empty, a &quot;good&quot; value
for an isosurface is determined from <var>v</var>.
</p>
<p>When called with a single output argument <code>isosurface</code> returns a
structure array <var>fv</var> that contains the fields <var>faces</var> and
<var>vertices</var> computed at the points
<code>[<var>x</var>, <var>y</var>, <var>z</var>] = meshgrid (1:l, 1:m, 1:n)</code> where
<code>[l, m, n] = size (<var>v</var>)</code>.  The output <var>fv</var> can be
used directly as input to the <code>patch</code> function.
</p>
<p>If called with additional input arguments <var>x</var>, <var>y</var>, and <var>z</var>
that are three-dimensional arrays with the same size as <var>v</var> or
vectors with lengths corresponding to the dimensions of <var>v</var>, then the
volume data is taken at the specified points.  If <var>x</var>, <var>y</var>, or
<var>z</var> are empty, the grid corresponds to the indices (<code>1:n</code>) in
the respective direction (see <a href="#XREFmeshgrid">meshgrid</a>).
</p>
<p>The optional input argument <var>col</var>, which is a three-dimensional array
of the same size as <var>v</var>, specifies coloring of the isosurface.  The
color data is interpolated, as necessary, to match <var>isoval</var>.  The
output structure array, in this case, has the additional field
<var>facevertexcdata</var>.
</p>
<p>If given the string input argument <code>&quot;noshare&quot;</code>, vertices may be
returned multiple times for different faces.  The default behavior is to
eliminate vertices shared by adjacent faces with <code>unique</code> which may be
time consuming.
</p>
<p>The string input argument <code>&quot;verbose&quot;</code> is supported for <small>MATLAB</small>
compatibility, but has no effect.
</p>
<p>Any string arguments must be passed after the other arguments.
</p>
<p>If called with two or three output arguments, return the information about
the faces <var>f</var>, vertices <var>v</var>, and color data <var>c</var> as separate
arrays instead of a single structure array.
</p>
<p>If called with no output argument, the isosurface geometry is directly
plotted with the <code>patch</code> command and a light object is added to
the axes if not yet present.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">[x, y, z] = meshgrid (1:5, 1:5, 1:5);
v = rand (5, 5, 5);
isosurface (x, y, z, v, .5);
</pre></div>

<p>will directly draw a random isosurface geometry in a graphics window.
</p>
<p>An example of an isosurface geometry with different additional coloring:
</p>
<div class="smallexample">
<pre class="smallexample">N = 15;    # Increase number of vertices in each direction
iso = .4;  # Change isovalue to .1 to display a sphere
lin = linspace (0, 2, N);
[x, y, z] = meshgrid (lin, lin, lin);
v = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
figure ();

subplot (2,2,1); view (-38, 20);
[f, vert] = isosurface (x, y, z, v, iso);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, vert, &quot;EdgeColor&quot;, &quot;none&quot;);
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, &quot;FaceColor&quot;, &quot;green&quot;, &quot;FaceLighting&quot;, &quot;gouraud&quot;);
light (&quot;Position&quot;, [1 1 5]);

subplot (2,2,2); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, vert, &quot;EdgeColor&quot;, &quot;blue&quot;);
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, &quot;FaceColor&quot;, &quot;none&quot;, &quot;EdgeLighting&quot;, &quot;gouraud&quot;);
light (&quot;Position&quot;, [1 1 5]);

subplot (2,2,3); view (-38, 20);
[f, vert, c] = isosurface (x, y, z, v, iso, y);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, vert, &quot;FaceVertexCData&quot;, c, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, &quot;FaceLighting&quot;, &quot;gouraud&quot;);
light (&quot;Position&quot;, [1 1 5]);

subplot (2,2,4); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, vert, &quot;FaceVertexCData&quot;, c, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;blue&quot;);
pbaspect ([1 1 1]);
isonormals (x, y, z, v, p)
set (p, &quot;FaceLighting&quot;, &quot;gouraud&quot;);
light (&quot;Position&quot;, [1 1 5]);
</pre></div>


<p><strong>See also:</strong> <a href="#XREFisonormals">isonormals</a>, <a href="#XREFisocolors">isocolors</a>, <a href="#XREFisocaps">isocaps</a>, <a href="#XREFsmooth3">smooth3</a>, <a href="#XREFreducevolume">reducevolume</a>, <a href="#XREFreducepatch">reducepatch</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFisonormals"></a><dl>
<dt><a name="index-isonormals"></a><em><var>vn</var> =</em> <strong>isonormals</strong> <em>(<var>val</var>, <var>vert</var>)</em></dt>
<dt><a name="index-isonormals-1"></a><em><var>vn</var> =</em> <strong>isonormals</strong> <em>(<var>val</var>, <var>hp</var>)</em></dt>
<dt><a name="index-isonormals-2"></a><em><var>vn</var> =</em> <strong>isonormals</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>vert</var>)</em></dt>
<dt><a name="index-isonormals-3"></a><em><var>vn</var> =</em> <strong>isonormals</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>hp</var>)</em></dt>
<dt><a name="index-isonormals-4"></a><em><var>vn</var> =</em> <strong>isonormals</strong> <em>(&hellip;, &quot;negate&quot;)</em></dt>
<dt><a name="index-isonormals-5"></a><em></em> <strong>isonormals</strong> <em>(<var>val</var>, <var>hp</var>)</em></dt>
<dt><a name="index-isonormals-6"></a><em></em> <strong>isonormals</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>hp</var>)</em></dt>
<dt><a name="index-isonormals-7"></a><em></em> <strong>isonormals</strong> <em>(&hellip;, &quot;negate&quot;)</em></dt>
<dd>
<p>Calculate normals to an isosurface.
</p>
<p>The vertex normals <var>vn</var> are calculated from the gradient of the
3-dimensional array <var>val</var> (size: lxmxn) containing the data for an
isosurface geometry.  The normals point towards smaller values in <var>val</var>.
</p>
<p>If called with one output argument <var>vn</var>, and the second input argument
<var>vert</var> holds the vertices of an isosurface, then the normals <var>vn</var>
are calculated at the vertices <var>vert</var> on a grid given by
<code>[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>.  The output argument
<var>vn</var> has the same size as <var>vert</var> and can be used to set the
<code>&quot;VertexNormals&quot;</code> property of the corresponding patch.
</p>
<p>If called with additional input arguments <var>x</var>, <var>y</var>, and <var>z</var>,
which are 3-dimensional arrays with the same size as <var>val</var>,
then the volume data is taken at these points.  Instead of the vertex data
<var>vert</var>, a patch handle <var>hp</var> can be passed to the function.
</p>
<p>If the last input argument is the string <code>&quot;negate&quot;</code>, compute the
reverse vector normals of an isosurface geometry (i.e., pointed towards
larger values in <var>val</var>).
</p>
<p>If no output argument is given, the property <code>&quot;VertexNormals&quot;</code> of
the patch associated with the patch handle <var>hp</var> is changed directly.
</p>

<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisocolors">isocolors</a>, <a href="#XREFsmooth3">smooth3</a>.
</p></dd></dl>


<a name="XREFisocaps"></a><dl>
<dt><a name="index-isocaps"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(<var>v</var>, <var>isoval</var>)</em></dt>
<dt><a name="index-isocaps-1"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(<var>v</var>)</em></dt>
<dt><a name="index-isocaps-2"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>isoval</var>)</em></dt>
<dt><a name="index-isocaps-3"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocaps-4"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(&hellip;, <var>which_caps</var>)</em></dt>
<dt><a name="index-isocaps-5"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(&hellip;, <var>which_plane</var>)</em></dt>
<dt><a name="index-isocaps-6"></a><em><var>fvc</var> =</em> <strong>isocaps</strong> <em>(&hellip;, <code>&quot;verbose&quot;</code>)</em></dt>
<dt><a name="index-isocaps-7"></a><em>[<var>faces</var>, <var>vertices</var>, <var>fvcdata</var>] =</em> <strong>isocaps</strong> <em>(&hellip;)</em></dt>
<dt><a name="index-isocaps-8"></a><em></em> <strong>isocaps</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Create end-caps for isosurfaces of 3-D data.
</p>
<p>This function places caps at the open ends of isosurfaces.
</p>
<p>The input argument <var>v</var> is a three-dimensional array that contains data
sampled over a volume.
</p>
<p>The input <var>isoval</var> is a scalar that specifies the value for the
isosurface.  If <var>isoval</var> is omitted or empty, a &quot;good&quot; value
for an isosurface is determined from <var>v</var>.
</p>
<p>When called with a single output argument, <code>isocaps</code> returns a
structure array <var>fvc</var> with the fields: <code>faces</code>, <code>vertices</code>,
and <code>facevertexcdata</code>.  The results are computed at the points
<code>[<var>x</var>, <var>y</var>, <var>z</var>] = meshgrid (1:l, 1:m, 1:n)</code> where
<code>[l, m, n] = size (<var>v</var>)</code>.  The output <var>fvc</var> can be used
directly as input to the <code>patch</code> function.
</p>
<p>If called with additional input arguments <var>x</var>, <var>y</var>, and <var>z</var>
that are three-dimensional arrays with the same size as <var>v</var> or
vectors with lengths corresponding to the dimensions of <var>v</var>, then the
volume data is taken at the specified points.  If <var>x</var>, <var>y</var>, or
<var>z</var> are empty, the grid corresponds to the indices (<code>1:n</code>) in
the respective direction (see <a href="#XREFmeshgrid">meshgrid</a>).
</p>
<p>The optional parameter <var>which_caps</var> can have one of the following
string values which defines how the data will be enclosed:
</p>
<dl compact="compact">
<dt><code>&quot;above&quot;</code>, <code>&quot;a&quot;</code> (default)</dt>
<dd><p>for end-caps that enclose the data above <var>isoval</var>.
</p>
</dd>
<dt><code>&quot;below&quot;</code>, <code>&quot;b&quot;</code></dt>
<dd><p>for end-caps that enclose the data below <var>isoval</var>.
</p></dd>
</dl>

<p>The optional parameter <var>which_plane</var> can have one of the following
string values to define which end-cap should be drawn:
</p>
<dl compact="compact">
<dt><code>&quot;all&quot;</code> (default)</dt>
<dd><p>for all of the end-caps.
</p>
</dd>
<dt><code>&quot;xmin&quot;</code></dt>
<dd><p>for end-caps at the lower x-plane of the data.
</p>
</dd>
<dt><code>&quot;xmax&quot;</code></dt>
<dd><p>for end-caps at the upper x-plane of the data.
</p>
</dd>
<dt><code>&quot;ymin&quot;</code></dt>
<dd><p>for end-caps at the lower y-plane of the data.
</p>
</dd>
<dt><code>&quot;ymax&quot;</code></dt>
<dd><p>for end-caps at the upper y-plane of the data.
</p>
</dd>
<dt><code>&quot;zmin&quot;</code></dt>
<dd><p>for end-caps at the lower z-plane of the data.
</p>
</dd>
<dt><code>&quot;zmax&quot;</code></dt>
<dd><p>for end-caps at the upper z-plane of the data.
</p></dd>
</dl>

<p>The string input argument <code>&quot;verbose&quot;</code> is supported for <small>MATLAB</small>
compatibility, but has no effect.
</p>
<p>If called with two or three output arguments, the data for faces
<var>faces</var>, vertices <var>vertices</var>, and the color data
<var>facevertexcdata</var> are returned in separate arrays instead of a single
structure.
</p>
<p>If called with no output argument, the end-caps are drawn directly in the
current figure with the <code>patch</code> command.
</p>

<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFisocolors"></a><dl>
<dt><a name="index-isocolors"></a><em><var>cdat</var> =</em> <strong>isocolors</strong> <em>(<var>c</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-1"></a><em><var>cdat</var> =</em> <strong>isocolors</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>c</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-2"></a><em><var>cdat</var> =</em> <strong>isocolors</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>r</var>, <var>g</var>, <var>b</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-3"></a><em><var>cdat</var> =</em> <strong>isocolors</strong> <em>(<var>r</var>, <var>g</var>, <var>b</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-4"></a><em><var>cdat</var> =</em> <strong>isocolors</strong> <em>(&hellip;, <var>p</var>)</em></dt>
<dt><a name="index-isocolors-5"></a><em></em> <strong>isocolors</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Compute isosurface colors.
</p>
<p>If called with one output argument, and the first input argument <var>c</var>
is a three-dimensional array that contains indexed color values, and the
second input argument <var>v</var> are the vertices of an isosurface geometry,
then return a matrix <var>cdat</var> with color data information for the geometry
at computed points <code>[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>.  The output
argument <var>cdat</var> can be used to manually set the
<code>&quot;FaceVertexCData&quot;</code> property of an isosurface patch object.
</p>
<p>If called with additional input arguments <var>x</var>, <var>y</var> and <var>z</var> which
are three-dimensional arrays of the same size as <var>c</var> then the
color data is taken at those specified points.
</p>
<p>Instead of indexed color data <var>c</var>, <code>isocolors</code> can also be called
with RGB values <var>r</var>, <var>g</var>, <var>b</var>.  If input arguments <var>x</var>,
<var>y</var>, <var>z</var> are not given then <code>meshgrid</code> computed values are
used.
</p>
<p>Optionally, a patch handle <var>p</var> can be given as the last input argument
to all function call variations and the vertex data will be extracted
from the isosurface patch object.  Finally, if no output argument is given
then the colors of the patch given by the patch handle <var>p</var> are changed.
</p>

<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>.
</p></dd></dl>


<a name="XREFsmooth3"></a><dl>
<dt><a name="index-smooth3"></a><em><var>smoothed_data</var> =</em> <strong>smooth3</strong> <em>(<var>data</var>)</em></dt>
<dt><a name="index-smooth3-1"></a><em><var>smoothed_data</var> =</em> <strong>smooth3</strong> <em>(<var>data</var>, <var>method</var>)</em></dt>
<dt><a name="index-smooth3-2"></a><em><var>smoothed_data</var> =</em> <strong>smooth3</strong> <em>(<var>data</var>, <var>method</var>, <var>sz</var>)</em></dt>
<dt><a name="index-smooth3-3"></a><em><var>smoothed_data</var> =</em> <strong>smooth3</strong> <em>(<var>data</var>, <var>method</var>, <var>sz</var>, <var>std_dev</var>)</em></dt>
<dd><p>Smooth values of 3-dimensional matrix <var>data</var>.
</p>
<p>This function can be used, for example, to reduce the impact of noise in
<var>data</var> before calculating isosurfaces.
</p>
<p><var>data</var> must be a non-singleton 3-dimensional matrix.  The smoothed data
from this matrix is returned in <var>smoothed_data</var> which is of the same
size as <var>data</var>.
</p>
<p>The option input <var>method</var> determines which convolution kernel is used
for the smoothing process.  Possible choices:
</p>
<dl compact="compact">
<dt><code>&quot;box&quot;</code>, <code>&quot;b&quot;</code> (default)</dt>
<dd><p>to use a convolution kernel with sharp edges.
</p>
</dd>
<dt><code>&quot;gaussian&quot;</code>, <code>&quot;g&quot;</code></dt>
<dd><p>to use a convolution kernel that is represented by a non-correlated
trivariate normal distribution function.
</p></dd>
</dl>

<p><var>sz</var> is either a vector of 3 elements representing the size of the
convolution kernel in x-, y- and z-direction or a scalar, in which case
the same size is used in all three dimensions.  The default value is 3.
</p>
<p>When <var>method</var> is <code>&quot;gaussian&quot;</code>, <var>std_dev</var> defines the standard
deviation of the trivariate normal distribution function.  <var>std_dev</var> is
either a vector of 3 elements representing the standard deviation of the
Gaussian convolution kernel in x-, y- and z-directions or a scalar, in which
case the same value is used in all three dimensions.  The default value is
0.65.
</p>

<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFreducevolume"></a><dl>
<dt><a name="index-reducevolume"></a><em>[<var>nx</var>, <var>ny</var>, <var>nz</var>, <var>nv</var>] =</em> <strong>reducevolume</strong> <em>(<var>v</var>, <var>r</var>)</em></dt>
<dt><a name="index-reducevolume-1"></a><em>[<var>nx</var>, <var>ny</var>, <var>nz</var>, <var>nv</var>] =</em> <strong>reducevolume</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>r</var>)</em></dt>
<dt><a name="index-reducevolume-2"></a><em><var>nv</var> =</em> <strong>reducevolume</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Reduce the volume of the dataset in <var>v</var> according to the values in
<var>r</var>.
</p>
<p><var>v</var> is a matrix that is non-singleton in the first 3 dimensions.
</p>
<p><var>r</var> can either be a vector of 3 elements representing the reduction
factors in the x-, y-, and z-directions or a scalar, in which case the same
reduction factor is used in all three dimensions.
</p>
<p><code>reducevolume</code> reduces the number of elements of <var>v</var> by taking
only every <var>r</var>-th element in the respective dimension.
</p>
<p>Optionally, <var>x</var>, <var>y</var>, and <var>z</var> can be supplied to represent the
set of coordinates of <var>v</var>.  They can either be matrices of the same size
as <var>v</var> or vectors with sizes according to the dimensions of <var>v</var>, in
which case they are expanded to matrices (see <a href="#XREFmeshgrid">meshgrid</a>).
</p>
<p>If <code>reducevolume</code> is called with two arguments then <var>x</var>, <var>y</var>,
and <var>z</var> are assumed to match the respective indices of <var>v</var>.
</p>
<p>The reduced matrix is returned in <var>nv</var>.
</p>
<p>Optionally, the reduced set of coordinates are returned in <var>nx</var>,
<var>ny</var>, and <var>nz</var>, respectively.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example"><var>v</var> = reshape (1:6*8*4, [6 8 4]);
<var>nv</var> = reducevolume (<var>v</var>, [4 3 2]);
</pre></div>

<div class="example">
<pre class="example"><var>v</var> = reshape (1:6*8*4, [6 8 4]);
<var>x</var> = 1:3:24;  <var>y</var> = -14:5:11;  <var>z</var> = linspace (16, 18, 4);
[<var>nx</var>, <var>ny</var>, <var>nz</var>, <var>nv</var>] = reducevolume (<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, [4 3 2]);
</pre></div>


<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>.
</p></dd></dl>


<a name="XREFreducepatch"></a><dl>
<dt><a name="index-reducepatch"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(<var>fv</var>)</em></dt>
<dt><a name="index-reducepatch-1"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(<var>faces</var>, <var>vertices</var>)</em></dt>
<dt><a name="index-reducepatch-2"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(<var>patch_handle</var>)</em></dt>
<dt><a name="index-reducepatch-3"></a><em></em> <strong>reducepatch</strong> <em>(<var>patch_handle</var>)</em></dt>
<dt><a name="index-reducepatch-4"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(&hellip;, <var>reduction_factor</var>)</em></dt>
<dt><a name="index-reducepatch-5"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(&hellip;, &quot;fast&quot;)</em></dt>
<dt><a name="index-reducepatch-6"></a><em><var>reduced_fv</var> =</em> <strong>reducepatch</strong> <em>(&hellip;, &quot;verbose&quot;)</em></dt>
<dt><a name="index-reducepatch-7"></a><em>[<var>reduced_faces</var>, <var>reduces_vertices</var>] =</em> <strong>reducepatch</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Reduce the number of faces and vertices in a patch object while retaining
the overall shape of the patch.
</p>
<p>The input patch can be represented by a structure <var>fv</var> with the
fields <code>faces</code> and <code>vertices</code>, by two matrices <var>faces</var> and
<var>vertices</var> (see, e.g., the result of <code>isosurface</code>), or by a
handle to a patch object <var>patch_handle</var> (see <a href="Graphics-Objects.html#XREFpatch">patch</a>).
</p>
<p>The number of faces and vertices in the patch is reduced by iteratively
collapsing the shortest edge of the patch to its midpoint (as discussed,
e.g., here:
<a href="https://libigl.github.io/libigl/tutorial/tutorial.html#meshdecimation">https://libigl.github.io/libigl/tutorial/tutorial.html#meshdecimation</a>).
</p>
<p>Currently, only patches consisting of triangles are supported.  The
resulting patch also consists only of triangles.
</p>
<p>If <code>reducepatch</code> is called with a handle to a valid patch
<var>patch_handle</var>, and without any output arguments, then the given
patch is updated immediately.
</p>
<p>If the <var>reduction_factor</var> is omitted, the resulting structure
<var>reduced_fv</var> includes approximately 50% of the faces of the original
patch.  If <var>reduction_factor</var> is a fraction between 0 (excluded) and 1
(excluded), a patch with approximately the corresponding fraction of faces
is determined.
If <var>reduction_factor</var> is an integer greater than or equal to 1, the
resulting patch has approximately <var>reduction_factor</var> faces.  Depending
on the geometry of the patch, the resulting number of faces can differ from
the given value of <var>reduction_factor</var>.  This is especially true when
many shared vertices are detected.
</p>
<p>For the reduction, it is necessary that vertices of touching faces are
shared.  Shared vertices are detected automatically.  This detection can be
skipped by passing the optional string argument <code>&quot;fast&quot;</code>.
</p>
<p>With the optional string arguments <code>&quot;verbose&quot;</code>, additional status
messages are printed to the command window.
</p>
<p>Any string input arguments must be passed after all other arguments.
</p>
<p>If called with one output argument, the reduced faces and vertices are
returned in a structure <var>reduced_fv</var> with the fields <code>faces</code> and
<code>vertices</code> (see the one output option of <code>isosurface</code>).
</p>
<p>If called with two output arguments, the reduced faces and vertices are
returned in two separate matrices <var>reduced_faces</var> and
<var>reduced_vertices</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>, <a href="#XREFreducevolume">reducevolume</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFshrinkfaces"></a><dl>
<dt><a name="index-shrinkfaces"></a><em></em> <strong>shrinkfaces</strong> <em>(<var>p</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-1"></a><em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>p</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-2"></a><em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>fv</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-3"></a><em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>f</var>, <var>v</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-4"></a><em>[<var>nf</var>, <var>nv</var>] =</em> <strong>shrinkfaces</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Reduce the size of faces in a patch by the shrink factor <var>sf</var>.
</p>
<p>The patch object can be specified by a graphics handle (<var>p</var>), a patch
structure (<var>fv</var>) with the fields <code>&quot;faces&quot;</code> and <code>&quot;vertices&quot;</code>,
or as two separate matrices (<var>f</var>, <var>v</var>) of faces and vertices.
</p>
<p>The shrink factor <var>sf</var> is a positive number specifying the percentage
of the original area the new face will occupy.  If no factor is given the
default is 0.3 (a reduction to 30% of the original size).  A factor greater
than 1.0 will result in the expansion of faces.
</p>
<p>Given a patch handle as the first input argument and no output parameters,
perform the shrinking of the patch faces in place and redraw the patch.
</p>
<p>If called with one output argument, return a structure with fields
<code>&quot;faces&quot;</code>, <code>&quot;vertices&quot;</code>, and <code>&quot;facevertexcdata&quot;</code>
containing the data after shrinking.  This structure can be used directly
as an input argument to the <code>patch</code> function.
</p>
<p><strong>Caution:</strong>: Performing the shrink operation on faces which are not
convex can lead to undesirable results.
</p>
<p>Example: a triangulated 3/4 circle and the corresponding shrunken version.
</p>
<div class="example">
<pre class="example">[phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
tri = delaunay (phi(:), r(:));
v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
clf ()
p = patch (&quot;Faces&quot;, tri, &quot;Vertices&quot;, v, &quot;FaceColor&quot;, &quot;none&quot;);
fv = shrinkfaces (p);
patch (fv)
axis equal
grid on
</pre></div>


<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFdiffuse"></a><dl>
<dt><a name="index-diffuse"></a><em></em> <strong>diffuse</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>)</em></dt>
<dd><p>Calculate the diffuse reflection strength of a surface defined by the normal
vector elements <var>sx</var>, <var>sy</var>, <var>sz</var>.
</p>
<p>The light source location vector <var>lv</var> can be given as a 2-element vector
[azimuth, elevation] in degrees or as a 3-element vector [x, y, z].
</p>
<p><strong>See also:</strong> <a href="#XREFspecular">specular</a>, <a href="#XREFsurfl">surfl</a>.
</p></dd></dl>


<a name="XREFspecular"></a><dl>
<dt><a name="index-specular"></a><em></em> <strong>specular</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>, <var>vv</var>)</em></dt>
<dt><a name="index-specular-1"></a><em></em> <strong>specular</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>, <var>vv</var>, <var>se</var>)</em></dt>
<dd><p>Calculate the specular reflection strength of a surface defined by the
normal vector elements <var>sx</var>, <var>sy</var>, <var>sz</var> using Phong&rsquo;s
approximation.
</p>
<p>The light source location and viewer location vectors are specified using
parameters <var>lv</var> and <var>vv</var> respectively.  The location vectors can
given as 2-element vectors [azimuth, elevation] in degrees or as 3-element
vectors [x, y, z].
</p>
<p>An optional sixth argument specifies the specular exponent (spread)
<var>se</var>.  If not given, <var>se</var> defaults to 10.
</p>
<p><strong>See also:</strong> <a href="#XREFdiffuse">diffuse</a>, <a href="#XREFsurfl">surfl</a>.
</p></dd></dl>


<a name="XREFlighting"></a><dl>
<dt><a name="index-lighting"></a><em></em> <strong>lighting</strong> <em>(<var>type</var>)</em></dt>
<dt><a name="index-lighting-1"></a><em></em> <strong>lighting</strong> <em>(<var>hax</var>, <var>type</var>)</em></dt>
<dd><p>Set the lighting of patch or surface graphic objects.
</p>
<p>Valid arguments for <var>type</var> are
</p>
<dl compact="compact">
<dt><code>&quot;flat&quot;</code></dt>
<dd><p>Draw objects with faceted lighting effects.
</p>
</dd>
<dt><code>&quot;gouraud&quot;</code></dt>
<dd><p>Draw objects with linear interpolation of the lighting effects between the
vertices.
</p>
</dd>
<dt><code>&quot;none&quot;</code></dt>
<dd><p>Draw objects without light and shadow effects.
</p></dd>
</dl>

<p>If the first argument <var>hax</var> is an axes handle, then change the lighting
effects of objects in this axes, rather than the current axes returned by
<code>gca</code>.
</p>
<p>The lighting effects are only visible if at least one light object is
present and visible in the same axes.
</p>

<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFlight">light</a>, <a href="Two_002dDimensional-Plots.html#XREFfill">fill</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFshading">shading</a>.
</p></dd></dl>


<a name="XREFmaterial"></a><dl>
<dt><a name="index-material"></a><em></em> <strong>material</strong> <em>shiny</em></dt>
<dt><a name="index-material-1"></a><em></em> <strong>material</strong> <em>dull</em></dt>
<dt><a name="index-material-2"></a><em></em> <strong>material</strong> <em>metal</em></dt>
<dt><a name="index-material-3"></a><em></em> <strong>material</strong> <em>default</em></dt>
<dt><a name="index-material-4"></a><em></em> <strong>material</strong> <em>([<var>as</var>, <var>ds</var>, <var>ss</var>])</em></dt>
<dt><a name="index-material-5"></a><em></em> <strong>material</strong> <em>([<var>as</var>, <var>ds</var>, <var>ss</var>, <var>se</var>])</em></dt>
<dt><a name="index-material-6"></a><em></em> <strong>material</strong> <em>([<var>as</var>, <var>ds</var>, <var>ss</var>, <var>se</var>, <var>scr</var>])</em></dt>
<dt><a name="index-material-7"></a><em></em> <strong>material</strong> <em>(<var>hlist</var>, &hellip;)</em></dt>
<dt><a name="index-material-8"></a><em><var>mtypes</var> =</em> <strong>material</strong> <em>()</em></dt>
<dt><a name="index-material-9"></a><em><var>refl_props</var> =</em> <strong>material</strong> <em>(<var>mtype_string</var>)</em></dt>
<dd><p>Set reflectance properties for the lighting of surfaces and patches.
</p>
<p>This function changes the ambient, diffuse, and specular strengths, as well
as the specular exponent and specular color reflectance, of all
<code>patch</code> and <code>surface</code> objects in the current axes.  This can be
used to simulate, to some extent, the reflectance properties of certain
materials when used with <code>light</code>.
</p>
<p>When called with a string, the aforementioned properties are set
according to the values in the following table:
</p>
<table>
<thead><tr><th width="0%"></th><th width="20%"><var>mtype</var></th><th width="15%">ambient- strength</th><th width="15%">diffuse-
strength</th><th width="15%">specular- strength</th><th width="15%">specular- exponent</th><th width="15%">specular-
color- reflectance</th><th width="0%"></th></tr></thead>
<tr><td width="0%"></td><td width="20%"><code>&quot;shiny&quot;</code></td><td width="15%">0.3</td><td width="15%">0.6</td><td width="15%">0.9</td><td width="15%">20</td><td width="15%">1.0</td><td width="0%"></td></tr>
<tr><td width="0%"></td><td width="20%"><code>&quot;dull&quot;</code></td><td width="15%">0.3</td><td width="15%">0.8</td><td width="15%">0.0</td><td width="15%">10</td><td width="15%">1.0</td><td width="0%"></td></tr>
<tr><td width="0%"></td><td width="20%"><code>&quot;metal&quot;</code></td><td width="15%">0.3</td><td width="15%">0.3</td><td width="15%">1.0</td><td width="15%">25</td><td width="15%">0.5</td><td width="0%"></td></tr>
<tr><td width="0%"></td><td width="20%"><code>&quot;default&quot;</code></td><td width="15%"><code>&quot;default&quot;</code></td><td width="15%"><code>&quot;default&quot;</code></td><td width="15%"><code>&quot;default&quot;</code></td><td width="15%"><code>&quot;default&quot;</code></td><td width="15%"><code>&quot;default&quot;</code></td><td width="0%"></td></tr>
</table>

<p>When called with a vector of three elements, the ambient, diffuse, and
specular strengths of all <code>patch</code> and <code>surface</code> objects in the
current axes are updated.  An optional fourth vector element updates the
specular exponent, and an optional fifth vector element updates the
specular color reflectance.
</p>
<p>A list of graphic handles can also be passed as the first argument.  In
this case, the properties of these handles and all child <code>patch</code> and
<code>surface</code> objects will be updated.
</p>
<p>Additionally, <code>material</code> can be called with a single output argument.
If called without input arguments, a column cell vector <var>mtypes</var> with
the strings for all available materials is returned.  If the one input
argument <var>mtype_string</var> is the name of a material, a 1x5 cell vector
<var>refl_props</var> with the reflectance properties of that material is
returned.  In both cases, no graphic properties are changed.
</p>

<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFlight">light</a>, <a href="Two_002dDimensional-Plots.html#XREFfill">fill</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>.
</p></dd></dl>


<a name="XREFcamlight"></a><dl>
<dt><a name="index-camlight"></a><em></em> <strong>camlight</strong> <em></em></dt>
<dt><a name="index-camlight-1"></a><em></em> <strong>camlight</strong> <em>right</em></dt>
<dt><a name="index-camlight-2"></a><em></em> <strong>camlight</strong> <em>left</em></dt>
<dt><a name="index-camlight-3"></a><em></em> <strong>camlight</strong> <em>headlight</em></dt>
<dt><a name="index-camlight-4"></a><em></em> <strong>camlight</strong> <em>(<var>az</var>, <var>el</var>)</em></dt>
<dt><a name="index-camlight-5"></a><em></em> <strong>camlight</strong> <em>(&hellip;, <var>style</var>)</em></dt>
<dt><a name="index-camlight-6"></a><em></em> <strong>camlight</strong> <em>(<var>hl</var>, &hellip;)</em></dt>
<dt><a name="index-camlight-7"></a><em><var>h</var> =</em> <strong>camlight</strong> <em>(&hellip;)</em></dt>
<dd><p>Add a light object to a figure using a simple interface.
</p>
<p>When called with no arguments, a light object is added to the current plot
and is placed slightly above and to the right of the camera&rsquo;s current
position: this is equivalent to <code>camlight right</code>.  The commands
<code>camlight left</code> and <code>camlight headlight</code> behave similarly with
the placement being either left of the camera position or centered on the
camera position.
</p>
<p>For more control, the light position can be specified by an azimuthal
rotation <var>az</var> and an elevation angle <var>el</var>, both in degrees,
relative to the current properties of the camera.
</p>
<p>The optional string <var>style</var> specifies whether the light is a local point
source (<code>&quot;local&quot;</code>, the default) or placed at infinite distance
(<code>&quot;infinite&quot;</code>).
</p>
<p>If the first argument <var>hl</var> is a handle to a light object, then act on
this light object rather than creating a new object.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the light object.
This can be used to move or further change properties of the light object.
</p>
<p>Examples:
</p>
<p>Add a light object to a plot
</p>
<div class="example">
<pre class="example">sphere (36);
camlight
</pre></div>

<p>Position the light source exactly
</p>
<div class="example">
<pre class="example">camlight (45, 30);
</pre></div>

<p>Here the light is first pitched upwards (see <a href="#XREFcamup">camup</a>) from the
camera position (see <a href="#XREFcampos">campos</a>) by 30 degrees.  It is then
yawed by 45 degrees to the right.  Both rotations are centered around the
camera target (see <a href="#XREFcamtarget">camtarget</a>).
</p>
<p>Return a handle to further manipulate the light object
</p>
<div class="example">
<pre class="example">clf
sphere (36);
hl = camlight (&quot;left&quot;);
set (hl, &quot;color&quot;, &quot;r&quot;);
</pre></div>


<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFlight">light</a>.
</p></dd></dl>


<a name="XREFmeshgrid"></a><dl>
<dt><a name="index-meshgrid"></a><em>[<var>xx</var>, <var>yy</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>, <var>y</var>)</em></dt>
<dt><a name="index-meshgrid-1"></a><em>[<var>xx</var>, <var>yy</var>, <var>zz</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshgrid-2"></a><em>[<var>xx</var>, <var>yy</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>)</em></dt>
<dt><a name="index-meshgrid-3"></a><em>[<var>xx</var>, <var>yy</var>, <var>zz</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Given vectors of <var>x</var> and <var>y</var> coordinates, return matrices <var>xx</var>
and <var>yy</var> corresponding to a full 2-D grid.
</p>
<p>The rows of <var>xx</var> are copies of <var>x</var>, and the columns of <var>yy</var> are
copies of <var>y</var>.  If <var>y</var> is omitted, then it is assumed to be the same
as <var>x</var>.
</p>
<p>If the optional <var>z</var> input is given, or <var>zz</var> is requested, then the
output will be a full 3-D grid.  If <var>z</var> is omitted and <var>zz</var> is
requested, it is assumed to be the same as <var>y</var>.
</p>
<p><code>meshgrid</code> is most frequently used to produce input for a 2-D or 3-D
function that will be plotted.  The following example creates a surface
plot of the &ldquo;sombrero&rdquo; function.
</p>
<div class="example">
<pre class="example">f = @(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
range = linspace (-8, 8, 41);
[<var>X</var>, <var>Y</var>] = meshgrid (range, range);
Z = f (X, Y);
surf (X, Y, Z);
</pre></div>

<p>Programming Note: <code>meshgrid</code> is restricted to 2-D or 3-D grid
generation.  The <code>ndgrid</code> function will generate 1-D through N-D
grids.  However, the functions are not completely equivalent.  If <var>x</var>
is a vector of length M and <var>y</var> is a vector of length N, then
<code>meshgrid</code> will produce an output grid which is NxM.  <code>ndgrid</code>
will produce an output which is MxN (transpose) for the same
input.  Some core functions expect <code>meshgrid</code> input and others expect
<code>ndgrid</code> input.  Check the documentation for the function in question
to determine the proper input format.
</p>
<p><strong>See also:</strong> <a href="#XREFndgrid">ndgrid</a>, <a href="#XREFmesh">mesh</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>.
</p></dd></dl>


<a name="XREFndgrid"></a><dl>
<dt><a name="index-ndgrid"></a><em>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] =</em> <strong>ndgrid</strong> <em>(<var>x1</var>, <var>x2</var>, &hellip;, <var>x</var>n)</em></dt>
<dt><a name="index-ndgrid-1"></a><em>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] =</em> <strong>ndgrid</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Given n vectors <var>x1</var>, &hellip;, <var>x</var>n, <code>ndgrid</code> returns n
arrays of dimension n.
</p>
<p>The elements of the i-th output argument contains the elements of the
vector <var>x</var>i repeated over all dimensions different from the i-th
dimension.  Calling ndgrid with only one input argument <var>x</var> is
equivalent to calling ndgrid with all n input arguments equal to <var>x</var>:
</p>
<p>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] = ndgrid (<var>x</var>, &hellip;, <var>x</var>)
</p>
<p>Programming Note: <code>ndgrid</code> is very similar to the function
<code>meshgrid</code> except that the first two dimensions are transposed in
comparison to <code>meshgrid</code>.  Some core functions expect <code>meshgrid</code>
input and others expect <code>ndgrid</code> input.  Check the documentation for
the function in question to determine the proper input format.
</p>
<p><strong>See also:</strong> <a href="#XREFmeshgrid">meshgrid</a>.
</p></dd></dl>


<a name="XREFplot3"></a><dl>
<dt><a name="index-plot3"></a><em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-plot3-1"></a><em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>prop</var>, <var>value</var>, &hellip;)</em></dt>
<dt><a name="index-plot3-2"></a><em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>fmt</var>)</em></dt>
<dt><a name="index-plot3-3"></a><em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>cplx</var>)</em></dt>
<dt><a name="index-plot3-4"></a><em></em> <strong>plot3</strong> <em>(<var>cplx</var>)</em></dt>
<dt><a name="index-plot3-5"></a><em></em> <strong>plot3</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-plot3-6"></a><em><var>h</var> =</em> <strong>plot3</strong> <em>(&hellip;)</em></dt>
<dd><p>Produce 3-D plots.
</p>
<p>Many different combinations of arguments are possible.  The simplest
form is
</p>
<div class="example">
<pre class="example">plot3 (<var>x</var>, <var>y</var>, <var>z</var>)
</pre></div>

<p>in which the arguments are taken to be the vertices of the points to
be plotted in three dimensions.  If all arguments are vectors of the
same length, then a single continuous line is drawn.  If all arguments
are matrices, then each column of is treated as a separate line.  No attempt
is made to transpose the arguments to make the number of rows match.
</p>
<p>If only two arguments are given, as
</p>
<div class="example">
<pre class="example">plot3 (<var>x</var>, <var>cplx</var>)
</pre></div>

<p>the real and imaginary parts of the second argument are used
as the <var>y</var> and <var>z</var> coordinates, respectively.
</p>
<p>If only one argument is given, as
</p>
<div class="example">
<pre class="example">plot3 (<var>cplx</var>)
</pre></div>

<p>the real and imaginary parts of the argument are used as the <var>y</var>
and <var>z</var> values, and they are plotted versus their index.
</p>
<p>Arguments may also be given in groups of three as
</p>
<div class="example">
<pre class="example">plot3 (<var>x1</var>, <var>y1</var>, <var>z1</var>, <var>x2</var>, <var>y2</var>, <var>z2</var>, &hellip;)
</pre></div>

<p>in which each set of three arguments is treated as a separate line or
set of lines in three dimensions.
</p>
<p>To plot multiple one- or two-argument groups, separate each group
with an empty format string, as
</p>
<div class="example">
<pre class="example">plot3 (<var>x1</var>, <var>c1</var>, &quot;&quot;, <var>c2</var>, &quot;&quot;, &hellip;)
</pre></div>

<p>Multiple property-value pairs may be specified which will affect the line
objects drawn by <code>plot3</code>.  If the <var>fmt</var> argument is supplied it
will format the line objects in the same manner as <code>plot</code>.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created plot.
</p>
<p>Example:
</p>
<div class="example">
<pre class="example">z = [0:0.05:5];
plot3 (cos (2*pi*z), sin (2*pi*z), z, &quot;;helix;&quot;);
plot3 (z, exp (2i*pi*z), &quot;;complex sinusoid;&quot;);
</pre></div>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezplot3">ezplot3</a>, <a href="Two_002dDimensional-Plots.html#XREFplot">plot</a>.
</p></dd></dl>


<a name="XREFview"></a><dl>
<dt><a name="index-view"></a><em></em> <strong>view</strong> <em>(<var>azimuth</var>, <var>elevation</var>)</em></dt>
<dt><a name="index-view-1"></a><em></em> <strong>view</strong> <em>([<var>azimuth</var> <var>elevation</var>])</em></dt>
<dt><a name="index-view-2"></a><em></em> <strong>view</strong> <em>([<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-view-3"></a><em></em> <strong>view</strong> <em>(2)</em></dt>
<dt><a name="index-view-4"></a><em></em> <strong>view</strong> <em>(3)</em></dt>
<dt><a name="index-view-5"></a><em></em> <strong>view</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-view-6"></a><em>[<var>azimuth</var>, <var>elevation</var>] =</em> <strong>view</strong> <em>()</em></dt>
<dd><p>Query or set the viewpoint for the current axes.
</p>
<p>The parameters <var>azimuth</var> and <var>elevation</var> can be given as two
arguments or as 2-element vector.  The viewpoint can also be specified with
Cartesian coordinates <var>x</var>, <var>y</var>, and <var>z</var>.
</p>
<p>The call <code>view (2)</code> sets the viewpoint to <var>azimuth</var>&nbsp;=&nbsp;0<!-- /@w -->
and <var>elevation</var>&nbsp;=&nbsp;90<!-- /@w -->, which is the default for 2-D graphs.
</p>
<p>The call <code>view (3)</code> sets the viewpoint to <var>azimuth</var>&nbsp;=&nbsp;<span class="nolinebreak">-37.5</span><!-- /@w -->
and <var>elevation</var>&nbsp;=&nbsp;30<!-- /@w -->, which is the default for 3-D graphs.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then operate on
this axes rather than the current axes returned by <code>gca</code>.
</p>
<p>If no inputs are given, return the current <var>azimuth</var> and
<var>elevation</var>.
</p></dd></dl>


<a name="XREFcamlookat"></a><dl>
<dt><a name="index-camlookat"></a><em></em> <strong>camlookat</strong> <em>()</em></dt>
<dt><a name="index-camlookat-1"></a><em></em> <strong>camlookat</strong> <em>(<var>h</var>)</em></dt>
<dt><a name="index-camlookat-2"></a><em></em> <strong>camlookat</strong> <em>(<var>handle_list</var>)</em></dt>
<dt><a name="index-camlookat-3"></a><em></em> <strong>camlookat</strong> <em>(<var>hax</var>)</em></dt>
<dd><p>Move the camera and adjust its properties to look at objects.
</p>
<p>When the input is a handle <var>h</var>, the camera is set to point toward the
center of the bounding box of <var>h</var>.  The camera&rsquo;s position is adjusted so
the bounding box approximately fills the field of view.
</p>
<p>This command fixes the camera&rsquo;s viewing direction
(<code>camtarget() - campos()</code>), camera up vector (see <a href="#XREFcamup">camup</a>)
and viewing angle (see <a href="#XREFcamva">camva</a>).  The camera target
(see <a href="#XREFcamtarget">camtarget</a>) and camera position
(see <a href="#XREFcampos">campos</a>) are changed.
</p>

<p>If the argument is a list <var>handle_list</var>, then a single bounding box for
all the objects is computed and the camera is then adjusted as above.
</p>
<p>If the argument is an axis object <var>hax</var>, then the children of the axis
are used as <var>handle_list</var>.  When called with no inputs, it uses the
current axis (see <a href="Graphics-Objects.html#XREFgca">gca</a>).
</p>

<p><strong>See also:</strong> <a href="#XREFcamorbit">camorbit</a>, <a href="#XREFcamzoom">camzoom</a>, <a href="#XREFcamroll">camroll</a>.
</p></dd></dl>


<a name="XREFcampos"></a><dl>
<dt><a name="index-campos"></a><em><var>P</var> =</em> <strong>campos</strong> <em>()</em></dt>
<dt><a name="index-campos-1"></a><em></em> <strong>campos</strong> <em>([<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-campos-2"></a><em><var>mode</var> =</em> <strong>campos</strong> <em>(&quot;mode&quot;)</em></dt>
<dt><a name="index-campos-3"></a><em></em> <strong>campos</strong> <em>(<var>mode</var>)</em></dt>
<dt><a name="index-campos-4"></a><em></em> <strong>campos</strong> <em>(<var>ax</var>, &hellip;)</em></dt>
<dd><p>Set or get the camera position.
</p>
<p>The default camera position is determined automatically based on the scene.
For example, to get the camera position:
</p>
<div class="example">
<pre class="example">hf = figure();
peaks()
p = campos ()
  &rArr; p =
      -27.394  -35.701   64.079
</pre></div>

<p>We can then move the camera further up the z-axis:
</p>
<div class="example">
<pre class="example">campos (p + [0 0 10])
campos ()
  &rArr; ans =
      -27.394  -35.701   74.079
</pre></div>

<p>Having made that change, the camera position <var>mode</var> is now manual:
</p>
<div class="example">
<pre class="example">campos (&quot;mode&quot;)
  &rArr; manual
</pre></div>

<p>We can set it back to automatic:
</p>
<div class="example">
<pre class="example">campos (&quot;auto&quot;)
campos ()
  &rArr; ans =
      -27.394  -35.701   64.079
close (hf)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcamup">camup</a>, <a href="#XREFcamtarget">camtarget</a>, <a href="#XREFcamva">camva</a>.
</p></dd></dl>


<a name="XREFcamorbit"></a><dl>
<dt><a name="index-camorbit"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>)</em></dt>
<dt><a name="index-camorbit-1"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, <var>coorsys</var>)</em></dt>
<dt><a name="index-camorbit-2"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, <var>coorsys</var>, <var>dir</var>)</em></dt>
<dt><a name="index-camorbit-3"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;data&quot;)</em></dt>
<dt><a name="index-camorbit-4"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;data&quot;, &quot;z&quot;)</em></dt>
<dt><a name="index-camorbit-5"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;data&quot;, &quot;x&quot;)</em></dt>
<dt><a name="index-camorbit-6"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;data&quot;, &quot;y&quot;)</em></dt>
<dt><a name="index-camorbit-7"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;data&quot;, [<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-camorbit-8"></a><em></em> <strong>camorbit</strong> <em>(<var>theta</var>, <var>phi</var>, &quot;camera&quot;)</em></dt>
<dt><a name="index-camorbit-9"></a><em></em> <strong>camorbit</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dd><p>Rotate the camera up/down and left/right around its target.
</p>
<p>Move the camera <var>phi</var> degrees up and <var>theta</var> degrees to the right,
as if it were in an orbit around its target.
Example:
</p>
<div class="example">
<pre class="example">sphere ()
camorbit (30, 20)
</pre></div>

<p>These rotations are centered around the camera target
(see <a href="#XREFcamtarget">camtarget</a>).
First the camera position is pitched up or down by rotating it <var>phi</var>
degrees around an axis orthogonal to both the viewing direction
(specifically <code>camtarget() - campos()</code>) and the camera &ldquo;up vector&rdquo;
(see <a href="#XREFcamup">camup</a>).
Example:
</p>
<div class="example">
<pre class="example">camorbit (0, 20)
</pre></div>

<p>The second rotation depends on the coordinate system <var>coorsys</var> and
direction <var>dir</var> inputs.
The default for <var>coorsys</var> is <code>&quot;data&quot;</code>.  In this case, the camera
is yawed left or right by rotating it <var>theta</var> degrees around an axis
specified by <var>dir</var>.
The default for <var>dir</var> is <code>&quot;z&quot;</code>, corresponding to the vector
<code>[0, 0, 1]</code>.
Example:
</p>
<div class="example">
<pre class="example">camorbit (30, 0)
</pre></div>

<p>When <var>coorsys</var> is set to <code>&quot;camera&quot;</code>, the camera is moved left or
right by rotating it around an axis parallel to the camera up vector
(see <a href="#XREFcamup">camup</a>).
The input <var>dir</var> should not be specified in this case.
Example:
</p>
<div class="example">
<pre class="example">camorbit (30, 0, &quot;camera&quot;)
</pre></div>

<p>(Note: the rotation by <var>phi</var> is unaffected by <code>&quot;camera&quot;</code>.)
</p>
<p>The <code>camorbit</code> command modifies two camera properties:
see <a href="#XREFcampos">campos</a> and see <a href="#XREFcamup">camup</a>.
</p>
<p>By default, this command affects the current axis; alternatively, an axis
can be specified by the optional argument <var>hax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcamzoom">camzoom</a>, <a href="#XREFcamroll">camroll</a>, <a href="#XREFcamlookat">camlookat</a>.
</p></dd></dl>


<a name="XREFcamroll"></a><dl>
<dt><a name="index-camroll"></a><em></em> <strong>camroll</strong> <em>(<var>theta</var>)</em></dt>
<dt><a name="index-camroll-1"></a><em></em> <strong>camroll</strong> <em>(<var>ax</var>, <var>theta</var>)</em></dt>
<dd><p>Roll the camera.
</p>
<p>Roll the camera clockwise by <var>theta</var> degrees.
For example, the following command will roll the camera by
30 degrees clockwise (to the right); this will cause the scene
to appear to roll by 30 degrees to the left:
</p>
<div class="example">
<pre class="example">peaks ()
camroll (30)
</pre></div>

<p>Roll the camera back:
</p>
<div class="example">
<pre class="example">camroll (-30)
</pre></div>

<p>The following command restores the default camera roll:
</p>
<div class="example">
<pre class="example">camup (&quot;auto&quot;)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcamzoom">camzoom</a>, <a href="#XREFcamorbit">camorbit</a>, <a href="#XREFcamlookat">camlookat</a>, <a href="#XREFcamup">camup</a>.
</p></dd></dl>


<a name="XREFcamtarget"></a><dl>
<dt><a name="index-camtarget"></a><em><var>T</var> =</em> <strong>camtarget</strong> <em>()</em></dt>
<dt><a name="index-camtarget-1"></a><em></em> <strong>camtarget</strong> <em>([<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-camtarget-2"></a><em><var>mode</var> =</em> <strong>camtarget</strong> <em>(&quot;mode&quot;)</em></dt>
<dt><a name="index-camtarget-3"></a><em></em> <strong>camtarget</strong> <em>(<var>mode</var>)</em></dt>
<dt><a name="index-camtarget-4"></a><em></em> <strong>camtarget</strong> <em>(<var>ax</var>, &hellip;)</em></dt>
<dd><p>Set or get where the camera is pointed.
</p>
<p>The camera target is a point in space where the camera is pointing.
Usually, it is determined automatically based on the scene:
</p>
<div class="example">
<pre class="example">hf = figure();
sphere (36)
v = camtarget ()
  &rArr; v =
      0   0   0
</pre></div>

<p>We can turn the camera to point at a new target:
</p>
<div class="example">
<pre class="example">camtarget ([1 1 1])
camtarget ()
  &rArr;   1   1   1
</pre></div>

<p>Having done so, the camera target <var>mode</var> is manual:
</p>
<div class="example">
<pre class="example">camtarget (&quot;mode&quot;)
  &rArr; manual
</pre></div>

<p>This means, for example, adding new objects to the scene will not retarget
the camera:
</p>
<div class="example">
<pre class="example">hold on;
peaks ()
camtarget ()
  &rArr;   1   1   1
</pre></div>

<p>We can reset it to be automatic:
</p>
<div class="example">
<pre class="example">camtarget (&quot;auto&quot;)
camtarget ()
  &rArr;   0   0   0.76426
close (hf)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcampos">campos</a>, <a href="#XREFcamup">camup</a>, <a href="#XREFcamva">camva</a>.
</p></dd></dl>


<a name="XREFcamup"></a><dl>
<dt><a name="index-camup"></a><em><var>up</var> =</em> <strong>camup</strong> <em>()</em></dt>
<dt><a name="index-camup-1"></a><em></em> <strong>camup</strong> <em>([<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-camup-2"></a><em><var>mode</var> =</em> <strong>camup</strong> <em>(&quot;mode&quot;)</em></dt>
<dt><a name="index-camup-3"></a><em></em> <strong>camup</strong> <em>(<var>mode</var>)</em></dt>
<dt><a name="index-camup-4"></a><em></em> <strong>camup</strong> <em>(<var>ax</var>, &hellip;)</em></dt>
<dd><p>Set or get the camera up vector.
</p>
<p>By default, the camera is oriented so that &ldquo;up&rdquo; corresponds to the
positive z-axis:
</p>
<div class="example">
<pre class="example">hf = figure ();
sphere (36)
v = camup ()
  &rArr; v =
      0   0   1
</pre></div>

<p>Specifying a new &ldquo;up vector&rdquo; rolls the camera and sets the mode to manual:
</p>
<div class="example">
<pre class="example">camup ([1 1 0])
camup ()
  &rArr;   1   1   0
camup (&quot;mode&quot;)
  &rArr; manual
</pre></div>

<p>Modifying the up vector does not modify the camera target
(see <a href="#XREFcamtarget">camtarget</a>).  Thus, the camera up vector might not be
orthogonal to the direction of the camera&rsquo;s view:
</p>
<div class="example">
<pre class="example">camup ([1 2 3])
dot (camup (), camtarget () - campos ())
  &rArr; 6...
</pre></div>

<p>A consequence is that &ldquo;pulling back&rdquo; on the up vector does not pitch the
camera view (as that would require changing the target).  Setting the up
vector is thus typically used only to roll the camera.  A more intuitive
command for this purpose is see <a href="#XREFcamroll">camroll</a>.
</p>
<p>Finally, we can reset the up vector to automatic mode:
</p>
<div class="example">
<pre class="example">camup (&quot;auto&quot;)
camup ()
  &rArr;   0   0   1
close (hf)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcampos">campos</a>, <a href="#XREFcamtarget">camtarget</a>, <a href="#XREFcamva">camva</a>.
</p></dd></dl>


<a name="XREFcamva"></a><dl>
<dt><a name="index-camva"></a><em><var>a</var> =</em> <strong>camva</strong> <em>()</em></dt>
<dt><a name="index-camva-1"></a><em></em> <strong>camva</strong> <em>(<var>a</var>)</em></dt>
<dt><a name="index-camva-2"></a><em><var>mode</var> =</em> <strong>camva</strong> <em>(&quot;mode&quot;)</em></dt>
<dt><a name="index-camva-3"></a><em></em> <strong>camva</strong> <em>(<var>mode</var>)</em></dt>
<dt><a name="index-camva-4"></a><em></em> <strong>camva</strong> <em>(<var>ax</var>, &hellip;)</em></dt>
<dd><p>Set or get the camera viewing angle.
</p>
<p>The camera has a viewing angle which determines how much can be seen.  By
default this is:
</p>
<div class="example">
<pre class="example">hf = figure();
sphere (36)
a = camva ()
  &rArr; a =  10.340
</pre></div>

<p>To get a wider-angle view, we could double the viewing angle.  This will
also set the mode to manual:
</p>
<div class="example">
<pre class="example">camva (2*a)
camva (&quot;mode&quot;)
  &rArr; manual
</pre></div>

<p>We can set it back to automatic:
</p>
<div class="example">
<pre class="example">camva (&quot;auto&quot;)
camva (&quot;mode&quot;)
  &rArr; auto
camva ()
  &rArr; ans =  10.340
close (hf)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcampos">campos</a>, <a href="#XREFcamtarget">camtarget</a>, <a href="#XREFcamup">camup</a>.
</p></dd></dl>


<a name="XREFcamzoom"></a><dl>
<dt><a name="index-camzoom"></a><em></em> <strong>camzoom</strong> <em>(<var>zf</var>)</em></dt>
<dt><a name="index-camzoom-1"></a><em></em> <strong>camzoom</strong> <em>(<var>ax</var>, <var>zf</var>)</em></dt>
<dd><p>Zoom the camera in or out.
</p>
<p>A value of <var>zf</var> larger than 1 &ldquo;zooms in&rdquo; such that the scene appears
magnified:
</p>
<div class="example">
<pre class="example">hf = figure ();
sphere (36)
camzoom (1.2)
</pre></div>

<p>A value smaller than 1 &ldquo;zooms out&rdquo; so the camera can see more of the
scene:
</p>
<div class="example">
<pre class="example">camzoom (0.5)
</pre></div>

<p>Technically speaking, zooming affects the &ldquo;viewing angle&rdquo;.  The following
command resets to the default zoom:
</p>
<div class="example">
<pre class="example">camva (&quot;auto&quot;)
close (hf)
</pre></div>

<p>By default, these commands affect the current axis; alternatively, an axis
can be specified by the optional argument <var>ax</var>.
</p>

<p><strong>See also:</strong> <a href="#XREFcamroll">camroll</a>, <a href="#XREFcamorbit">camorbit</a>, <a href="#XREFcamlookat">camlookat</a>, <a href="#XREFcamva">camva</a>.
</p></dd></dl>


<a name="XREFslice"></a><dl>
<dt><a name="index-slice"></a><em></em> <strong>slice</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>sx</var>, <var>sy</var>, <var>sz</var>)</em></dt>
<dt><a name="index-slice-1"></a><em></em> <strong>slice</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em></dt>
<dt><a name="index-slice-2"></a><em></em> <strong>slice</strong> <em>(<var>v</var>, <var>sx</var>, <var>sy</var>, <var>sz</var>)</em></dt>
<dt><a name="index-slice-3"></a><em></em> <strong>slice</strong> <em>(<var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em></dt>
<dt><a name="index-slice-4"></a><em></em> <strong>slice</strong> <em>(&hellip;, <var>method</var>)</em></dt>
<dt><a name="index-slice-5"></a><em></em> <strong>slice</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-slice-6"></a><em><var>h</var> =</em> <strong>slice</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot slices of 3-D data/scalar fields.
</p>
<p>Each element of the 3-dimensional array <var>v</var> represents a scalar value at
a location given by the parameters <var>x</var>, <var>y</var>, and <var>z</var>.  The
parameters <var>x</var>, <var>x</var>, and <var>z</var> are either 3-dimensional arrays of
the same size as the array <var>v</var> in the <code>&quot;meshgrid&quot;</code> format or
vectors.  The parameters <var>xi</var>, etc. respect a similar format to
<var>x</var>, etc., and they represent the points at which the array <var>vi</var>
is interpolated using interp3.  The vectors <var>sx</var>, <var>sy</var>, and
<var>sz</var> contain points of orthogonal slices of the respective axes.
</p>
<p>If <var>x</var>, <var>y</var>, <var>z</var> are omitted, they are assumed to be
<code>x = 1:size (<var>v</var>, 2)</code>, <code>y = 1:size (<var>v</var>, 1)</code> and
<code>z = 1:size (<var>v</var>, 3)</code>.
</p>
<p><var>method</var> is one of:
</p>
<dl compact="compact">
<dt><code>&quot;nearest&quot;</code></dt>
<dd><p>Return the nearest neighbor.
</p>
</dd>
<dt><code>&quot;linear&quot;</code></dt>
<dd><p>Linear interpolation from nearest neighbors.
</p>
</dd>
<dt><code>&quot;cubic&quot;</code></dt>
<dd><p>Cubic interpolation from four nearest neighbors (not implemented yet).
</p>
</dd>
<dt><code>&quot;spline&quot;</code></dt>
<dd><p>Cubic spline interpolation&mdash;smooth first and second derivatives
throughout the curve.
</p></dd>
</dl>

<p>The default method is <code>&quot;linear&quot;</code>.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example">[x, y, z] = meshgrid (linspace (-8, 8, 32));
v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
slice (x, y, z, v, [], 0, []);

[xi, yi] = meshgrid (linspace (-7, 7));
zi = xi + yi;
slice (x, y, z, v, xi, yi, zi);
</pre></div>

<p><strong>See also:</strong> <a href="Multi_002ddimensional-Interpolation.html#XREFinterp3">interp3</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>.
</p></dd></dl>


<a name="XREFribbon"></a><dl>
<dt><a name="index-ribbon"></a><em></em> <strong>ribbon</strong> <em>(<var>y</var>)</em></dt>
<dt><a name="index-ribbon-1"></a><em></em> <strong>ribbon</strong> <em>(<var>x</var>, <var>y</var>)</em></dt>
<dt><a name="index-ribbon-2"></a><em></em> <strong>ribbon</strong> <em>(<var>x</var>, <var>y</var>, <var>width</var>)</em></dt>
<dt><a name="index-ribbon-3"></a><em></em> <strong>ribbon</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-ribbon-4"></a><em><var>h</var> =</em> <strong>ribbon</strong> <em>(&hellip;)</em></dt>
<dd><p>Draw a ribbon plot for the columns of <var>y</var> vs. <var>x</var>.
</p>
<p>If <var>x</var> is omitted, a vector containing the row numbers is assumed
(<code>1:rows (Y)</code>).  Alternatively, <var>x</var> can also be a vector with
same number of elements as rows of <var>y</var> in which case the same
<var>x</var> is used for each column of <var>y</var>.
</p>
<p>The optional parameter <var>width</var> specifies the width of a single ribbon
(default is 0.75).
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a vector of graphics handles to
the surface objects representing each ribbon.
</p>
<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFwaterfall">waterfall</a>.
</p></dd></dl>


<a name="XREFshading"></a><dl>
<dt><a name="index-shading"></a><em></em> <strong>shading</strong> <em>(<var>type</var>)</em></dt>
<dt><a name="index-shading-1"></a><em></em> <strong>shading</strong> <em>(<var>hax</var>, <var>type</var>)</em></dt>
<dd><p>Set the shading of patch or surface graphic objects.
</p>
<p>Valid arguments for <var>type</var> are
</p>
<dl compact="compact">
<dt><code>&quot;flat&quot;</code></dt>
<dd><p>Single colored patches with invisible edges.
</p>
</dd>
<dt><code>&quot;faceted&quot;</code></dt>
<dd><p>Single colored patches with black edges.
</p>
</dd>
<dt><code>&quot;interp&quot;</code></dt>
<dd><p>Colors between patch vertices are interpolated and the patch edges are
invisible.
</p></dd>
</dl>

<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p><strong>See also:</strong> <a href="Two_002dDimensional-Plots.html#XREFfill">fill</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFlighting">lighting</a>.
</p></dd></dl>


<a name="XREFscatter3"></a><dl>
<dt><a name="index-scatter3"></a><em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-scatter3-1"></a><em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>s</var>)</em></dt>
<dt><a name="index-scatter3-2"></a><em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>s</var>, <var>c</var>)</em></dt>
<dt><a name="index-scatter3-3"></a><em></em> <strong>scatter3</strong> <em>(&hellip;, <var>style</var>)</em></dt>
<dt><a name="index-scatter3-4"></a><em></em> <strong>scatter3</strong> <em>(&hellip;, &quot;filled&quot;)</em></dt>
<dt><a name="index-scatter3-5"></a><em></em> <strong>scatter3</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>)</em></dt>
<dt><a name="index-scatter3-6"></a><em></em> <strong>scatter3</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-scatter3-7"></a><em><var>h</var> =</em> <strong>scatter3</strong> <em>(&hellip;)</em></dt>
<dd><p>Draw a 3-D scatter plot.
</p>
<p>A marker is plotted at each point defined by the coordinates in the vectors
<var>x</var>, <var>y</var>, and <var>z</var>.
</p>
<p>The size of the markers is determined by <var>s</var>, which can be a scalar
or a vector of the same length as <var>x</var>, <var>y</var>, and <var>z</var>.  If <var>s</var>
is not given, or is an empty matrix, then a default value of 8 points is
used.
</p>
<p>The color of the markers is determined by <var>c</var>, which can be a string
defining a fixed color; a 3-element vector giving the red, green, and blue
components of the color; a vector of the same length as <var>x</var> that gives
a scaled index into the current colormap; or an Nx3 matrix
defining the RGB color of each marker individually.
</p>
<p>The marker to use can be changed with the <var>style</var> argument, that is a
string defining a marker in the same manner as the <code>plot</code> command.
If no marker is specified it defaults to <code>&quot;o&quot;</code> or circles.
If the argument <code>&quot;filled&quot;</code> is given then the markers are filled.
</p>
<p>Additional property/value pairs are passed directly to the underlying
patch object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the hggroup
object representing the points.
</p>
<div class="example">
<pre class="example">[x, y, z] = peaks (20);
scatter3 (x(:), y(:), z(:), [], z(:));
</pre></div>


<p><strong>See also:</strong> <a href="Two_002dDimensional-Plots.html#XREFscatter">scatter</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFplot">plot</a>.
</p></dd></dl>


<a name="XREFwaterfall"></a><dl>
<dt><a name="index-waterfall"></a><em></em> <strong>waterfall</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-waterfall-1"></a><em></em> <strong>waterfall</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-waterfall-2"></a><em></em> <strong>waterfall</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-waterfall-3"></a><em></em> <strong>waterfall</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-waterfall-4"></a><em></em> <strong>waterfall</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-waterfall-5"></a><em><var>h</var> =</em> <strong>waterfall</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D waterfall plot.
</p>
<p>A waterfall plot is similar to a <code>meshz</code> plot except only
mesh lines for the rows of <var>z</var> (x-values) are shown.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axes,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="#XREFmeshz">meshz</a>, <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFribbon">ribbon</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="Aspect-Ratio.html#Aspect-Ratio" accesskey="1">Aspect Ratio</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="Three_002ddimensional-Function-Plotting.html#Three_002ddimensional-Function-Plotting" accesskey="2">Three-dimensional Function Plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="Three_002ddimensional-Geometric-Shapes.html#Three_002ddimensional-Geometric-Shapes" accesskey="3">Three-dimensional Geometric Shapes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<div class="header">
<p>
Next: <a href="Plot-Annotations.html#Plot-Annotations" accesskey="n" rel="next">Plot Annotations</a>, Previous: <a href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots" accesskey="p" rel="prev">Two-Dimensional Plots</a>, Up: <a href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" accesskey="u" rel="up">High-Level Plotting</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
