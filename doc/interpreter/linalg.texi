@c DO NOT EDIT!  Generated automatically by munge-texi.pl.

@c Copyright (C) 1996-2018 John W. Eaton
@c
@c This file is part of Octave.
@c
@c Octave is free software: you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by
@c the Free Software Foundation, either version 3 of the License, or
@c (at your option) any later version.
@c
@c Octave is distributed in the hope that it will be useful, but
@c WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <https://www.gnu.org/licenses/>.

@node Linear Algebra
@chapter Linear Algebra
@cindex linear algebra

This chapter documents the linear algebra functions provided in Octave.
Reference material for many of these functions may be found in
@nospell{Golub and Van Loan}, @cite{Matrix Computations, 2nd Ed.},
Johns Hopkins, 1989, and in the @cite{@sc{lapack} Users' Guide}, SIAM, 1992.
The @cite{@sc{lapack} Users' Guide} is available at:
@cite{http://www.netlib.org/lapack/lug/}

A common text for engineering courses is @nospell{G. Strang},
@cite{Linear Algebra and Its Applications, 4th Edition}. It has become a
widespread reference for linear algebra.  An alternative is P. Lax
@cite{Linear Algebra and Its Applications}, and also is a good choice.  It
claims to be suitable for high school students with substantial mathematical
interests as well as first-year undergraduates.

@menu
* Techniques Used for Linear Algebra::
* Basic Matrix Functions::
* Matrix Factorizations::
* Functions of a Matrix::
* Specialized Solvers::
@end menu

@node Techniques Used for Linear Algebra
@section Techniques Used for Linear Algebra
@cindex linear algebra, techniques

Octave includes a polymorphic solver that selects an appropriate matrix
factorization depending on the properties of the matrix itself.
Generally, the cost of determining the matrix type is small relative to
the cost of factorizing the matrix itself.  In any case the matrix type
is cached once it is calculated so that it is not re-determined each
time it is used in a linear equation.

The selection tree for how the linear equation is solved or a matrix
inverse is formed is given by:

@enumerate 1
@item If the matrix is upper or lower triangular sparse use a forward or
backward substitution using the @sc{lapack} xTRTRS function, and goto 4.

@c Permuted triangular matrices currently disabled in the code
@c
@c @item If the matrix is a upper triangular matrix with column permutations
@c or lower triangular matrix with row permutations, perform a forward or
@c backward substitution, and goto 5.

@item If the matrix is square, Hermitian with a real positive diagonal,
attempt Cholesky@tie{}factorization using the @sc{lapack} xPOTRF function.

@item If the Cholesky@tie{}factorization failed or the matrix is not
Hermitian with a real positive diagonal, and the matrix is square, factorize
using the @sc{lapack} xGETRF function.

@item If the matrix is not square, or any of the previous solvers flags
a singular or near singular matrix, find a least squares solution using
the @sc{lapack} xGELSD function.
@end enumerate

The user can force the type of the matrix with the @code{matrix_type}
function.  This overcomes the cost of discovering the type of the matrix.
However, it should be noted that identifying the type of the matrix incorrectly
will lead to unpredictable results, and so @code{matrix_type} should be
used with care.

It should be noted that the test for whether a matrix is a candidate for
Cholesky@tie{}factorization, performed above, and by the @code{matrix_type}
function, does not make certain that the matrix is
Hermitian.  However, the attempt to factorize the matrix will quickly
detect a non-Hermitian matrix.

@node Basic Matrix Functions
@section Basic Matrix Functions
@cindex matrix functions, basic

@c balance libinterp/corefcn/balance.cc
@anchor{XREFbalance}
@deftypefn  {} {@var{AA} =} balance (@var{A})
@deftypefnx {} {@var{AA} =} balance (@var{A}, @var{opt})
@deftypefnx {} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})
@deftypefnx {} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})
@deftypefnx {} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})

Balance the matrix @var{A} to reduce numerical errors in future
calculations.

Compute @code{@var{AA} = @var{DD} \ @var{A} * @var{DD}} in which @var{AA}
is a matrix whose row and column norms are roughly equal in magnitude, and
@code{@var{DD} = @var{P} * @var{D}}, in which @var{P} is a permutation
matrix and @var{D} is a diagonal matrix of powers of two.  This allows the
equilibration to be computed without round-off.  Results of eigenvalue
calculation are typically improved by balancing first.

If two output values are requested, @code{balance} returns
the diagonal @var{D} and the permutation @var{P} separately as vectors.
In this case, @code{@var{DD} = eye(n)(:,@var{P}) * diag (@var{D})}, where
@math{n} is the matrix size.

If four output values are requested, compute @code{@var{AA} =
@var{CC}*@var{A}*@var{DD}} and @code{@var{BB} = @var{CC}*@var{B}*@var{DD}},
in which @var{AA} and @var{BB} have nonzero elements of approximately the
same magnitude and @var{CC} and @var{DD} are permuted diagonal matrices as
in @var{DD} for the algebraic eigenvalue problem.

The eigenvalue balancing option @var{opt} may be one of:

@table @asis
@item @qcode{"noperm"}, @qcode{"S"}
Scale only; do not permute.

@item @qcode{"noscal"}, @qcode{"P"}
Permute only; do not scale.
@end table

Algebraic eigenvalue balancing uses standard @sc{lapack} routines.

Generalized eigenvalue problem balancing uses Ward's algorithm
(SIAM Journal on Scientific and Statistical Computing, 1981).
@end deftypefn


@c bandwidth scripts/linear-algebra/bandwidth.m
@anchor{XREFbandwidth}
@deftypefn  {} {@var{bw} =} bandwidth (@var{A}, @var{type})
@deftypefnx {} {[@var{lower}, @var{upper}] =} bandwidth (@var{A})
Compute the bandwidth of @var{A}.

The @var{type} argument is the string @qcode{"lower"} for the lower
bandwidth and @qcode{"upper"} for the upper bandwidth.  If no @var{type} is
specified return both the lower and upper bandwidth of @var{A}.

The lower/upper bandwidth of a matrix is the number of
subdiagonals/superdiagonals with nonzero entries.

@seealso{@ref{XREFisbanded,,isbanded}, @ref{XREFisdiag,,isdiag}, @ref{XREFistril,,istril}, @ref{XREFistriu,,istriu}}
@end deftypefn


@c cond scripts/linear-algebra/cond.m
@anchor{XREFcond}
@deftypefn  {} {} cond (@var{A})
@deftypefnx {} {} cond (@var{A}, @var{p})
Compute the @var{p}-norm condition number of a matrix with respect to
inversion.

@code{cond (@var{A})} is defined as
@tex
$ {\parallel A \parallel_p * \parallel A^{-1} \parallel_p .} $
@end tex
@ifnottex
@code{norm (@var{A}, @var{p}) * norm (inv (@var{A}), @var{p})}.
@end ifnottex

By default, @code{@var{p} = 2} is used which implies a (relatively slow)
singular value decomposition.  Other possible selections are
@code{@var{p} = 1, Inf, "fro"} which are generally faster.  See @code{norm}
for a full discussion of possible @var{p} values.

The condition number of a matrix quantifies the sensitivity of the matrix
inversion operation when small changes are made to matrix elements.  Ideally
the condition number will be close to 1.  When the number is large this
indicates small changes (such as underflow or round-off error) will produce
large changes in the resulting output.  In such cases the solution results
from numerical computing are not likely to be accurate.
@seealso{@ref{XREFcondest,,condest}, @ref{XREFrcond,,rcond}, @ref{XREFcondeig,,condeig}, @ref{XREFnorm,,norm}, @ref{XREFsvd,,svd}}
@end deftypefn


@c condeig scripts/linear-algebra/condeig.m
@anchor{XREFcondeig}
@deftypefn  {} {@var{c} =} condeig (@var{a})
@deftypefnx {} {[@var{v}, @var{lambda}, @var{c}] =} condeig (@var{a})
Compute condition numbers of a matrix with respect to eigenvalues.

The condition numbers are the reciprocals of the cosines of the angles
between the left and right eigenvectors; Large values indicate that the
matrix has multiple distinct eigenvalues.

The input @var{a} must be a square numeric matrix.

The outputs are:

@itemize @bullet
@item
@var{c} is a vector of condition numbers for the eigenvalues of
@var{a}.

@item
@var{v} is the matrix of right eigenvectors of @var{a}.  The result is
equivalent to calling @code{[@var{v}, @var{lambda}] = eig (@var{a})}.

@item
@var{lambda} is the diagonal matrix of eigenvalues of @var{a}.  The
result is equivalent to calling
@code{[@var{v}, @var{lambda}] = eig (@var{a})}.
@end itemize

Example

@example
@group
a = [1, 2; 3, 4];
c = condeig (a)
@result{} [1.0150; 1.0150]
@end group
@end example
@seealso{@ref{XREFeig,,eig}, @ref{XREFcond,,cond}, @ref{XREFbalance,,balance}}
@end deftypefn


@c det libinterp/corefcn/det.cc
@anchor{XREFdet}
@deftypefn  {} {} det (@var{A})
@deftypefnx {} {[@var{d}, @var{rcond}] =} det (@var{A})
Compute the determinant of @var{A}.

Return an estimate of the reciprocal condition number if requested.

Programming Notes: Routines from @sc{lapack} are used for full matrices and
code from @sc{umfpack} is used for sparse matrices.

The determinant should not be used to check a matrix for singularity.
For that, use any of the condition number functions: @code{cond},
@code{condest}, @code{rcond}.
@seealso{@ref{XREFcond,,cond}, @ref{XREFcondest,,condest}, @ref{XREFrcond,,rcond}}
@end deftypefn


@c eig libinterp/corefcn/eig.cc
@anchor{XREFeig}
@deftypefn  {} {@var{lambda} =} eig (@var{A})
@deftypefnx {} {@var{lambda} =} eig (@var{A}, @var{B})
@deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A})
@deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})
@deftypefnx {} {[@var{V}, @var{lambda}, @var{W}] =} eig (@var{A})
@deftypefnx {} {[@var{V}, @var{lambda}, @var{W}] =} eig (@var{A}, @var{B})
@deftypefnx {} {[@dots{}] =} eig (@var{A}, @var{balanceOption})
@deftypefnx {} {[@dots{}] =} eig (@var{A}, @var{B}, @var{algorithm})
@deftypefnx {} {[@dots{}] =} eig (@dots{}, @var{eigvalOption})
Compute the eigenvalues (@var{lambda}) and optionally the right eigenvectors
(@var{V}) and the left eigenvectors (@var{W}) of a matrix or pair of matrices.

The flag @var{balanceOption} can be one of:

@table @asis
@item @qcode{"balance"} (default)
Preliminary balancing is on.

@item @qcode{"nobalance"}
Disables preliminary balancing.
@end table

The flag @var{eigvalOption} can be one of:

@table @asis
@item @qcode{"matrix"}
Return the eigenvalues in a diagonal matrix.  (default if 2 or 3 outputs
are requested)

@item @qcode{"vector"}
Return the eigenvalues in a column vector.  (default if only 1 output is
requested, e.g., @var{lambda} = eig (@var{A}))
@end table

The flag @var{algorithm} can be one of:

@table @asis
@item @qcode{"chol"}
Use the Cholesky factorization of B.  (default if @var{A} is symmetric
(Hermitian) and @var{B} is symmetric (Hermitian) positive definite)

@item @qcode{"qz"}
Use the QZ algorithm.  (used whenever @var{A} or @var{B} are not symmetric)
@end table

@multitable @columnfractions .31 .23 .23 .23
@headitem @tab no flag @tab chol @tab qz
@item both are symmetric
@tab @qcode{"chol"}
@tab @qcode{"chol"}
@tab @qcode{"qz"}
@item at least one is not symmetric
@tab @qcode{"qz"}
@tab @qcode{"qz"}
@tab @qcode{"qz"}
@end multitable

The eigenvalues returned by @code{eig} are not ordered.
@seealso{@ref{XREFeigs,,eigs}, @ref{XREFsvd,,svd}}
@end deftypefn


@c givens libinterp/corefcn/givens.cc
@anchor{XREFgivens}
@deftypefn  {} {@var{G} =} givens (@var{x}, @var{y})
@deftypefnx {} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})
Compute the Givens rotation matrix @var{G}.

@tex
The Givens matrix is a $2\times 2$ orthogonal matrix
$$
 G = \left[\matrix{c & s\cr -s'& c\cr}\right]
$$
such that
$$
 G \left[\matrix{x\cr y}\right] = \left[\matrix{\ast\cr 0}\right]
$$
with $x$ and $y$ scalars.
@end tex
@ifnottex
The Givens matrix is a 2-by-2 orthogonal matrix

@example
@group
@var{G} = [ @var{c} , @var{s}
     -@var{s}', @var{c}]
@end group
@end example

@noindent
such that

@example
@var{G} * [@var{x}; @var{y}] = [*; 0]
@end example

@noindent
with @var{x} and @var{y} scalars.
@end ifnottex

If two output arguments are requested, return the factors @var{c} and @var{s}
rather than the Givens rotation matrix.

For example:

@example
@group
givens (1, 1)
   @result{}   0.70711   0.70711
       -0.70711   0.70711
@end group
@end example

Note: The Givens matrix represents a counterclockwise rotation of a 2-D
plane and can be used to introduce zeros into a matrix prior to complete
factorization.
@seealso{@ref{XREFplanerot,,planerot}, @ref{XREFqr,,qr}}
@end deftypefn


@c gsvd libinterp/corefcn/gsvd.cc
@anchor{XREFgsvd}
@deftypefn  {} {@var{S} =} gsvd (@var{A}, @var{B})
@deftypefnx {} {[@var{U}, @var{V}, @var{X}, @var{C}, @var{S}] =} gsvd (@var{A}, @var{B})
@deftypefnx {} {[@var{U}, @var{V}, @var{X}, @var{C}, @var{S}] =} gsvd (@var{A}, @var{B}, 0)
Compute the generalized singular value decomposition of (@var{A}, @var{B}).

The generalized singular value decomposition is defined by the following
relations:

@tex
$$ A = U C X^\dagger $$
$$ B = V S X^\dagger $$
$$ C^\dagger C + S^\dagger S = eye (columns (A)) $$
@end tex
@ifnottex

@example
@group
A = U*C*X'
B = V*S*X'
C'*C + S'*S = eye (columns (A))
@end group
@end example

@end ifnottex

The function @code{gsvd} normally returns just the vector of generalized
singular values
@tex
$$ \sqrt{{{diag (C^\dagger C)} \over {diag (S^\dagger S)}}} $$
@end tex
@ifnottex
@code{sqrt (diag (C'*C) ./ diag (S'*S))}.
@end ifnottex
If asked for five return values, it also computes
@tex
$U$, $V$, $X$, and $C$.
@end tex
@ifnottex
U, V, X, and C.
@end ifnottex

If the optional third input is present, @code{gsvd} constructs the
"economy-sized" decomposition where the number of columns of @var{U}, @var{V}
and the number of rows of @var{C}, @var{S} is less than or equal to the number
of columns of @var{A}.  This option is not yet implemented.

Programming Note: the code is a wrapper to the corresponding @sc{lapack} dggsvd
and zggsvd routines.

@seealso{@ref{XREFsvd,,svd}}
@end deftypefn


@c planerot scripts/linear-algebra/planerot.m
@anchor{XREFplanerot}
@deftypefn {} {[@var{G}, @var{y}] =} planerot (@var{x})
Compute the Givens rotation matrix for the two-element column vector
@var{x}.

@tex
The Givens matrix is a $2\times 2$ orthogonal matrix
$$
 G = \left[\matrix{c & s\cr -s'& c\cr}\right]
$$
such that
$$
 G \left[\matrix{x(1)\cr x(2)}\right] = \left[\matrix{\ast\cr 0}\right]
$$
@end tex
@ifnottex
The Givens matrix is a 2-by-2 orthogonal matrix

@example
@group
@var{G} = [ @var{c} , @var{s}
     -@var{s}', @var{c}]
@end group
@end example

@noindent
such that

@example
@var{y} = @var{G} * [@var{x}(1); @var{x}(2)] @equiv{} [*; 0]
@end example

@end ifnottex

Note: The Givens matrix represents a counterclockwise rotation of a 2-D
plane and can be used to introduce zeros into a matrix prior to complete
factorization.
@seealso{@ref{XREFgivens,,givens}, @ref{XREFqr,,qr}}
@end deftypefn


@c inv libinterp/corefcn/inv.cc
@anchor{XREFinv}
@deftypefn  {} {@var{x} =} inv (@var{A})
@deftypefnx {} {[@var{x}, @var{rcond}] =} inv (@var{A})
Compute the inverse of the square matrix @var{A}.

Return an estimate of the reciprocal condition number if requested,
otherwise warn of an ill-conditioned matrix if the reciprocal condition
number is small.

In general it is best to avoid calculating the inverse of a matrix directly.
For example, it is both faster and more accurate to solve systems of
equations (@var{A}*@math{x} = @math{b}) with
@code{@var{y} = @var{A} \ @math{b}}, rather than
@code{@var{y} = inv (@var{A}) * @math{b}}.

If called with a sparse matrix, then in general @var{x} will be a full
matrix requiring significantly more storage.  Avoid forming the inverse of a
sparse matrix if possible.
@seealso{@ref{XREFldivide,,ldivide}, @ref{XREFrdivide,,rdivide}, @ref{XREFpinv,,pinv}}
@end deftypefn


@c linsolve scripts/linear-algebra/linsolve.m
@anchor{XREFlinsolve}
@deftypefn  {} {@var{x} =} linsolve (@var{A}, @var{b})
@deftypefnx {} {@var{x} =} linsolve (@var{A}, @var{b}, @var{opts})
@deftypefnx {} {[@var{x}, @var{R}] =} linsolve (@dots{})
Solve the linear system @code{A*x = b}.

With no options, this function is equivalent to the left division operator
@w{(@code{x = A \ b})} or the matrix-left-divide function
@w{(@code{x = mldivide (A, b)})}.

Octave ordinarily examines the properties of the matrix @var{A} and chooses
a solver that best matches the matrix.  By passing a structure @var{opts}
to @code{linsolve} you can inform Octave directly about the matrix @var{A}.
In this case Octave will skip the matrix examination and proceed directly
to solving the linear system.

@strong{Warning:} If the matrix @var{A} does not have the properties listed
in the @var{opts} structure then the result will not be accurate AND no
warning will be given.  When in doubt, let Octave examine the matrix and
choose the appropriate solver as this step takes little time and the result
is cached so that it is only done once per linear system.

Possible @var{opts} fields (set value to true/false):

@table @asis
@item LT
@var{A} is lower triangular

@item UT
@var{A} is upper triangular

@item UHESS
@var{A} is upper Hessenberg (currently makes no difference)

@item SYM
@var{A} is symmetric or complex Hermitian (currently makes no difference)

@item POSDEF
@var{A} is positive definite

@item RECT
@var{A} is general rectangular (currently makes no difference)

@item TRANSA
  Solve @code{A'*x = b} if true rather than @code{A*x = b}
@end table

The optional second output @var{R} is the inverse condition number of
@var{A} (zero if matrix is singular).
@seealso{@ref{XREFmldivide,,mldivide}, @ref{XREFmatrix_type,,matrix_type}, @ref{XREFrcond,,rcond}}
@end deftypefn


@c matrix_type libinterp/corefcn/matrix_type.cc
@anchor{XREFmatrix_type}
@deftypefn  {} {@var{type} =} matrix_type (@var{A})
@deftypefnx {} {@var{type} =} matrix_type (@var{A}, "nocompute")
@deftypefnx {} {@var{A} =} matrix_type (@var{A}, @var{type})
@deftypefnx {} {@var{A} =} matrix_type (@var{A}, "upper", @var{perm})
@deftypefnx {} {@var{A} =} matrix_type (@var{A}, "lower", @var{perm})
@deftypefnx {} {@var{A} =} matrix_type (@var{A}, "banded", @var{nl}, @var{nu})
Identify the matrix type or mark a matrix as a particular type.

This allows more rapid solutions of linear equations involving @var{A} to be
performed.

Called with a single argument, @code{matrix_type} returns the type of the
matrix and caches it for future use.

Called with more than one argument, @code{matrix_type} allows the type of
the matrix to be defined.

If the option @qcode{"nocompute"} is given, the function will not attempt
to guess the type if it is still unknown.  This is useful for debugging
purposes.

The possible matrix types depend on whether the matrix is full or sparse,
and can be one of the following

@table @asis
@item @qcode{"unknown"}
Remove any previously cached matrix type, and mark type as unknown.

@item @qcode{"full"}
Mark the matrix as full.

@item @qcode{"positive definite"}
Probable full positive definite matrix.

@item @qcode{"diagonal"}
Diagonal matrix.  (Sparse matrices only)

@item @qcode{"permuted diagonal"}
Permuted Diagonal matrix.  The permutation does not need to be specifically
indicated, as the structure of the matrix explicitly gives this.  (Sparse
matrices only)

@item @qcode{"upper"}
Upper triangular.  If the optional third argument @var{perm} is given, the
matrix is assumed to be a permuted upper triangular with the permutations
defined by the vector @var{perm}.

@item @qcode{"lower"}
Lower triangular.  If the optional third argument @var{perm} is given, the
matrix is assumed to be a permuted lower triangular with the permutations
defined by the vector @var{perm}.

@item  @qcode{"banded"}
@itemx @qcode{"banded positive definite"}
Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}
above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal
and treated with specialized code.  In addition the matrix can be marked as
probably a positive definite.  (Sparse matrices only)

@item @qcode{"singular"}
The matrix is assumed to be singular and will be treated with a minimum norm
solution.

@end table

Note that the matrix type will be discovered automatically on the first
attempt to solve a linear equation involving @var{A}.  Therefore
@code{matrix_type} is only useful to give Octave hints of the matrix type.
Incorrectly defining the matrix type will result in incorrect results from
solutions of linear equations; it is entirely @strong{the responsibility of
the user} to correctly identify the matrix type.

Also, the test for positive definiteness is a low-cost test for a Hermitian
matrix with a real positive diagonal.  This does not guarantee that the
matrix is positive definite, but only that it is a probable candidate.  When
such a matrix is factorized, a Cholesky@tie{}factorization is first
attempted, and if that fails the matrix is then treated with an
LU@tie{}factorization.  Once the matrix has been factorized,
@code{matrix_type} will return the correct classification of the matrix.
@end deftypefn


@c norm libinterp/corefcn/data.cc
@anchor{XREFnorm}
@deftypefn  {} {} norm (@var{A})
@deftypefnx {} {} norm (@var{A}, @var{p})
@deftypefnx {} {} norm (@var{A}, @var{p}, @var{opt})
Compute the p-norm of the matrix @var{A}.

If the second argument is not given, @w{@code{p = 2}} is used.

If @var{A} is a matrix (or sparse matrix):

@table @asis
@item @var{p} = @code{1}
1-norm, the largest column sum of the absolute values of @var{A}.

@item @var{p} = @code{2}
Largest singular value of @var{A}.

@item @var{p} = @code{Inf} or @qcode{"inf"}
@cindex infinity norm
Infinity norm, the largest row sum of the absolute values of @var{A}.

@item @var{p} = @qcode{"fro"}
@cindex @nospell{Frobenius} norm
@nospell{Frobenius} norm of @var{A},
@code{sqrt (sum (diag (@var{A}' * @var{A})))}.

@item other @var{p}, @code{@var{p} > 1}
@cindex general p-norm
maximum @code{norm (A*x, p)} such that @code{norm (x, p) == 1}
@end table

If @var{A} is a vector or a scalar:

@table @asis
@item @var{p} = @code{Inf} or @qcode{"inf"}
@code{max (abs (@var{A}))}.

@item @var{p} = @code{-Inf}
@code{min (abs (@var{A}))}.

@item @var{p} = @qcode{"fro"}
@nospell{Frobenius} norm of @var{A}, @code{sqrt (sumsq (abs (A)))}.

@item @var{p} = 0
Hamming norm---the number of nonzero elements.

@item other @var{p}, @code{@var{p} > 1}
p-norm of @var{A}, @code{(sum (abs (@var{A}) .^ @var{p})) ^ (1/@var{p})}.

@item other @var{p} @code{@var{p} < 1}
the p-pseudonorm defined as above.
@end table

If @var{opt} is the value @qcode{"rows"}, treat each row as a vector and
compute its norm.  The result is returned as a column vector.
Similarly, if @var{opt} is @qcode{"columns"} or @qcode{"cols"} then
compute the norms of each column and return a row vector.
@seealso{@ref{XREFnormest,,normest}, @ref{XREFnormest1,,normest1}, @ref{XREFvecnorm,,vecnorm}, @ref{XREFcond,,cond}, @ref{XREFsvd,,svd}}
@end deftypefn


@c null scripts/linear-algebra/null.m
@anchor{XREFnull}
@deftypefn  {} {} null (@var{A})
@deftypefnx {} {} null (@var{A}, @var{tol})
Return an orthonormal basis of the null space of @var{A}.

The dimension of the null space is taken as the number of singular values of
@var{A} not greater than @var{tol}.  If the argument @var{tol} is missing,
it is computed as

@example
max (size (@var{A})) * max (svd (@var{A})) * eps
@end example
@seealso{@ref{XREForth,,orth}}
@end deftypefn


@c orth scripts/linear-algebra/orth.m
@anchor{XREForth}
@deftypefn  {} {} orth (@var{A})
@deftypefnx {} {} orth (@var{A}, @var{tol})
Return an orthonormal basis of the range space of @var{A}.

The dimension of the range space is taken as the number of singular values
of @var{A} greater than @var{tol}.  If the argument @var{tol} is missing, it
is computed as

@example
max (size (@var{A})) * max (svd (@var{A})) * eps
@end example
@seealso{@ref{XREFnull,,null}}
@end deftypefn


@c mgorth libinterp/corefcn/mgorth.cc
@anchor{XREFmgorth}
@deftypefn {} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})
Orthogonalize a given column vector @var{x} with respect to a set of
orthonormal vectors comprising the columns of @var{v} using the modified
Gram-Schmidt method.

On exit, @var{y} is a unit vector such that:

@example
@group
  norm (@var{y}) = 1
  @var{v}' * @var{y} = 0
  @var{x} = [@var{v}, @var{y}]*@var{h}'
@end group
@end example

@end deftypefn


@c pinv libinterp/corefcn/pinv.cc
@anchor{XREFpinv}
@deftypefn  {} {} pinv (@var{x})
@deftypefnx {} {} pinv (@var{x}, @var{tol})
Return the @nospell{Moore-Penrose} pseudoinverse of @var{x}.

Singular values less than @var{tol} are ignored.

If the second argument is omitted, it is taken to be

@example
tol = max ([rows(@var{x}), columns(@var{x})]) * norm (@var{x}) * eps
@end example

@seealso{@ref{XREFinv,,inv}, @ref{XREFldivide,,ldivide}}
@end deftypefn

@cindex pseudoinverse

@c rank scripts/linear-algebra/rank.m
@anchor{XREFrank}
@deftypefn  {} {} rank (@var{A})
@deftypefnx {} {} rank (@var{A}, @var{tol})
Compute the rank of matrix @var{A}, using the singular value decomposition.

The rank is taken to be the number of singular values of @var{A} that are
greater than the specified tolerance @var{tol}.  If the second argument is
omitted, it is taken to be

@example
tol = max (size (@var{A})) * sigma(1) * eps;
@end example

@noindent
where @code{eps} is machine precision and @code{sigma(1)} is the largest
singular value of @var{A}.

The rank of a matrix is the number of linearly independent rows or columns
and equals the dimension of the row and column space.  The function
@code{orth} may be used to compute an orthonormal basis of the column space.

For testing if a system @code{@var{A}*@var{x} = @var{b}} of linear equations
is solvable, one can use

@example
rank (@var{A}) == rank ([@var{A} @var{b}])
@end example

In this case, @code{@var{x} = @var{A} \ @var{b}} finds a particular solution
@var{x}.  The general solution is @var{x} plus the null space of matrix
@var{A}.  The function @code{null} may be used to compute a basis of the
null space.

Example:

@example
@group
A = [1 2 3
     4 5 6
     7 8 9];
rank (A)
  @result{} 2
@end group
@end example

@noindent
In this example, the number of linearly independent rows is only 2 because
the final row is a linear combination of the first two rows:

@example
A(3,:) == -A(1,:) + 2 * A(2,:)
@end example

@seealso{@ref{XREFnull,,null}, @ref{XREForth,,orth}, @ref{XREFsprank,,sprank}, @ref{XREFsvd,,svd}, @ref{XREFeps,,eps}}
@end deftypefn


@c rcond libinterp/corefcn/rcond.cc
@anchor{XREFrcond}
@deftypefn {} {@var{c} =} rcond (@var{A})
Compute the 1-norm estimate of the reciprocal condition number as returned
by @sc{lapack}.

If the matrix is well-conditioned then @var{c} will be near 1 and if the
matrix is poorly conditioned it will be close to 0.

The matrix @var{A} must not be sparse.  If the matrix is sparse then
@code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used
instead.
@seealso{@ref{XREFcond,,cond}, @ref{XREFcondest,,condest}}
@end deftypefn


@c trace scripts/linear-algebra/trace.m
@anchor{XREFtrace}
@deftypefn {} {} trace (@var{A})
Compute the trace of @var{A}, the sum of the elements along the main
diagonal.

The implementation is straightforward: @code{sum (diag (@var{A}))}.
@seealso{@ref{XREFeig,,eig}}
@end deftypefn


@c rref scripts/linear-algebra/rref.m
@anchor{XREFrref}
@deftypefn  {} {} rref (@var{A})
@deftypefnx {} {} rref (@var{A}, @var{tol})
@deftypefnx {} {[@var{r}, @var{k}] =} rref (@dots{})
Return the reduced row echelon form of @var{A}.

@var{tol} defaults to
@code{eps * max (size (@var{A})) * norm (@var{A}, inf)}.

The optional return argument @var{k} contains the vector of
"bound variables", which are those columns on which elimination has been
performed.

@end deftypefn


@c vecnorm scripts/linear-algebra/vecnorm.m
@anchor{XREFvecnorm}
@deftypefn  {} {@var{n} =} vecnorm (@var{A})
@deftypefnx {} {@var{n} =} vecnorm (@var{A}, @var{p})
@deftypefnx {} {@var{n} =} vecnorm (@var{A}, @var{p}, @var{dim})
Return the p-norm of the elements of @var{A} along dimension @var{dim}.

The p-norm of a vector is defined as

@tex
$$ {\Vert A \Vert}_p  = \left[ \sum_{i=1}^N {| A_i |}^p \right] ^ {1/p} $$
@end tex
@ifnottex

@example
@var{p-norm} (@var{A}, @var{p}) = sum (abs (@var{A}) .^ @var{p})) ^ (1/@var{p})
@end example

@end ifnottex
If @var{p} is omitted it defaults to 2 (Euclidean norm).  @var{p} can be
@code{Inf} (absolute value of largest element).

If @var{dim} is omitted the first non-singleton dimension is used.

@seealso{@ref{XREFnorm,,norm}}
@end deftypefn


@node Matrix Factorizations
@section Matrix Factorizations
@cindex matrix factorizations

@c chol libinterp/dldfcn/chol.cc
@anchor{XREFchol}
@deftypefn  {} {@var{R} =} chol (@var{A})
@deftypefnx {} {[@var{R}, @var{p}] =} chol (@var{A})
@deftypefnx {} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{A})
@deftypefnx {} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{A}, "vector")
@deftypefnx {} {[@var{L}, @dots{}] =} chol (@dots{}, "lower")
@deftypefnx {} {[@var{R}, @dots{}] =} chol (@dots{}, "upper")
@cindex Cholesky factorization
Compute the upper Cholesky@tie{}factor, @var{R}, of the real symmetric
or complex Hermitian positive definite matrix @var{A}.

The upper Cholesky@tie{}factor @var{R} is computed by using the upper
triangular part of matrix @var{A} and is defined by
@tex
$ R^T R = A $.
@end tex
@ifnottex

@example
@var{R}' * @var{R} = @var{A}.
@end example

@end ifnottex

Calling @code{chol} using the optional @qcode{"upper"} flag has the
same behavior.  In contrast, using the optional @qcode{"lower"} flag,
@code{chol} returns the lower triangular factorization, computed by using
the lower triangular part of matrix @var{A}, such that
@tex
$ L L^T = A $.
@end tex
@ifnottex

@example
@var{L} * @var{L}' = @var{A}.
@end example

@end ifnottex

Called with one output argument @code{chol} fails if matrix @var{A} is
not positive definite.  Note that if matrix @var{A} is not real symmetric
or complex Hermitian then the lower triangular part is considered to be
the (complex conjugate) transpose of the upper triangular part, or vice
versa, given the @qcode{"lower"} flag.

Called with two or more output arguments @var{p} flags whether the matrix
@var{A} was positive definite and @code{chol} does not fail.  A zero value
of @var{p} indicates that matrix @var{A} is positive definite and @var{R}
gives the factorization.  Otherwise, @var{p} will have a positive value.

If called with three output arguments matrix @var{A} must be sparse and
a sparsity preserving row/column permutation is applied to matrix @var{A}
prior to the factorization.  That is @var{R} is the factorization of
@code{@var{A}(@var{Q},@var{Q})} such that
@tex
$ R^T R = Q^T A Q$.
@end tex
@ifnottex

@example
@var{R}' * @var{R} = @var{Q}' * @var{A} * @var{Q}.
@end example

@end ifnottex

The sparsity preserving permutation is generally returned as a matrix.
However, given the optional flag @qcode{"vector"}, @var{Q} will be
returned as a vector such that
@tex
$ R^T R = A (Q, Q)$.
@end tex
@ifnottex

@example
@var{R}' * @var{R} = @var{A}(@var{Q}, @var{Q}).
@end example

@end ifnottex

In general the lower triangular factorization is significantly faster for
sparse matrices.
@seealso{@ref{XREFhess,,hess}, @ref{XREFlu,,lu}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}, @ref{XREFichol,,ichol}, @ref{XREFcholinv,,cholinv}, @ref{XREFchol2inv,,chol2inv}, @ref{XREFcholupdate,,cholupdate}, @ref{XREFcholinsert,,cholinsert}, @ref{XREFcholdelete,,choldelete}, @ref{XREFcholshift,,cholshift}}
@end deftypefn


@c cholinv libinterp/dldfcn/chol.cc
@anchor{XREFcholinv}
@deftypefn {} {} cholinv (@var{A})
Compute the inverse of the symmetric positive definite matrix @var{A} using
the Cholesky@tie{}factorization.
@seealso{@ref{XREFchol,,chol}, @ref{XREFchol2inv,,chol2inv}, @ref{XREFinv,,inv}}
@end deftypefn


@c chol2inv libinterp/dldfcn/chol.cc
@anchor{XREFchol2inv}
@deftypefn {} {} chol2inv (@var{U})
Invert a symmetric, positive definite square matrix from its Cholesky
decomposition, @var{U}.

Note that @var{U} should be an upper-triangular matrix with positive
diagonal elements.  @code{chol2inv (@var{U})} provides
@code{inv (@var{U}'*@var{U})} but it is much faster than using @code{inv}.
@seealso{@ref{XREFchol,,chol}, @ref{XREFcholinv,,cholinv}, @ref{XREFinv,,inv}}
@end deftypefn


@c cholupdate libinterp/dldfcn/chol.cc
@anchor{XREFcholupdate}
@deftypefn {} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})
Update or downdate a Cholesky@tie{}factorization.

Given an upper triangular matrix @var{R} and a column vector @var{u},
attempt to determine another upper triangular matrix @var{R1} such that

@itemize @bullet
@item
@var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'
if @var{op} is @qcode{"+"}

@item
@var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'
if @var{op} is @qcode{"-"}
@end itemize

If @var{op} is @qcode{"-"}, @var{info} is set to

@itemize
@item 0 if the downdate was successful,

@item 1 if @var{R}'*@var{R} - @var{u}*@var{u}' is not positive definite,

@item 2 if @var{R} is singular.
@end itemize

If @var{info} is not present, an error message is printed in cases 1 and 2.
@seealso{@ref{XREFchol,,chol}, @ref{XREFcholinsert,,cholinsert}, @ref{XREFcholdelete,,choldelete}, @ref{XREFcholshift,,cholshift}}
@end deftypefn


@c cholinsert libinterp/dldfcn/chol.cc
@anchor{XREFcholinsert}
@deftypefn  {} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})
@deftypefnx {} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})
Update a Cholesky factorization given a row or column to insert in the original factored matrix.

Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian
positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper
triangular, return the Cholesky@tie{}factorization of
@var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and
@w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.

On return, @var{info} is set to

@itemize
@item 0 if the insertion was successful,

@item 1 if @var{A1} is not positive definite,

@item 2 if @var{R} is singular.
@end itemize

If @var{info} is not present, an error message is printed in cases 1 and 2.
@seealso{@ref{XREFchol,,chol}, @ref{XREFcholupdate,,cholupdate}, @ref{XREFcholdelete,,choldelete}, @ref{XREFcholshift,,cholshift}}
@end deftypefn


@c choldelete libinterp/dldfcn/chol.cc
@anchor{XREFcholdelete}
@deftypefn {} {@var{R1} =} choldelete (@var{R}, @var{j})
Update a Cholesky factorization given a row or column to delete from the original factored matrix.

Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian
positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper
triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where
@w{p = [1:j-1,j+1:n+1]}.
@seealso{@ref{XREFchol,,chol}, @ref{XREFcholupdate,,cholupdate}, @ref{XREFcholinsert,,cholinsert}, @ref{XREFcholshift,,cholshift}}
@end deftypefn


@c cholshift libinterp/dldfcn/chol.cc
@anchor{XREFcholshift}
@deftypefn {} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})
Update a Cholesky factorization given a range of columns to shift in the original factored matrix.

Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian
positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper
triangular, return the Cholesky@tie{}factorization of
@w{@var{A}(p,p)}, where @w{p} is the permutation @*
@code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*
 or @*
@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*

@seealso{@ref{XREFchol,,chol}, @ref{XREFcholupdate,,cholupdate}, @ref{XREFcholinsert,,cholinsert}, @ref{XREFcholdelete,,choldelete}}
@end deftypefn


@c hess libinterp/corefcn/hess.cc
@anchor{XREFhess}
@deftypefn  {} {@var{H} =} hess (@var{A})
@deftypefnx {} {[@var{P}, @var{H}] =} hess (@var{A})
@cindex Hessenberg decomposition
Compute the Hessenberg decomposition of the matrix @var{A}.

The Hessenberg decomposition is
@tex
$$
A = PHP^T
$$
where $P$ is a square unitary matrix ($P^TP = I$), and $H$
is upper Hessenberg ($H_{i,j} = 0, \forall i > j+1$).
@end tex
@ifnottex
@code{@var{P} * @var{H} * @var{P}' = @var{A}} where @var{P} is a square
unitary matrix (@code{@var{P}' * @var{P} = I}, using complex-conjugate
transposition) and @var{H} is upper Hessenberg
(@code{@var{H}(i, j) = 0 forall i > j+1)}.
@end ifnottex

The Hessenberg decomposition is usually used as the first step in an
eigenvalue computation, but has other applications as well
(see @nospell{Golub, Nash, and Van Loan},
IEEE Transactions on Automatic Control, 1979).
@seealso{@ref{XREFeig,,eig}, @ref{XREFchol,,chol}, @ref{XREFlu,,lu}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}}
@end deftypefn


@c lu libinterp/corefcn/lu.cc
@anchor{XREFlu}
@deftypefn  {} {[@var{L}, @var{U}] =} lu (@var{A})
@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})
@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})
@deftypefnx {} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})
@deftypefnx {} {[@dots{}] =} lu (@var{S}, @var{thres})
@deftypefnx {} {@var{y} =} lu (@dots{})
@deftypefnx {} {[@dots{}] =} lu (@dots{}, "vector")
@cindex LU decomposition
Compute the LU@tie{}decomposition of @var{A}.

If @var{A} is full then subroutines from @sc{lapack} are used, and if
@var{A} is sparse then @sc{umfpack} is used.

The result is returned in a permuted form, according to the optional return
value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},

@example
[l, u, p] = lu (@var{a})
@end example

@noindent
returns

@example
@group
l =

  1.00000  0.00000
  0.33333  1.00000

u =

  3.00000  4.00000
  0.00000  0.66667

p =

  0  1
  1  0
@end group
@end example

The matrix is not required to be square.

When called with two or three output arguments and a sparse input matrix,
@code{lu} does not attempt to perform sparsity preserving column permutations.
Called with a fourth output argument, the sparsity preserving column
transformation @var{Q} is returned, such that
@code{@var{P} * @var{A} * @var{Q} = @var{L} * @var{U}}.  This is the
@strong{preferred} way to call @code{lu} with sparse input matrices.

Called with a fifth output argument and a sparse input matrix, @code{lu}
attempts to use a scaling factor @var{R} on the input matrix such that
@code{@var{P} * (@var{R} \ @var{A}) * @var{Q} = @var{L} * @var{U}}.
This typically leads to a sparser and more stable factorization.

An additional input argument @var{thres}, that defines the pivoting
threshold can be given.  @var{thres} can be a scalar, in which case
it defines the @sc{umfpack} pivoting tolerance for both symmetric and
unsymmetric cases.  If @var{thres} is a 2-element vector, then the first
element defines the pivoting tolerance for the unsymmetric @sc{umfpack}
pivoting strategy and the second for the symmetric strategy.  By default,
the values defined by @code{spparms} are used ([0.1, 0.001]).

Given the string argument @qcode{"vector"}, @code{lu} returns the values
of @var{P} and @var{Q} as vector values, such that for full matrix,
@code{@var{A}(@var{P},:) = @var{L} * @var{U}}, and @code{@var{R}(@var{P},:)
* @var{A}(:,@var{Q}) = @var{L} * @var{U}}.

With two output arguments, returns the permuted forms of the upper and
lower triangular matrices, such that @code{@var{A} = @var{L} * @var{U}}.
With one output argument @var{y}, then the matrix returned by the
@sc{lapack} routines is returned.  If the input matrix is sparse then the
matrix @var{L} is embedded into @var{U} to give a return value similar to
the full case.  For both full and sparse matrices, @code{lu} loses the
permutation information.
@seealso{@ref{XREFluupdate,,luupdate}, @ref{XREFilu,,ilu}, @ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}}
@end deftypefn


@c luupdate libinterp/corefcn/lu.cc
@anchor{XREFluupdate}
@deftypefn  {} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})
@deftypefnx {} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})
Given an LU@tie{}factorization of a real or complex matrix
@w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and
@var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization
of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are
column vectors (rank-1 update) or matrices with equal number of columns
(rank-k update).

Optionally, row-pivoted updating can be used by supplying a row permutation
(pivoting) matrix @var{P}; in that case, an updated permutation matrix is
returned.  Note that if @var{L}, @var{U}, @var{P} is a pivoted
LU@tie{}factorization as obtained by @code{lu}:

@example
[@var{L}, @var{U}, @var{P}] = lu (@var{A});
@end example

@noindent
then a factorization of @tcode{@var{A}+@var{x}*@var{y}.'} can be obtained
either as

@example
[@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})
@end example

@noindent
or

@example
[@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})
@end example

The first form uses the unpivoted algorithm, which is faster, but less
stable.  The second form uses a slower pivoted algorithm, which is more
stable.

The matrix case is done as a sequence of rank-1 updates; thus, for large
enough k, it will be both faster and more accurate to recompute the
factorization from scratch.
@seealso{@ref{XREFlu,,lu}, @ref{XREFcholupdate,,cholupdate}, @ref{XREFqrupdate,,qrupdate}}
@end deftypefn


@c qr libinterp/dldfcn/qr.cc
@anchor{XREFqr}
@deftypefn  {} {[@var{Q}, @var{R}] =} qr (@var{A})
@deftypefnx {} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})  # non-sparse A
@deftypefnx {} {@var{X} =} qr (@var{A})  # non-sparse A
@deftypefnx {} {@var{R} =} qr (@var{A})  # sparse A
@deftypefnx {} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B})
@deftypefnx {} {[@dots{}] =} qr (@dots{}, 0)
@deftypefnx {} {[@dots{}] =} qr (@dots{}, "vector")
@deftypefnx {} {[@dots{}] =} qr (@dots{}, "matrix")
@cindex QR factorization
Compute the QR@tie{}factorization of @var{A}, using standard @sc{lapack}
subroutines.

The QR@tie{}factorization is
@tex
$QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.
@end tex
@ifnottex

@example
@var{Q} * @var{R} = @var{A}
@end example

@noindent
where @var{Q} is an orthogonal matrix and @var{R} is upper triangular.
@end ifnottex

For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},

@example
[@var{Q}, @var{R}] = qr (@var{A})
@end example

@noindent
returns

@example
@group
@var{Q} =

  -0.31623  -0.94868
  -0.94868   0.31623

@var{R} =

  -3.16228  -4.42719
   0.00000  -0.63246
@end group
@end example

@noindent
which multiplied together return the original matrix

@example
@group
@var{Q} * @var{R}
  @result{}
     1.0000   2.0000
     3.0000   4.0000
@end group
@end example

If just a single return value is requested then it is either @var{R}, if
@var{A} is sparse, or @var{X}, such that @code{@var{R} = triu (@var{X})} if
@var{A} is full.  (Note: unlike most commands, the single return value is not
the first return value when multiple values are requested.)

If the matrix @var{A} is full, and a third output @var{P} is requested, then
@code{qr} calculates the permuted QR@tie{}factorization
@tex
$QR = AP$ where $Q$ is an orthogonal matrix, $R$ is upper triangular, and $P$
is a permutation matrix.
@end tex
@ifnottex

@example
@var{Q} * @var{R} = @var{A} * @var{P}
@end example

@noindent
where @var{Q} is an orthogonal matrix, @var{R} is upper triangular, and
@var{P} is a permutation matrix.
@end ifnottex

The permuted QR@tie{}factorization has the additional property that the
diagonal entries of @var{R} are ordered by decreasing magnitude.  In other
words, @code{abs (diag (@var{R}))} will be ordered from largest to smallest.

For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},

@example
[@var{Q}, @var{R}, @var{P}] = qr (@var{A})
@end example

@noindent
returns

@example
@group
@var{Q} =

  -0.44721  -0.89443
  -0.89443   0.44721

@var{R} =

  -4.47214  -3.13050
   0.00000   0.44721

@var{P} =

   0  1
   1  0
@end group
@end example

If the input matrix @var{A} is sparse then the sparse QR@tie{}factorization
is computed using @sc{CSparse}.  Because the matrix @var{Q} is, in general, a
full matrix, it is recommended to request only one return value @var{R}.  In
that case, the computation avoids the construction of @var{Q} and returns
@var{R} such that @code{@var{R} = chol (@var{A}' * @var{A})}.

If an additional matrix @var{B} is supplied and two return values are
requested, then @code{qr} returns @var{C}, where
@code{@var{C} = @var{Q}' * @var{B}}.  This allows the least squares
approximation of @code{@var{A} \ @var{B}} to be calculated as

@example
@group
[@var{C}, @var{R}] = qr (@var{A}, @var{B})
@var{x} = @var{R} \ @var{C}
@end group
@end example

If the final argument is the string @qcode{"vector"} then @var{P} is a
permutation vector (of the columns of @var{A}) instead of a permutation matrix.
In this case, the defining relationship is

@example
@var{Q} * @var{R} = @var{A}(:, @var{P})
@end example

The default, however, is to return a permutation matrix and this may be
explicitly specified by using a final argument of @qcode{"matrix"}.

If the final argument is the scalar 0 an @qcode{"economy"} factorization is
returned.  When the original matrix @var{A} has size MxN and M > N then the
@qcode{"economy"} factorization will calculate just N rows in @var{R} and N
columns in @var{Q} and omit the zeros in @var{R}.  If M @leq{} N there is no
difference between the economy and standard factorizations.  When calculating
an @qcode{"economy"} factorization the output @var{P} is always a vector
rather than a matrix.

Background: The QR factorization has applications in the solution of least
squares problems
@tex
$$
\min_x \left\Vert A x - b \right\Vert_2
$$
@end tex
@ifnottex

@example
min norm (A*x - b)
@end example

@end ifnottex
for overdetermined systems of equations (i.e.,
@tex
$A$
@end tex
@ifnottex
@var{A}
@end ifnottex
is a tall, thin matrix).

The permuted QR@tie{}factorization
@code{[@var{Q}, @var{R}, @var{P}] = qr (@var{A})} allows the construction of an
orthogonal basis of @code{span (A)}.

@seealso{@ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFlu,,lu}, @ref{XREFqz,,qz}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}, @ref{XREFqrupdate,,qrupdate}, @ref{XREFqrinsert,,qrinsert}, @ref{XREFqrdelete,,qrdelete}, @ref{XREFqrshift,,qrshift}}
@end deftypefn


@c qrupdate libinterp/dldfcn/qr.cc
@anchor{XREFqrupdate}
@deftypefn {} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})
Update a QR factorization given update vectors or matrices.

Given a QR@tie{}factorization of a real or complex matrix
@w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and
@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of
@w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are column vectors
(rank-1 update) or matrices with equal number of columns
(rank-k update).  Notice that the latter case is done as a sequence of
rank-1 updates; thus, for k large enough, it will be both faster and more
accurate to recompute the factorization from scratch.

The QR@tie{}factorization supplied may be either full (Q is square) or
economized (R is square).

@seealso{@ref{XREFqr,,qr}, @ref{XREFqrinsert,,qrinsert}, @ref{XREFqrdelete,,qrdelete}, @ref{XREFqrshift,,qrshift}}
@end deftypefn


@c qrinsert libinterp/dldfcn/qr.cc
@anchor{XREFqrinsert}
@deftypefn {} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})
Update a QR factorization given a row or column to insert in the original factored matrix.


Given a QR@tie{}factorization of a real or complex matrix
@w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and
@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of
@w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be inserted
into @var{A} (if @var{orient} is @qcode{"col"}), or the
QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x} is a row
vector to be inserted into @var{A} (if @var{orient} is @qcode{"row"}).

The default value of @var{orient} is @qcode{"col"}.  If @var{orient} is
@qcode{"col"}, @var{u} may be a matrix and @var{j} an index vector
resulting in the QR@tie{}factorization of a matrix @var{B} such that
@w{B(:,@var{j})} gives @var{u} and @w{B(:,@var{j}) = []} gives @var{A}.
Notice that the latter case is done as a sequence of k insertions;
thus, for k large enough, it will be both faster and more accurate to
recompute the factorization from scratch.

If @var{orient} is @qcode{"col"}, the QR@tie{}factorization supplied may
be either full (Q is square) or economized (R is square).

If @var{orient} is @qcode{"row"}, full factorization is needed.
@seealso{@ref{XREFqr,,qr}, @ref{XREFqrupdate,,qrupdate}, @ref{XREFqrdelete,,qrdelete}, @ref{XREFqrshift,,qrshift}}
@end deftypefn


@c qrdelete libinterp/dldfcn/qr.cc
@anchor{XREFqrdelete}
@deftypefn {} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})
Update a QR factorization given a row or column to delete from the original factored matrix.

Given a QR@tie{}factorization of a real or complex matrix
@w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and
@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of
@w{[A(:,1:j-1), U, A(:,j:n)]},
where @var{u} is a column vector to be inserted into @var{A}
(if @var{orient} is @qcode{"col"}),
or the QR@tie{}factorization of @w{[A(1:j-1,:);X;A(:,j:n)]},
where @var{x} is a row @var{orient} is @qcode{"row"}).
The default value of @var{orient} is @qcode{"col"}.

If @var{orient} is @qcode{"col"}, @var{j} may be an index vector
resulting in the QR@tie{}factorization of a matrix @var{B} such that
@w{A(:,@var{j}) = []} gives @var{B}.  Notice that the latter case is done as
a sequence of k deletions; thus, for k large enough, it will be both faster
and more accurate to recompute the factorization from scratch.

If @var{orient} is @qcode{"col"}, the QR@tie{}factorization supplied may
be either full (Q is square) or economized (R is square).

If @var{orient} is @qcode{"row"}, full factorization is needed.
@seealso{@ref{XREFqr,,qr}, @ref{XREFqrupdate,,qrupdate}, @ref{XREFqrinsert,,qrinsert}, @ref{XREFqrshift,,qrshift}}
@end deftypefn


@c qrshift libinterp/dldfcn/qr.cc
@anchor{XREFqrshift}
@deftypefn {} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})
Update a QR factorization given a range of columns to shift in the original factored matrix.

Given a QR@tie{}factorization of a real or complex matrix
@w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and
@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization
of @w{@var{A}(:,p)}, where @w{p} is the permutation @*
@code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*
 or @*
@code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*

@seealso{@ref{XREFqr,,qr}, @ref{XREFqrupdate,,qrupdate}, @ref{XREFqrinsert,,qrinsert}, @ref{XREFqrdelete,,qrdelete}}
@end deftypefn


@c qz libinterp/corefcn/qz.cc
@anchor{XREFqz}
@deftypefn  {} {@var{lambda} =} qz (@var{A}, @var{B})
@deftypefnx {} {[@var{AA}, @var{BB}, @var{Q}, @var{Z}, @var{V}, @var{W}, @var{lambda}] =} qz (@var{A}, @var{B})
@deftypefnx {} {[@var{AA}, @var{BB}, @var{Z}] =} qz (@var{A}, @var{B}, @var{opt})
@deftypefnx {} {[@var{AA}, @var{BB}, @var{Z}, @var{lambda}] =} qz (@var{A}, @var{B}, @var{opt})
Compute the QZ@tie{}decomposition of a generalized eigenvalue problem.

The generalized eigenvalue problem is defined as

@tex
$$A x = \lambda B x$$
@end tex
@ifnottex

@math{A x = @var{lambda} B x}

@end ifnottex

There are three calling forms of the function:

@enumerate
@item @code{@var{lambda} = qz (@var{A}, @var{B})}

Compute the generalized eigenvalues
@tex
$\lambda.$
@end tex
@ifnottex
@var{lambda}.
@end ifnottex

@item @code{[@var{AA}, @var{BB}, @var{Q}, @var{Z}, @var{V}, @var{W}, @var{lambda}] = qz (@var{A}, @var{B})}

Compute QZ@tie{}decomposition, generalized eigenvectors, and generalized
eigenvalues.
@tex
$$ AV = BV{ \rm diag }(\lambda) $$
$$ W^T A = { \rm diag }(\lambda)W^T B $$
$$ AA = Q^T AZ, BB = Q^T BZ $$
@end tex
@ifnottex

@example
@group

@var{A} * @var{V} = @var{B} * @var{V} * diag (@var{lambda})
@var{W}' * @var{A} = diag (@var{lambda}) * @var{W}' * @var{B}
@var{AA} = @var{Q} * @var{A} * @var{Z}, @var{BB} = @var{Q} * @var{B} * @var{Z}

@end group
@end example

@end ifnottex
with @var{Q} and @var{Z} orthogonal (unitary for complex case).

@item @code{[@var{AA}, @var{BB}, @var{Z} @{, @var{lambda}@}] = qz (@var{A}, @var{B}, @var{opt})}

As in form 2 above, but allows ordering of generalized eigenpairs for, e.g.,
solution of discrete time algebraic @nospell{Riccati} equations.  Form 3 is not
available for complex matrices, and does not compute the generalized
eigenvectors @var{V}, @var{W}, nor the orthogonal matrix @var{Q}.

@table @var
@item opt
for ordering eigenvalues of the @nospell{GEP} pencil.  The leading block of
the revised pencil contains all eigenvalues that satisfy:

@table @asis
@item @qcode{"N"}
unordered (default)

@item @qcode{"S"}
small: leading block has all
@tex
$|\lambda| < 1$
@end tex
@ifnottex
|@var{lambda}| < 1
@end ifnottex

@item @qcode{"B"}
big: leading block has all
@tex
$|\lambda| \geq 1$
@end tex
@ifnottex
|@var{lambda}| @geq{} 1
@end ifnottex

@item @qcode{"-"}
negative real part: leading block has all eigenvalues in the open left
half-plane

@item @qcode{"+"}
non-negative real part: leading block has all eigenvalues in the closed right
half-plane
@end table
@end table
@end enumerate

Note: @code{qz} performs permutation balancing, but not scaling
(@pxref{XREFbalance,,balance}), which may be lead to less accurate results than
@code{eig}.  The order of output arguments was selected for compatibility with
@sc{matlab}.
@seealso{@ref{XREFeig,,eig}, @ref{XREFbalance,,balance}, @ref{XREFlu,,lu}, @ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFqr,,qr}, @ref{XREFqzhess,,qzhess}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}}
@end deftypefn


@c qzhess scripts/linear-algebra/qzhess.m
@anchor{XREFqzhess}
@deftypefn {} {[@var{aa}, @var{bb}, @var{q}, @var{z}] =} qzhess (@var{A}, @var{B})
Compute the Hessenberg-triangular decomposition of the matrix pencil
@code{(@var{A}, @var{B})}, returning
@code{@var{aa} = @var{q} * @var{A} * @var{z}},
@code{@var{bb} = @var{q} * @var{B} * @var{z}}, with @var{q} and @var{z}
orthogonal.

For example:

@example
@group
[aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
     @result{} aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
     @result{} bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
     @result{}  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
     @result{}  z = [ 1, 0; 0, 1 ]
@end group
@end example

The Hessenberg-triangular decomposition is the first step in
@nospell{Moler and Stewart's} QZ@tie{}decomposition algorithm.

Algorithm taken from @nospell{Golub and Van Loan},
@cite{Matrix Computations, 2nd edition}.

@seealso{@ref{XREFlu,,lu}, @ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}, @ref{XREFschur,,schur}, @ref{XREFsvd,,svd}}
@end deftypefn


@c schur libinterp/corefcn/schur.cc
@anchor{XREFschur}
@deftypefn  {} {@var{S} =} schur (@var{A})
@deftypefnx {} {@var{S} =} schur (@var{A}, "real")
@deftypefnx {} {@var{S} =} schur (@var{A}, "complex")
@deftypefnx {} {@var{S} =} schur (@var{A}, @var{opt})
@deftypefnx {} {[@var{U}, @var{S}] =} schur (@dots{})
@cindex Schur decomposition
Compute the Schur@tie{}decomposition of @var{A}.

The Schur@tie{}decomposition is defined as
@tex
$$
 S = U^T A U
$$
@end tex
@ifnottex

@example
@code{@var{S} = @var{U}' * @var{A} * @var{U}}
@end example

@end ifnottex
where @var{U} is a unitary matrix
@tex
($U^T U$ is identity)
@end tex
@ifnottex
(@code{@var{U}'* @var{U}} is identity)
@end ifnottex
and @var{S} is upper triangular.  The eigenvalues of @var{A} (and @var{S})
are the diagonal elements of @var{S}.  If the matrix @var{A} is real, then
the real Schur@tie{}decomposition is computed, in which the matrix @var{U}
is orthogonal and @var{S} is block upper triangular with blocks of size at
most
@tex
$2 \times 2$
@end tex
@ifnottex
@code{2 x 2}
@end ifnottex
along the diagonal.  The diagonal elements of @var{S}
(or the eigenvalues of the
@tex
$2 \times 2$
@end tex
@ifnottex
@code{2 x 2}
@end ifnottex
blocks, when appropriate) are the eigenvalues of @var{A} and @var{S}.

The default for real matrices is a real Schur@tie{}decomposition.
A complex decomposition may be forced by passing the flag
@qcode{"complex"}.

The eigenvalues are optionally ordered along the diagonal according to the
value of @var{opt}.  @code{@var{opt} = "a"} indicates that all eigenvalues
with negative real parts should be moved to the leading block of @var{S}
(used in @code{are}), @code{@var{opt} = "d"} indicates that all
eigenvalues with magnitude less than one should be moved to the leading
block of @var{S} (used in @code{dare}), and @code{@var{opt} = "u"}, the
default, indicates that no ordering of eigenvalues should occur.  The
leading @var{k} columns of @var{U} always span the @var{A}-invariant
subspace corresponding to the @var{k} leading eigenvalues of @var{S}.

The Schur@tie{}decomposition is used to compute eigenvalues of a square
matrix, and has applications in the solution of algebraic @nospell{Riccati}
equations in control (see @code{are} and @code{dare}).
@seealso{@ref{XREFrsf2csf,,rsf2csf}, @ref{XREFordschur,,ordschur}, @ref{XREFlu,,lu}, @ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}, @ref{XREFsvd,,svd}}
@end deftypefn


@c rsf2csf libinterp/corefcn/schur.cc
@anchor{XREFrsf2csf}
@deftypefn {} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})
Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a
complex, upper triangular Schur@tie{}form @var{T}.

Note that the following relations hold:

@tex
$UR \cdot TR \cdot {UR}^T = U T U^{\dagger}$ and
$U^{\dagger} U$ is the identity matrix I.
@end tex
@ifnottex
@tcode{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and
@code{@var{U}' * @var{U}} is the identity matrix I.
@end ifnottex

Note also that @var{U} and @var{T} are not unique.
@seealso{@ref{XREFschur,,schur}}
@end deftypefn


@c ordschur libinterp/corefcn/ordschur.cc
@anchor{XREFordschur}
@deftypefn {} {[@var{UR}, @var{SR}] =} ordschur (@var{U}, @var{S}, @var{select})
Reorders the real Schur factorization (@var{U},@var{S}) obtained with the
@code{schur} function, so that selected eigenvalues appear in the upper left
diagonal blocks of the quasi triangular Schur matrix.

The logical vector @var{select} specifies the selected eigenvalues as they
appear along @var{S}'s diagonal.

For example, given the matrix @code{@var{A} = [1, 2; 3, 4]}, and its Schur
decomposition

@example
[@var{U}, @var{S}] = schur (@var{A})
@end example

@noindent
which returns

@example
@group
@var{U} =

  -0.82456  -0.56577
   0.56577  -0.82456

@var{S} =

  -0.37228  -1.00000
   0.00000   5.37228

@end group
@end example

It is possible to reorder the decomposition so that the positive eigenvalue
is in the upper left corner, by doing:

@example
[@var{U}, @var{S}] = ordschur (@var{U}, @var{S}, [0,1])
@end example

@seealso{@ref{XREFschur,,schur}}
@end deftypefn


@c subspace scripts/linear-algebra/subspace.m
@anchor{XREFsubspace}
@deftypefn {} {@var{angle} =} subspace (@var{A}, @var{B})
Determine the largest principal angle between two subspaces
spanned by the columns of matrices @var{A} and @var{B}.
@end deftypefn


@c svd libinterp/corefcn/svd.cc
@anchor{XREFsvd}
@deftypefn  {} {@var{s} =} svd (@var{A})
@deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})
@deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, "econ")
@deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, 0)
@cindex singular value decomposition
Compute the singular value decomposition of @var{A}.

The singular value decomposition is defined by the relation

@tex
$$
 A = U S V^{\dagger}
$$
@end tex
@ifnottex

@example
A = U*S*V'
@end example

@end ifnottex

The function @code{svd} normally returns only the vector of singular values.
When called with three return values, it computes
@tex
$U$, $S$, and $V$.
@end tex
@ifnottex
@var{U}, @var{S}, and @var{V}.
@end ifnottex
For example,

@example
svd (hilb (3))
@end example

@noindent
returns

@example
@group
ans =

  1.4083189
  0.1223271
  0.0026873
@end group
@end example

@noindent
and

@example
[u, s, v] = svd (hilb (3))
@end example

@noindent
returns

@example
@group
u =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867

s =

  1.40832  0.00000  0.00000
  0.00000  0.12233  0.00000
  0.00000  0.00000  0.00269

v =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867
@end group
@end example

When given a second argument that is not 0, @code{svd} returns an economy-sized
decomposition, eliminating the unnecessary rows or columns of @var{U} or
@var{V}.

If the second argument is exactly 0, then the choice of decomposition is based
on the matrix @var{A}.  If @var{A} has more rows than columns then an
economy-sized decomposition is returned, otherwise a regular decomposition
is calculated.

Algorithm Notes: When calculating the full decomposition (left and right
singular matrices in addition to singular values) there is a choice of two
routines in @sc{lapack}.  The default routine used by Octave is @code{gesdd}
which is 5X faster than the alternative @code{gesvd}, but may use more memory
and may be less accurate for some matrices.  See the documentation for
@code{svd_driver} for more information.
@seealso{@ref{XREFsvd_driver,,svd_driver}, @ref{XREFsvds,,svds}, @ref{XREFeig,,eig}, @ref{XREFlu,,lu}, @ref{XREFchol,,chol}, @ref{XREFhess,,hess}, @ref{XREFqr,,qr}, @ref{XREFqz,,qz}}
@end deftypefn


@c svd_driver libinterp/corefcn/svd.cc
@anchor{XREFsvd_driver}
@deftypefn  {} {@var{val} =} svd_driver ()
@deftypefnx {} {@var{old_val} =} svd_driver (@var{new_val})
@deftypefnx {} {} svd_driver (@var{new_val}, "local")
Query or set the underlying @sc{lapack} driver used by @code{svd}.

Currently recognized values are @qcode{"gesdd"} and @qcode{"gesvd"}.
The default is @qcode{"gesdd"}.

When called from inside a function with the @qcode{"local"} option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.

Algorithm Notes: The @sc{lapack} library provides two routines for calculating
the full singular value decomposition (left and right singular matrices as
well as singular values).  When calculating just the singular values the
following discussion is not relevant.

The default routine use by Octave is the newer @code{gesdd} which is based on a
Divide-and-Conquer algorithm that is 5X faster than the alternative
@code{gesvd}, which is based on QR factorization.  However, the new algorithm
can use significantly more memory.  For an @nospell{MxN} input matrix the
memory usage is of order O(min(M,N) ^ 2), whereas the alternative is of order
O(max(M,N)).  In general, modern computers have abundant memory so Octave has
chosen to prioritize speed.

In addition, there have been instances in the past where some input matrices
were not accurately decomposed by @code{gesdd}.  This appears to have been
resolved with modern versions of @sc{lapack}.  However, if certainty is
required the accuracy of the decomposition can always be tested after the fact
with

@example
@group
[@var{u}, @var{s}, @var{v}] = svd (@var{x});
norm (@var{x} - @var{u}*@var{s}*@var{v'}, "fro")
@end group
@end example

@seealso{@ref{XREFsvd,,svd}}
@end deftypefn


@c FIXME: should there be a new section here?

@c housh scripts/linear-algebra/housh.m
@anchor{XREFhoush}
@deftypefn {} {[@var{housv}, @var{beta}, @var{zer}] =} housh (@var{x}, @var{j}, @var{z})
Compute Householder reflection vector @var{housv} to reflect @var{x} to be
the j-th column of identity, i.e.,

@example
@group
(I - beta*housv*housv')x =  norm (x)*e(j) if x(j) < 0,
(I - beta*housv*housv')x = -norm (x)*e(j) if x(j) >= 0
@end group
@end example

@noindent
Inputs

@table @var
@item x
vector

@item j
index into vector

@item z
threshold for zero  (usually should be the number 0)
@end table

@noindent
Outputs (see @nospell{Golub and Van Loan}):

@table @var
@item beta
If beta = 0, then no reflection need be applied (@nospell{zer} set to 0)

@item housv
householder vector
@end table
@end deftypefn


@c krylov scripts/linear-algebra/krylov.m
@anchor{XREFkrylov}
@deftypefn {} {[@var{u}, @var{h}, @var{nu}] =} krylov (@var{A}, @var{V}, @var{k}, @var{eps1}, @var{pflg})
Construct an orthogonal basis @var{u} of a block Krylov subspace.

The block Krylov subspace has the following form:

@example
[v a*v a^2*v @dots{} a^(k+1)*v]
@end example

@noindent
The construction is made with Householder reflections to guard against loss
of orthogonality.

If @var{V} is a vector, then @var{h} contains the Hessenberg matrix
such that @nospell{@tcode{a*u == u*h+rk*ek'}}, in which
@code{rk = a*u(:,k)-u*h(:,k)}, and @nospell{@tcode{ek'}} is the vector
@code{[0, 0, @dots{}, 1]} of length @var{k}.  Otherwise, @var{h} is
meaningless.

If @var{V} is a vector and @var{k} is greater than @code{length (A) - 1},
then @var{h} contains the Hessenberg matrix such that @code{a*u == u*h}.

The value of @var{nu} is the dimension of the span of the Krylov subspace
(based on @var{eps1}).

If @var{b} is a vector and @var{k} is greater than @var{m-1}, then @var{h}
contains the Hessenberg decomposition of @var{A}.

The optional parameter @var{eps1} is the threshold for zero.  The default
value is 1e-12.

If the optional parameter @var{pflg} is nonzero, row pivoting is used to
improve numerical behavior.  The default value is 0.

Reference: @nospell{A. Hodel, P. Misra}, @cite{Partial Pivoting in the
Computation of Krylov Subspaces of Large Sparse Systems}, Proceedings of
the 42nd IEEE Conference on Decision and Control, December 2003.
@end deftypefn


@node Functions of a Matrix
@section Functions of a Matrix
@cindex matrix, functions of

@c expm scripts/linear-algebra/expm.m
@anchor{XREFexpm}
@deftypefn {} {} expm (@var{A})
Return the exponential of a matrix.

The matrix exponential is defined as the infinite Taylor series
@tex
$$
 \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
$$
@end tex
@ifnottex

@example
expm (A) = I + A + A^2/2! + A^3/3! + @dots{}
@end example

@end ifnottex
However, the Taylor series is @emph{not} the way to compute the matrix
exponential; see @nospell{Moler and Van Loan}, @cite{Nineteen Dubious Ways
to Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
uses Ward's diagonal Pad@'e approximation method with three step
preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
Pad@'e approximations are rational polynomials of matrices
@tex
$D_q(A)^{-1}N_q(A)$
@end tex
@ifnottex

@example
@group
     -1
D (A)   N (A)
@end group
@end example

@end ifnottex
whose Taylor series matches the first
@tex
$2 q + 1 $
@end tex
@ifnottex
@code{2q+1}
@end ifnottex
terms of the Taylor series above; direct evaluation of the Taylor series
(with the same preconditioning steps) may be desirable in lieu of the
Pad@'e approximation when
@tex
$D_q(A)$
@end tex
@ifnottex
@code{Dq(A)}
@end ifnottex
is ill-conditioned.
@seealso{@ref{XREFlogm,,logm}, @ref{XREFsqrtm,,sqrtm}}
@end deftypefn


@c logm scripts/linear-algebra/logm.m
@anchor{XREFlogm}
@deftypefn  {} {@var{s} =} logm (@var{A})
@deftypefnx {} {@var{s} =} logm (@var{A}, @var{opt_iters})
@deftypefnx {} {[@var{s}, @var{iters}] =} logm (@dots{})
Compute the matrix logarithm of the square matrix @var{A}.

The implementation utilizes a Pad@'e approximant and the identity

@example
logm (@var{A}) = 2^k * logm (@var{A}^(1 / 2^k))
@end example

The optional input @var{opt_iters} is the maximum number of square roots
to compute and defaults to 100.

The optional output @var{iters} is the number of square roots actually
computed.
@seealso{@ref{XREFexpm,,expm}, @ref{XREFsqrtm,,sqrtm}}
@end deftypefn


@c sqrtm libinterp/corefcn/sqrtm.cc
@anchor{XREFsqrtm}
@deftypefn  {} {@var{s} =} sqrtm (@var{A})
@deftypefnx {} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})
Compute the matrix square root of the square matrix @var{A}.

Ref: @nospell{N.J. Higham}.  @cite{A New sqrtm for @sc{matlab}}.  Numerical
Analysis Report No. 336, Manchester @nospell{Centre} for Computational
Mathematics, Manchester, England, January 1999.
@seealso{@ref{XREFexpm,,expm}, @ref{XREFlogm,,logm}}
@end deftypefn


@c kron libinterp/corefcn/kron.cc
@anchor{XREFkron}
@deftypefn  {} {} kron (@var{A}, @var{B})
@deftypefnx {} {} kron (@var{A1}, @var{A2}, @dots{})
Form the Kronecker product of two or more matrices.

This is defined block by block as

@example
x = [ a(i,j)*b ]
@end example

For example:

@example
@group
kron (1:4, ones (3, 1))
     @result{}  1  2  3  4
         1  2  3  4
         1  2  3  4
@end group
@end example

If there are more than two input arguments @var{A1}, @var{A2}, @dots{},
@var{An} the Kronecker product is computed as

@example
kron (kron (@var{A1}, @var{A2}), @dots{}, @var{An})
@end example

@noindent
Since the Kronecker product is associative, this is well-defined.
@end deftypefn


@c blkmm libinterp/corefcn/dot.cc
@anchor{XREFblkmm}
@deftypefn {} {} blkmm (@var{A}, @var{B})
Compute products of matrix blocks.

The blocks are given as 2-dimensional subarrays of the arrays @var{A},
@var{B}.  The size of @var{A} must have the form @code{[m,k,@dots{}]} and
size of @var{B} must be @code{[k,n,@dots{}]}.  The result is then of size
@code{[m,n,@dots{}]} and is computed as follows:

@example
@group
for i = 1:prod (size (@var{A})(3:end))
  @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)
endfor
@end group
@end example
@end deftypefn


@c sylvester libinterp/corefcn/sylvester.cc
@anchor{XREFsylvester}
@deftypefn {} {@var{X} =} sylvester (@var{A}, @var{B}, @var{C})
Solve the Sylvester equation.

The Sylvester equation is defined as:
@tex
$$
 A X + X B = C
$$
@end tex
@ifnottex

@example
A X + X B = C
@end example

@end ifnottex
The solution is computed using standard @sc{lapack} subroutines.

For example:

@example
@group
sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
   @result{} [ 0.50000, 0.66667; 0.66667, 0.50000 ]
@end group
@end example
@end deftypefn


@node Specialized Solvers
@section Specialized Solvers
@cindex matrix, specialized solvers

@c bicg scripts/sparse/bicg.m
@anchor{XREFbicg}
@deftypefn  {} {@var{x} =} bicg (@var{A}, @var{b})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
@deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
Solve the linear system of equations @w{@code{@var{A} * @var{x} = @var{b}}}
by means of the Bi-Conjugate Gradient iterative method.

The input arguments are:

@itemize

@item @var{A} is the matrix of the linear system and it must be square.
@var{A} can be passed as a matrix, function handle, or inline function
@code{Afun} such that @w{@code{Afun (x, "notransp") = A * x}} and
@w{@code{Afun (x, "transp") = A' * x}}.  Additional parameters to
@code{Afun} may be passed after @var{x0}.

@item @var{b} is the right-hand side vector.  It must be a column vector
with the same number of rows as @var{A}.

@item
@var{tol} is the required relative tolerance for the residual error,
@w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
@w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
@w{@code{@var{tol} * norm (@var{b})}}}.
If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.

@item
@var{maxit} is the maximum allowed number of iterations; if @var{maxit}
is omitted or empty then a value of 20 is used.

@item
@var{M1}, @var{M2} are the preconditioners.  The preconditioner @var{M} is
given as @code{@var{M} = @var{M1} * @var{M2}}.  Both @var{M1} and @var{M2}
can be passed as a matrix or as a function handle or inline function
@code{g} such that @w{@code{g (@var{x}, "notransp") = @var{M1} \ @var{x}}}
or @w{@code{g (@var{x}, "notransp") = @var{M2} \ @var{x}}} and
@w{@code{g (@var{x}, "transp") = @var{M1}' \ @var{x}}} or
@w{@code{g (@var{x}, "transp") = @var{M2}' \ @var{x}}}.
If @var{M1} is omitted or empty, then preconditioning is not applied.
The preconditioned system is theoretically equivalent to applying the
@code{bicg} method to the linear system
@code{inv (@var{M1}) * A * inv (@var{M2}) * @var{y} = inv
(@var{M1}) * @var{b}} and
@code{inv (@var{M2'}) * A' * inv (@var{M1'}) * @var{z} =
inv (@var{M2'}) * @var{b}} and then setting
@code{@var{x} = inv (@var{M2}) * @var{y}}.

@item
@var{x0} is the initial guess.  If @var{x0} is omitted or empty then the
function sets @var{x0} to a zero vector by default.
@end itemize

Any arguments which follow @var{x0} are treated as parameters, and passed in
an appropriate manner to any of the functions (@var{Afun} or @var{Mfun}) or
that have been given to @code{bicg}.

The output parameters are:

@itemize

@item
@var{x} is the computed approximation to the solution of
@w{@code{@var{A} * @var{x} = @var{b}}}.  If the algorithm did not converge,
then @var{x} is the iteration which has the minimum residual.

@item
@var{flag} indicates the exit status:

@itemize
@item 0: The algorithm converged to within the prescribed tolerance.

@item 1: The algorithm did not converge and it reached the maximum number of
iterations.

@item 2: The preconditioner matrix is singular.

@item 3: The algorithm stagnated, i.e., the absolute value of the
difference between the current iteration @var{x} and the previous is less
than @code{eps * norm (@var{x},2)}.

@item 4: The algorithm could not continue because intermediate values
became too small or too large for reliable computation.
@end itemize

@item
@var{relres} is the ratio of the final residual to its initial value,
measured in the Euclidean norm.

@item
@var{iter} is the iteration which @var{x} is computed.

@item
@var{resvec} is a vector containing the residual at each iteration.
The total number of iterations performed is given by
@code{length (@var{resvec}) - 1}.
@end itemize

Consider a trivial problem with a tridiagonal matrix

@example
@group
n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n)) + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
              sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A);  # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afun = @@(x, string) strcmp (string, "notransp") * (A * x) + ...
                     strcmp (string, "transp") * (A' * x);
Mfun = @@(x, string) strcmp (string, "notransp") * (M \ x) + ...
                     strcmp (string, "transp") * (M' \ x);
M1fun = @@(x, string) strcmp (string, "notransp") * (M1 \ x) + ...
                     strcmp (string, "transp") * (M1' \ x);
M2fun = @@(x, string) strcmp (string, "notransp") * (M2 \ x) + ...
                     strcmp (string, "transp") * (M2' \ x);
@end group
@end example

@sc{Example 1:} simplest usage of @code{bicg}

@example
x = bicg (A, b)
@end example

@sc{Example 2:} @code{bicg} with a function that computes
@code{@var{A}*@var{x}} and @code{@var{A'}*@var{x}}

@example
x = bicg (Afun, b, [], n)
@end example

@sc{Example 3:} @code{bicg} with a preconditioner matrix @var{M}

@example
x = bicg (A, b, 1e-6, n, M)
@end example

@sc{Example 4:} @code{bicg} with a function as preconditioner

@example
x = bicg (Afun, b, 1e-6, n, Mfun)
@end example

@sc{Example 5:} @code{bicg} with preconditioner matrices @var{M1}
and @var{M2}

@example
x = bicg (A, b, 1e-6, n, M1, M2)
@end example

@sc{Example 6:} @code{bicg} with functions as preconditioners

@example
x = bicg (Afun, b, 1e-6, n, M1fun, M2fun)
@end example

@sc{Example 7:} @code{bicg} with as input a function requiring an argument

@example
@group
function y = Ap (A, x, string, z)
  ## compute A^z * x or (A^z)' * x
  y = x;
  if (strcmp (string, "notransp"))
    for i = 1:z
      y = A * y;
    endfor
  elseif (strcmp (string, "transp"))
    for i = 1:z
      y = A' * y;
    endfor
  endif
endfunction

Apfun = @@(x, string, p) Ap (A, x, string, p);
x = bicg (Apfun, b, [], [], [], [], [], 2);
@end group
@end example

References:

@enumerate

@item @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
Second edition, 2003, SIAM.

@end enumerate

@seealso{@ref{XREFbicgstab,,bicgstab}, @ref{XREFcgs,,cgs}, @ref{XREFgmres,,gmres}, @ref{XREFpcg,,pcg}, @ref{XREFqmr,,qmr}, @ref{XREFtfqmr,,tfqmr}}
@end deftypefn


@c bicgstab scripts/sparse/bicgstab.m
@anchor{XREFbicgstab}
@deftypefn  {} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
@deftypefnx {} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, @dots{})
Solve @code{A x = b} using the stabilizied Bi-conjugate gradient iterative
method.

The input parameters are:

@itemize @minus

@item @var{A} is the matrix of the linear system and it must be square.
@var{A} can be passed as a matrix, function handle, or inline
function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
parameters to @code{Afun} are passed after @var{x0}.

@item @var{b} is the right hand side vector.  It must be a column vector
with the same number of rows as @var{A}.

@item
@var{tol} is the required relative tolerance for the residual error,
@w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
@w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
@w{@code{@var{tol} * norm (@var{b})}}}.
If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.

@item @var{maxit} the maximum number of outer iterations, if not given or
set to [] the default value @code{min (20, numel (b))} is used.

@item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
@var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
Both @var{M1} and @var{M2} can be passed as a matrix or as a function
handle or inline function @code{g} such that
@code{g(@var{x}) = @var{M1} \ @var{x}} or
@code{g(@var{x}) = @var{M2} \ @var{x}}.
The technique used is the right preconditioning, i.e., it is
solved @code{@var{A} * inv (@var{M}) * @var{y} = @var{b}} and then
@code{@var{x} = inv (@var{M}) * @var{y}}.

@item @var{x0} the initial guess, if not given or set to [] the default
value @code{zeros (size (@var{b}))} is used.

@end itemize

The arguments which follow @var{x0} are treated as parameters, and passed in
a proper way to any of the functions (@var{A} or @var{M}) which are passed
to @code{bicstab}.

The output parameters are:

@itemize @minus

@item @var{x} is the approximation computed.  If the method doesn't
converge then it is the iterated with the minimum residual.

@item @var{flag} indicates the exit status:

@itemize @minus
@item 0: iteration converged to the within the chosen tolerance

@item 1: the maximum number of iterations was reached before convergence

@item 2: the preconditioner matrix is singular

@item 3: the algorithm reached stagnation

@item 4: the algorithm can't continue due to a division by zero
@end itemize

@item @var{relres} is the relative residual obtained with as
@code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.

@item @var{iter} is the (possibily half) iteration which @var{x} is
computed.  If it is an half iteration then it is @code{@var{iter} + 0.5}

@item @var{resvec} is a vector containing the residual of each half and
total iteration (There are also the half iterations since @var{x} is
computed in two steps at each iteration).
Doing @code{(length(@var{resvec}) - 1) / 2} is possible to see the
total number of (total) iterations performed.

@end itemize

Let us consider a trivial problem with a tridiagonal matrix

@example
@group
n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afun = @@(x) A * x;
Mfun = @@(x) M \ x;
M1fun = @@(x) M1 \ x;
M2fun = @@(x) M2 \ x;
@end group
@end example

@sc{Example 1:} simplest usage of @code{bicgstab}

@example
x = bicgstab (A, b, [], n)
@end example

@sc{Example 2:} @code{bicgstab} with a function which computes
@code{@var{A} * @var{x}}

@example
x = bicgstab (Afun, b, [], n)
@end example

@sc{Example 3:} @code{bicgstab} with a preconditioner matrix @var{M}

@example
x = bicgstab (A, b, [], 1e-06, n, M)
@end example

@sc{Example 4:} @code{bicgstab} with a function as preconditioner

@example
x = bicgstab (Afun, b, 1e-6, n, Mfun)
@end example

@sc{Example 5:} @code{bicgstab} with preconditioner matrices @var{M1}
and @var{M2}

@example
x = bicgstab (A, b, [], 1e-6, n, M1, M2)
@end example

@sc{Example 6:} @code{bicgstab} with functions as preconditioners

@example
x = bicgstab (Afun, b, 1e-6, n, M1fun, M2fun)
@end example

@sc{Example 7:} @code{bicgstab} with as input a function requiring
an argument

@example
@group
function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfun = @@(x, string, p) Ap (A, x, string, p);
x = bicgstab (Apfun, b, [], [], [], [], [], 2);
@end group
@end example

@sc{Example 8:} explicit example to show that @code{bicgstab} uses a
right preconditioner

@example
@group
[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by bicgstab after one iteration
[x_ref, fl] = bicgstab (A, b, [], 1, M)

## right preconditioning
[y, fl] = bicgstab (A / M, b, [], 1)
x = M \ y # compare x and x_ref

@end group
@end example

References:

@enumerate

@item @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear
Systems}, Second edition, 2003, SIAM

@end enumerate

@seealso{@ref{XREFbicg,,bicg}, @ref{XREFcgs,,cgs}, @ref{XREFgmres,,gmres}, @ref{XREFpcg,,pcg}, @ref{XREFqmr,,qmr}, @ref{XREFtfqmr,,tfqmr}}

@end deftypefn


@c cgs scripts/sparse/cgs.m
@anchor{XREFcgs}
@deftypefn  {} {@var{x} =} cgs (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
@deftypefnx {} {@var{x} =} cgs (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, @dots{})
Solve @code{A x = b}, where @var{A} is a square matrix, using the
Conjugate Gradients Squared method.

The input arguments are:

@itemize @minus

@item @var{A} is the matrix of the linear system and it must be square.
@var{A} can be passed as a matrix, function handle, or inline
function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
parameters to @code{Afun} are passed after @var{x0}.

@item @var{b} is the right hand side vector.  It must be a column vector
with same number of rows of @var{A}.

@item @var{tol} is the relative tolerance, if not given or set to [] the
default value 1e-6 is used.

@item @var{maxit} the maximum number of outer iterations, if not given or
set to [] the default value @code{min (20, numel (b))} is used.

@item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
matrix is given as @code{M = M1 * M2}.  Both @var{M1}
and @var{M2} can be passed as a matrix or as a function handle or inline
function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
If M1 is empty or not passed then no preconditioners are applied.
The technique used is the right preconditioning, i.e., it is solved
@code{@var{A}*inv(@var{M})*y = b} and then @code{@var{x} = inv(@var{M})*y}.

@item @var{x0} the initial guess, if not given or set to [] the default
value @code{zeros (size (b))} is used.
@end itemize

The arguments which follow @var{x0} are treated as parameters, and passed in
a proper way to any of the functions (@var{A} or @var{P}) which are passed
to @code{cgs}.

The output parameters are:

@itemize @minus

@item @var{x} is the approximation computed.  If the method doesn't
converge then it is the iterated with the minimum residual.

@item @var{flag} indicates the exit status:

@itemize @minus
@item 0: iteration converged to the within the chosen tolerance

@item 1: the maximum number of iterations was reached before convergence

@item 2: the preconditioner matrix is singular

@item 3: the algorithm reached stagnation

@item 4: the algorithm can't continue due to a division by zero
@end itemize

@item @var{relres} is the relative residual obtained with as
@code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.

@item @var{iter} is the iteration which @var{x} is computed.

@item @var{resvec} is a vector containing the residual at each iteration.
Doing @code{length(@var{resvec}) - 1} is possible to see the total number
of iterations performed.
@end itemize

Let us consider a trivial problem with a tridiagonal matrix

@example
@group
n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afun = @@(x) A * x;
Mfun = @@(x) M \ x;
M1fun = @@(x) M1 \ x;
M2fun = @@(x) M2 \ x;
@end group
@end example

@sc{Example 1:} simplest usage of @code{cgs}

@example
x = cgs (A, b, [], n)
@end example

@sc{Example 2:} @code{cgs} with a function which computes
@code{@var{A} * @var{x}}

@example
x = cgs (Afun, b, [], n)
@end example

@sc{Example 3:} @code{cgs} with a preconditioner matrix @var{M}

@example
x = cgs (A, b, [], 1e-06, n, M)
@end example

@sc{Example 4:} @code{cgs} with a function as preconditioner

@example
x = cgs (Afun, b, 1e-6, n, Mfun)
@end example

@sc{Example 5:} @code{cgs} with preconditioner matrices @var{M1}
and @var{M2}

@example
x = cgs (A, b, [], 1e-6, n, M1, M2)
@end example

@sc{Example 6:} @code{cgs} with functions as preconditioners

@example
x = cgs (Afun, b, 1e-6, n, M1fun, M2fun)
@end example

@sc{Example 7:} @code{cgs} with as input a function requiring an argument

@example
@group
function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfun = @@(x, string, p) Ap (A, x, string, p);
x = cgs (Apfun, b, [], [], [], [], [], 2);
@end group
@end example

@sc{Example 8:} explicit example to show that @code{cgs} uses a
right preconditioner

@example
@group
[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by cgs after one iteration
[x_ref, fl] = cgs (A, b, [], 1, M)

## right preconditioning
[y, fl] = cgs (A / M, b, [], 1)
x = M \ y # compare x and x_ref

@end group
@end example

References:

@enumerate

@item @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
Second edition, 2003, SIAM

@end enumerate

@seealso{@ref{XREFpcg,,pcg}, @ref{XREFbicgstab,,bicgstab}, @ref{XREFbicg,,bicg}, @ref{XREFgmres,,gmres}, @ref{XREFqmr,,qmr}, @ref{XREFtfqmr,,tfqmr}}
@end deftypefn


@c gmres scripts/sparse/gmres.m
@anchor{XREFgmres}
@deftypefn  {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
@deftypefnx {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} gmres (@var{A}, @var{b}, @dots{})
Solve @code{A x = b} using the Preconditioned GMRES iterative method with
restart, a.k.a. PGMRES(restart).

The input arguments are:

@itemize @minus

@item @var{A} is the matrix of the linear system and it must be square.
@var{A} can be passed as a matrix, function handle, or inline
function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
parameters to @code{Afun} are passed after @var{x0}.

@item @var{b} is the right hand side vector.  It must be a column vector
with the same numbers of rows as @var{A}.

@item @var{restart} is the number of iterations before that the
method restarts.  If it is [] or N = numel (b), then the restart
is not applied.

@item @var{tol} is the required relative tolerance for the
preconditioned residual error,
@code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}.  The iteration
stops if @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x}))
@leq{} @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is
omitted or empty, then a tolerance of 1e-6 is used.

@item @var{maxit} is the maximum number of outer iterations, if not given or
set to [], then the default value @code{min (10, @var{N} / @var{restart})}
is used.
Note that, if @var{restart} is empty, then @var{maxit} is the maximum number
of iterations.  If @var{restart} and @var{maxit} are not empty, then
the maximum number of iterations is @code{@var{restart} * @var{maxit}}.
If both @var{restart} and @var{maxit} are empty, then the maximum
number of iterations is set to @code{min (10, @var{N})}.

@item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
@var{M} is given as @code{M = M1 * M2}.  Both @var{M1} and @var{M2} can
be passed as a matrix, function handle, or inline function @code{g} such
that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.  If @var{M1} is [] or not
given, then the preconditioner is not applied.
The technique used is the left-preconditioning, i.e., it is solved
@code{inv(@var{M}) * @var{A} * @var{x} = inv(@var{M}) * @var{b}} instead of
@code{@var{A} * @var{x} = @var{b}}.

@item @var{x0} is the initial guess,
if not given or set to [], then the default value
@code{zeros (size (@var{b}))} is used.

@end itemize

The arguments which follow @var{x0} are treated as parameters, and passed in
a proper way to any of the functions (@var{A} or @var{M} or
@var{M1} or @var{M2}) which are passed to @code{gmres}.

The outputs are:

@itemize @minus

@item @var{x} the computed approximation.  If the method does not
converge, then it is the iterated with minimum residual.

@item @var{flag} indicates the exit status:

@table @asis
@item 0 : iteration converged to within the specified tolerance

@item 1 : maximum number of iterations exceeded

@item 2 : the preconditioner matrix is singular

@item 3 : algorithm reached stagnation (the relative difference between two
consecutive iterations is less than eps)
@end table

@item @var{relres} is the value of the relative preconditioned
residual of the approximation @var{x}.

@item @var{iter} is a vector containing the number of outer iterations and
inner iterations performed to compute @var{x}.  That is:

@itemize
@item @var{iter(1)}: number of outer iterations, i.e., how many
times the method restarted.  (if @var{restart} is empty or @var{N},
then it is 1, if not 1 @leq{} @var{iter(1)} @leq{} @var{maxit}).

@item @var{iter(2)}: the number of iterations performed before the
restart, i.e., the method restarts when
@code{@var{iter(2)} = @var{restart}}.  If @var{restart} is empty or
@var{N}, then 1 @leq{} @var{iter(2)} @leq{} @var{maxit}.
@end itemize

To be more clear, the approximation @var{x} is computed at the iteration
@code{(@var{iter(1)} - 1) * @var{restart} + @var{iter(2)}}.
Since the output @var{x} corresponds to the minimal preconditioned
residual solution, the total number of iterations that
the method performed is given by @code{length (resvec) - 1}.

@item @var{resvec} is a vector containing the preconditioned
relative residual at each iteration, including the 0-th iteration
@code{norm (@var{A} * @var{x0} - @var{b})}.
@end itemize

Let us consider a trivial problem with a tridiagonal matrix

@example
@group
n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case, it corresponds to lu (A)
M = M1 * M2;
Afun = @@(x) A * x;
Mfun = @@(x) M \ x;
M1fun = @@(x) M1 \ x;
M2fun = @@(x) M2 \ x;
@end group
@end example

@sc{Example 1:} simplest usage of @code{gmres}

@example
x = gmres (A, b, [], [], n)
@end example

@sc{Example 2:} @code{gmres} with a function which computes
@code{@var{A} * @var{x}}

@example
x = gmres (Afun, b, [], [], n)
@end example

@sc{Example 3:} usage of @code{gmres} with the restart

@example
x = gmres (A, b, restart);
@end example

@sc{Example 4:} @code{gmres} with a preconditioner matrix @var{M}
with and without restart

@example
@group
x = gmres (A, b, [], 1e-06, n, M)
x = gmres (A, b, restart, 1e-06, n, M)
@end group
@end example

@sc{Example 5:} @code{gmres} with a function as preconditioner

@example
x = gmres (Afun, b, [], 1e-6, n, Mfun)
@end example

@sc{Example 6:} @code{gmres} with preconditioner matrices @var{M1}
and @var{M2}

@example
x = gmres (A, b, [], 1e-6, n, M1, M2)
@end example

@sc{Example 7:} @code{gmres} with functions as preconditioners

@example
x = gmres (Afun, b, 1e-6, n, M1fun, M2fun)
@end example

@sc{Example 8:} @code{gmres} with as input a function requiring an argument

@example
@group
  function y = Ap (A, x, p) # compute A^p * x
     y = x;
     for i = 1:p
       y = A * y;
     endfor
  endfunction
Apfun = @@(x, p) Ap (A, x, p);
x = gmres (Apfun, b, [], [], [], [], [], [], 2);
@end group
@end example

@sc{Example 9:} explicit example to show that @code{gmres} uses a
left preconditioner

@example
@group
[M1, M2] = ilu (A + 0.1 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by gmres after two iterations
[x_ref, fl] = gmres (A, b, [], [], 1, M)

## left preconditioning
[x, fl] = gmres (M \ A, M \ b, [], [], 1)
x # compare x and x_ref

@end group
@end example

References:

@enumerate

@item @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear
Systems}, Second edition, 2003, SIAM

@end enumerate
@seealso{@ref{XREFbicg,,bicg}, @ref{XREFbicgstab,,bicgstab}, @ref{XREFcgs,,cgs}, @ref{XREFpcg,,pcg}, @ref{XREFpcr,,pcr}, @ref{XREFqmr,,qmr}, @ref{XREFtfqmr,,tfqmr}}
@end deftypefn


@c qmr scripts/sparse/qmr.m
@anchor{XREFqmr}
@deftypefn  {} {@var{x} =} qmr (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
@deftypefnx {} {@var{x} =} qmr (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} qmr (@var{A}, @var{b}, @dots{})
Solve @code{A x = b} using the Quasi-Minimal Residual iterative method
(without look-ahead).

@itemize @minus
@item @var{rtol} is the relative tolerance, if not given or set to [] the
default value 1e-6 is used.

@item @var{maxit} the maximum number of outer iterations, if not given or
set to [] the default value @code{min (20, numel (b))} is used.

@item @var{x0} the initial guess, if not given or set to [] the default
value @code{zeros (size (b))} is used.
@end itemize

@var{A} can be passed as a matrix or as a function handle or inline
function @code{f} such that @code{f(x, "notransp") = A*x} and
@code{f(x, "transp") = A'*x}.

The preconditioner @var{P} is given as @code{P = M1 * M2}.  Both @var{M1}
and @var{M2} can be passed as a matrix or as a function handle or inline
function @code{g} such that @code{g(x, "notransp") = M1 \ x} or
@code{g(x, "notransp") = M2 \ x} and @code{g(x, "transp") = M1' \ x} or
@code{g(x, "transp") = M2' \ x}.

If called with more than one output parameter

@itemize @minus
@item @var{flag} indicates the exit status:

@itemize @minus
@item 0: iteration converged to the within the chosen tolerance

@item 1: the maximum number of iterations was reached before convergence

@item 3: the algorithm reached stagnation
@end itemize

(the value 2 is unused but skipped for compatibility).

@item @var{relres} is the final value of the relative residual.

@item @var{iter} is the number of iterations performed.

@item @var{resvec} is a vector containing the residual norms at each
      iteration.
@end itemize

References:

@enumerate
@item
@nospell{R. Freund and N. Nachtigal}, @cite{QMR: a quasi-minimal residual
method for non-Hermitian linear systems}, @nospell{Numerische Mathematik},
1991, 60, pp. 315-339.

@item
@nospell{ R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra},
@nospell{ V. Eijkhour, R. Pozo, C. Romine, and H. van der Vorst},
@cite{Templates for the solution of linear systems: Building blocks
for iterative methods}, SIAM, 2nd ed., 1994.
@end enumerate

@seealso{@ref{XREFbicg,,bicg}, @ref{XREFbicgstab,,bicgstab}, @ref{XREFcgs,,cgs}, @ref{XREFgmres,,gmres}, @ref{XREFpcg,,pcg}}
@end deftypefn


@c tfqmr scripts/sparse/tfqmr.m
@anchor{XREFtfqmr}
@deftypefn  {} {@var{x} =} tfqmr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
@deftypefnx {} {@var{x} =} tfqmr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
@deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} tfqmr (@var{A}, @var{b}, @dots{})
Solve @code{A x = b} using the Transpose-Tree qmr method, based on the cgs.

The input parameters are:

@itemize @minus

@item @var{A} is the matrix of the linear system and it must be square.
@var{A} can be passed as a matrix, function handle, or inline
function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
parameters to @code{Afun} are passed after @var{x0}.

@item @var{b} is the right hand side vector.  It must be a column vector
with the same number of rows as @var{A}.

@item @var{tol} is the relative tolerance, if not given or set to [] the
default value 1e-6 is used.

@item @var{maxit} the maximum number of outer iterations, if not given or
set to [] the default value @code{min (20, numel (b))} is used.  To be
compatible, since the method as different behaviors in the iteration
number is odd or even, is considered as iteration in @code{tfqmr} the
entire odd-even cycle.  That is, to make an entire iteration, the algorithm
performs two sub-iterations: the odd one and the even one.

@item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
@var{M} is given as @code{M = M1 * M2}.
Both @var{M1} and @var{M2} can be passed as a matrix or as a function
handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
@code{g(x) = M2 \ x}.
The technique used is the right-preconditioning, i.e., it is solved
@code{A*inv(M)*y = b} and then @code{x = inv(M)*y}, instead of
@code{A x = b}.

@item @var{x0} the initial guess, if not given or set to [] the default
value @code{zeros (size (b))} is used.

@end itemize

The arguments which follow @var{x0} are treated as parameters, and passed in
a proper way to any of the functions (@var{A} or @var{M}) which are passed
to @code{tfqmr}.

The output parameters are:

@itemize @minus

@item @var{x} is the approximation computed.  If the method doesn't
converge then it is the iterated with the minimum residual.

@item @var{flag} indicates the exit status:

@itemize @minus
@item 0: iteration converged to the within the chosen tolerance

@item 1: the maximum number of iterations was reached before convergence

@item 2: the preconditioner matrix is singular

@item 3: the algorithm reached stagnation

@item 4: the algorithm can't continue due to a division by zero
@end itemize

@item @var{relres} is the relative residual obtained as
@code{(@var{A}*@var{x}-@var{b}) / @code{norm (@var{b})}}.

@item @var{iter} is the iteration which @var{x} is
computed.

@item @var{resvec} is a vector containing the residual at each iteration
(including @code{norm (b - A x0)}).
Doing @code{length (@var{resvec}) - 1} is possible to see the
total number of iterations performed.

@end itemize

Let us consider a trivial problem with a tridiagonal matrix

@example
@group
n = 20;
A = toeplitz (sparse ([1, 1], [1, 2], [2, 1] * n ^ 2, 1, n))  + ...
    toeplitz (sparse (1, 2, -1, 1, n) * n / 2, ...
    sparse (1, 2, 1, 1, n) * n / 2);
b = A * ones (n, 1);
restart = 5;
[M1, M2] = ilu (A); # in this tridiag case it corresponds to chol (A)'
M = M1 * M2;
Afun = @@(x) A * x;
Mfun = @@(x) M \ x;
M1fun = @@(x) M1 \ x;
M2fun = @@(x) M2 \ x;
@end group
@end example

@sc{Example 1:} simplest usage of @code{tfqmr}

@example
x = tfqmr (A, b, [], n)
@end example

@sc{Example 2:} @code{tfqmr} with a function which computes
@code{@var{A} * @var{x}}

@example
x = tfqmr (Afun, b, [], n)
@end example

@sc{Example 3:} @code{tfqmr} with a preconditioner matrix @var{M}

@example
x = tfqmr (A, b, [], 1e-06, n, M)
@end example

@sc{Example 4:} @code{tfqmr} with a function as preconditioner

@example
x = tfqmr (Afun, b, 1e-6, n, Mfun)
@end example

@sc{Example 5:} @code{tfqmr} with preconditioner matrices @var{M1}
and @var{M2}

@example
x = tfqmr (A, b, [], 1e-6, n, M1, M2)
@end example

@sc{Example 6:} @code{tfmqr} with functions as preconditioners

@example
x = tfqmr (Afun, b, 1e-6, n, M1fun, M2fun)
@end example

@sc{Example 7:} @code{tfqmr} with as input a function requiring an argument

@example
@group
function y = Ap (A, x, z) # compute A^z * x
   y = x;
   for i = 1:z
     y = A * y;
   endfor
 endfunction
Apfun = @@(x, string, p) Ap (A, x, string, p);
x = tfqmr (Apfun, b, [], [], [], [], [], 2);
@end group
@end example

@sc{Example 8:} explicit example to show that @code{tfqmr} uses a
right preconditioner

@example
@group
[M1, M2] = ilu (A + 0.3 * eye (n)); # factorization of A perturbed
M = M1 * M2;

## reference solution computed by tfqmr after one iteration
[x_ref, fl] = tfqmr (A, b, [], 1, M)

## right preconditioning
[y, fl] = tfqmr (A / M, b, [], 1)
x = M \ y # compare x and x_ref

@end group
@end example

References:

@enumerate

@item @nospell{Y. Saad}, @cite{Iterative Methods for Sparse Linear Systems},
Second edition, 2003, SIAM

@end enumerate

@seealso{@ref{XREFbicg,,bicg}, @ref{XREFbicgstab,,bicgstab}, @ref{XREFcgs,,cgs}, @ref{XREFgmres,,gmres}, @ref{XREFpcg,,pcg}, @ref{XREFqmr,,qmr}, @ref{XREFpcr,,pcr}}

@end deftypefn

